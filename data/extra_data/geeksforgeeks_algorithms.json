[
    {
        "title": "DSA Tutorial - Learn Data Structures and Algorithms",
        "description": "DSA (Data Structures and Algorithms)  is the study of organizing data efficiently using data structures like arrays, stacks, and trees, paired with step-by-step procedures (or algorithms) to solve problems effectively. Data structures manage how data is stored and accessed, while algorithms focus on processing this data. Hoping you have learned a programming language of your choice, here comes the next stage of the roadmap - Learn about Time and Space Complexities. Once you have learned basics of a programming language, it is recommended that you learn basic logic building To analyze algorithms, we mainly measure order of growth of time or space taken in terms of input size.  We do this in the worst case scenario in most of the cases. Please refer the below links for a clear understanding of these concepts. Array is a linear data structure where elements are allocated contiguous memory, allowing for constant-time access. Searching algorithms are used to locate specific data within a large set of data. It helps find a target value within the data. There are various types of searching algorithms, each with its own approach and efficiency. Sorting algorithms are used to arrange the elements of a list in a specific order, such as numerical or alphabetical. It organizes the items in a systematic way, making it easier to search for and access specific elements. Hashing is a technique that generates a fixed-size output (hash value) from an input of variable size using mathematical formulas called hash functions. Hashing is commonly used in data structures for efficient searching, insertion and deletion. In Two Pointer Technique, we typically use two index variables from two corners of an array. We use the two pointer technique for searching a required point or value in an array. In Window Sliding Technique, we use the result of previous subarray to quickly compute the result of current. In Prefix Sum Technique, we compute prefix sums of an array to quickly find results for a subarray. String is a sequence of characters, typically immutable and have limited set of elements (lower case or all English alphabets). Recursion is a programming technique where a function calls itself within its own definition. It is usually used to solve problems that can be broken down into smaller instances of the same problem. Matrix is a two-dimensional array of elements, arranged in rows and columns. It is represented as a rectangular grid, with each element at the intersection of a row and column. Linked list is a linear data structure that stores data in nodes, which are connected by pointers. Unlike arrays, nodes of linked lists are not stored in contiguous memory locations and can only be accessed sequentially, starting from the head of list. Stack is a linear data structure that follows the Last In, First Out (LIFO) principle. Stacks play an important role in managing function calls, memory, and are widely used in algorithms like stock span problem, next greater element and largest area in a histogram. Queue is a linear data structure that follows the First In, First Out (FIFO) principle. Queues play an important role in managing tasks or data in order, scheduling and message handling systems. A deque (double-ended queue) is a data structure that allows elements to be added or removed from both ends efficiently. Tree is a non-linear, hierarchical data structure consisting of nodes connected by edges, with a top node called the root and nodes having child nodes. It is widely used in file systems, databases, decision-making algorithms, etc. Heap is a complete binary tree data structure that satisfies the heap property. Heaps are usually used to implement priority queues, where the smallest or largest element is always at the root of the tree. Graph is a non-linear data structure consisting of a finite set of vertices(or nodes) and a set of edges(or links)that connect a pair of nodes. Graphs are widely used to represent relationships between entities. Greedy Algorithm builds up the solution one piece at a time and chooses the next piece which gives the most obvious and immediate benefit i.e., which is the most optimal choice at that moment. So the problems where choosing locally optimal also leads to the global solutions are best fit for Greedy. Dynamic Programming is a method used to solve complex problems by breaking them down into simpler subproblems. By solving each subproblem only once and storing the results, it avoids redundant computations, leading to more efficient solutions for a wide range of problems. Bitwise Algorithms: Operate on individual bits of numbers. Backtracking Algorithm : Follow Recursion  with the option to revert and traces back if the solution from current point is not feasible. Divide and conquer:  A strategy to solve problems by dividing them into smaller subproblems, solving those subproblems, and combining the solutions to obtain the final solution. Branch and Bound : Used in combinatorial optimization problems to systematically search for the best solution. It works by dividing the problem into smaller subproblems, or branches, and then eliminating certain branches based on bounds on the optimal solution. This process continues until the best solution is found or all branches have been explored. Geometric algorithms are a set of algorithms that solve problems related to shapes, points, lines and polygons. Randomized algorithms are algorithms that use randomness to solve problems. They make use of random input to achieve their goals, often leading to simpler and more efficient solutions. These algorithms may not product same result but are particularly useful in situations when a probabilistic approach is acceptable. Advanced Data Structures like Trie, Segment Tree, Red-Black Tree and Binary Indexed Tree offer significant performance improvements for specific problem domains. They provide efficient solutions for tasks like fast prefix searches, range queries, dynamic updates, and maintaining balanced data structures, which are crucial for handling large datasets and real-time processing. By optimizing time complexity, they enable better scalability and faster execution in many computational problems. R  ",
        "code": "",
        "complexity": {
            "time": "Advanced Data Structures like Trie, Segment Tree, Red-Black Tree and Binary Indexed Tree offer significant performance improvements for specific problem domains. They provide efficient solutions for tasks like fast prefix searches, range queries, dynamic updates, and maintaining balanced data structures, which are crucial for handling large datasets and real-time processing. By optimizing time complexity, they enable better scalability and faster execution in many computational problems.",
            "space": ""
        },
        "tags": [
            "DSA"
        ],
        "url": "https://www.geeksforgeeks.org/learn-data-structures-and-algorithms-dsa-tutorial/"
    },
    {
        "title": "Data Structures Tutorial",
        "description": "Data structures are the fundamental building blocks of computer programming. They define how data is organized, stored, and manipulated within a program. Understanding data structures is very important for developing efficient and effective algorithms. A data structure is a storage that is used to store and organize data. It is a way of arranging data on a computer so that it can be accessed and updated efficiently. A data structure is not only used for organizing the data. It is also used for processing, retrieving, and storing data. There are different basic and advanced types of data structures that are used in almost every program or software system that has been developed. So we must have good knowledge about data structures. Please refer Complete Data Structures & Algorithms Tutorial for topic-wise guide, practice problems and interview questions.  H  ",
        "code": "",
        "complexity": {
            "time": "",
            "space": ""
        },
        "tags": [
            "DSA"
        ],
        "url": "https://www.geeksforgeeks.org/data-structures/"
    },
    {
        "title": "Algorithms Tutorial",
        "description": "Algorithm is a step-by-step procedure for solving a problem or accomplishing a task. In the context of data structures and algorithms, it is a set of well-defined instructions for performing a specific computational task. Algorithms are fundamental to computer science and play a very important role in designing efficient solutions for various problems. Understanding algorithms is essential for anyone interested in mastering data structures and algorithms.  An algorithm is a finite sequence of well-defined instructions that can be used to solve a computational problem. It provides a step-by-step procedure that convert an input into a desired output. Algorithms typically follow a logical structure: Algorithms are essential for solving complex computational problems efficiently and effectively. They provide a systematic approach to: Please refer Complete Data Structures & Algorithms Tutorial for topic-wise guide, practice problems and interview questions.  H  ",
        "code": "",
        "complexity": {
            "time": "",
            "space": ""
        },
        "tags": [
            "DSA"
        ],
        "url": "https://www.geeksforgeeks.org/fundamentals-of-algorithms/"
    },
    {
        "title": "Getting Started with Array Data Structure",
        "description": "Array is a collection of items of the same variable type that are stored at contiguous memory locations. It is one of the most popular and simple data structures used in programming. In an array, all the elements are stored in contiguous memory locations. So, if we initialize an array, the elements will be allocated sequentially in memory. This allows for efficient access and manipulation of elements.  Arrays can be declared in various ways in different languages. For better illustration, below are some language-specific array declarations: Arrays can be initialized in different ways in different languages. Below are some language-specific array initializations: Assume there is a class of five students and if we have to keep records of their marks in examination then, we can do this by declaring five variables individual and keeping track of records but what if the number of students becomes very large, it would be challenging to manipulate and maintain the data. What it means is that, we can use normal variables (v1, v2, v3, ..) when we have a small number of objects. But if we want to store a large number of instances, it becomes difficult to manage them with normal variables. The idea of an array is to represent many instances in one variable.  Arrays can be classified in two ways: 1. Fixed Sized Arrays We cannot alter or update the size of this array.  Here only a fixed size (i,e. the size that is mentioned in square brackets []) of memory will be allocated for storage. In case, we don’t know the size of the array then if we declare a larger size and store a lesser number of elements will result in a wastage of memory or we declare a lesser size than the number of elements then we won’t get enough memory to store all the elements. In such cases, static memory allocation is not preferred. 2. Dynamic Sized Arrays The size of the array changes as per user requirements during execution of code so the coders do not have to worry about sizes. They can add and removed the elements as per the need. The memory is mostly dynamically allocated and de-allocated in these arrays. 1. One-dimensional Array(1-D Array): You can imagine a 1d array as a row, where elements are stored one after another.  2. Multi-dimensional Array: A multi-dimensional array is an array with more than one dimension. We can use multidimensional array to store complex data in the form of tables, etc. We can have 2-D arrays, 3-D arrays, 4-D arrays and so on. To read more about Matrix Refer, Matrix Data Structure  To read more about Multidimensional Array Refer, Multidimensional Arrays in C – 2D and 3D Arrays  Array traversal refers to the process of accessing and processing each element of an array sequentially. This is one of the most fundamental operations in programming, as arrays are widely used data structures for storing multiple elements in a single variable. How Array Traversal Works? When an array is created, it occupies a contiguous block of memory where elements are stored in an indexed manner. Each element can be accessed using its index, which starts from 0 in most programming languages. For example, consider an array containing five integers: arr = [10, 20, 30, 40, 50] Here: Array traversal means accessing each element from start to end (or sometimes in reverse order), usually by using a loop. Types of Array Traversal Array traversal can be done in multiple ways based on the requirement: To read more about Array Traversal Refer, Traversal in Array Insertion in an array refers to the process of adding a new element at a specific position while maintaining the order of the existing elements. Since arrays have a fixed size in static implementations, inserting an element often requires shifting existing elements to make space. How Insertion Works in an Array? Arrays are stored in contiguous memory locations, meaning elements are arranged in a sequential block. When inserting a new element, the following happens: For example, if we have the array: arr = [10, 20, 30, 40, 50] and we want to insert 25 at index 2, the new array will be: arr = [10, 20, 25, 30, 40, 50] Here, elements 30, 40, and 50 have shifted right to make space. Types of Insertion 1. Insertion at the Beginning (Index 0) 2. Insertion at a Specific Index 3. Insertion at the End To read more about Insertion in Array Refer, Inserting Elements in an Array – Array Operations Deletion in an array refers to the process of removing an element from a specific position while maintaining the order of the remaining elements. Unlike linked lists, where deletion is efficient, removing an element from an array requires shifting elements to fill the gap. How Deletion Works in an Array? Since arrays have contiguous memory allocation, deleting an element does not reduce the allocated memory size. Instead, it involves: For example, consider the array: arr = [10, 20, 30, 40, 50] If we delete the element 30 (index 2), the new array will be: arr = [10, 20, 40, 50] Here, elements 40 and 50 shifted left to fill the gap. Types of Deletion 1. Deletion at the Beginning (Index 0) 2. Deletion at a Specific Index 3. Deletion at the End To read more about Deletion in Array Refer, Deleting Elements in an Array – Array Operations 4. Searching in Array Searching in an array refers to the process of finding a specific element in a given list of elements. The goal is to determine whether the element exists in the array and, if so, find its index (position). Searching is a fundamental operation in programming, as it is used in data retrieval, filtering, and processing. There are two main types of searching techniques in an array: 1. Linear Search (Sequential Search) Consider an array: arr = [10, 20, 30, 40, 50] If we search for 30, the algorithm will: 2. Binary Search (Efficient Search for Sorted Arrays) Consider a sorted array: arr = [10, 20, 30, 40, 50] If we search for 30: To read more about Searching in Array Refer, Searching Elements in Array Next Read: Applications, Advantages and Disadvantages of Array  ",
        "code": "// This array will store integer type element\nint arr[5];      \n\n// This array will store char type element\nchar arr[10];   \n\n// This array will store float type element\nfloat arr[20];\n// This array will store integer type element\nint arr[5];      \n\n// This array will store char type element\nchar arr[10];   \n\n// This array will store float type element\nfloat arr[20];\n// This array will store integer type element\nint arr[];     \n\n// This array will store char type element\nchar arr[];   \n\n// This array will store float type element\nfloat arr[];\n# In Python, all types of lists are created same way\narr = []\n// This array will store integer type element\nint[] arr;\n\n// This array will store char type element\nchar[] arr2;\n\n// This array will store float type element\nfloat[] arr3;\n// JS code\nlet arr = []\nint arr[] = { 1, 2, 3, 4, 5 };\nchar arr[5] = { 'a', 'b', 'c', 'd', 'e' };\nfloat arr[10] = { 1.4, 2.0, 24, 5.0, 0.0 };\nint arr[] = { 1, 2, 3, 4, 5 };\nchar arr[5] = { 'a', 'b', 'c', 'd', 'e' };\nfloat arr[10] = { 1.4, 2.0, 24, 5.0, 0.0 };\nint arr[] = { 1, 2, 3, 4, 5 };\nchar arr[] = { 'a', 'b', 'c', 'd', 'e' };\nfloat arr[] = { 1.4f, 2.0f, 24f, 5.0f, 0.0f };\n# This list will store integer type elements\narr = [1, 2, 3, 4, 5]\n\n# This list will store character type elements (strings in Python)\narr = ['a', 'b', 'c', 'd', 'e']\n\n# This list will store float type elements\narr = [1.4, 2.0, 24.0, 5.0, 0.0]  # All float values\nint[] arr = { 1, 2, 3, 4, 5 };\nchar[] arr = { 'a', 'b', 'c', 'd', 'e' };\nfloat[] arr = { 1.4f, 2.0f, 24f, 5.0f, 0.0f };\nlet arr = [ 1, 2, 3, 4, 5 ];\nlet arr = [ 'a', 'b', 'c', 'd', 'e' ];\nlet arr = [ 1.4, 2.0, 24, 5.0, 0.0 ];\n// Method 1 to create a fixed sized array. \n// Here the memory is allocated at compile time.\nint arr[5]; \n// Another way (creation and initialization both)\nint arr2[5] = {1, 2, 3, 4, 5}; \n\n// Method 2 to create a fixed sized array\n// Here memory is allocated at run time (Also\n// known as dynamically allocated arrays)\nint *arr = new int[5];\n// Method 1 to create a fixed sized array. \n// Here the memory is allocated at compile time.\nint arr1[5];\n// Another way (creation and initialization both)\nint arr2[5] = {1, 2, 3, 4, 5}; \n\n\n// Method 2 to create a fixed sized array\n// Here memory is allocated at run time (Also\n// known as dynamically allocated arrays)\nint *arr = (int*)malloc(n * sizeof(int));\n// Fixed sized array examples\nint[] arr1 = new int [5];\n\n// Another way (Array creation and \n// initialization both)\nint[] arr2 = {1, 2, 3, 4, 5};\n# Create a fixed-size list of length 5, \n# initialized with zeros\narr = [0] * 5\n\n# Output the fixed-size list\nprint(arr)\n// Fixed sized array examples\nint[] arr1 = new int [5];\n\n// Another way (Array creation and \n// initialization both)\nint[] arr2 = {1, 2, 3, 4, 5};\n#include<vector>\n\n// Dynamic Integer Array\nvector<int> v;\n// C does not seem to support\n// dynamic sized arrays as of now\n// Dynamic Integer Array\nArrayList<Integer> arr = new ArrayList<>();\n# Dynamic Array\narr = []\n// Similar to Java\nArrayList myList = new ArrayList();\n// Dynamic Sized Array\nlet arr = new Array();\n",
        "complexity": {
            "time": "",
            "space": ""
        },
        "tags": [
            "DSA"
        ],
        "url": "https://www.geeksforgeeks.org/complete-guide-to-arrays-data-structure/"
    },
    {
        "title": "String in Data Structure",
        "description": "A string is a sequence of characters.  The following facts make string an interesting data structure. Please refer String Problems Topic Wise for the list of questions on different topics like binary string, subsequence and substring, pattern searching and palindrome. H  ",
        "code": "",
        "complexity": {
            "time": "",
            "space": ""
        },
        "tags": [
            "DSA"
        ],
        "url": "https://www.geeksforgeeks.org/complete-guide-to-string-data-structure/"
    },
    {
        "title": "Linked List Data Structure",
        "description": "A linked list is a fundamental data structure in computer science. It mainly allows efficient insertion and deletion operations compared to arrays.  Like arrays, it is also used to implement other data structures like stack, queue and deque. Here’s the comparison of Linked List vs Arrays Linked List: Array: Quick Links : Recommended: H  ",
        "code": "",
        "complexity": {
            "time": "",
            "space": ""
        },
        "tags": [
            "DSA"
        ],
        "url": "https://www.geeksforgeeks.org/linked-list-data-structure/"
    },
    {
        "title": "Stack Data Structure",
        "description": "A Stack is a linear data structure that follows a particular order in which the operations are performed. The order may be LIFO(Last In First Out) or FILO(First In Last Out). LIFO implies that the element that is inserted last, comes out first and FILO implies that the element that is inserted first, comes out last. It behaves like a stack of plates, where the last plate added is the first one to be removed. Think of it this way:  Quick Links : Recommended: H  ",
        "code": "",
        "complexity": {
            "time": "",
            "space": ""
        },
        "tags": [
            "DSA"
        ],
        "url": "https://www.geeksforgeeks.org/stack-data-structure/"
    },
    {
        "title": "Queue Data Structure",
        "description": "A Queue Data Structure is a fundamental concept in computer science used for storing and managing data in a specific order.  Quick Links: Recommended: H  ",
        "code": "",
        "complexity": {
            "time": "",
            "space": ""
        },
        "tags": [
            "DSA"
        ],
        "url": "https://www.geeksforgeeks.org/queue-data-structure/"
    },
    {
        "title": "Introduction to Tree Data Structure",
        "description": "Tree data structure is a hierarchical structure that is used to represent and organize data in the form of parent child relationship. The following are some real world situations which are naturally a tree. The topmost node of the tree is called the root, and the nodes below it are called the child nodes. Each node can have multiple child nodes, and these child nodes can also have their own child nodes, forming a recursive structure.  Basic Terminologies In Tree The data in a tree are not stored in a sequential manner i.e., they are not stored linearly. Instead, they are arranged on multiple levels or we can say it is a hierarchical structure. For this reason, the tree is considered to be a non-linear data structure. We strongly recommend to study a Binary Tree first as a Binary Tree has structure and code implementation compared to a general tree. A tree consists of a root node, and zero or more subtrees T1, T2, … , Tk such that there is an edge from the root node of the tree to the root node of each subtree. Subtree of a node X consists of all the nodes which have node X as the ancestor node. Representation of Tree Data Structure A tree can be represented using a collection of nodes. Each of the nodes can be represented with the help of class or structs. Below is the representation of Node in different languages: One reason to use trees might be because you want to store information that naturally forms a hierarchy. For example, the file system on a computer: The DOM model of an HTML page is also tree where we have html tag as root, head and body its children and these tags, then have their own children.Please refer Applications, Advantages and Disadvantages of Tree for details. Tree data structure can be classified into three types based upon the number of children each node of the tree can have. The types are: Please refer Types of Trees in Data Structures for details. Implementation of Tree Data Structure: Number of edges: An edge can be defined as the connection between two nodes. If a tree has N nodes then it will have (N-1) edges. There is only one path from each node to any other node of the tree. Depth of a node: The depth of a node is defined as the length of the path from the root to that node. Each edge adds 1 unit of length to the path. So, it can also be defined as the number of edges in the path from the root of the tree to the node.  ",
        "code": "class Node {\npublic:\n    int data;\n    Node* first_child;\n    Node* second_child;\n    Node* third_child;\n    .\n    .\n    .\n    Node* nth_child;\n};\nstruct Node {\n    int data;\n    struct Node* first_child;\n    struct Node* second_child;\n    struct Node* third_child;\n    .\n    .\n    .\n    struct Node* nth_child;\n};\npublic static class Node {\n    int data;\n    Node first_child;\n    Node second_child;\n    Node third_child;\n      .\n    .\n    .\n    Node nth_child;\n}\nclass Node:\n    def __init__(self, data):\n        self.data = data\n        self.children = []\nclass Node {\n    constructor(data) {\n        this.data = data;\n        this.children = [];\n    }\n}\n// C++ program to demonstrate some of the above\n// terminologies\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Function to add an edge between vertices x and y\nvoid addEdge(int x, int y, vector<vector<int> >& adj)\n{\n    adj[x].push_back(y);\n    adj[y].push_back(x);\n}\n\n// Function to print the parent of each node\nvoid printParents(int node, vector<vector<int> >& adj,\n                  int parent)\n{\n    // current node is Root, thus, has no parent\n    if (parent == 0)\n        cout << node << \"->Root\" << endl;\n    else\n        cout << node << \"->\" << parent << endl;\n  \n    // Using DFS\n    for (auto cur : adj[node])\n        if (cur != parent)\n            printParents(cur, adj, node);\n}\n\n// Function to print the children of each node\nvoid printChildren(int Root, vector<vector<int> >& adj)\n{\n    // Queue for the BFS\n    queue<int> q;\n  \n    // pushing the root\n    q.push(Root);\n  \n    // visit array to keep track of nodes that have been\n    // visited\n    int vis[adj.size()] = { 0 };\n  \n    // BFS\n    while (!q.empty()) {\n        int node = q.front();\n        q.pop();\n        vis[node] = 1;\n        cout << node << \"-> \";\n        for (auto cur : adj[node])\n            if (vis[cur] == 0) {\n                cout << cur << \" \";\n                q.push(cur);\n            }\n        cout << endl;\n    }\n}\n\n// Function to print the leaf nodes\nvoid printLeafNodes(int Root, vector<vector<int> >& adj)\n{\n    // Leaf nodes have only one edge and are not the root\n    for (int i = 1; i < adj.size(); i++)\n        if (adj[i].size() == 1 && i != Root)\n            cout << i << \" \";\n    cout << endl;\n}\n\n// Function to print the degrees of each node\nvoid printDegrees(int Root, vector<vector<int> >& adj)\n{\n    for (int i = 1; i < adj.size(); i++) {\n        cout << i << \": \";\n      \n        // Root has no parent, thus, its degree is equal to\n        // the edges it is connected to\n        if (i == Root)\n            cout << adj[i].size() << endl;\n        else\n            cout << adj[i].size() - 1 << endl;\n    }\n}\n// Driver code\nint main()\n{\n    // Number of nodes\n    int N = 7, Root = 1;\n    // Adjacency list to store the tree\n    vector<vector<int> > adj(N + 1, vector<int>());\n    // Creating the tree\n    addEdge(1, 2, adj);\n    addEdge(1, 3, adj);\n    addEdge(1, 4, adj);\n    addEdge(2, 5, adj);\n    addEdge(2, 6, adj);\n    addEdge(4, 7, adj);\n  \n    // Printing the parents of each node\n    cout << \"The parents of each node are:\" << endl;\n    printParents(Root, adj, 0);\n\n    // Printing the children of each node\n    cout << \"The children of each node are:\" << endl;\n    printChildren(Root, adj);\n\n    // Printing the leaf nodes in the tree\n    cout << \"The leaf nodes of the tree are:\" << endl;\n    printLeafNodes(Root, adj);\n\n    // Printing the degrees of each node\n    cout << \"The degrees of each node are:\" << endl;\n    printDegrees(Root, adj);\n\n    return 0;\n}\n// java code for above approach\nimport java.io.*;\nimport java.util.*;\n\nclass GFG {\n\n    // Function to print the parent of each node\n    public static void\n    printParents(int node, Vector<Vector<Integer> > adj,\n                 int parent)\n    {\n\n        // current node is Root, thus, has no parent\n        if (parent == 0)\n            System.out.println(node + \"->Root\");\n        else\n            System.out.println(node + \"->\" + parent);\n\n        // Using DFS\n        for (int i = 0; i < adj.get(node).size(); i++)\n            if (adj.get(node).get(i) != parent)\n                printParents(adj.get(node).get(i), adj,\n                             node);\n    }\n\n    // Function to print the children of each node\n    public static void\n    printChildren(int Root, Vector<Vector<Integer> > adj)\n    {\n\n        // Queue for the BFS\n        Queue<Integer> q = new LinkedList<>();\n\n        // pushing the root\n        q.add(Root);\n\n        // visit array to keep track of nodes that have been\n        // visited\n        int vis[] = new int[adj.size()];\n\n        Arrays.fill(vis, 0);\n\n        // BFS\n        while (q.size() != 0) {\n            int node = q.peek();\n            q.remove();\n            vis[node] = 1;\n            System.out.print(node + \"-> \");\n\n            for (int i = 0; i < adj.get(node).size(); i++) {\n                if (vis[adj.get(node).get(i)] == 0) {\n                    System.out.print(adj.get(node).get(i)\n                                     + \" \");\n                    q.add(adj.get(node).get(i));\n                }\n            }\n            System.out.println();\n        }\n    }\n\n    // Function to print the leaf nodes\n    public static void\n    printLeafNodes(int Root, Vector<Vector<Integer> > adj)\n    {\n\n        // Leaf nodes have only one edge and are not the\n        // root\n        for (int i = 1; i < adj.size(); i++)\n            if (adj.get(i).size() == 1 && i != Root)\n                System.out.print(i + \" \");\n\n        System.out.println();\n    }\n\n    // Function to print the degrees of each node\n    public static void\n    printDegrees(int Root, Vector<Vector<Integer> > adj)\n    {\n        for (int i = 1; i < adj.size(); i++) {\n            System.out.print(i + \": \");\n\n            // Root has no parent, thus, its degree is\n            // equal to the edges it is connected to\n            if (i == Root)\n                System.out.println(adj.get(i).size());\n            else\n                System.out.println(adj.get(i).size() - 1);\n        }\n    }\n\n    // Driver code\n    public static void main(String[] args)\n    {\n\n        // Number of nodes\n        int N = 7, Root = 1;\n\n        // Adjacency list to store the tree\n        Vector<Vector<Integer> > adj\n            = new Vector<Vector<Integer> >();\n        for (int i = 0; i < N + 1; i++) {\n            adj.add(new Vector<Integer>());\n        }\n\n        // Creating the tree\n        adj.get(1).add(2);\n        adj.get(2).add(1);\n\n        adj.get(1).add(3);\n        adj.get(3).add(1);\n\n        adj.get(1).add(4);\n        adj.get(4).add(1);\n\n        adj.get(2).add(5);\n        adj.get(5).add(2);\n\n        adj.get(2).add(6);\n        adj.get(6).add(2);\n\n        adj.get(4).add(7);\n        adj.get(7).add(4);\n\n        // Printing the parents of each node\n        System.out.println(\"The parents of each node are:\");\n        printParents(Root, adj, 0);\n\n        // Printing the children of each node\n        System.out.println(\n            \"The children of each node are:\");\n        printChildren(Root, adj);\n\n        // Printing the leaf nodes in the tree\n        System.out.println(\n            \"The leaf nodes of the tree are:\");\n        printLeafNodes(Root, adj);\n\n        // Printing the degrees of each node\n        System.out.println(\"The degrees of each node are:\");\n        printDegrees(Root, adj);\n    }\n}\n\n// This code is contributed by rj13to.\nfrom collections import deque\n\n# Function to add an edge between vertices x and y\ndef addEdge(x, y, adj):\n    adj[x].append(y)\n    adj[y].append(x)\n\n# Function to print the parent of each node\ndef printParents(node, adj, parent):\n    # current node is Root, thus, has no parent\n    if parent == 0:\n        print(\"{}->Root\".format(node))\n    else:\n        print(\"{}->{}\".format(node, parent))\n\n    # Using DFS\n    for cur in adj[node]:\n        if cur != parent:\n            printParents(cur, adj, node)\n\n# Function to print the children of each node\ndef printChildren(Root, adj):\n    # Queue for the BFS\n    q = deque()\n    # pushing the root\n    q.append(Root)\n    # visit array to keep track of nodes that have been\n    # visited\n    vis = [0] * len(adj)\n    # BFS\n    while q:\n        node = q.popleft()\n        vis[node] = 1\n        print(\"{}->\".format(node)),\n        for cur in adj[node]:\n            if vis[cur] == 0:\n                print(cur),\n                q.append(cur)\n        print()\n\n# Function to print the leaf nodes\ndef printLeafNodes(Root, adj):\n    # Leaf nodes have only one edge and are not the root\n    for i in range(1, len(adj)):\n        if len(adj[i]) == 1 and i != Root:\n            print(i),\n\n# Function to print the degrees of each node\ndef printDegrees(Root, adj):\n    for i in range(1, len(adj)):\n        print(i, \":\"),\n        # Root has no parent, thus, its degree is equal to\n        # the edges it is connected to\n        if i == Root:\n            print(len(adj[i]))\n        else:\n            print(len(adj[i]) - 1)\n\n# Driver code\nN = 7\nRoot = 1\n# Adjacency list to store the tree\nadj = [[] for _ in range(N + 1)]\n# Creating the tree\naddEdge(1, 2, adj)\naddEdge(1, 3, adj)\naddEdge(1, 4, adj)\naddEdge(2, 5, adj)\naddEdge(2, 6, adj)\naddEdge(4, 7, adj)\n\n# Printing the parents of each node\nprint(\"The parents of each node are:\")\nprintParents(Root, adj, 0)\n\n# Printing the children of each node\nprint(\"The children of each node are:\")\nprintChildren(Root, adj)\n\n# Printing the leaf nodes in the tree\nprint(\"The leaf nodes of the tree are:\")\nprintLeafNodes(Root, adj)\n\n# Printing the degrees of each node\nprint(\"The degrees of each node are:\")\nprintDegrees(Root, adj)\nusing System;\nusing System.Collections.Generic;\n\nclass GfG\n{\n    static void PrintParents(int node, List<List<int>> adj, int parent)\n    {\n        if (parent == 0)\n        {\n            Console.WriteLine($\"{node} -> Root\");\n        }\n        else\n        {\n            Console.WriteLine($\"{node} -> {parent}\");\n        }\n\n        foreach (int cur in adj[node])\n        {\n            if (cur != parent)\n            {\n                PrintParents(cur, adj, node);\n            }\n        }\n    }\n\n    static void PrintChildren(int Root, List<List<int>> adj)\n    {\n        Queue<int> q = new Queue<int>();\n        q.Enqueue(Root);\n        bool[] vis = new bool[adj.Count];\n\n        while (q.Count > 0)\n        {\n            int node = q.Dequeue();\n            vis[node] = true;\n            Console.Write($\"{node} -> \");\n\n            foreach (int cur in adj[node])\n            {\n                if (!vis[cur])\n                {\n                    Console.Write($\"{cur} \");\n                    q.Enqueue(cur);\n                }\n            }\n            Console.WriteLine();\n        }\n    }\n\n    static void PrintLeafNodes(int Root, List<List<int>> adj)\n    {\n        for (int i = 0; i < adj.Count; i++)\n        {\n            if (adj[i].Count == 1 && i != Root)\n            {\n                Console.Write($\"{i} \");\n            }\n        }\n        Console.WriteLine();\n    }\n\n    static void PrintDegrees(int Root, List<List<int>> adj)\n    {\n        for (int i = 1; i < adj.Count; i++)\n        {\n            Console.Write($\"{i}: \");\n\n            if (i == Root)\n            {\n                Console.WriteLine(adj[i].Count);\n            }\n            else\n            {\n                Console.WriteLine(adj[i].Count - 1);\n            }\n        }\n    }\n\n    static void Main(string[] args)\n    {\n        int N = 7;\n        int Root = 1;\n        List<List<int>> adj = new List<List<int>>();\n\n        for (int i = 0; i <= N; i++)\n        {\n            adj.Add(new List<int>());\n        }\n\n        adj[1].AddRange(new int[] { 2, 3, 4 });\n        adj[2].AddRange(new int[] { 1, 5, 6 });\n        adj[4].Add(7);\n\n        Console.WriteLine(\"The parents of each node are:\");\n        PrintParents(Root, adj, 0);\n\n        Console.WriteLine(\"The children of each node are:\");\n        PrintChildren(Root, adj);\n\n        Console.WriteLine(\"The leaf nodes of the tree are:\");\n        PrintLeafNodes(Root, adj);\n\n        Console.WriteLine(\"The degrees of each node are:\");\n        PrintDegrees(Root, adj);\n    }\n}\n// Number of nodes\nlet n = 7, root = 1;\n\n// Adjacency list to store the tree\nlet adj = new Array(n + 1).fill(null).map(() => []);\n\n// Creating the tree\naddEdge(1, 2, adj);\naddEdge(1, 3, adj);\naddEdge(1, 4, adj);\naddEdge(2, 5, adj);\naddEdge(2, 6, adj);\naddEdge(4, 7, adj);\n\n// Function to add an edge between vertices x and y\nfunction addEdge(x, y, arr) {\n    arr[x].push(y);\n    arr[y].push(x);\n}\n\n// Function to print the parent of each node\nfunction printParents(node, arr, parent) {\n    // current node is Root, thus, has no parent\n    if (parent == 0)\n        console.log(`${node}->root`);\n    else\n        console.log(`${node}->${parent}`);\n        \n    // Using DFS\n    for (let cur of arr[node])\n        if (cur != parent)\n            printParents(cur, arr, node);\n}\n\n// Function to print the children of each node\nfunction printChildren(root, arr) {\n    // Queue for the BFS\n    let q = [];\n    \n    // pushing the root\n    q.push(root);\n    \n    // visit array to keep track of nodes\n    // that have been visited\n    let vis = new Array(arr.length).fill(0);\n    \n    // BFS\n    while (q.length > 0) {\n        let node = q.shift();\n        vis[node] = 1;\n        console.log(`${node}-> `);\n        for (let cur of arr[node])\n            if (vis[cur] == 0) {\n                console.log(cur + \" \");\n                q.push(cur);\n            }\n        console.log(\"\\n\");\n    }\n}\n\n// Function to print the leaf nodes\nfunction printLeafNodes(root, arr) {\n    // Leaf nodes have only one edge\n    // and are not the root\n    for (let i = 1; i < arr.length; i++)\n        if (arr[i].length == 1 &&\n        i != root)\n            console.log(i + \" \");\n    console.log(\"\\n\");\n}\n\n// Function to print the degrees of each node\nfunction printDegrees(Root, arr) {\n    for (let i = 1; i < arr.length; i++) {\n        console.log(`${i}: `);\n        \n        // Root has no parent, thus, its degree is equal to\n        // the edges it is connected to\n        if (i == root)\n            console.log(arr[i].length + \"\\n\");\n        else\n            console.log(arr[i].length - 1 + \"\\n\");\n    }\n}\n\n// Function to print the tree in a hierarchical format\nfunction printTree(node, arr, parent, level) {\n    // Indent based on the level of the node\n    console.log(\"  \".repeat(level) + \"└── \" + node);\n\n    // Recursively print children\n    for (let cur of arr[node])\n        if (cur != parent)\n            printTree(cur, arr, node, level + 1);\n}\n\n// Driver code\n\n// Printing the tree in a hierarchical format\nconsole.log(\"Tree Structure:\");\nprintTree(root, adj, 0, 0);\n\n// Printing the parents of each node\nconsole.log(\"\\nThe parents of each node are:\");\nprintParents(root, adj, 0);\n\n// Printing the children of each node\nconsole.log(\"\\nThe children of each node are:\");\nprintChildren(root, adj);\n\n// Printing the leaf nodes in the tree\nconsole.log(\"\\nThe leaf nodes of the tree are:\");\nprintLeafNodes(root, adj);\n\n// Printing the degrees of each node\nconsole.log(\"\\nThe degrees of each node are:\");\nprintDegrees(root, adj);\nThe parents of each node are:\n1->Root\n2->1\n5->2\n6->2\n3->1\n4->1\n7->4\nThe children of each node are:\n1-> 2 3 4 \n2-> 5 6 \n3-> \n4-> 7 \n5-> \n6-> \n7-> \nThe leaf nodes of the tree are:\n3 5 6 7 \nThe degrees o...\n",
        "complexity": {
            "time": "",
            "space": ""
        },
        "tags": [
            "DSA"
        ],
        "url": "https://www.geeksforgeeks.org/introduction-to-tree-data-structure-and-algorithm-tutorials/"
    },
    {
        "title": "Graph  Algorithms",
        "description": "Graph algorithms are methods used to manipulate and analyze graphs, solving various range of problems like finding the shortest path, cycles detection. If you are looking for difficulty-wise list of problems, please refer to Graph Data Structure. Quick Links : Recommended: H  ",
        "code": "",
        "complexity": {
            "time": "",
            "space": ""
        },
        "tags": [
            "DSA"
        ],
        "url": "https://www.geeksforgeeks.org/graph-data-structure-and-algorithms/"
    },
    {
        "title": "Searching Algorithms",
        "description": "Searching algorithms are essential tools in computer science used to locate specific items within a collection of data. In this tutorial, we are mainly going to focus upon searching in an array. When we search an item in an array, there are two most common algorithms used based on the type of input array. One more common search technique is Two Pointers Technique where we begin searching from both ends of the array.  Quick Links: H  ",
        "code": "",
        "complexity": {
            "time": "",
            "space": ""
        },
        "tags": [
            "DSA"
        ],
        "url": "https://www.geeksforgeeks.org/searching-algorithms/"
    },
    {
        "title": "Sorting Algorithms",
        "description": "A Sorting Algorithm is used to rearrange a given array or list of elements in an order.  For example, a given array [10, 20, 5, 2] becomes [2, 5, 10, 20] after sorting in increasing order and becomes [20, 10, 5, 2] after sorting in decreasing order. Comparison Based : Selection Sort,  Bubble Sort,  Insertion Sort,  Merge Sort,  Quick Sort,  Heap Sort, Cycle Sort, 3-way Merge SortNon Comparison Based :  Counting Sort, Radix Sort, Bucket Sort,  TimSort, Comb Sort, Pigeonhole SortHybrid Sorting Algorithms : IntroSort, Tim Sort Quick Links : Recommended: H  ",
        "code": "",
        "complexity": {
            "time": "",
            "space": ""
        },
        "tags": [
            "DSA"
        ],
        "url": "https://www.geeksforgeeks.org/sorting-algorithms/"
    },
    {
        "title": "Introduction to Recursion",
        "description": "The process in which a function calls itself directly or indirectly is called recursion and the corresponding function is called a recursive function. Need of Recursion Steps to Implement Recursion Step1 – Define a base case: Identify the simplest (or base) case for which the solution is known or trivial. This is the stopping condition for the recursion, as it prevents the function from infinitely calling itself.Step2 – Define a recursive case: Define the problem in terms of smaller subproblems. Break the problem down into smaller versions of itself, and call the function recursively to solve each subproblem.Step3 – Ensure the recursion terminates: Make sure that the recursive function eventually reaches the base case, and does not enter an infinite loop.Step4 – Combine the solutions: Combine the solutions of the subproblems to solve the original problem. Example 1 : Sum of Natural Numbers Let us consider a problem to find the sum of natural numbers, there are several ways of doing that but the simplest approach is simply to add the numbers starting from 0 to n. What is the base condition in recursion? A recursive program stops at a base condition.  There can be more than one base conditions in a recursion. In the above program, the base condition is when n = 1. How a particular problem is solved using recursion? The idea is to represent a problem in terms of one or more smaller problems, and add one or more base conditions that stop the recursion. Example 2 : Factorial of a Number The factorial of a number n (where n >= 0) is the product of all positive integers from 1 to n. To compute the factorial recursively, we calculate the factorial of n by using the factorial of (n-1). The base case for the recursive function is when n = 0, in which case we return 1. Illustration of the above code: When does Stack Overflow error occur in recursion? If the base case is not reached or not defined, then the stack overflow problem may arise. Let us take an example to understand this. int fact(int n){    // wrong base case (it may cause stack overflow).    if (n == 100)         return 1;    else        return n*fact(n-1);} What is the difference between direct and indirect recursion? A function is called direct recursive if it calls itself directly during its execution. In other words, the function makes a recursive call to itself within its own body. An indirect recursive function is one that calls another function, and that other function, in turn, calls the original function either directly or through other functions. This creates a chain of recursive calls involving multiple functions, as opposed to direct recursion, where a function calls itself. // An example of direct recursionvoid directRecFun(){    // Some code….    directRecFun();    // Some code…}// An example of indirect recursionvoid indirectRecFun1(){    // Some code…    indirectRecFun2();    // Some code…}void indirectRecFun2(){    // Some code…    indirectRecFun1();    // Some code…} What is the difference between tail and non-tail recursion? A recursive function is tail recursive when a recursive call is the last thing executed by the function. Please refer tail recursion for details. How memory is allocated to different function calls in recursion? Recursion uses more memory to store data of every recursive call in an internal function call stack. When any function is called from main(), the memory is allocated to it on the stack. A recursive function calls itself, the memory for a called function is allocated on top of memory allocated to the calling function and a different copy of local variables is created for each function call. When the base case is reached, the function returns its value to the function by whom it is called and memory is de-allocated and the process continues.Let us take the example of how recursion works by taking a simple function. Initial Call: When printFun(3) is called from main(), memory is allocated for printFun(3). The local variable test is initialized to 3, and statements 1 to 4 are pushed onto the stack. First Recursive Call: Second Recursive Call: Third Recursive Call: Base Case: When printFun(0) is called, it hits the base case (if statement) and returns control to printFun(1). Returning from Recursion: Output: As a result, the output will print the values in the following order: The memory stack grows with each function call and shrinks as the recursion unwinds, following the LIFO structure.  Recursion VS Iteration What are the advantages of recursive programming over iterative programming? What are the disadvantages of recursive programming over iterative programming? Note every recursive program can be written iteratively and vice versa is also true. Example 3 : Fibonacci with Recursion Write a program and recurrence relation to find the Fibonacci series of n where n >= 0. Mathematical Equation: n if n == 0, n == 1;      fib(n) = fib(n-1) + fib(n-2) otherwise; Recurrence Relation: T(n) = T(n-1) + T(n-2) + O(1) Recursion Tree for the above Code: fibonacci series These are just a few examples of the many applications of recursion in computer science and programming. Recursion is a versatile and powerful tool that can be used to solve many different types of problems. Summary of Recursion: Output based practice problems for beginners: Practice Questions for Recursion | Set 1 Practice Questions for Recursion | Set 2 Practice Questions for Recursion | Set 3 Practice Questions for Recursion | Set 4 Practice Questions for Recursion | Set 5 Practice Questions for Recursion | Set 6 Practice Questions for Recursion | Set 7Quiz on Recursion Coding Practice on Recursion: All Articles on Recursion Recursive Practice Problems with Solutions S  ",
        "code": "#include <iostream>\nusing namespace std;\n\n// Recursive function to find the sum of \n// numbers from 0 to n\nint findSum(int n)\n{\n    // Base case \n    if (n == 1) \n        return 1; \n  \n    // Recursive case \n    return n + findSum(n - 1);\n}\n\nint main()\n{\n    int n = 5;\n    cout << findSum(n);\n    return 0;\n}\n#include <stdio.h>\n\n// Recursive function to find the sum of \n// numbers from 0 to n\nint findSum(int n)\n{\n    // Base case \n    if (n == 1) \n        return 1; \n  \n    // Recursive case \n    return n + findSum(n - 1);\n}\n\nint main()\n{\n    int n = 5;\n    printf(\"%d\", findSum(n));\n    return 0;\n}\npublic class Main {\n    // Recursive function to find the sum of \n    // numbers from 0 to n\n    static int findSum(int n) {\n        // Base case \n        if (n == 1) \n            return 1; \n        \n        // Recursive case \n        return n + findSum(n - 1);\n    }\n\n    public static void main(String[] args) {\n        int n = 5;\n        System.out.println(findSum(n));\n    }\n}\ndef findSum(n):\n    # Base case \n    if n == 1:\n        return 1\n    \n    # Recursive case \n    return n + findSum(n - 1)\n\nn = 5\nprint(findSum(n))\nusing System;\n\nclass Program {\n    // Recursive function to find the sum of \n    // numbers from 0 to n\n    static int FindSum(int n) {\n        // Base case \n        if (n == 1) \n            return 1;\n        \n        // Recursive case \n        return n + FindSum(n - 1);\n    }\n\n    static void Main() {\n        int n = 5;\n        Console.WriteLine(FindSum(n));\n    }\n}\n// Recursive function to find the sum of \n// numbers from 0 to n\nfunction findSum(n) {\n    // Base case \n    if (n === 1) \n        return 1;\n    \n    // Recursive case \n    return n + findSum(n - 1);\n}\n\nlet n = 5;\nconsole.log(findSum(n));\n15\n#include <iostream>\nusing namespace std;\n\nint fact(int n)\n{\n    // BASE CONDITION\n    if (n == 0)\n        return 1;\n  \n    return n * fact(n - 1);\n}\n\nint main()\n{\n    cout << \"Factorial of 5 : \" << fact(5);\n    return 0;\n}\n#include <stdio.h>\n\nint fact(int n) {\n  \n    // BASE CONDITION\n    if (n == 0)\n        return 1;\n  \n    return n * fact(n - 1);\n}\n\nint main() {\n    printf(\"Factorial of 5 : %d\\n\", fact(5));\n    return 0;\n}\npublic class GfG {\n    public static int fact(int n) {\n      \n        // BASE CONDITION\n        if (n == 0)\n            return 1;\n      \n        return n * fact(n - 1);\n    }\n\n    public static void main(String[] args) {\n        System.out.println(\"Factorial of 5 : \" + fact(5));\n    }\n}\ndef fact(n):\n  \n    # BASE CONDITION\n    if n == 0:\n        return 1\n    return n * fact(n - 1)\n\nprint(\"Factorial of 5 : \", fact(5))\nusing System;\n\nclass Program {\n    static int Fact(int n) {\n      \n        // BASE CONDITION\n        if (n == 0)\n            return 1;\n        \n        return n * Fact(n - 1);\n    }\n\n    static void Main() {\n        Console.WriteLine(\"Factorial of 5 : \" + Fact(5));\n    }\n}\nfunction fact(n) {\n\n    // BASE CONDITION\n    if (n === 0)\n        return 1;\n    \n    return n * fact(n - 1);\n}\n\nconsole.log(\"Factorial of 5 : \" + fact(5));\n<?php\nfunction fact($n) {\n  \n    // BASE CONDITION\n    if ($n == 0)\n        return 1;\n  \n    return $n * fact($n - 1);\n}\n\necho \"Factorial of 5 : \" . fact(5);\n?>\nFactorial of 5 : 120\n// A C++ program to demonstrate working of\n// recursion\n#include <bits/stdc++.h>\nusing namespace std;\n\nvoid printFun(int test)\n{\n    if (test < 1)\n        return;\n    else {\n        cout << test << \" \";\n        printFun(test - 1); // statement 2\n        cout << test << \" \";\n        return;\n    }\n}\n\n// Driver Code\nint main()\n{\n    int test = 3;\n    printFun(test);\n}\n// A C program to demonstrate working of recursion\n#include <stdio.h>\n\nvoid printFun(int test)\n{\n    if (test < 1)\n        return;\n    else {\n        printf(\"%d \", test);\n        printFun(test - 1); // statement 2\n        printf(\"%d \", test);\n        return;\n    }\n}\n\n// Driver Code\nint main()\n{\n    int test = 3;\n    printFun(test);\n    return 0;\n}\n// A Java program to demonstrate working of\n// recursion\nclass GFG {\n    static void printFun(int test)\n    {\n        if (test < 1)\n            return;\n        else {\n            System.out.printf(\"%d \", test);\n            printFun(test - 1); // statement 2\n            System.out.printf(\"%d \", test);\n            return;\n        }\n    }\n\n    // Driver Code\n    public static void main(String[] args)\n    {\n        int test = 3;\n        printFun(test);\n    }\n}\n\n// This code is contributed by\n// Smitha Dinesh Semwal\n# A Python 3 program to\n# demonstrate working of\n# recursion\n\n\ndef printFun(test):\n\n    if (test < 1):\n        return\n    else:\n\n        print(test, end=\" \")\n        printFun(test-1)  # statement 2\n        print(test, end=\" \")\n        return\n\n# Driver Code\ntest = 3\nprintFun(test)\n\n# This code is contributed by\n# Smitha Dinesh Semwal\n// A C# program to demonstrate\n// working of recursion\nusing System;\n\nclass GFG {\n\n    // function to demonstrate\n    // working of recursion\n    static void printFun(int test)\n    {\n        if (test < 1)\n            return;\n        else {\n            Console.Write(test + \" \");\n\n            // statement 2\n            printFun(test - 1);\n\n            Console.Write(test + \" \");\n            return;\n        }\n    }\n\n    // Driver Code\n    public static void Main(String[] args)\n    {\n        int test = 3;\n        printFun(test);\n    }\n}\n\n// This code is contributed by Anshul Aggarwal.\n// A JavaScript program to demonstrate working of recursion\nfunction printFun(test) {\n    if (test < 1)\n        return;\n    else {\n        console.log(test);\n        printFun(test - 1); // statement 2\n        console.log(test);\n        return;\n    }\n}\n\n// Driver Code\nlet test = 3;\nprintFun(test);\n<?php\n// PHP program to demonstrate \n// working of recursion\n\n// function to demonstrate \n// working of recursion\nfunction printFun($test)\n{\n    if ($test < 1)\n        return;\n    else\n    {\n        echo(\"$test \");\n        \n        // statement 2\n        printFun($test-1); \n        \n        echo(\"$test \");\n        return;\n    }\n}\n\n// Driver Code\n$test = 3;\nprintFun($test);\n\n// This code is contributed by\n// Smitha Dinesh Semwal.\n?>\n3 2 1 1 2 3\n// C++ code to implement Fibonacci series\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Function for fibonacci\n\nint fib(int n)\n{\n    // Stop condition\n    if (n == 0)\n        return 0;\n\n    // Stop condition\n    if (n == 1 || n == 2)\n        return 1;\n\n    // Recursion function\n    else\n        return (fib(n - 1) + fib(n - 2));\n}\n\n// Driver Code\nint main()\n{\n    // Initialize variable n.\n    int n = 5;\n    cout<<\"Fibonacci series of 5 numbers is: \";\n\n    // for loop to print the fibonacci series.\n    for (int i = 0; i < n; i++) \n    {\n        cout<<fib(i)<<\" \";\n    }\n    return 0;\n}\n// C code to implement Fibonacci series\n#include <stdio.h>\n\n// Function for fibonacci\nint fib(int n)\n{\n    // Stop condition\n    if (n == 0)\n        return 0;\n\n    // Stop condition\n    if (n == 1 || n == 2)\n        return 1;\n\n    // Recursion function\n    else\n        return (fib(n - 1) + fib(n - 2));\n}\n\n// Driver Code\nint main()\n{\n    // Initialize variable n.\n    int n = 5;\n    printf(\"Fibonacci series \"\n           \"of %d numbers is: \",\n           n);\n\n    // for loop to print the fibonacci series.\n    for (int i = 0; i < n; i++) {\n        printf(\"%d \", fib(i));\n    }\n    return 0;\n}\n// Java code to implement Fibonacci series\nimport java.util.*;\n\nclass GFG\n{\n\n// Function for fibonacci\nstatic int fib(int n)\n{\n    // Stop condition\n    if (n == 0)\n        return 0;\n\n    // Stop condition\n    if (n == 1 || n == 2)\n        return 1;\n\n    // Recursion function\n    else\n        return (fib(n - 1) + fib(n - 2));\n}\n\n// Driver Code\npublic static void main(String []args)\n{\n  \n    // Initialize variable n.\n    int n = 5;\n    System.out.print(\"Fibonacci series of 5 numbers is: \");\n\n    // for loop to print the fibonacci series.\n    for (int i = 0; i < n; i++) \n    {\n        System.out.print(fib(i)+\" \");\n    }\n}\n}\n\n// This code is contributed by rutvik_56.\n# Python code to implement Fibonacci series\n\n# Function for fibonacci\ndef fib(n):\n\n    # Stop condition\n    if (n == 0):\n        return 0\n\n    # Stop condition\n    if (n == 1 or n == 2):\n        return 1\n\n    # Recursion function\n    else:\n        return (fib(n - 1) + fib(n - 2))\n\n\n# Driver Code\n\n# Initialize variable n.\nn = 5;\nprint(\"Fibonacci series of 5 numbers is :\",end=\" \")\n\n# for loop to print the fibonacci series.\nfor i in range(0,n): \n    print(fib(i),end=\" \")\nusing System;\n\npublic class GFG\n{\n\n  // Function for fibonacci\n  static int fib(int n)\n  {\n\n    // Stop condition\n    if (n == 0)\n      return 0;\n\n    // Stop condition\n    if (n == 1 || n == 2)\n      return 1;\n\n    // Recursion function\n    else\n      return (fib(n - 1) + fib(n - 2));\n  }\n\n  // Driver Code\n  static public void Main ()\n  {\n\n    // Initialize variable n.\n    int n = 5;\n    Console.Write(\"Fibonacci series of 5 numbers is: \");\n\n    // for loop to print the fibonacci series.\n    for (int i = 0; i < n; i++) \n    {\n      Console.Write(fib(i) + \" \");\n    }\n  }\n}\n\n// This code is contributed by avanitrachhadiya2155\n// Function for fibonacci\nfunction fib(n) {\n    // Stop condition\n    if (n === 0) return 0;\n\n    // Stop condition\n    if (n === 1 || n === 2) return 1;\n\n    // Recursion function\n    return fib(n - 1) + fib(n - 2);\n}\n\n// Driver Code\nlet n = 5;\nconsole.log(\"Fibonacci series of 5 numbers is:\");\n\n// for loop to print the fibonacci series.\nfor (let i = 0; i < n; i++) {\n    console.log(fib(i) + \" \");\n}\nFibonacci series of 5 numbers is: 0 1 1 2 3\n",
        "complexity": {
            "time": "",
            "space": ""
        },
        "tags": [
            "DSA"
        ],
        "url": "https://www.geeksforgeeks.org/introduction-to-recursion-2/"
    },
    {
        "title": "Dynamic Programming or DP",
        "description": "Dynamic Programming is an algorithmic technique with the following properties.  Quick Links: H  ",
        "code": "",
        "complexity": {
            "time": "",
            "space": ""
        },
        "tags": [
            "DSA"
        ],
        "url": "https://www.geeksforgeeks.org/dynamic-programming/"
    },
    {
        "title": "Binary Tree Data Structure",
        "description": "A  Binary Tree Data Structure  is a hierarchical data structure in which each node has at most two children, referred to as the left child and the right child. It is commonly used in computer science for efficient storage and retrieval of data, with various operations such as insertion, deletion, and traversal. Quick Links : Recommended: H  ",
        "code": "",
        "complexity": {
            "time": "",
            "space": ""
        },
        "tags": [
            "DSA"
        ],
        "url": "https://www.geeksforgeeks.org/binary-tree-data-structure/"
    },
    {
        "title": "Binary Search Tree",
        "description": "A Binary Search Tree (or BST) is a data structure used in computer science for organizing and storing data in a sorted manner. Each node in a Binary Search Tree has at most two children, a left child and a right child, with the left child containing values less than the parent node and the right child containing values greater than the parent node. This hierarchical structure allows for efficient searching, insertion, and deletion operations on the data stored in the tree. Some Quizzes: Quick Links : Recommended: H  ",
        "code": "",
        "complexity": {
            "time": "",
            "space": ""
        },
        "tags": [
            "DSA"
        ],
        "url": "https://www.geeksforgeeks.org/binary-search-tree-data-structure/"
    },
    {
        "title": "Heap Data Structure",
        "description": "A Heap is a complete binary tree data structure that satisfies the heap property: for every node, the value of its children is greater than or equal to its own value. Heaps are usually used to implement priority queues, where the smallest (or largest) element is always at the root of the tree.  Quick Links: Recommended: H  ",
        "code": "",
        "complexity": {
            "time": "",
            "space": ""
        },
        "tags": [
            "DSA"
        ],
        "url": "https://www.geeksforgeeks.org/heap-data-structure/"
    },
    {
        "title": "Hashing in Data Structure",
        "description": "Hashing is a technique used in data structures that efficiently stores and retrieves data in a way that allows for quick access. Quick Links : Recommended: H  ",
        "code": "",
        "complexity": {
            "time": "",
            "space": ""
        },
        "tags": [
            "DSA"
        ],
        "url": "https://www.geeksforgeeks.org/hashing-data-structure/"
    },
    {
        "title": "Divide and Conquer Algorithm",
        "description": "Divide and Conquer algorithm is a problem-solving strategy that involves. Examples of Divide and Conquer are Merge Sort, Quick Sort, Binary Search and Closest Pair of Points.  Quick Links : H  ",
        "code": "",
        "complexity": {
            "time": "",
            "space": ""
        },
        "tags": [
            "DSA"
        ],
        "url": "https://www.geeksforgeeks.org/divide-and-conquer/"
    },
    {
        "title": "Mathematical Algorithms",
        "description": "The following is the list of mathematical coding problem ordered topic wise. Please refer Mathematical Algorithms (Difficulty Wise) for the difficulty wise list of problems. Quick Links : H  ",
        "code": "",
        "complexity": {
            "time": "",
            "space": ""
        },
        "tags": [
            "DSA"
        ],
        "url": "https://www.geeksforgeeks.org/mathematical-algorithms/"
    },
    {
        "title": "Geometric Algorithms",
        "description": "Geometric algorithms are a type of algorithm that deal with solving problems related to geometry. These algorithms are used to solve various geometric problems such as computing the area of a polygon, finding the intersection of geometric shapes, determining the convex hull of a set of points, and many other tasks related to geometric objects and their properties. Geometric algorithms are important in various fields such as computer graphics, computer-aided design, robotics, and geographical information systems. Table of Content Quick Links : H  ",
        "code": "",
        "complexity": {
            "time": "",
            "space": ""
        },
        "tags": [
            "DSA"
        ],
        "url": "https://www.geeksforgeeks.org/geometric-algorithms/"
    },
    {
        "title": "Bitwise Algorithms",
        "description": "Bitwise algorithms in Data Structures and Algorithms (DSA) involve manipulating individual bits of binary representations of numbers to perform operations efficiently. These algorithms utilize bitwise operators like AND, OR, XOR, NOT, Left Shift, and Right Shift. Quick Links : Bitwise algorithms are algorithms that operate on individual bits of data rather than on larger data types like integers or floating-point numbers. These algorithms manipulate bits directly, typically using bitwise operators such as AND, OR, XOR, shift left, shift right, and complement. Here are some common bitwise algorithms and operations: Quick Links :  H  ",
        "code": "",
        "complexity": {
            "time": "",
            "space": ""
        },
        "tags": [
            "DSA"
        ],
        "url": "https://www.geeksforgeeks.org/bitwise-algorithms/"
    },
    {
        "title": "Greedy Algorithms",
        "description": "Greedy algorithms are a class of algorithms that make locally optimal choices at each step with the hope of finding a global optimum solution. H  ",
        "code": "",
        "complexity": {
            "time": "",
            "space": ""
        },
        "tags": [
            "DSA"
        ],
        "url": "https://www.geeksforgeeks.org/greedy-algorithms/"
    },
    {
        "title": "Backtracking Algorithm",
        "description": "Backtracking algorithms are like problem-solving strategies that help explore different options to find the best solution. They work by trying out different paths and if one doesn't work, they backtrack and try another until they find the right one. It's like solving a puzzle by testing different pieces until they fit together perfectly. Quick Links : Backtracking is a problem-solving algorithmic technique that involves finding a solution incrementally by trying different options and undoing them if they lead to a dead end. It is commonly used in situations where you need to explore multiple possibilities to solve a problem, like searching for a path in a maze or solving puzzles like Sudoku. When a dead end is reached, the algorithm backtracks to the previous decision point and explores a different path until a solution is found or all possibilities have been exhausted. A backtracking algorithm works by recursively exploring all possible solutions to a problem. It starts by choosing an initial solution, and then it explores all possible extensions of that solution. If an extension leads to a solution, the algorithm returns that solution. If an extension does not lead to a solution, the algorithm backtracks to the previous solution and tries a different extension. The following is a general outline of how a backtracking algorithm works: Example: Finding the shortest path through a maze Input: A maze represented as a 2D array, where 0 represents an open space and 1 represents a wall. Algorithm: Backtracking algorithms are best used to solve problems that have the following characteristics: Backtracking algorithms are used in a wide variety of applications, including: H  ",
        "code": "",
        "complexity": {
            "time": "",
            "space": ""
        },
        "tags": [
            "DSA"
        ],
        "url": "https://www.geeksforgeeks.org/backtracking-algorithms/"
    },
    {
        "title": "Branch and Bound Algorithm",
        "description": "The Branch and Bound Algorithm is a method used in combinatorial optimization problems to systematically search for the best solution. It works by dividing the problem into smaller subproblems, or branches, and then eliminating certain branches based on bounds on the optimal solution. This process continues until the best solution is found or all branches have been explored. Branch and Bound is commonly used in problems like the traveling salesman and job scheduling. Branch and Bound Algorithm Quick Links: H  ",
        "code": "",
        "complexity": {
            "time": "",
            "space": ""
        },
        "tags": [
            "DSA"
        ],
        "url": "https://www.geeksforgeeks.org/branch-and-bound-algorithm/"
    },
    {
        "title": "Matrix Data Structure",
        "description": "Matrix Data Structure is a two-dimensional array arranged in rows and columns. It is commonly used to represent mathematical matrices and is fundamental in various fields like mathematics, computer graphics, and data processing. Matrices allow for efficient storage and manipulation of data in a structured format. Quick Links: Recommended: H  ",
        "code": "",
        "complexity": {
            "time": "",
            "space": ""
        },
        "tags": [
            "DSA"
        ],
        "url": "https://www.geeksforgeeks.org/matrix/"
    },
    {
        "title": "Pattern Searching",
        "description": "Pattern searching algorithms are essential tools in computer science and data processing. These algorithms are designed to efficiently find a particular pattern within a larger set of data. Pattern searching algorithms have numerous applications, including: Recommended: H  ",
        "code": "",
        "complexity": {
            "time": "",
            "space": ""
        },
        "tags": [
            "DSA"
        ],
        "url": "https://www.geeksforgeeks.org/pattern-searching/"
    },
    {
        "title": "Randomized Algorithms",
        "description": "Randomized algorithms in data structures and algorithms (DSA) are algorithms that use randomness in their computations to achieve a desired outcome. These algorithms introduce randomness to improve efficiency or simplify the algorithm design. By incorporating random choices into their processes, randomized algorithms can often provide faster solutions or better approximations compared to deterministic algorithms. They are particularly useful in situations where exact solutions are difficult to find or when a probabilistic approach is acceptable. For example, in Randomized Quick Sort, we use a random number to pick the next pivot (or we randomly shuffle the array). Typically, this randomness is used to reduce time complexity or space complexity in other standard algorithms. Recommended: H  ",
        "code": "",
        "complexity": {
            "time": "For example, in Randomized Quick Sort, we use a random number to pick the next pivot (or we randomly shuffle the array). Typically, this randomness is used to reduce time complexity or space complexity in other standard algorithms.",
            "space": ""
        },
        "tags": [
            "DSA"
        ],
        "url": "https://www.geeksforgeeks.org/randomized-algorithms/"
    },
    {
        "title": "DSA Tutorial - Learn Data Structures and Algorithms",
        "description": "DSA (Data Structures and Algorithms)  is the study of organizing data efficiently using data structures like arrays, stacks, and trees, paired with step-by-step procedures (or algorithms) to solve problems effectively. Data structures manage how data is stored and accessed, while algorithms focus on processing this data. Hoping you have learned a programming language of your choice, here comes the next stage of the roadmap - Learn about Time and Space Complexities. Once you have learned basics of a programming language, it is recommended that you learn basic logic building To analyze algorithms, we mainly measure order of growth of time or space taken in terms of input size.  We do this in the worst case scenario in most of the cases. Please refer the below links for a clear understanding of these concepts. Array is a linear data structure where elements are allocated contiguous memory, allowing for constant-time access. Searching algorithms are used to locate specific data within a large set of data. It helps find a target value within the data. There are various types of searching algorithms, each with its own approach and efficiency. Sorting algorithms are used to arrange the elements of a list in a specific order, such as numerical or alphabetical. It organizes the items in a systematic way, making it easier to search for and access specific elements. Hashing is a technique that generates a fixed-size output (hash value) from an input of variable size using mathematical formulas called hash functions. Hashing is commonly used in data structures for efficient searching, insertion and deletion. In Two Pointer Technique, we typically use two index variables from two corners of an array. We use the two pointer technique for searching a required point or value in an array. In Window Sliding Technique, we use the result of previous subarray to quickly compute the result of current. In Prefix Sum Technique, we compute prefix sums of an array to quickly find results for a subarray. String is a sequence of characters, typically immutable and have limited set of elements (lower case or all English alphabets). Recursion is a programming technique where a function calls itself within its own definition. It is usually used to solve problems that can be broken down into smaller instances of the same problem. Matrix is a two-dimensional array of elements, arranged in rows and columns. It is represented as a rectangular grid, with each element at the intersection of a row and column. Linked list is a linear data structure that stores data in nodes, which are connected by pointers. Unlike arrays, nodes of linked lists are not stored in contiguous memory locations and can only be accessed sequentially, starting from the head of list. Stack is a linear data structure that follows the Last In, First Out (LIFO) principle. Stacks play an important role in managing function calls, memory, and are widely used in algorithms like stock span problem, next greater element and largest area in a histogram. Queue is a linear data structure that follows the First In, First Out (FIFO) principle. Queues play an important role in managing tasks or data in order, scheduling and message handling systems. A deque (double-ended queue) is a data structure that allows elements to be added or removed from both ends efficiently. Tree is a non-linear, hierarchical data structure consisting of nodes connected by edges, with a top node called the root and nodes having child nodes. It is widely used in file systems, databases, decision-making algorithms, etc. Heap is a complete binary tree data structure that satisfies the heap property. Heaps are usually used to implement priority queues, where the smallest or largest element is always at the root of the tree. Graph is a non-linear data structure consisting of a finite set of vertices(or nodes) and a set of edges(or links)that connect a pair of nodes. Graphs are widely used to represent relationships between entities. Greedy Algorithm builds up the solution one piece at a time and chooses the next piece which gives the most obvious and immediate benefit i.e., which is the most optimal choice at that moment. So the problems where choosing locally optimal also leads to the global solutions are best fit for Greedy. Dynamic Programming is a method used to solve complex problems by breaking them down into simpler subproblems. By solving each subproblem only once and storing the results, it avoids redundant computations, leading to more efficient solutions for a wide range of problems. Bitwise Algorithms: Operate on individual bits of numbers. Backtracking Algorithm : Follow Recursion  with the option to revert and traces back if the solution from current point is not feasible. Divide and conquer:  A strategy to solve problems by dividing them into smaller subproblems, solving those subproblems, and combining the solutions to obtain the final solution. Branch and Bound : Used in combinatorial optimization problems to systematically search for the best solution. It works by dividing the problem into smaller subproblems, or branches, and then eliminating certain branches based on bounds on the optimal solution. This process continues until the best solution is found or all branches have been explored. Geometric algorithms are a set of algorithms that solve problems related to shapes, points, lines and polygons. Randomized algorithms are algorithms that use randomness to solve problems. They make use of random input to achieve their goals, often leading to simpler and more efficient solutions. These algorithms may not product same result but are particularly useful in situations when a probabilistic approach is acceptable. Advanced Data Structures like Trie, Segment Tree, Red-Black Tree and Binary Indexed Tree offer significant performance improvements for specific problem domains. They provide efficient solutions for tasks like fast prefix searches, range queries, dynamic updates, and maintaining balanced data structures, which are crucial for handling large datasets and real-time processing. By optimizing time complexity, they enable better scalability and faster execution in many computational problems. R  ",
        "code": "",
        "complexity": {
            "time": "Advanced Data Structures like Trie, Segment Tree, Red-Black Tree and Binary Indexed Tree offer significant performance improvements for specific problem domains. They provide efficient solutions for tasks like fast prefix searches, range queries, dynamic updates, and maintaining balanced data structures, which are crucial for handling large datasets and real-time processing. By optimizing time complexity, they enable better scalability and faster execution in many computational problems.",
            "space": ""
        },
        "tags": [
            "Algorithms"
        ],
        "url": "https://www.geeksforgeeks.org/learn-data-structures-and-algorithms-dsa-tutorial/"
    },
    {
        "title": "Algorithms Tutorial",
        "description": "Algorithm is a step-by-step procedure for solving a problem or accomplishing a task. In the context of data structures and algorithms, it is a set of well-defined instructions for performing a specific computational task. Algorithms are fundamental to computer science and play a very important role in designing efficient solutions for various problems. Understanding algorithms is essential for anyone interested in mastering data structures and algorithms.  An algorithm is a finite sequence of well-defined instructions that can be used to solve a computational problem. It provides a step-by-step procedure that convert an input into a desired output. Algorithms typically follow a logical structure: Algorithms are essential for solving complex computational problems efficiently and effectively. They provide a systematic approach to: Please refer Complete Data Structures & Algorithms Tutorial for topic-wise guide, practice problems and interview questions.  H  ",
        "code": "",
        "complexity": {
            "time": "",
            "space": ""
        },
        "tags": [
            "Algorithms"
        ],
        "url": "https://www.geeksforgeeks.org/fundamentals-of-algorithms/"
    },
    {
        "title": "Analysis of Algorithms",
        "description": "Analysis of Algorithms is a fundamental aspect of computer science that involves evaluating performance of algorithms and programs. Efficiency is measured in terms of time and space. H  ",
        "code": "",
        "complexity": {
            "time": "",
            "space": ""
        },
        "tags": [
            "Algorithms"
        ],
        "url": "https://www.geeksforgeeks.org/design-and-analysis-of-algorithms/"
    },
    {
        "title": "Sorting Algorithms",
        "description": "A Sorting Algorithm is used to rearrange a given array or list of elements in an order.  For example, a given array [10, 20, 5, 2] becomes [2, 5, 10, 20] after sorting in increasing order and becomes [20, 10, 5, 2] after sorting in decreasing order. Comparison Based : Selection Sort,  Bubble Sort,  Insertion Sort,  Merge Sort,  Quick Sort,  Heap Sort, Cycle Sort, 3-way Merge SortNon Comparison Based :  Counting Sort, Radix Sort, Bucket Sort,  TimSort, Comb Sort, Pigeonhole SortHybrid Sorting Algorithms : IntroSort, Tim Sort Quick Links : Recommended: H  ",
        "code": "",
        "complexity": {
            "time": "",
            "space": ""
        },
        "tags": [
            "Algorithms"
        ],
        "url": "https://www.geeksforgeeks.org/sorting-algorithms/"
    },
    {
        "title": "Searching Algorithms",
        "description": "Searching algorithms are essential tools in computer science used to locate specific items within a collection of data. In this tutorial, we are mainly going to focus upon searching in an array. When we search an item in an array, there are two most common algorithms used based on the type of input array. One more common search technique is Two Pointers Technique where we begin searching from both ends of the array.  Quick Links: H  ",
        "code": "",
        "complexity": {
            "time": "",
            "space": ""
        },
        "tags": [
            "Algorithms"
        ],
        "url": "https://www.geeksforgeeks.org/searching-algorithms/"
    },
    {
        "title": "Greedy Algorithms",
        "description": "Greedy algorithms are a class of algorithms that make locally optimal choices at each step with the hope of finding a global optimum solution. H  ",
        "code": "",
        "complexity": {
            "time": "",
            "space": ""
        },
        "tags": [
            "Algorithms"
        ],
        "url": "https://www.geeksforgeeks.org/greedy-algorithms/"
    },
    {
        "title": "Recursive Algorithms",
        "description": "Recursion is technique used in computer science to solve big problems by breaking them into smaller, similar problems. The process in which a function calls itself directly or indirectly is called recursion and the corresponding function is called a recursive function. Using a recursive algorithm, certain problems can be solved quite easily.  Quiz based on Recursion: A recursive algorithm is an algorithm that uses recursion to solve a problem. Recursive algorithms typically have two parts: There are several different recursion types and terms. These include: Recursion is a powerful technique that can be used to solve a wide variety of problems. However, it is important to use recursion carefully, as it can lead to stack overflows if not used properly. Recursion should be used when: Here are some common examples of recursion: Example 1: Factorial: The factorial of a number n is the product of all the integers from 1 to n. The factorial of n can be defined recursively as: Example 2: Fibonacci sequence: The Fibonacci sequence is a sequence of numbers where each number is the sum of the two preceding numbers. The Fibonacci sequence can be defined recursively as: Here are some common applications of recursion:  ",
        "code": "factorial(n) = n * factorial(n-1)\nfib(n) = fib(n-1) + fib(n-2)\n",
        "complexity": {
            "time": "",
            "space": ""
        },
        "tags": [
            "Algorithms"
        ],
        "url": "https://www.geeksforgeeks.org/recursion-algorithms/"
    },
    {
        "title": "Backtracking Algorithm",
        "description": "Backtracking algorithms are like problem-solving strategies that help explore different options to find the best solution. They work by trying out different paths and if one doesn't work, they backtrack and try another until they find the right one. It's like solving a puzzle by testing different pieces until they fit together perfectly. Quick Links : Backtracking is a problem-solving algorithmic technique that involves finding a solution incrementally by trying different options and undoing them if they lead to a dead end. It is commonly used in situations where you need to explore multiple possibilities to solve a problem, like searching for a path in a maze or solving puzzles like Sudoku. When a dead end is reached, the algorithm backtracks to the previous decision point and explores a different path until a solution is found or all possibilities have been exhausted. A backtracking algorithm works by recursively exploring all possible solutions to a problem. It starts by choosing an initial solution, and then it explores all possible extensions of that solution. If an extension leads to a solution, the algorithm returns that solution. If an extension does not lead to a solution, the algorithm backtracks to the previous solution and tries a different extension. The following is a general outline of how a backtracking algorithm works: Example: Finding the shortest path through a maze Input: A maze represented as a 2D array, where 0 represents an open space and 1 represents a wall. Algorithm: Backtracking algorithms are best used to solve problems that have the following characteristics: Backtracking algorithms are used in a wide variety of applications, including: H  ",
        "code": "",
        "complexity": {
            "time": "",
            "space": ""
        },
        "tags": [
            "Algorithms"
        ],
        "url": "https://www.geeksforgeeks.org/backtracking-algorithms/"
    },
    {
        "title": "Dynamic Programming or DP",
        "description": "Dynamic Programming is an algorithmic technique with the following properties.  Quick Links: H  ",
        "code": "",
        "complexity": {
            "time": "",
            "space": ""
        },
        "tags": [
            "Algorithms"
        ],
        "url": "https://www.geeksforgeeks.org/dynamic-programming/"
    },
    {
        "title": "Divide and Conquer Algorithm",
        "description": "Divide and Conquer algorithm is a problem-solving strategy that involves. Examples of Divide and Conquer are Merge Sort, Quick Sort, Binary Search and Closest Pair of Points.  Quick Links : H  ",
        "code": "",
        "complexity": {
            "time": "",
            "space": ""
        },
        "tags": [
            "Algorithms"
        ],
        "url": "https://www.geeksforgeeks.org/divide-and-conquer/"
    },
    {
        "title": "Geometric Algorithms",
        "description": "Geometric algorithms are a type of algorithm that deal with solving problems related to geometry. These algorithms are used to solve various geometric problems such as computing the area of a polygon, finding the intersection of geometric shapes, determining the convex hull of a set of points, and many other tasks related to geometric objects and their properties. Geometric algorithms are important in various fields such as computer graphics, computer-aided design, robotics, and geographical information systems. Table of Content Quick Links : H  ",
        "code": "",
        "complexity": {
            "time": "",
            "space": ""
        },
        "tags": [
            "Algorithms"
        ],
        "url": "https://www.geeksforgeeks.org/geometric-algorithms/"
    },
    {
        "title": "Mathematical Algorithms",
        "description": "The following is the list of mathematical coding problem ordered topic wise. Please refer Mathematical Algorithms (Difficulty Wise) for the difficulty wise list of problems. Quick Links : H  ",
        "code": "",
        "complexity": {
            "time": "",
            "space": ""
        },
        "tags": [
            "Algorithms"
        ],
        "url": "https://www.geeksforgeeks.org/mathematical-algorithms/"
    },
    {
        "title": "Pattern Searching",
        "description": "Pattern searching algorithms are essential tools in computer science and data processing. These algorithms are designed to efficiently find a particular pattern within a larger set of data. Pattern searching algorithms have numerous applications, including: Recommended: H  ",
        "code": "",
        "complexity": {
            "time": "",
            "space": ""
        },
        "tags": [
            "Algorithms"
        ],
        "url": "https://www.geeksforgeeks.org/pattern-searching/"
    },
    {
        "title": "Bitwise Algorithms",
        "description": "Bitwise algorithms in Data Structures and Algorithms (DSA) involve manipulating individual bits of binary representations of numbers to perform operations efficiently. These algorithms utilize bitwise operators like AND, OR, XOR, NOT, Left Shift, and Right Shift. Quick Links : Bitwise algorithms are algorithms that operate on individual bits of data rather than on larger data types like integers or floating-point numbers. These algorithms manipulate bits directly, typically using bitwise operators such as AND, OR, XOR, shift left, shift right, and complement. Here are some common bitwise algorithms and operations: Quick Links :  H  ",
        "code": "",
        "complexity": {
            "time": "",
            "space": ""
        },
        "tags": [
            "Algorithms"
        ],
        "url": "https://www.geeksforgeeks.org/bitwise-algorithms/"
    },
    {
        "title": "Branch and Bound Algorithm",
        "description": "The Branch and Bound Algorithm is a method used in combinatorial optimization problems to systematically search for the best solution. It works by dividing the problem into smaller subproblems, or branches, and then eliminating certain branches based on bounds on the optimal solution. This process continues until the best solution is found or all branches have been explored. Branch and Bound is commonly used in problems like the traveling salesman and job scheduling. Branch and Bound Algorithm Quick Links: H  ",
        "code": "",
        "complexity": {
            "time": "",
            "space": ""
        },
        "tags": [
            "Algorithms"
        ],
        "url": "https://www.geeksforgeeks.org/branch-and-bound-algorithm/"
    },
    {
        "title": "Randomized Algorithms",
        "description": "Randomized algorithms in data structures and algorithms (DSA) are algorithms that use randomness in their computations to achieve a desired outcome. These algorithms introduce randomness to improve efficiency or simplify the algorithm design. By incorporating random choices into their processes, randomized algorithms can often provide faster solutions or better approximations compared to deterministic algorithms. They are particularly useful in situations where exact solutions are difficult to find or when a probabilistic approach is acceptable. For example, in Randomized Quick Sort, we use a random number to pick the next pivot (or we randomly shuffle the array). Typically, this randomness is used to reduce time complexity or space complexity in other standard algorithms. Recommended: H  ",
        "code": "",
        "complexity": {
            "time": "For example, in Randomized Quick Sort, we use a random number to pick the next pivot (or we randomly shuffle the array). Typically, this randomness is used to reduce time complexity or space complexity in other standard algorithms.",
            "space": ""
        },
        "tags": [
            "Algorithms"
        ],
        "url": "https://www.geeksforgeeks.org/randomized-algorithms/"
    },
    {
        "title": "DSA Tutorial - Learn Data Structures and Algorithms",
        "description": "DSA (Data Structures and Algorithms)  is the study of organizing data efficiently using data structures like arrays, stacks, and trees, paired with step-by-step procedures (or algorithms) to solve problems effectively. Data structures manage how data is stored and accessed, while algorithms focus on processing this data. Hoping you have learned a programming language of your choice, here comes the next stage of the roadmap - Learn about Time and Space Complexities. Once you have learned basics of a programming language, it is recommended that you learn basic logic building To analyze algorithms, we mainly measure order of growth of time or space taken in terms of input size.  We do this in the worst case scenario in most of the cases. Please refer the below links for a clear understanding of these concepts. Array is a linear data structure where elements are allocated contiguous memory, allowing for constant-time access. Searching algorithms are used to locate specific data within a large set of data. It helps find a target value within the data. There are various types of searching algorithms, each with its own approach and efficiency. Sorting algorithms are used to arrange the elements of a list in a specific order, such as numerical or alphabetical. It organizes the items in a systematic way, making it easier to search for and access specific elements. Hashing is a technique that generates a fixed-size output (hash value) from an input of variable size using mathematical formulas called hash functions. Hashing is commonly used in data structures for efficient searching, insertion and deletion. In Two Pointer Technique, we typically use two index variables from two corners of an array. We use the two pointer technique for searching a required point or value in an array. In Window Sliding Technique, we use the result of previous subarray to quickly compute the result of current. In Prefix Sum Technique, we compute prefix sums of an array to quickly find results for a subarray. String is a sequence of characters, typically immutable and have limited set of elements (lower case or all English alphabets). Recursion is a programming technique where a function calls itself within its own definition. It is usually used to solve problems that can be broken down into smaller instances of the same problem. Matrix is a two-dimensional array of elements, arranged in rows and columns. It is represented as a rectangular grid, with each element at the intersection of a row and column. Linked list is a linear data structure that stores data in nodes, which are connected by pointers. Unlike arrays, nodes of linked lists are not stored in contiguous memory locations and can only be accessed sequentially, starting from the head of list. Stack is a linear data structure that follows the Last In, First Out (LIFO) principle. Stacks play an important role in managing function calls, memory, and are widely used in algorithms like stock span problem, next greater element and largest area in a histogram. Queue is a linear data structure that follows the First In, First Out (FIFO) principle. Queues play an important role in managing tasks or data in order, scheduling and message handling systems. A deque (double-ended queue) is a data structure that allows elements to be added or removed from both ends efficiently. Tree is a non-linear, hierarchical data structure consisting of nodes connected by edges, with a top node called the root and nodes having child nodes. It is widely used in file systems, databases, decision-making algorithms, etc. Heap is a complete binary tree data structure that satisfies the heap property. Heaps are usually used to implement priority queues, where the smallest or largest element is always at the root of the tree. Graph is a non-linear data structure consisting of a finite set of vertices(or nodes) and a set of edges(or links)that connect a pair of nodes. Graphs are widely used to represent relationships between entities. Greedy Algorithm builds up the solution one piece at a time and chooses the next piece which gives the most obvious and immediate benefit i.e., which is the most optimal choice at that moment. So the problems where choosing locally optimal also leads to the global solutions are best fit for Greedy. Dynamic Programming is a method used to solve complex problems by breaking them down into simpler subproblems. By solving each subproblem only once and storing the results, it avoids redundant computations, leading to more efficient solutions for a wide range of problems. Bitwise Algorithms: Operate on individual bits of numbers. Backtracking Algorithm : Follow Recursion  with the option to revert and traces back if the solution from current point is not feasible. Divide and conquer:  A strategy to solve problems by dividing them into smaller subproblems, solving those subproblems, and combining the solutions to obtain the final solution. Branch and Bound : Used in combinatorial optimization problems to systematically search for the best solution. It works by dividing the problem into smaller subproblems, or branches, and then eliminating certain branches based on bounds on the optimal solution. This process continues until the best solution is found or all branches have been explored. Geometric algorithms are a set of algorithms that solve problems related to shapes, points, lines and polygons. Randomized algorithms are algorithms that use randomness to solve problems. They make use of random input to achieve their goals, often leading to simpler and more efficient solutions. These algorithms may not product same result but are particularly useful in situations when a probabilistic approach is acceptable. Advanced Data Structures like Trie, Segment Tree, Red-Black Tree and Binary Indexed Tree offer significant performance improvements for specific problem domains. They provide efficient solutions for tasks like fast prefix searches, range queries, dynamic updates, and maintaining balanced data structures, which are crucial for handling large datasets and real-time processing. By optimizing time complexity, they enable better scalability and faster execution in many computational problems. R  ",
        "code": "",
        "complexity": {
            "time": "Advanced Data Structures like Trie, Segment Tree, Red-Black Tree and Binary Indexed Tree offer significant performance improvements for specific problem domains. They provide efficient solutions for tasks like fast prefix searches, range queries, dynamic updates, and maintaining balanced data structures, which are crucial for handling large datasets and real-time processing. By optimizing time complexity, they enable better scalability and faster execution in many computational problems.",
            "space": ""
        },
        "tags": [
            "Analysis of Algorithms"
        ],
        "url": "https://www.geeksforgeeks.org/learn-data-structures-and-algorithms-dsa-tutorial/"
    },
    {
        "title": "Algorithms Tutorial",
        "description": "Algorithm is a step-by-step procedure for solving a problem or accomplishing a task. In the context of data structures and algorithms, it is a set of well-defined instructions for performing a specific computational task. Algorithms are fundamental to computer science and play a very important role in designing efficient solutions for various problems. Understanding algorithms is essential for anyone interested in mastering data structures and algorithms.  An algorithm is a finite sequence of well-defined instructions that can be used to solve a computational problem. It provides a step-by-step procedure that convert an input into a desired output. Algorithms typically follow a logical structure: Algorithms are essential for solving complex computational problems efficiently and effectively. They provide a systematic approach to: Please refer Complete Data Structures & Algorithms Tutorial for topic-wise guide, practice problems and interview questions.  H  ",
        "code": "",
        "complexity": {
            "time": "",
            "space": ""
        },
        "tags": [
            "Analysis of Algorithms"
        ],
        "url": "https://www.geeksforgeeks.org/fundamentals-of-algorithms/"
    },
    {
        "title": "Analysis of Algorithms",
        "description": "Analysis of Algorithms is a fundamental aspect of computer science that involves evaluating performance of algorithms and programs. Efficiency is measured in terms of time and space. H  ",
        "code": "",
        "complexity": {
            "time": "",
            "space": ""
        },
        "tags": [
            "Analysis of Algorithms"
        ],
        "url": "https://www.geeksforgeeks.org/design-and-analysis-of-algorithms/"
    },
    {
        "title": "Sorting Algorithms",
        "description": "A Sorting Algorithm is used to rearrange a given array or list of elements in an order.  For example, a given array [10, 20, 5, 2] becomes [2, 5, 10, 20] after sorting in increasing order and becomes [20, 10, 5, 2] after sorting in decreasing order. Comparison Based : Selection Sort,  Bubble Sort,  Insertion Sort,  Merge Sort,  Quick Sort,  Heap Sort, Cycle Sort, 3-way Merge SortNon Comparison Based :  Counting Sort, Radix Sort, Bucket Sort,  TimSort, Comb Sort, Pigeonhole SortHybrid Sorting Algorithms : IntroSort, Tim Sort Quick Links : Recommended: H  ",
        "code": "",
        "complexity": {
            "time": "",
            "space": ""
        },
        "tags": [
            "Analysis of Algorithms"
        ],
        "url": "https://www.geeksforgeeks.org/sorting-algorithms/"
    },
    {
        "title": "Searching Algorithms",
        "description": "Searching algorithms are essential tools in computer science used to locate specific items within a collection of data. In this tutorial, we are mainly going to focus upon searching in an array. When we search an item in an array, there are two most common algorithms used based on the type of input array. One more common search technique is Two Pointers Technique where we begin searching from both ends of the array.  Quick Links: H  ",
        "code": "",
        "complexity": {
            "time": "",
            "space": ""
        },
        "tags": [
            "Analysis of Algorithms"
        ],
        "url": "https://www.geeksforgeeks.org/searching-algorithms/"
    },
    {
        "title": "Greedy Algorithms",
        "description": "Greedy algorithms are a class of algorithms that make locally optimal choices at each step with the hope of finding a global optimum solution. H  ",
        "code": "",
        "complexity": {
            "time": "",
            "space": ""
        },
        "tags": [
            "Analysis of Algorithms"
        ],
        "url": "https://www.geeksforgeeks.org/greedy-algorithms/"
    },
    {
        "title": "Recursive Algorithms",
        "description": "Recursion is technique used in computer science to solve big problems by breaking them into smaller, similar problems. The process in which a function calls itself directly or indirectly is called recursion and the corresponding function is called a recursive function. Using a recursive algorithm, certain problems can be solved quite easily.  Quiz based on Recursion: A recursive algorithm is an algorithm that uses recursion to solve a problem. Recursive algorithms typically have two parts: There are several different recursion types and terms. These include: Recursion is a powerful technique that can be used to solve a wide variety of problems. However, it is important to use recursion carefully, as it can lead to stack overflows if not used properly. Recursion should be used when: Here are some common examples of recursion: Example 1: Factorial: The factorial of a number n is the product of all the integers from 1 to n. The factorial of n can be defined recursively as: Example 2: Fibonacci sequence: The Fibonacci sequence is a sequence of numbers where each number is the sum of the two preceding numbers. The Fibonacci sequence can be defined recursively as: Here are some common applications of recursion:  ",
        "code": "factorial(n) = n * factorial(n-1)\nfib(n) = fib(n-1) + fib(n-2)\n",
        "complexity": {
            "time": "",
            "space": ""
        },
        "tags": [
            "Analysis of Algorithms"
        ],
        "url": "https://www.geeksforgeeks.org/recursion-algorithms/"
    },
    {
        "title": "Backtracking Algorithm",
        "description": "Backtracking algorithms are like problem-solving strategies that help explore different options to find the best solution. They work by trying out different paths and if one doesn't work, they backtrack and try another until they find the right one. It's like solving a puzzle by testing different pieces until they fit together perfectly. Quick Links : Backtracking is a problem-solving algorithmic technique that involves finding a solution incrementally by trying different options and undoing them if they lead to a dead end. It is commonly used in situations where you need to explore multiple possibilities to solve a problem, like searching for a path in a maze or solving puzzles like Sudoku. When a dead end is reached, the algorithm backtracks to the previous decision point and explores a different path until a solution is found or all possibilities have been exhausted. A backtracking algorithm works by recursively exploring all possible solutions to a problem. It starts by choosing an initial solution, and then it explores all possible extensions of that solution. If an extension leads to a solution, the algorithm returns that solution. If an extension does not lead to a solution, the algorithm backtracks to the previous solution and tries a different extension. The following is a general outline of how a backtracking algorithm works: Example: Finding the shortest path through a maze Input: A maze represented as a 2D array, where 0 represents an open space and 1 represents a wall. Algorithm: Backtracking algorithms are best used to solve problems that have the following characteristics: Backtracking algorithms are used in a wide variety of applications, including: H  ",
        "code": "",
        "complexity": {
            "time": "",
            "space": ""
        },
        "tags": [
            "Analysis of Algorithms"
        ],
        "url": "https://www.geeksforgeeks.org/backtracking-algorithms/"
    },
    {
        "title": "Dynamic Programming or DP",
        "description": "Dynamic Programming is an algorithmic technique with the following properties.  Quick Links: H  ",
        "code": "",
        "complexity": {
            "time": "",
            "space": ""
        },
        "tags": [
            "Analysis of Algorithms"
        ],
        "url": "https://www.geeksforgeeks.org/dynamic-programming/"
    },
    {
        "title": "Divide and Conquer Algorithm",
        "description": "Divide and Conquer algorithm is a problem-solving strategy that involves. Examples of Divide and Conquer are Merge Sort, Quick Sort, Binary Search and Closest Pair of Points.  Quick Links : H  ",
        "code": "",
        "complexity": {
            "time": "",
            "space": ""
        },
        "tags": [
            "Analysis of Algorithms"
        ],
        "url": "https://www.geeksforgeeks.org/divide-and-conquer/"
    },
    {
        "title": "Geometric Algorithms",
        "description": "Geometric algorithms are a type of algorithm that deal with solving problems related to geometry. These algorithms are used to solve various geometric problems such as computing the area of a polygon, finding the intersection of geometric shapes, determining the convex hull of a set of points, and many other tasks related to geometric objects and their properties. Geometric algorithms are important in various fields such as computer graphics, computer-aided design, robotics, and geographical information systems. Table of Content Quick Links : H  ",
        "code": "",
        "complexity": {
            "time": "",
            "space": ""
        },
        "tags": [
            "Analysis of Algorithms"
        ],
        "url": "https://www.geeksforgeeks.org/geometric-algorithms/"
    },
    {
        "title": "Mathematical Algorithms",
        "description": "The following is the list of mathematical coding problem ordered topic wise. Please refer Mathematical Algorithms (Difficulty Wise) for the difficulty wise list of problems. Quick Links : H  ",
        "code": "",
        "complexity": {
            "time": "",
            "space": ""
        },
        "tags": [
            "Analysis of Algorithms"
        ],
        "url": "https://www.geeksforgeeks.org/mathematical-algorithms/"
    },
    {
        "title": "Pattern Searching",
        "description": "Pattern searching algorithms are essential tools in computer science and data processing. These algorithms are designed to efficiently find a particular pattern within a larger set of data. Pattern searching algorithms have numerous applications, including: Recommended: H  ",
        "code": "",
        "complexity": {
            "time": "",
            "space": ""
        },
        "tags": [
            "Analysis of Algorithms"
        ],
        "url": "https://www.geeksforgeeks.org/pattern-searching/"
    },
    {
        "title": "Bitwise Algorithms",
        "description": "Bitwise algorithms in Data Structures and Algorithms (DSA) involve manipulating individual bits of binary representations of numbers to perform operations efficiently. These algorithms utilize bitwise operators like AND, OR, XOR, NOT, Left Shift, and Right Shift. Quick Links : Bitwise algorithms are algorithms that operate on individual bits of data rather than on larger data types like integers or floating-point numbers. These algorithms manipulate bits directly, typically using bitwise operators such as AND, OR, XOR, shift left, shift right, and complement. Here are some common bitwise algorithms and operations: Quick Links :  H  ",
        "code": "",
        "complexity": {
            "time": "",
            "space": ""
        },
        "tags": [
            "Analysis of Algorithms"
        ],
        "url": "https://www.geeksforgeeks.org/bitwise-algorithms/"
    },
    {
        "title": "Branch and Bound Algorithm",
        "description": "The Branch and Bound Algorithm is a method used in combinatorial optimization problems to systematically search for the best solution. It works by dividing the problem into smaller subproblems, or branches, and then eliminating certain branches based on bounds on the optimal solution. This process continues until the best solution is found or all branches have been explored. Branch and Bound is commonly used in problems like the traveling salesman and job scheduling. Branch and Bound Algorithm Quick Links: H  ",
        "code": "",
        "complexity": {
            "time": "",
            "space": ""
        },
        "tags": [
            "Analysis of Algorithms"
        ],
        "url": "https://www.geeksforgeeks.org/branch-and-bound-algorithm/"
    },
    {
        "title": "Randomized Algorithms",
        "description": "Randomized algorithms in data structures and algorithms (DSA) are algorithms that use randomness in their computations to achieve a desired outcome. These algorithms introduce randomness to improve efficiency or simplify the algorithm design. By incorporating random choices into their processes, randomized algorithms can often provide faster solutions or better approximations compared to deterministic algorithms. They are particularly useful in situations where exact solutions are difficult to find or when a probabilistic approach is acceptable. For example, in Randomized Quick Sort, we use a random number to pick the next pivot (or we randomly shuffle the array). Typically, this randomness is used to reduce time complexity or space complexity in other standard algorithms. Recommended: H  ",
        "code": "",
        "complexity": {
            "time": "For example, in Randomized Quick Sort, we use a random number to pick the next pivot (or we randomly shuffle the array). Typically, this randomness is used to reduce time complexity or space complexity in other standard algorithms.",
            "space": ""
        },
        "tags": [
            "Analysis of Algorithms"
        ],
        "url": "https://www.geeksforgeeks.org/randomized-algorithms/"
    },
    {
        "title": "DSA Tutorial - Learn Data Structures and Algorithms",
        "description": "DSA (Data Structures and Algorithms)  is the study of organizing data efficiently using data structures like arrays, stacks, and trees, paired with step-by-step procedures (or algorithms) to solve problems effectively. Data structures manage how data is stored and accessed, while algorithms focus on processing this data. Hoping you have learned a programming language of your choice, here comes the next stage of the roadmap - Learn about Time and Space Complexities. Once you have learned basics of a programming language, it is recommended that you learn basic logic building To analyze algorithms, we mainly measure order of growth of time or space taken in terms of input size.  We do this in the worst case scenario in most of the cases. Please refer the below links for a clear understanding of these concepts. Array is a linear data structure where elements are allocated contiguous memory, allowing for constant-time access. Searching algorithms are used to locate specific data within a large set of data. It helps find a target value within the data. There are various types of searching algorithms, each with its own approach and efficiency. Sorting algorithms are used to arrange the elements of a list in a specific order, such as numerical or alphabetical. It organizes the items in a systematic way, making it easier to search for and access specific elements. Hashing is a technique that generates a fixed-size output (hash value) from an input of variable size using mathematical formulas called hash functions. Hashing is commonly used in data structures for efficient searching, insertion and deletion. In Two Pointer Technique, we typically use two index variables from two corners of an array. We use the two pointer technique for searching a required point or value in an array. In Window Sliding Technique, we use the result of previous subarray to quickly compute the result of current. In Prefix Sum Technique, we compute prefix sums of an array to quickly find results for a subarray. String is a sequence of characters, typically immutable and have limited set of elements (lower case or all English alphabets). Recursion is a programming technique where a function calls itself within its own definition. It is usually used to solve problems that can be broken down into smaller instances of the same problem. Matrix is a two-dimensional array of elements, arranged in rows and columns. It is represented as a rectangular grid, with each element at the intersection of a row and column. Linked list is a linear data structure that stores data in nodes, which are connected by pointers. Unlike arrays, nodes of linked lists are not stored in contiguous memory locations and can only be accessed sequentially, starting from the head of list. Stack is a linear data structure that follows the Last In, First Out (LIFO) principle. Stacks play an important role in managing function calls, memory, and are widely used in algorithms like stock span problem, next greater element and largest area in a histogram. Queue is a linear data structure that follows the First In, First Out (FIFO) principle. Queues play an important role in managing tasks or data in order, scheduling and message handling systems. A deque (double-ended queue) is a data structure that allows elements to be added or removed from both ends efficiently. Tree is a non-linear, hierarchical data structure consisting of nodes connected by edges, with a top node called the root and nodes having child nodes. It is widely used in file systems, databases, decision-making algorithms, etc. Heap is a complete binary tree data structure that satisfies the heap property. Heaps are usually used to implement priority queues, where the smallest or largest element is always at the root of the tree. Graph is a non-linear data structure consisting of a finite set of vertices(or nodes) and a set of edges(or links)that connect a pair of nodes. Graphs are widely used to represent relationships between entities. Greedy Algorithm builds up the solution one piece at a time and chooses the next piece which gives the most obvious and immediate benefit i.e., which is the most optimal choice at that moment. So the problems where choosing locally optimal also leads to the global solutions are best fit for Greedy. Dynamic Programming is a method used to solve complex problems by breaking them down into simpler subproblems. By solving each subproblem only once and storing the results, it avoids redundant computations, leading to more efficient solutions for a wide range of problems. Bitwise Algorithms: Operate on individual bits of numbers. Backtracking Algorithm : Follow Recursion  with the option to revert and traces back if the solution from current point is not feasible. Divide and conquer:  A strategy to solve problems by dividing them into smaller subproblems, solving those subproblems, and combining the solutions to obtain the final solution. Branch and Bound : Used in combinatorial optimization problems to systematically search for the best solution. It works by dividing the problem into smaller subproblems, or branches, and then eliminating certain branches based on bounds on the optimal solution. This process continues until the best solution is found or all branches have been explored. Geometric algorithms are a set of algorithms that solve problems related to shapes, points, lines and polygons. Randomized algorithms are algorithms that use randomness to solve problems. They make use of random input to achieve their goals, often leading to simpler and more efficient solutions. These algorithms may not product same result but are particularly useful in situations when a probabilistic approach is acceptable. Advanced Data Structures like Trie, Segment Tree, Red-Black Tree and Binary Indexed Tree offer significant performance improvements for specific problem domains. They provide efficient solutions for tasks like fast prefix searches, range queries, dynamic updates, and maintaining balanced data structures, which are crucial for handling large datasets and real-time processing. By optimizing time complexity, they enable better scalability and faster execution in many computational problems. R  ",
        "code": "",
        "complexity": {
            "time": "Advanced Data Structures like Trie, Segment Tree, Red-Black Tree and Binary Indexed Tree offer significant performance improvements for specific problem domains. They provide efficient solutions for tasks like fast prefix searches, range queries, dynamic updates, and maintaining balanced data structures, which are crucial for handling large datasets and real-time processing. By optimizing time complexity, they enable better scalability and faster execution in many computational problems.",
            "space": ""
        },
        "tags": [
            "Sorting"
        ],
        "url": "https://www.geeksforgeeks.org/learn-data-structures-and-algorithms-dsa-tutorial/"
    },
    {
        "title": "No Title",
        "description": "",
        "code": "",
        "complexity": {
            "time": "",
            "space": ""
        },
        "tags": [
            "Sorting"
        ],
        "url": "https://www.geeksforgeeks.org/explore?page=1&category=Sorting&sortBy=submissions"
    },
    {
        "title": "Top MCQs on Sorting Algorithms with Answers",
        "description": "Question 1 What is recurrence for worst case of QuickSort and what is the time complexity in Worst case? Recurrence is T(n) = T(n-2) + O(n) and time complexity is O(n^2) Recurrence is T(n) = T(n-1) + O(n) and time complexity is O(n^2) Recurrence is T(n) = 2T(n/2) + O(n) and time complexity is O(nLogn) Recurrence is T(n) = T(n/10) + T(9n/10) + O(n) and time complexity is O(nLogn) Question 2 Suppose we have an O(n) time algorithm that finds the median of an unsorted array. Now consider a QuickSort implementation where we first find the median using the above algorithm, then use the median as a pivot. What will be the worst-case time complexity of this modified QuickSort? O(n^2 Logn) O(n^2) O(n Logn Logn) O(nLogn) Question 3 Which of the following is not a stable sorting algorithm in its typical implementation. Insertion Sort Merge Sort Quick Sort Bubble Sort Question 4 Which of the following sorting algorithms in its typical implementation gives best performance when applied on an array which is sorted or almost sorted (maximum 1 or two elements are misplaced). Quick Sort Heap Sort Merge Sort Insertion Sort Question 5 Suppose we are sorting an array of eight integers using quicksort, and we have just finished the first partitioning with the array looking like this:  Which statement is correct? The pivot could be either the 7 or the 9. The pivot could be the 7, but it is not the 9 The pivot is not the 7, but it could be the 9 Neither the 7 nor the 9 is the pivot. Question 6 Suppose we are sorting an array of eight integers using heapsort, and we have just finished some heapify (either maxheapify or minheapify) operations. The array now looks like this: 16 14 15 10 12 27 28 How many heapify operations have been performed on root of heap? 1 2 3 or 4 5 or 6 Question 7 What is the best time complexity of bubble sort(optimised)? N^2 NlogN N N(logN)^2 Question 8 Question 9 In a modified merge sort, the input array is splitted at a position one-third of the length(N) of the array. Which of the following is the tightest upper bound on time complexity of this modified Merge Sort. N(logN base 3) N(logN base 2/3) N(logN base 1/3) N(logN base 3/2) Question 10 Which sorting algorithm will take least time when all elements of input array are identical? Consider typical implementations of sorting algorithms. Insertion Sort Heap Sort Merge Sort Selection Sort There are 31 questions to complete. ",
        "code": "2  5  1  7  9  12  11  10\n",
        "complexity": {
            "time": "In a modified merge sort, the input array is splitted at a position one-third of the length(N) of the array. Which of the following is the tightest upper bound on time complexity of this modified Merge Sort.",
            "space": ""
        },
        "tags": [
            "Sorting"
        ],
        "url": "https://www.geeksforgeeks.org/quizzes/top-mcqs-on-sorting-algorithms-with-answers/"
    },
    {
        "title": "Introduction to Sorting Techniques – Data Structure and Algorithm Tutorials",
        "description": "Sorting refers to rearrangement of a given array or list of elements according to a comparison operator on the elements. The comparison operator is used to decide the new order of elements in the respective data structure. The sorting algorithm is important in Computer Science because it reduces the complexity of a problem. There is a wide range of applications for these algorithms, including searching algorithms, database algorithms, divide and conquer methods, and data structure algorithms. In the following sections, we list some important scientific applications where sorting algorithms are used There are various sorting algorithms are used in data structures. The following two types of sorting algorithms can be broadly classified: Sorting algorithm Selection sort, Bubble sort, Insertion Sort, Cycle Sort, Merge Sort, 3-way Merge Sort, Quick sort,  Heap sort and Counting sort Radix sort, Bucket sort, Shell sort, Tim Sort, Comb Sort, Pigeonhole sorting, Cocktail Sort,  Strand sort,  Bitonic Sort,  Stooge Sort, Tag Sort,  Tree sort, Cartesian Sort, Odd-Even Sort / Brick Sort, Gnome sort, Cocktail shaker sort H  ",
        "code": "",
        "complexity": {
            "time": "",
            "space": ""
        },
        "tags": [
            "Sorting"
        ],
        "url": "https://www.geeksforgeeks.org/introduction-to-sorting-algorithm/"
    },
    {
        "title": "Bubble Sort Algorithm",
        "description": "Bubble Sort is the simplest sorting algorithm that works by repeatedly swapping the adjacent elements if they are in the wrong order. This algorithm is not suitable for large data sets as its average and worst-case time complexity are quite high. Below is the implementation of the bubble sort. It can be optimized by stopping the algorithm if the inner loop didn’t cause any swap. Time Complexity: O(n2)Auxiliary Space: O(1)Please refer Complexity Analysis of Bubble Sort for details.  ",
        "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n// An optimized version of Bubble Sort \nvoid bubbleSort(vector<int>& arr) {\n    int n = arr.size();\n    bool swapped;\n  \n    for (int i = 0; i < n - 1; i++) {\n        swapped = false;\n        for (int j = 0; j < n - i - 1; j++) {\n            if (arr[j] > arr[j + 1]) {\n                swap(arr[j], arr[j + 1]);\n                swapped = true;\n            }\n        }\n      \n        // If no two elements were swapped, then break\n        if (!swapped)\n            break;\n    }\n}\n\n// Function to print a vector\nvoid printVector(const vector<int>& arr) {\n    for (int num : arr)\n        cout << \" \" << num;\n}\n\nint main() {\n    vector<int> arr = { 64, 34, 25, 12, 22, 11, 90 };\n    bubbleSort(arr);\n    cout << \"Sorted array: \\n\";\n    printVector(arr);\n    return 0;\n}\n// Optimized implementation of Bubble sort\n#include <stdbool.h>\n#include <stdio.h>\n\nvoid swap(int* xp, int* yp){\n    int temp = *xp;\n    *xp = *yp;\n    *yp = temp;\n}\n\n// An optimized version of Bubble Sort\nvoid bubbleSort(int arr[], int n){\n    int i, j;\n    bool swapped;\n    for (i = 0; i < n - 1; i++) {\n        swapped = false;\n        for (j = 0; j < n - i - 1; j++) {\n            if (arr[j] > arr[j + 1]) {\n                swap(&arr[j], &arr[j + 1]);\n                swapped = true;\n            }\n        }\n\n        // If no two elements were swapped by inner loop,\n        // then break\n        if (swapped == false)\n            break;\n    }\n}\n\n// Function to print an array\nvoid printArray(int arr[], int size){\n    int i;\n    for (i = 0; i < size; i++)\n        printf(\"%d \", arr[i]);\n}\n\nint main(){\n    int arr[] = { 64, 34, 25, 12, 22, 11, 90 };\n    int n = sizeof(arr) / sizeof(arr[0]);\n    bubbleSort(arr, n);\n    printf(\"Sorted array: \\n\");\n    printArray(arr, n);\n    return 0;\n}\n// Optimized java implementation of Bubble sort\nimport java.io.*;\n\nclass GFG {\n    \n    // An optimized version of Bubble Sort\n    static void bubbleSort(int arr[], int n){\n        int i, j, temp;\n        boolean swapped;\n        for (i = 0; i < n - 1; i++) {\n            swapped = false;\n            for (j = 0; j < n - i - 1; j++) {\n                if (arr[j] > arr[j + 1]) {\n                    \n                    // Swap arr[j] and arr[j+1]\n                    temp = arr[j];\n                    arr[j] = arr[j + 1];\n                    arr[j + 1] = temp;\n                    swapped = true;\n                }\n            }\n\n            // If no two elements were\n            // swapped by inner loop, then break\n            if (swapped == false)\n                break;\n        }\n    }\n\n    // Function to print an array\n    static void printArray(int arr[], int size){\n        int i;\n        for (i = 0; i < size; i++)\n            System.out.print(arr[i] + \" \");\n        System.out.println();\n    }\n\n    // Driver program\n    public static void main(String args[]){\n        int arr[] = { 64, 34, 25, 12, 22, 11, 90 };\n        int n = arr.length;\n        bubbleSort(arr, n);\n        System.out.println(\"Sorted array: \");\n        printArray(arr, n);\n    }\n}\n# Optimized Python program for implementation of Bubble Sort\ndef bubbleSort(arr):\n    n = len(arr)\n    \n    # Traverse through all array elements\n    for i in range(n):\n        swapped = False\n\n        # Last i elements are already in place\n        for j in range(0, n-i-1):\n\n            # Traverse the array from 0 to n-i-1\n            # Swap if the element found is greater\n            # than the next element\n            if arr[j] > arr[j+1]:\n                arr[j], arr[j+1] = arr[j+1], arr[j]\n                swapped = True\n        if (swapped == False):\n            break\n\n# Driver code to test above\nif __name__ == \"__main__\":\n    arr = [64, 34, 25, 12, 22, 11, 90]\n\n    bubbleSort(arr)\n\n    print(\"Sorted array:\")\n    for i in range(len(arr)):\n        print(\"%d\" % arr[i], end=\" \")\n// Optimized C# implementation of Bubble sort\nusing System;\n\nclass GFG {\n  \n    // An optimized version of Bubble Sort\n    static void bubbleSort(int[] arr, int n){\n        int i, j, temp;\n        bool swapped;\n        for (i = 0; i < n - 1; i++) {\n            swapped = false;\n            for (j = 0; j < n - i - 1; j++) {\n                if (arr[j] > arr[j + 1]) {\n                    \n                    // Swap arr[j] and arr[j+1]\n                    temp = arr[j];\n                    arr[j] = arr[j + 1];\n                    arr[j + 1] = temp;\n                    swapped = true;\n                }\n            }\n\n            // If no two elements were\n            // swapped by inner loop, then break\n            if (swapped == false)\n                break;\n        }\n    }\n\n    // Function to print an array\n    static void printArray(int[] arr, int size){\n        int i;\n        for (i = 0; i < size; i++)\n            Console.Write(arr[i] + \" \");\n        Console.WriteLine();\n    }\n\n    // Driver method\n    public static void Main(){\n        int[] arr = { 64, 34, 25, 12, 22, 11, 90 };\n        int n = arr.Length;\n        bubbleSort(arr, n);\n        Console.WriteLine(\"Sorted array:\");\n        printArray(arr, n);\n    }\n}\n// Optimized javaScript implementation\n// of Bubble sort\nfunction bubbleSort(arr, n){\n    var i, j, temp;\n    var swapped;\n    for (i = 0; i < n - 1; i++){\n        swapped = false;\n        for (j = 0; j < n - i - 1; j++){\n            if (arr[j] > arr[j + 1]) \n            {\n                // Swap arr[j] and arr[j+1]\n                temp = arr[j];\n                arr[j] = arr[j + 1];\n                arr[j + 1] = temp;\n                swapped = true;\n            }\n        }\n\n        // IF no two elements were \n        // swapped by inner loop, then break\n        if (swapped == false)\n        break;\n    }\n}\n\n// Function to print an array \nfunction printArray(arr, size){\n  var i;\n  for (i = 0; i < size; i++)\n      console.log(arr[i] + \" \");\n}\n\n// Driver program\nvar arr = [ 64, 34, 25, 12, 22, 11, 90 ];\nvar n = arr.length;\nbubbleSort(arr, n);\nconsole.log(\"Sorted array: \");\nprintArray(arr, n);\n<?php \n// PHP Optimized implementation\n// of Bubble sort\nfunction bubbleSort(&$arr)\n{\n    $n = sizeof($arr);\n\n    // Traverse through all array elements\n    for($i = 0; $i < $n; $i++)\n    {\n        $swapped = False;\n\n        // Last i elements are already\n        // in place\n        for ($j = 0; $j < $n - $i - 1; $j++)\n        {\n            \n            // Traverse the array from 0 to\n            // n-i-1. Swap if the element \n            // found is greater than the\n            // next element\n            if ($arr[$j] > $arr[$j+1])\n            {\n                $t = $arr[$j];\n                $arr[$j] = $arr[$j+1];\n                $arr[$j+1] = $t;\n                $swapped = True;\n            }\n        }\n\n        // If no two elements were swapped\n        // by inner loop, then break\n        if ($swapped == False)\n            break;\n    }\n}\n        \n// Driver code\n$arr = array(64, 34, 25, 12, 22, 11, 90); \n$len = sizeof($arr);\nbubbleSort($arr);\n\necho \"Sorted array: \\n\";\n\nfor($i = 0; $i < $len; $i++)\n    echo $arr[$i].\" \";\n    \n// This code is contributed by ChitraNayal.\n?>\nSorted array: \n 11 12 22 25 34 64 90\n",
        "complexity": {
            "time": "Time Complexity: O(n2)Auxiliary Space: O(1)Please refer Complexity Analysis of Bubble Sort for details.",
            "space": ""
        },
        "tags": [
            "Sorting"
        ],
        "url": "https://www.geeksforgeeks.org/bubble-sort-algorithm/"
    },
    {
        "title": "Quick Sort",
        "description": "QuickSort is a sorting algorithm based on the Divide and Conquer that picks an element as a pivot and partitions the given array around the picked pivot by placing the pivot in its correct position in the sorted array. It works on the principle of divide and conquer, breaking down the problem into smaller sub-problems. There are mainly three steps in the algorithm: Here’s a basic overview of how the QuickSort algorithm works. There are many different choices for picking pivots. The key process in quickSort is a partition(). There are three common algorithms to partition. All these algorithms have O(n) time complexity. The logic is simple, we start from the leftmost element and keep track of the index of smaller (or equal) elements as i . While traversing, if we find a smaller element, we swap the current element with arr[i]. Otherwise, we ignore the current element. Let us understand the working of partition algorithm with the help of the following example:  In the previous step, we looked at how the partitioning process rearranges the array based on the chosen pivot. Next, we apply the same method recursively to the smaller sub-arrays on the left and right of the pivot. Each time, we select new pivots and partition the arrays again. This process continues until only one element is left, which is always sorted. Once every element is in its correct position, the entire array is sorted. Below image illustrates, how the recursive method calls for the smaller sub-arrays on the left and right of the pivot: Quick Sort  is a crucial algorithm in the industry, but there are other sorting algorithms that may be more optimal in different cases. Time Complexity: Auxiliary Space: O(n), due to recursive call stack Please refer Time and Space Complexity Analysis of Quick Sort for more details. Please refer Application of Quicksort for more details.  ",
        "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint partition(vector<int>& arr, int low, int high) {\n  \n    // Choose the pivot\n    int pivot = arr[high];\n  \n    // Index of smaller element and indicates \n    // the right position of pivot found so far\n    int i = low - 1;\n\n    // Traverse arr[low..high] and move all smaller\n    // elements on left side. Elements from low to \n    // i are smaller after every iteration\n    for (int j = low; j <= high - 1; j++) {\n        if (arr[j] < pivot) {\n            i++;\n            swap(arr[i], arr[j]);\n        }\n    }\n    \n    // Move pivot after smaller elements and\n    // return its position\n    swap(arr[i + 1], arr[high]);  \n    return i + 1;\n}\n\n// The QuickSort function implementation\nvoid quickSort(vector<int>& arr, int low, int high) {\n  \n    if (low < high) {\n      \n        // pi is the partition return index of pivot\n        int pi = partition(arr, low, high);\n\n        // Recursion calls for smaller elements\n        // and greater or equals elements\n        quickSort(arr, low, pi - 1);\n        quickSort(arr, pi + 1, high);\n    }\n}\n\nint main() {\n    vector<int> arr = {10, 7, 8, 9, 1, 5};\n    int n = arr.size();\n    quickSort(arr, 0, n - 1);\n  \n    for (int i = 0; i < n; i++) {\n        cout << arr[i] << \" \";\n    }\n    return 0;\n}\n#include <stdio.h>\n\nvoid swap(int* a, int* b);\n\n// Partition function\nint partition(int arr[], int low, int high) {\n    \n    // Choose the pivot\n    int pivot = arr[high];\n    \n    // Index of smaller element and indicates \n    // the right position of pivot found so far\n    int i = low - 1;\n\n    // Traverse arr[low..high] and move all smaller\n    // elements to the left side. Elements from low to \n    // i are smaller after every iteration\n    for (int j = low; j <= high - 1; j++) {\n        if (arr[j] < pivot) {\n            i++;\n            swap(&arr[i], &arr[j]);\n        }\n    }\n    \n    // Move pivot after smaller elements and\n    // return its position\n    swap(&arr[i + 1], &arr[high]);  \n    return i + 1;\n}\n\n// The QuickSort function implementation\nvoid quickSort(int arr[], int low, int high) {\n    if (low < high) {\n        \n        // pi is the partition return index of pivot\n        int pi = partition(arr, low, high);\n\n        // Recursion calls for smaller elements\n        // and greater or equals elements\n        quickSort(arr, low, pi - 1);\n        quickSort(arr, pi + 1, high);\n    }\n}\n\nvoid swap(int* a, int* b) {\n    int t = *a;\n    *a = *b;\n    *b = t;\n}\n\nint main() {\n    int arr[] = {10, 7, 8, 9, 1, 5};\n    int n = sizeof(arr) / sizeof(arr[0]);\n\n    quickSort(arr, 0, n - 1);\n    for (int i = 0; i < n; i++) {\n        printf(\"%d \", arr[i]);\n    }\n    \n    return 0;\n}\nimport java.util.Arrays;\n\nclass GfG {\n\n    // Partition function\n    static int partition(int[] arr, int low, int high) {\n        \n        // Choose the pivot\n        int pivot = arr[high];\n        \n        // Index of smaller element and indicates \n        // the right position of pivot found so far\n        int i = low - 1;\n\n        // Traverse arr[low..high] and move all smaller\n        // elements to the left side. Elements from low to \n        // i are smaller after every iteration\n        for (int j = low; j <= high - 1; j++) {\n            if (arr[j] < pivot) {\n                i++;\n                swap(arr, i, j);\n            }\n        }\n        \n        // Move pivot after smaller elements and\n        // return its position\n        swap(arr, i + 1, high);  \n        return i + 1;\n    }\n\n    // Swap function\n    static void swap(int[] arr, int i, int j) {\n        int temp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = temp;\n    }\n\n    // The QuickSort function implementation\n    static void quickSort(int[] arr, int low, int high) {\n        if (low < high) {\n            \n            // pi is the partition return index of pivot\n            int pi = partition(arr, low, high);\n\n            // Recursion calls for smaller elements\n            // and greater or equals elements\n            quickSort(arr, low, pi - 1);\n            quickSort(arr, pi + 1, high);\n        }\n    }\n\n    public static void main(String[] args) {\n        int[] arr = {10, 7, 8, 9, 1, 5};\n        int n = arr.length;\n      \n        quickSort(arr, 0, n - 1);\n        \n        for (int val : arr) {\n            System.out.print(val + \" \");  \n        }\n    }\n}\n# Partition function\ndef partition(arr, low, high):\n    \n    # Choose the pivot\n    pivot = arr[high]\n    \n    # Index of smaller element and indicates \n    # the right position of pivot found so far\n    i = low - 1\n    \n    # Traverse arr[low..high] and move all smaller\n    # elements to the left side. Elements from low to \n    # i are smaller after every iteration\n    for j in range(low, high):\n        if arr[j] < pivot:\n            i += 1\n            swap(arr, i, j)\n    \n    # Move pivot after smaller elements and\n    # return its position\n    swap(arr, i + 1, high)\n    return i + 1\n\n# Swap function\ndef swap(arr, i, j):\n    arr[i], arr[j] = arr[j], arr[i]\n\n# The QuickSort function implementation\ndef quickSort(arr, low, high):\n    if low < high:\n        \n        # pi is the partition return index of pivot\n        pi = partition(arr, low, high)\n        \n        # Recursion calls for smaller elements\n        # and greater or equals elements\n        quickSort(arr, low, pi - 1)\n        quickSort(arr, pi + 1, high)\n\n# Main driver code\nif __name__ == \"__main__\":\n    arr = [10, 7, 8, 9, 1, 5]\n    n = len(arr)\n\n    quickSort(arr, 0, n - 1)\n    \n    for val in arr:\n        print(val, end=\" \")\nusing System;\n\nclass GfG {\n\n    // Partition function\n    static int Partition(int[] arr, int low, int high) {\n        \n        // Choose the pivot\n        int pivot = arr[high];\n        \n        // Index of smaller element and indicates \n        // the right position of pivot found so far\n        int i = low - 1;\n\n        // Traverse arr[low..high] and move all smaller\n        // elements to the left side. Elements from low to \n        // i are smaller after every iteration\n        for (int j = low; j <= high - 1; j++) {\n            if (arr[j] < pivot) {\n                i++;\n                Swap(arr, i, j);\n            }\n        }\n        \n        // Move pivot after smaller elements and\n        // return its position\n        Swap(arr, i + 1, high);  \n        return i + 1;\n    }\n\n    // Swap function\n    static void Swap(int[] arr, int i, int j) {\n        int temp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = temp;\n    }\n\n    // The QuickSort function implementation\n    static void QuickSort(int[] arr, int low, int high) {\n        if (low < high) {\n            \n            // pi is the partition return index of pivot\n            int pi = Partition(arr, low, high);\n\n            // Recursion calls for smaller elements\n            // and greater or equals elements\n            QuickSort(arr, low, pi - 1);\n            QuickSort(arr, pi + 1, high);\n        }\n    }\n\n    static void Main(string[] args) {\n        int[] arr = {10, 7, 8, 9, 1, 5};\n        int n = arr.Length;\n\n        QuickSort(arr, 0, n - 1);\n        foreach (int val in arr) {\n            Console.Write(val + \" \"); \n        }\n    }\n}\n// Partition function\nfunction partition(arr, low, high)\n{\n\n    // Choose the pivot\n    let pivot = arr[high];\n\n    // Index of smaller element and indicates\n    // the right position of pivot found so far\n    let i = low - 1;\n\n    // Traverse arr[low..high] and move all smaller\n    // elements to the left side. Elements from low to\n    // i are smaller after every iteration\n    for (let j = low; j <= high - 1; j++) {\n        if (arr[j] < pivot) {\n            i++;\n            swap(arr, i, j);\n        }\n    }\n\n    // Move pivot after smaller elements and\n    // return its position\n    swap(arr, i + 1, high);\n    return i + 1;\n}\n\n// Swap function\nfunction swap(arr, i, j)\n{\n    let temp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = temp;\n}\n\n// The QuickSort function implementation\nfunction quickSort(arr, low, high)\n{\n    if (low < high) {\n\n        // pi is the partition return index of pivot\n        let pi = partition(arr, low, high);\n\n        // Recursion calls for smaller elements\n        // and greater or equals elements\n        quickSort(arr, low, pi - 1);\n        quickSort(arr, pi + 1, high);\n    }\n}\n\n// Main driver code\nlet arr = [ 10, 7, 8, 9, 1, 5 ];\nlet n = arr.length;\n\n// Call QuickSort on the entire array\nquickSort(arr, 0, n - 1);\nfor (let i = 0; i < arr.length; i++) {\n    console.log(arr[i] + \" \");\n}\n<?php\n// Function to swap two elements\nfunction swap(&$a, &$b) {\n    $temp = $a;\n    $a = $b;\n    $b = $temp;\n}\n\n// Partition function\nfunction partition(&$arr, $low, $high) {\n    \n    // Choose the pivot\n    $pivot = $arr[$high];\n    \n    // Index of smaller element and indicates \n    // the right position of pivot found so far\n    $i = $low - 1;\n\n    // Traverse arr[low..high] and move all smaller\n    // elements to the left side. Elements from low to \n    // i are smaller after every iteration\n    for ($j = $low; $j <= $high - 1; $j++) {\n        if ($arr[$j] < $pivot) {\n            $i++;\n            swap($arr[$i], $arr[$j]);\n        }\n    }\n    \n    // Move pivot after smaller elements and\n    // return its position\n    swap($arr[$i + 1], $arr[$high]);  \n    return $i + 1;\n}\n\n// The QuickSort function implementation\nfunction quickSort(&$arr, $low, $high) {\n    if ($low < $high) {\n        \n        // pi is the partition return index of pivot\n        $pi = partition($arr, $low, $high);\n\n        // Recursion calls for smaller elements\n        // and greater or equals elements\n        quickSort($arr, $low, $pi - 1);\n        quickSort($arr, $pi + 1, $high);\n    }\n}\n\n// Main driver code\n$arr = array(10, 7, 8, 9, 1, 5);\n$n = count($arr);\n\nquickSort($arr, 0, $n - 1);\nfor ($i = 0; $i < count($arr); $i++) {\n    echo $arr[$i] . \" \";  \n}\n?>\nSorted Array\n1 5 7 8 9 10\n",
        "complexity": {
            "time": "Time Complexity:",
            "space": "Please refer Time and Space Complexity Analysis of Quick Sort for more details."
        },
        "tags": [
            "Sorting"
        ],
        "url": "https://www.geeksforgeeks.org/quick-sort-algorithm/"
    },
    {
        "title": "Merge Sort – Data Structure and Algorithms Tutorials",
        "description": "Merge sort  is a sorting algorithm that follows the  divide-and-conquer  approach. It works by recursively dividing the input array into smaller subarrays and sorting those subarrays then merging them back together to obtain the sorted array. In simple terms, we can say that the process of  merge sort  is to divide the array into two halves, sort each half, and then merge the sorted halves back together. This process is repeated until the entire array is sorted. Merge Sort Algorithm Table of Content Merge sort is a popular sorting algorithm known for its efficiency and stability. It follows the  divide-and-conquer  approach to sort a given array of elements. Here’s a step-by-step explanation of how merge sort works: Let’s sort the array or list  [38, 27, 43, 10]  using Merge Sort Let’s look at the working of above example: Divide: Conquer: Merge: Therefore, the sorted list is  [10, 27, 38, 43]  . The recurrence relation of merge sort is:[Tex]T(n) = \\begin{cases} \\Theta(1) & \\text{if } n = 1 \\\\ 2T\\left(\\frac{n}{2}\\right) + \\Theta(n) & \\text{if } n > 1 \\end{cases}[/Tex] Advantages Disadvantages Quick Links:  ",
        "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n// Merges two subarrays of arr[].\n// First subarray is arr[left..mid]\n// Second subarray is arr[mid+1..right]\nvoid merge(vector<int>& arr, int left, \n                     int mid, int right)\n{\n    int n1 = mid - left + 1;\n    int n2 = right - mid;\n\n    // Create temp vectors\n    vector<int> L(n1), R(n2);\n\n    // Copy data to temp vectors L[] and R[]\n    for (int i = 0; i < n1; i++)\n        L[i] = arr[left + i];\n    for (int j = 0; j < n2; j++)\n        R[j] = arr[mid + 1 + j];\n\n    int i = 0, j = 0;\n    int k = left;\n\n    // Merge the temp vectors back \n    // into arr[left..right]\n    while (i < n1 && j < n2) {\n        if (L[i] <= R[j]) {\n            arr[k] = L[i];\n            i++;\n        }\n        else {\n            arr[k] = R[j];\n            j++;\n        }\n        k++;\n    }\n\n    // Copy the remaining elements of L[], \n    // if there are any\n    while (i < n1) {\n        arr[k] = L[i];\n        i++;\n        k++;\n    }\n\n    // Copy the remaining elements of R[], \n    // if there are any\n    while (j < n2) {\n        arr[k] = R[j];\n        j++;\n        k++;\n    }\n}\n\n// begin is for left index and end is right index\n// of the sub-array of arr to be sorted\nvoid mergeSort(vector<int>& arr, int left, int right)\n{\n    if (left >= right)\n        return;\n\n    int mid = left + (right - left) / 2;\n    mergeSort(arr, left, mid);\n    mergeSort(arr, mid + 1, right);\n    merge(arr, left, mid, right);\n}\n\n// Function to print a vector\nvoid printVector(vector<int>& arr)\n{\n    for (int i = 0; i < arr.size(); i++)\n        cout << arr[i] << \" \";\n    cout << endl;\n}\n\n// Driver code\nint main()\n{\n    vector<int> arr = { 12, 11, 13, 5, 6, 7 };\n    int n = arr.size();\n\n    cout << \"Given vector is \\n\";\n    printVector(arr);\n\n    mergeSort(arr, 0, n - 1);\n\n    cout << \"\\nSorted vector is \\n\";\n    printVector(arr);\n    return 0;\n}\n// C program for Merge Sort\n#include <stdio.h>\n#include <stdlib.h>\n\n// Merges two subarrays of arr[].\n// First subarray is arr[l..m]\n// Second subarray is arr[m+1..r]\nvoid merge(int arr[], int l, int m, int r)\n{\n    int i, j, k;\n    int n1 = m - l + 1;\n    int n2 = r - m;\n\n    // Create temp arrays\n    int L[n1], R[n2];\n\n    // Copy data to temp arrays L[] and R[]\n    for (i = 0; i < n1; i++)\n        L[i] = arr[l + i];\n    for (j = 0; j < n2; j++)\n        R[j] = arr[m + 1 + j];\n\n    // Merge the temp arrays back into arr[l..r\n    i = 0;\n    j = 0;\n    k = l;\n    while (i < n1 && j < n2) {\n        if (L[i] <= R[j]) {\n            arr[k] = L[i];\n            i++;\n        }\n        else {\n            arr[k] = R[j];\n            j++;\n        }\n        k++;\n    }\n\n    // Copy the remaining elements of L[],\n    // if there are any\n    while (i < n1) {\n        arr[k] = L[i];\n        i++;\n        k++;\n    }\n\n    // Copy the remaining elements of R[],\n    // if there are any\n    while (j < n2) {\n        arr[k] = R[j];\n        j++;\n        k++;\n    }\n}\n\n// l is for left index and r is right index of the\n// sub-array of arr to be sorted\nvoid mergeSort(int arr[], int l, int r)\n{\n    if (l < r) {\n        int m = l + (r - l) / 2;\n\n        // Sort first and second halves\n        mergeSort(arr, l, m);\n        mergeSort(arr, m + 1, r);\n\n        merge(arr, l, m, r);\n    }\n}\n\n// Function to print an array\nvoid printArray(int A[], int size)\n{\n    int i;\n    for (i = 0; i < size; i++)\n        printf(\"%d \", A[i]);\n    printf(\"\\n\");\n}\n\n// Driver code\nint main()\n{\n    int arr[] = { 12, 11, 13, 5, 6, 7 };\n    int arr_size = sizeof(arr) / sizeof(arr[0]);\n\n    printf(\"Given array is \\n\");\n    printArray(arr, arr_size);\n\n    mergeSort(arr, 0, arr_size - 1);\n\n    printf(\"\\nSorted array is \\n\");\n    printArray(arr, arr_size);\n    return 0;\n}\n// Java program for Merge Sort\nimport java.io.*;\n\nclass GfG {\n\n    // Merges two subarrays of arr[].\n    // First subarray is arr[l..m]\n    // Second subarray is arr[m+1..r]\n    static void merge(int arr[], int l, int m, int r)\n    {\n        // Find sizes of two subarrays to be merged\n        int n1 = m - l + 1;\n        int n2 = r - m;\n\n        // Create temp arrays\n        int L[] = new int[n1];\n        int R[] = new int[n2];\n\n        // Copy data to temp arrays\n        for (int i = 0; i < n1; ++i)\n            L[i] = arr[l + i];\n        for (int j = 0; j < n2; ++j)\n            R[j] = arr[m + 1 + j];\n\n        // Merge the temp arrays\n\n        // Initial indices of first and second subarrays\n        int i = 0, j = 0;\n\n        // Initial index of merged subarray array\n        int k = l;\n        while (i < n1 && j < n2) {\n            if (L[i] <= R[j]) {\n                arr[k] = L[i];\n                i++;\n            }\n            else {\n                arr[k] = R[j];\n                j++;\n            }\n            k++;\n        }\n\n        // Copy remaining elements of L[] if any\n        while (i < n1) {\n            arr[k] = L[i];\n            i++;\n            k++;\n        }\n\n        // Copy remaining elements of R[] if any\n        while (j < n2) {\n            arr[k] = R[j];\n            j++;\n            k++;\n        }\n    }\n\n    // Main function that sorts arr[l..r] using\n    // merge()\n    static void sort(int arr[], int l, int r)\n    {\n        if (l < r) {\n\n            // Find the middle point\n            int m = l + (r - l) / 2;\n\n            // Sort first and second halves\n            sort(arr, l, m);\n            sort(arr, m + 1, r);\n\n            // Merge the sorted halves\n            merge(arr, l, m, r);\n        }\n    }\n\n    // A utility function to print array of size n\n    static void printArray(int arr[])\n    {\n        int n = arr.length;\n        for (int i = 0; i < n; ++i)\n            System.out.print(arr[i] + \" \");\n        System.out.println();\n    }\n\n    // Driver code\n    public static void main(String args[])\n    {\n        int arr[] = { 12, 11, 13, 5, 6, 7 };\n\n        System.out.println(\"Given array is\");\n        printArray(arr);\n\n        sort(arr, 0, arr.length - 1);\n\n        System.out.println(\"\\nSorted array is\");\n        printArray(arr);\n    }\n}\ndef merge(arr, left, mid, right):\n    n1 = mid - left + 1\n    n2 = right - mid\n\n    # Create temp arrays\n    L = [0] * n1\n    R = [0] * n2\n\n    # Copy data to temp arrays L[] and R[]\n    for i in range(n1):\n        L[i] = arr[left + i]\n    for j in range(n2):\n        R[j] = arr[mid + 1 + j]\n\n    i = 0  # Initial index of first subarray\n    j = 0  # Initial index of second subarray\n    k = left  # Initial index of merged subarray\n\n    # Merge the temp arrays back\n    # into arr[left..right]\n    while i < n1 and j < n2:\n        if L[i] <= R[j]:\n            arr[k] = L[i]\n            i += 1\n        else:\n            arr[k] = R[j]\n            j += 1\n        k += 1\n\n    # Copy the remaining elements of L[],\n    # if there are any\n    while i < n1:\n        arr[k] = L[i]\n        i += 1\n        k += 1\n\n    # Copy the remaining elements of R[], \n    # if there are any\n    while j < n2:\n        arr[k] = R[j]\n        j += 1\n        k += 1\n\ndef merge_sort(arr, left, right):\n    if left < right:\n        mid = (left + right) // 2\n\n        merge_sort(arr, left, mid)\n        merge_sort(arr, mid + 1, right)\n        merge(arr, left, mid, right)\n\ndef print_list(arr):\n    for i in arr:\n        print(i, end=\" \")\n    print()\n\n# Driver code\nif __name__ == \"__main__\":\n    arr = [12, 11, 13, 5, 6, 7]\n    print(\"Given array is\")\n    print_list(arr)\n\n    merge_sort(arr, 0, len(arr) - 1)\n\n    print(\"\\nSorted array is\")\n    print_list(arr)\n// C# program for Merge Sort\nusing System;\n\nclass GfG {\n\n    // Merges two subarrays of []arr.\n    // First subarray is arr[l..m]\n    // Second subarray is arr[m+1..r]\n    static void merge(int[] arr, int l, int m, int r)\n    {\n        // Find sizes of two\n        // subarrays to be merged\n        int n1 = m - l + 1;\n        int n2 = r - m;\n\n        // Create temp arrays\n        int[] L = new int[n1];\n        int[] R = new int[n2];\n        int i, j;\n\n        // Copy data to temp arrays\n        for (i = 0; i < n1; ++i)\n            L[i] = arr[l + i];\n        for (j = 0; j < n2; ++j)\n            R[j] = arr[m + 1 + j];\n\n        // Merge the temp arrays\n\n        // Initial indexes of first\n        // and second subarrays\n        i = 0;\n        j = 0;\n\n        // Initial index of merged\n        // subarray array\n        int k = l;\n        while (i < n1 && j < n2) {\n            if (L[i] <= R[j]) {\n                arr[k] = L[i];\n                i++;\n            }\n            else {\n                arr[k] = R[j];\n                j++;\n            }\n            k++;\n        }\n\n        // Copy remaining elements\n        // of L[] if any\n        while (i < n1) {\n            arr[k] = L[i];\n            i++;\n            k++;\n        }\n\n        // Copy remaining elements\n        // of R[] if any\n        while (j < n2) {\n            arr[k] = R[j];\n            j++;\n            k++;\n        }\n    }\n\n    // Main function that\n    // sorts arr[l..r] using\n    // merge()\n    static void mergeSort(int[] arr, int l, int r)\n    {\n        if (l < r) {\n\n            // Find the middle point\n            int m = l + (r - l) / 2;\n\n            // Sort first and second halves\n            mergeSort(arr, l, m);\n            mergeSort(arr, m + 1, r);\n\n            // Merge the sorted halves\n            merge(arr, l, m, r);\n        }\n    }\n\n    // A utility function to\n    // print array of size n\n    static void printArray(int[] arr)\n    {\n        int n = arr.Length;\n        for (int i = 0; i < n; ++i)\n            Console.Write(arr[i] + \" \");\n        Console.WriteLine();\n    }\n\n    // Driver code\n    public static void Main(String[] args)\n    {\n        int[] arr = { 12, 11, 13, 5, 6, 7 };\n        Console.WriteLine(\"Given array is\");\n        printArray(arr);\n        mergeSort(arr, 0, arr.Length - 1);\n        Console.WriteLine(\"\\nSorted array is\");\n        printArray(arr);\n    }\n}\nfunction merge(arr, left, mid, right) {\n    const n1 = mid - left + 1;\n    const n2 = right - mid;\n\n    // Create temp arrays\n    const L = new Array(n1);\n    const R = new Array(n2);\n\n    // Copy data to temp arrays L[] and R[]\n    for (let i = 0; i < n1; i++)\n        L[i] = arr[left + i];\n    for (let j = 0; j < n2; j++)\n        R[j] = arr[mid + 1 + j];\n\n    let i = 0, j = 0;\n    let k = left;\n\n    // Merge the temp arrays back into arr[left..right]\n    while (i < n1 && j < n2) {\n        if (L[i] <= R[j]) {\n            arr[k] = L[i];\n            i++;\n        } else {\n            arr[k] = R[j];\n            j++;\n        }\n        k++;\n    }\n\n    // Copy the remaining elements of L[], if there are any\n    while (i < n1) {\n        arr[k] = L[i];\n        i++;\n        k++;\n    }\n\n    // Copy the remaining elements of R[], if there are any\n    while (j < n2) {\n        arr[k] = R[j];\n        j++;\n        k++;\n    }\n}\n\nfunction mergeSort(arr, left, right) {\n    if (left >= right)\n        return;\n\n    const mid = Math.floor(left + (right - left) / 2);\n    mergeSort(arr, left, mid);\n    mergeSort(arr, mid + 1, right);\n    merge(arr, left, mid, right);\n}\n\nfunction printArray(arr) {\n    console.log(arr.join(\" \"));\n}\n\n// Driver code\nconst arr = [12, 11, 13, 5, 6, 7];\nconsole.log(\"Given array is\");\nprintArray(arr);\n\nmergeSort(arr, 0, arr.length - 1);\n\nconsole.log(\"\\nSorted array is\");\nprintArray(arr);\n<?php\n/* PHP recursive program for Merge Sort */\n\n// Merges two subarrays of arr[].\n// First subarray is arr[l..m]\n// Second subarray is arr[m+1..r]\nfunction merge(&$arr, $l, $m, $r)\n{\n    $n1 = $m - $l + 1;\n    $n2 = $r - $m;\n\n    // Create temp arrays\n    $L = array();\n    $R = array();\n  \n    // Copy data to temp arrays L[] and R[]\n    for ($i = 0; $i < $n1; $i++)\n        $L[$i] = $arr[$l + $i];\n    for ($j = 0; $j < $n2; $j++)\n        $R[$j] = $arr[$m + 1 + $j];\n\n    // Merge the temp arrays back into arr[l..r]\n    $i = 0;\n    $j = 0;\n    $k = $l;\n    while ($i < $n1 && $j < $n2) {\n        if ($L[$i] <= $R[$j]) {\n            $arr[$k] = $L[$i];\n            $i++;\n        }\n        else {\n            $arr[$k] = $R[$j];\n            $j++;\n        }\n        $k++;\n    }\n\n    // Copy the remaining elements of L[], \n    // if there are any\n    while ($i < $n1) {\n        $arr[$k] = $L[$i];\n        $i++;\n        $k++;\n    }\n\n    // Copy the remaining elements of R[], \n    // if there are any\n    while ($j < $n2) {\n        $arr[$k] = $R[$j];\n        $j++;\n        $k++;\n    }\n}\n\n// l is for left index and r is right index of the\n// sub-array of arr to be sorted\nfunction mergeSort(&$arr, $l, $r)\n{\n    if ($l < $r) {\n        $m = $l + (int)(($r - $l) / 2);\n\n        // Sort first and second halves\n        mergeSort($arr, $l, $m);\n        mergeSort($arr, $m + 1, $r);\n\n        merge($arr, $l, $m, $r);\n    }\n}\n\n// Function to print an array\nfunction printArray($A, $size)\n{\n    for ($i = 0; $i < $size; $i++)\n        echo $A[$i].\" \";\n    echo \"\\n\";\n}\n\n// Driver code\n$arr = array(12, 11, 13, 5, 6, 7);\n$arr_size = sizeof($arr);\n\necho \"Given array is \\n\";\nprintArray($arr, $arr_size);\n\nmergeSort($arr, 0, $arr_size - 1);\n\necho \"\\nSorted array is \\n\";\nprintArray($arr, $arr_size);\nreturn 0;\n\n//This code is contributed by Susobhan Akhuli\n?>\nGiven array is \n12 11 13 5 6 7 \n\nSorted array is \n5 6 7 11 12 13\n",
        "complexity": {
            "time": "",
            "space": ""
        },
        "tags": [
            "Sorting"
        ],
        "url": "https://www.geeksforgeeks.org/merge-sort/"
    },
    {
        "title": "Insertion Sort Algorithm",
        "description": "Insertion sort is a simple sorting algorithm that works by iteratively inserting each element of an unsorted list into its correct position in a sorted portion of the list. It is like sorting playing cards in your hands. You split the cards into two groups: the sorted cards and the unsorted cards. Then, you pick a card from the unsorted group and put it in the right place in the sorted group.  arr = {23, 1, 10, 5, 2} Initial: First Pass: Second Pass: Third Pass: Fourth Pass: Final Array: Time Complexity Space Complexity Please refer Complexity Analysis of Insertion Sort for details. Advantages Disadvantages Insertion sort is commonly used in situations where: What are the Boundary Cases of the Insertion Sort algorithm? Insertion sort takes the maximum time to sort if elements are sorted in reverse order. And it takes minimum time (Order of n) when elements are already sorted. What is the Algorithmic Paradigm of the Insertion Sort algorithm? The Insertion Sort algorithm follows an incremental approach. Is Insertion Sort an in-place sorting algorithm? Yes, insertion sort is an in-place sorting algorithm. Is Insertion Sort a stable algorithm? Yes, insertion sort is a stable sorting algorithm. When is the Insertion Sort algorithm used? Insertion sort is used when number of elements is small. It can also be useful when the input array is almost sorted, and only a few elements are misplaced in a complete big array.  ",
        "code": "// C++ program for implementation of Insertion Sort\n#include <iostream>\nusing namespace std;\n\n/* Function to sort array using insertion sort */\nvoid insertionSort(int arr[], int n)\n{\n    for (int i = 1; i < n; ++i) {\n        int key = arr[i];\n        int j = i - 1;\n\n        /* Move elements of arr[0..i-1], that are\n           greater than key, to one position ahead\n           of their current position */\n        while (j >= 0 && arr[j] > key) {\n            arr[j + 1] = arr[j];\n            j = j - 1;\n        }\n        arr[j + 1] = key;\n    }\n}\n\n/* A utility function to print array of size n */\nvoid printArray(int arr[], int n)\n{\n    for (int i = 0; i < n; ++i)\n        cout << arr[i] << \" \";\n    cout << endl;\n}\n\n// Driver method\nint main()\n{\n    int arr[] = { 12, 11, 13, 5, 6 };\n    int n = sizeof(arr) / sizeof(arr[0]);\n\n    insertionSort(arr, n);\n    printArray(arr, n);\n\n    return 0;\n}\n\n/* This code is contributed by Hritik Shah. */\n// C program for implementation of Insertion Sort\n#include <stdio.h>\n\n/* Function to sort array using insertion sort */\nvoid insertionSort(int arr[], int n)\n{\n    for (int i = 1; i < n; ++i) {\n        int key = arr[i];\n        int j = i - 1;\n\n        /* Move elements of arr[0..i-1], that are\n           greater than key, to one position ahead\n           of their current position */\n        while (j >= 0 && arr[j] > key) {\n            arr[j + 1] = arr[j];\n            j = j - 1;\n        }\n        arr[j + 1] = key;\n    }\n}\n\n/* A utility function to print array of size n */\nvoid printArray(int arr[], int n)\n{\n    for (int i = 0; i < n; ++i)\n        printf(\"%d \", arr[i]);\n    printf(\"\\n\");\n}\n\n// Driver method\nint main()\n{\n    int arr[] = { 12, 11, 13, 5, 6 };\n    int n = sizeof(arr) / sizeof(arr[0]);\n\n    insertionSort(arr, n);\n    printArray(arr, n);\n\n    return 0;\n}\n\n/* This code is contributed by Hritik Shah. */\n// Java program for implementation of Insertion Sort\npublic class InsertionSort {\n    /* Function to sort array using insertion sort */\n    void sort(int arr[])\n    {\n        int n = arr.length;\n        for (int i = 1; i < n; ++i) {\n            int key = arr[i];\n            int j = i - 1;\n\n            /* Move elements of arr[0..i-1], that are\n               greater than key, to one position ahead\n               of their current position */\n            while (j >= 0 && arr[j] > key) {\n                arr[j + 1] = arr[j];\n                j = j - 1;\n            }\n            arr[j + 1] = key;\n        }\n    }\n\n    /* A utility function to print array of size n */\n    static void printArray(int arr[])\n    {\n        int n = arr.length;\n        for (int i = 0; i < n; ++i)\n            System.out.print(arr[i] + \" \");\n\n        System.out.println();\n    }\n\n    // Driver method\n    public static void main(String args[])\n    {\n        int arr[] = { 12, 11, 13, 5, 6 };\n\n        InsertionSort ob = new InsertionSort();\n        ob.sort(arr);\n\n        printArray(arr);\n    }\n}\n\n/* This code is contributed by Hritik Shah. */\n# Python program for implementation of Insertion Sort\n\n# Function to sort array using insertion sort\ndef insertionSort(arr):\n    for i in range(1, len(arr)):\n        key = arr[i]\n        j = i - 1\n\n        # Move elements of arr[0..i-1], that are\n        # greater than key, to one position ahead\n        # of their current position\n        while j >= 0 and key < arr[j]:\n            arr[j + 1] = arr[j]\n            j -= 1\n        arr[j + 1] = key\n\n# A utility function to print array of size n\ndef printArray(arr):\n    for i in range(len(arr)):\n        print(arr[i], end=\" \")\n    print()\n\n# Driver method\nif __name__ == \"__main__\":\n    arr = [12, 11, 13, 5, 6]\n    insertionSort(arr)\n    printArray(arr)\n\n    # This code is contributed by Hritik Shah.\n// C# program for implementation of Insertion Sort\nusing System;\n\nclass InsertionSort {\n    /* Function to sort array using insertion sort */\n    void sort(int[] arr) {\n        int n = arr.Length;\n        for (int i = 1; i < n; ++i) {\n            int key = arr[i];\n            int j = i - 1;\n\n            /* Move elements of arr[0..i-1], that are\n               greater than key, to one position ahead\n               of their current position */\n            while (j >= 0 && arr[j] > key) {\n                arr[j + 1] = arr[j];\n                j = j - 1;\n            }\n            arr[j + 1] = key;\n        }\n    }\n\n    /* A utility function to print array of size n */\n    static void printArray(int[] arr) {\n        int n = arr.Length;\n        for (int i = 0; i < n; ++i)\n            Console.Write(arr[i] + \" \");\n\n        Console.WriteLine();\n    }\n\n    // Driver method\n    public static void Main() {\n        int[] arr = { 12, 11, 13, 5, 6 };\n\n        InsertionSort ob = new InsertionSort();\n        ob.sort(arr);\n\n        printArray(arr);\n    }\n}\n\n/* This code is contributed by Hritik Shah. */\n// Javascript program for insertion sort \n\n// Function to sort array using insertion sort\nfunction insertionSort(arr) {\n    for (let i = 1; i < arr.length; i++) {\n        let key = arr[i];\n        let j = i - 1;\n\n        /* Move elements of arr[0..i-1], that are\n           greater than key, to one position ahead\n           of their current position */\n        while (j >= 0 && arr[j] > key) {\n            arr[j + 1] = arr[j];\n            j = j - 1;\n        }\n        arr[j + 1] = key;\n    }\n}\n\n// A utility function to print array of size n\nfunction printArray(arr) {\n    console.log(arr.join(\" \"));\n}\n\n// Driver method\nlet arr = [12, 11, 13, 5, 6];\n\ninsertionSort(arr);\nprintArray(arr);\n\n// This code is contributed by Hritik Shah.\n<?php \n// PHP program for insertion sort\n\n// Function to sort an array using insertion sort\nfunction insertionSort(&$arr, $n)\n{\n    for ($i = 1; $i < $n; $i++)\n    {\n        $key = $arr[$i];\n        $j = $i - 1;\n\n        // Move elements of arr[0..i-1],\n        // that are greater than key, to \n        // one position ahead of their \n        // current position\n        while ($j >= 0 && $arr[$j] > $key)\n        {\n            $arr[$j + 1] = $arr[$j];\n            $j = $j - 1;\n        }\n        \n        $arr[$j + 1] = $key;\n    }\n}\n\n// A utility function to print an array of size n\nfunction printArray(&$arr, $n)\n{\n    for ($i = 0; $i < $n; $i++)\n        echo $arr[$i] . \" \";\n    echo \"\\n\";\n}\n\n// Driver Code\n$arr = array(12, 11, 13, 5, 6);\n$n = sizeof($arr);\ninsertionSort($arr, $n);\nprintArray($arr, $n);\n\n// This code is contributed by Hritik Shah.\n?>\n5 6 11 12 13\n",
        "complexity": {
            "time": "Time Complexity",
            "space": "Space Complexity"
        },
        "tags": [
            "Sorting"
        ],
        "url": "https://www.geeksforgeeks.org/insertion-sort-algorithm/"
    },
    {
        "title": "Selection Sort",
        "description": "Selection Sort is a comparison-based sorting algorithm. It sorts an array by repeatedly selecting the smallest (or largest) element from the unsorted portion and swapping it with the first unsorted element. This process continues until the entire array is sorted. Time Complexity: O(n2) ,as there are two nested loops: Auxiliary Space: O(1) as the only extra memory used is for temporary variables. Question 1: Is Selection Sort a stable sorting algorithm? Answer: No, Selection Sort is not stable as it may change the relative order of equal elements. Question 2: What is the time complexity of Selection Sort? Answer: Selection Sort has a time complexity of O(n^2) in the best, average, and worst cases. Question 3: Does Selection Sort require extra memory? Answer: No, Selection Sort is an in-place sorting algorithm and requires only O(1) additional space. Question 4: When is it best to use Selection Sort? Answer: Selection Sort is best used for small datasets, educational purposes, or when memory usage needs to be minimal. Question 5: How does Selection Sort differ from Bubble Sort? Answer: Selection Sort selects the minimum element and places it in the correct position with fewer swaps, while Bubble Sort repeatedly swaps adjacent elements to sort the array.  ",
        "code": "// C++ program to implement Selection Sort\n#include <bits/stdc++.h>\nusing namespace std;\n\nvoid selectionSort(vector<int> &arr) {\n    int n = arr.size();\n\n    for (int i = 0; i < n - 1; ++i) {\n\n        // Assume the current position holds\n        // the minimum element\n        int min_idx = i;\n\n        // Iterate through the unsorted portion\n        // to find the actual minimum\n        for (int j = i + 1; j < n; ++j) {\n            if (arr[j] < arr[min_idx]) {\n\n                // Update min_idx if a smaller\n                // element is found\n                min_idx = j; \n            }\n        }\n\n        // Move minimum element to its\n        // correct position\n        swap(arr[i], arr[min_idx]);\n    }\n}\n\nvoid printArray(vector<int> &arr) {\n    for (int &val : arr) {\n        cout << val << \" \";\n    }\n    cout << endl;\n}\n\nint main() {\n    vector<int> arr = {64, 25, 12, 22, 11};\n\n    cout << \"Original array: \";\n    printArray(arr); \n\n    selectionSort(arr);\n\n    cout << \"Sorted array: \";\n    printArray(arr);\n\n    return 0;\n}\n// C program for implementation of selection sort\n#include <stdio.h>\n\nvoid selectionSort(int arr[], int n) {\n    for (int i = 0; i < n - 1; i++) {\n      \n        // Assume the current position holds\n        // the minimum element\n        int min_idx = i;\n        \n        // Iterate through the unsorted portion\n        // to find the actual minimum\n        for (int j = i + 1; j < n; j++) {\n            if (arr[j] < arr[min_idx]) {\n              \n                // Update min_idx if a smaller element is found\n                min_idx = j;\n            }\n        }\n        \n        // Move minimum element to its\n        // correct position\n        int temp = arr[i];\n        arr[i] = arr[min_idx];\n        arr[min_idx] = temp;\n    }\n}\n\nvoid printArray(int arr[], int n) {\n    for (int i = 0; i < n; i++) {\n        printf(\"%d \", arr[i]);\n    }\n    printf(\"\\n\");\n}\n\nint main() {\n    int arr[] = {64, 25, 12, 22, 11};\n    int n = sizeof(arr) / sizeof(arr[0]);\n    \n    printf(\"Original array: \");\n    printArray(arr, n);\n    \n    selectionSort(arr, n);\n    \n    printf(\"Sorted array: \");\n    printArray(arr, n);\n    \n    return 0;\n}\n// Java program for implementation of Selection Sort\nimport java.util.Arrays;\n\nclass GfG {\n\n    static void selectionSort(int[] arr){\n        int n = arr.length;\n        for (int i = 0; i < n - 1; i++) {\n          \n            // Assume the current position holds\n            // the minimum element\n            int min_idx = i;\n\n            // Iterate through the unsorted portion\n            // to find the actual minimum\n            for (int j = i + 1; j < n; j++) {\n                if (arr[j] < arr[min_idx]) {\n                  \n                    // Update min_idx if a smaller element\n                    // is found\n                    min_idx = j;\n                }\n            }\n\n            // Move minimum element to its\n            // correct position\n            int temp = arr[i];\n            arr[i] = arr[min_idx];\n            arr[min_idx] = temp;           \n        }\n    }\n\n    static void printArray(int[] arr){\n        for (int val : arr) {\n            System.out.print(val + \" \");\n        }\n        System.out.println();\n    }\n  \n    public static void main(String[] args){\n        int[] arr = { 64, 25, 12, 22, 11 };\n\n        System.out.print(\"Original array: \");\n        printArray(arr);\n\n        selectionSort(arr);\n\n        System.out.print(\"Sorted array: \");\n        printArray(arr);\n    }\n}\n# Python program for implementation of Selection\n# Sort\n\ndef selection_sort(arr):\n    n = len(arr)\n    for i in range(n - 1):\n      \n        # Assume the current position holds\n        # the minimum element\n        min_idx = i\n        \n        # Iterate through the unsorted portion\n        # to find the actual minimum\n        for j in range(i + 1, n):\n            if arr[j] < arr[min_idx]:\n              \n                # Update min_idx if a smaller element is found\n                min_idx = j\n        \n        # Move minimum element to its\n        # correct position\n        arr[i], arr[min_idx] = arr[min_idx], arr[i]\n\ndef print_array(arr):\n    for val in arr:\n        print(val, end=\" \")\n    print()\n\nif __name__ == \"__main__\":\n    arr = [64, 25, 12, 22, 11]\n    \n    print(\"Original array: \", end=\"\")\n    print_array(arr)\n    \n    selection_sort(arr)\n    \n    print(\"Sorted array: \", end=\"\")\n    print_array(arr)\n// C# program for implementation\n// of Selection Sort\nusing System;\n\nclass GfG {\n\n    static void selectionSort(int[] arr){\n        int n = arr.Length;\n        for (int i = 0; i < n - 1; i++) {\n\n            // Assume the current position holds\n            // the minimum element\n            int min_idx = i;\n\n            // Iterate through the unsorted portion\n            // to find the actual minimum\n            for (int j = i + 1; j < n; j++) {\n                if (arr[j] < arr[min_idx]) {\n\n                    // Update min_idx if a smaller element\n                    // is found\n                    min_idx = j;\n                }\n            }\n\n           // Move minimum element to its\n           // correct position\n           int temp = arr[i];\n           arr[i] = arr[min_idx];\n           arr[min_idx] = temp;         \n        }\n    }\n\n    static void printArray(int[] arr){\n        foreach(int val in arr){\n            Console.Write(val + \" \");\n        }\n        Console.WriteLine();\n    }\n\n    public static void Main(){\n        int[] arr = { 64, 25, 12, 22, 11 };\n\n        Console.Write(\"Original array: \");\n        printArray(arr);\n\n        selectionSort(arr);\n\n        Console.Write(\"Sorted array: \");\n        printArray(arr);\n    }\n}\nfunction selectionSort(arr) {\n    let n = arr.length;\n    for (let i = 0; i < n - 1; i++) {\n    \n        // Assume the current position holds\n        // the minimum element\n        let min_idx = i;\n        \n        // Iterate through the unsorted portion\n        // to find the actual minimum\n        for (let j = i + 1; j < n; j++) {\n            if (arr[j] < arr[min_idx]) {\n            \n                // Update min_idx if a smaller element is found\n                min_idx = j;\n            }\n        }\n        \n        // Move minimum element to its\n        // correct position\n        let temp = arr[i];\n        arr[i] = arr[min_idx];\n        arr[min_idx] = temp;\n    }\n}\n\nfunction printArray(arr) {\n    for (let val of arr) {\n        process.stdout.write(val + \" \");\n    }\n    console.log();\n}\n\n// Driver function \nconst arr = [64, 25, 12, 22, 11];\n\nconsole.log(\"Original array: \");\nprintArray(arr);\n\nselectionSort(arr);\n\nconsole.log(\"Sorted array: \");\nprintArray(arr);\n<?php\n\nfunction selectionSort(&$arr) {\n    $n = count($arr);\n    for ($i = 0; $i < $n - 1; $i++) {\n      \n        // Assume the current position holds\n        // the minimum element\n        $min_idx = $i;\n        \n        // Iterate through the unsorted portion\n        // to find the actual minimum\n        for ($j = $i + 1; $j < $n; $j++) {\n            if ($arr[$j] < $arr[$min_idx]) {\n              \n                // Update min_idx if a smaller element is found\n                $min_idx = $j;\n            }\n        }\n        \n        // Move minimum element to its\n        // correct position\n        $temp = $arr[$i];\n        $arr[$i] = $arr[$min_idx];\n        $arr[$min_idx] = $temp;\n    }\n}\n\nfunction printArray($arr) {\n    foreach ($arr as $val) {\n        echo $val . \" \";\n    }\n    echo \"\\n\";\n}\n\n$arr = [64, 25, 12, 22, 11];\n\necho \"Original array: \";\nprintArray($arr);\n\nselectionSort($arr);\n\necho \"Sorted array: \";\nprintArray($arr);\n\n?>\nOriginal vector: 64 25 12 22 11 \nSorted vector:   11 12 22 25 64\n",
        "complexity": {
            "time": "Answer: Selection Sort has a time complexity of O(n^2) in the best, average, and worst cases.",
            "space": ""
        },
        "tags": [
            "Sorting"
        ],
        "url": "https://www.geeksforgeeks.org/selection-sort-algorithm-2/"
    },
    {
        "title": "Heap Sort – Data Structures and Algorithms Tutorials",
        "description": "Heap sort  is a comparison-based sorting technique based on  Binary Heap Data Structure. It can be seen as an optimization over selection sort where we first find the max (or min) element and swap it with the last (or first). We repeat the same process for the remaining elements. In Heap Sort, we use Binary Heap so that we can quickly find and move the max element in O(Log n) instead of O(n) and hence achieve the O(n Log n) time complexity. Table of Content First convert the array into a max heap using heapify, Please note that this happens in-place. The array elements are re-arranged to follow heap properties. Then one by one delete the root node of the Max-heap and replace it with the last node and heapify. Repeat this process while size of heap is greater than 1. We first need to visualize the array as a complete binary tree. For an array of size n, the root is at index 0, the left child of an element at index i is at 2i + 1, and the right child is at 2i + 2. In the illustration above, we have shown some steps to sort the array. We need to keep repeating these steps until there’s only one element left in the heap. Time Complexity:  O(n log n) Auxiliary Space:  O(log n), due to the recursive call stack. However, auxiliary space can be O(1) for iterative implementation.  ",
        "code": "// C++ program for implementation of Heap Sort using vector\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n// To heapify a subtree rooted with node i\n// which is an index in arr[].\nvoid heapify(vector<int>& arr, int n, int i){\n\n    // Initialize largest as root\n    int largest = i;\n\n    // left index = 2*i + 1\n    int l = 2 * i + 1;\n\n    // right index = 2*i + 2\n    int r = 2 * i + 2;\n\n    // If left child is larger than root\n    if (l < n && arr[l] > arr[largest])\n        largest = l;\n\n    // If right child is larger than largest so far\n    if (r < n && arr[r] > arr[largest])\n        largest = r;\n\n    // If largest is not root\n    if (largest != i) {\n        swap(arr[i], arr[largest]);\n\n        // Recursively heapify the affected sub-tree\n        heapify(arr, n, largest);\n    }\n}\n\n// Main function to do heap sort\nvoid heapSort(vector<int>& arr){\n    int n = arr.size();\n\n    // Build heap (rearrange vector)\n    for (int i = n / 2 - 1; i >= 0; i--)\n        heapify(arr, n, i);\n\n    // One by one extract an element from heap\n    for (int i = n - 1; i > 0; i--) {\n\n        // Move current root to end\n        swap(arr[0], arr[i]);\n\n        // Call max heapify on the reduced heap\n        heapify(arr, i, 0);\n    }\n}\n\n// A utility function to print vector of size n\nvoid printArray(vector<int>& arr){\n    for (int i = 0; i < arr.size(); ++i)\n        cout << arr[i] << \" \";\n    cout << \"\\n\";\n}\n\n// Driver's code\nint main(){\n    vector<int> arr = { 9, 4, 3, 8, 10, 2, 5 };\n\n    // Function call\n    heapSort(arr);\n\n    cout << \"Sorted array is \\n\";\n    printArray(arr);\n}\n#include <stdio.h>\n\n// To heapify a subtree rooted with node i\n// which is an index in arr[].\nvoid heapify(int arr[], int n, int i) {\n\n    // Initialize largest as root\n    int largest = i; \n\n    // left index = 2*i + 1\n    int l = 2 * i + 1; \n\n    // right index = 2*i + 2\n    int r = 2 * i + 2;\n\n    // If left child is larger than root\n    if (l < n && arr[l] > arr[largest]) {\n        largest = l;\n    }\n\n    // If right child is larger than largest so far\n    if (r < n && arr[r] > arr[largest]) {\n        largest = r;\n    }\n\n    // If largest is not root\n    if (largest != i) {\n        int temp = arr[i];\n        arr[i] = arr[largest];\n        arr[largest] = temp;\n\n        // Recursively heapify the affected sub-tree\n        heapify(arr, n, largest);\n    }\n}\n\n// Main function to do heap sort\nvoid heapSort(int arr[], int n) {\n\n    // Build heap (rearrange array)\n    for (int i = n / 2 - 1; i >= 0; i--) {\n        heapify(arr, n, i);\n    }\n\n    // One by one extract an element from heap\n    for (int i = n - 1; i > 0; i--) {\n\n        // Move current root to end\n        int temp = arr[0]; \n        arr[0] = arr[i];\n        arr[i] = temp;\n\n        // Call max heapify on the reduced heap\n        heapify(arr, i, 0);\n    }\n}\n\n// A utility function to print array of size n\nvoid printArray(int arr[], int n) {\n    for (int i = 0; i < n; i++) {\n        printf(\"%d \", arr[i]);\n    }\n    printf(\"\\n\");\n}\n\n// Driver's code\nint main() {\n    int arr[] = {9, 4, 3, 8, 10, 2, 5}; \n    int n = sizeof(arr) / sizeof(arr[0]);\n\n    heapSort(arr, n);\n\n    printf(\"Sorted array is \\n\");\n    printArray(arr, n);\n    return 0;\n}\nimport java.util.Arrays;\n\nclass GfG {\n  \n    // To heapify a subtree rooted with node i\n    // which is an index in arr[].\n    static void heapify(int arr[], int n, int i) {\n\n        // Initialize largest as root\n        int largest = i; \n\n        // left index = 2*i + 1\n        int l = 2 * i + 1; \n\n        // right index = 2*i + 2\n        int r = 2 * i + 2;\n\n        // If left child is larger than root\n        if (l < n && arr[l] > arr[largest]) {\n            largest = l;\n        }\n\n        // If right child is larger than largest so far\n        if (r < n && arr[r] > arr[largest]) {\n            largest = r;\n        }\n\n        // If largest is not root\n        if (largest != i) {\n            int temp = arr[i];\n            arr[i] = arr[largest];\n            arr[largest] = temp;\n\n            // Recursively heapify the affected sub-tree\n            heapify(arr, n, largest);\n        }\n    }\n\n    // Main function to do heap sort\n    static void heapSort(int arr[]) {\n        int n = arr.length;\n\n        // Build heap (rearrange array)\n        for (int i = n / 2 - 1; i >= 0; i--) {\n            heapify(arr, n, i);\n        }\n\n        // One by one extract an element from heap\n        for (int i = n - 1; i > 0; i--) {\n\n            // Move current root to end\n            int temp = arr[0]; \n            arr[0] = arr[i];\n            arr[i] = temp;\n\n            // Call max heapify on the reduced heap\n            heapify(arr, i, 0);\n        }\n    }\n\n    // A utility function to print array of size n\n    static void printArray(int arr[]) {\n        for (int i = 0; i < arr.length; i++) {\n            System.out.print(arr[i] + \" \");\n        }\n        System.out.println();\n    }\n\n    // Driver's code\n    public static void main(String args[]) {\n        int arr[] = {9, 4, 3, 8, 10, 2, 5}; \n        heapSort(arr);\n        System.out.println(\"Sorted array is \");\n        printArray(arr);\n    }\n}\n# Python program for implementation of heap Sort\n\n# To heapify a subtree rooted with node i\n# which is an index in arr[].\ndef heapify(arr, n, i):\n    \n     # Initialize largest as root\n    largest = i \n    \n    #  left index = 2*i + 1\n    l = 2 * i + 1 \n    \n    # right index = 2*i + 2\n    r = 2 * i + 2  \n\n    # If left child is larger than root\n    if l < n and arr[l] > arr[largest]:\n        largest = l\n\n    # If right child is larger than largest so far\n    if r < n and arr[r] > arr[largest]:\n        largest = r\n\n    # If largest is not root\n    if largest != i:\n        arr[i], arr[largest] = arr[largest], arr[i]  # Swap\n\n        # Recursively heapify the affected sub-tree\n        heapify(arr, n, largest)\n\n# Main function to do heap sort\ndef heapSort(arr):\n    \n    n = len(arr) \n\n    # Build heap (rearrange array)\n    for i in range(n // 2 - 1, -1, -1):\n        heapify(arr, n, i)\n\n    # One by one extract an element from heap\n    for i in range(n - 1, 0, -1):\n      \n        # Move root to end\n        arr[0], arr[i] = arr[i], arr[0] \n\n        # Call max heapify on the reduced heap\n        heapify(arr, i, 0)\n\ndef printArray(arr):\n    for i in arr:\n        print(i, end=\" \")\n    print()\n\n# Driver's code\narr = [9, 4, 3, 8, 10, 2, 5] \nheapSort(arr)\nprint(\"Sorted array is \")\nprintArray(arr)\nusing System;\n\nclass GfG {\n    // To heapify a subtree rooted with node i\n    // which is an index in arr[].\n    static void Heapify(int[] arr, int n, int i) {\n      \n         // Initialize largest as root\n        int largest = i;\n      \n        // left index = 2*i + 1\n        int l = 2 * i + 1; \n      \n        // right index = 2*i + 2\n        int r = 2 * i + 2; \n\n        // If left child is larger than root\n        if (l < n && arr[l] > arr[largest]) {\n            largest = l;\n        }\n\n        // If right child is larger than largest so far\n        if (r < n && arr[r] > arr[largest]) {\n            largest = r;\n        }\n\n        // If largest is not root\n        if (largest != i) {\n            int temp = arr[i]; // Swap\n            arr[i] = arr[largest];\n            arr[largest] = temp;\n\n            // Recursively heapify the affected sub-tree\n            Heapify(arr, n, largest);\n        }\n    }\n\n    // Main function to do heap sort\n    static void HeapSortArray(int[] arr) {\n        int n = arr.Length;\n\n        // Build heap (rearrange array)\n        for (int i = n / 2 - 1; i >= 0; i--) {\n            Heapify(arr, n, i);\n        }\n\n        // One by one extract an element from heap\n        for (int i = n - 1; i > 0; i--) {\n          \n            // Move current root to end\n            int temp = arr[0]; \n            arr[0] = arr[i];\n            arr[i] = temp;\n\n            // Call max heapify on the reduced heap\n            Heapify(arr, i, 0);\n        }\n    }\n\n    // A utility function to print array of size n\n    static void PrintArray(int[] arr) {\n        foreach (int value in arr) {\n            Console.Write(value + \" \");\n        }\n        Console.WriteLine();\n    }\n\n    // Driver's code\n    public static void Main(string[] args) {\n        int[] arr = {9, 4, 3, 8, 10, 2, 5};\n        HeapSortArray(arr);\n        Console.WriteLine(\"Sorted array is \");\n        PrintArray(arr);\n    }\n}\n// To heapify a subtree rooted with node i\n// which is an index in arr[].\nfunction heapify(arr, n, i) {\n\n    // Initialize largest as root\n    let largest = i;\n    \n    // left index = 2*i + 1\n    let l = 2 * i + 1; \n    \n    // right index = 2*i + 2\n    let r = 2 * i + 2; \n\n    // If left child is larger than root\n    if (l < n && arr[l] > arr[largest]) {\n        largest = l;\n    }\n\n    // If right child is larger than largest so far\n    if (r < n && arr[r] > arr[largest]) {\n        largest = r;\n    }\n\n    // If largest is not root\n    if (largest !== i) {\n        let temp = arr[i]; // Swap\n        arr[i] = arr[largest];\n        arr[largest] = temp;\n\n        // Recursively heapify the affected sub-tree\n        heapify(arr, n, largest);\n    }\n}\n\n// Main function to do heap sort\nfunction heapSort(arr) {\n    let n = arr.length;\n\n    // Build heap (rearrange array)\n    for (let i = Math.floor(n / 2) - 1; i >= 0; i--) {\n        heapify(arr, n, i);\n    }\n\n    // One by one extract an element from heap\n    for (let i = n - 1; i > 0; i--) {\n    \n        // Move current root to end\n        let temp = arr[0];\n        arr[0] = arr[i];\n        arr[i] = temp;\n\n        // Call max heapify on the reduced heap\n        heapify(arr, i, 0);\n    }\n}\n\n// A utility function to print array of size n\nfunction printArray(arr) {\n    for (let i = 0; i < arr.length; i++) {\n        console.log(arr[i] + \" \");\n    }\n    console.log();\n}\n\n// Driver's code\nlet arr = [9, 4, 3, 8, 10, 2, 5];\nheapSort(arr);\nconsole.log(\"Sorted array is \");\nprintArray(arr);\n<?php\n\n// To heapify a subtree rooted with node i\n// which is an index in arr[].\nfunction heapify(&$arr, $n, $i) {\n  \n    // Initialize largest as root\n    $largest = $i; \n  \n    // left index = 2*i + 1\n    $l = 2 * $i + 1;\n  \n    // right index = 2*i + 2\n    $r = 2 * $i + 2; \n\n    // If left child is larger than root\n    if ($l < $n && $arr[$l] > $arr[$largest]) {\n        $largest = $l;\n    }\n\n    // If right child is larger than largest so far\n    if ($r < $n && $arr[$r] > $arr[$largest]) {\n        $largest = $r;\n    }\n\n    // If largest is not root\n    if ($largest != $i) {\n        $temp = $arr[$i]; // Swap\n        $arr[$i] = $arr[$largest];\n        $arr[$largest] = $temp;\n\n        // Recursively heapify the affected sub-tree\n        heapify($arr, $n, $largest);\n    }\n}\n\n// Main function to do heap sort\nfunction heapSort(&$arr) {\n    $n = count($arr);\n\n    // Build heap (rearrange array)\n    for ($i = intval($n / 2) - 1; $i >= 0; $i--) {\n        heapify($arr, $n, $i);\n    }\n\n    // One by one extract an element from heap\n    for ($i = $n - 1; $i > 0; $i--) {\n      \n        // Move current root to end\n        $temp = $arr[0]; \n        $arr[0] = $arr[$i];\n        $arr[$i] = $temp;\n\n        // Call max heapify on the reduced heap\n        heapify($arr, $i, 0);\n    }\n}\n\n// A utility function to print array of size n\nfunction printArray($arr) {\n    foreach ($arr as $value) {\n        echo $value . \" \";\n    }\n    echo \"\\n\";\n}\n\n// Driver's code\n$arr = [9, 4, 3, 8, 10, 2, 5];\nheapSort($arr);\necho \"Sorted array is:\\n\";\nprintArray($arr);\n?>\nSorted array is \n2 3 4 5 8 9 10\n",
        "complexity": {
            "time": "Time Complexity:  O(n log n) Auxiliary Space:  O(log n), due to the recursive call stack. However, auxiliary space can be O(1) for iterative implementation.",
            "space": ""
        },
        "tags": [
            "Sorting"
        ],
        "url": "https://www.geeksforgeeks.org/heap-sort/"
    },
    {
        "title": "Time Complexities of all Sorting Algorithms",
        "description": "The efficiency of an algorithm depends on two parameters: Both are calculated as the function of input size(n). One important thing here is that despite these parameters, the efficiency of an algorithm also depends upon the nature and size of the input. Time Complexity is defined as order of growth of time taken in terms of input size rather than the total time taken. It is because the total time taken also depends on some external factors like the compiler used, the processor’s speed, etc. Auxiliary Space is extra space (apart from input and output) required for an algorithm. Following is a quick revision sheet that you may refer to at the last minute:  ",
        "code": "",
        "complexity": {
            "time": "Time Complexity is defined as order of growth of time taken in terms of input size rather than the total time taken. It is because the total time taken also depends on some external factors like the compiler used, the processor’s speed, etc.",
            "space": ""
        },
        "tags": [
            "Sorting"
        ],
        "url": "https://www.geeksforgeeks.org/time-complexities-of-all-sorting-algorithms/"
    },
    {
        "title": "Radix Sort – Data Structures and Algorithms Tutorials",
        "description": "Radix Sort is a linear sorting algorithm that sorts elements by processing them digit by digit. It is an efficient sorting algorithm for integers or strings with fixed-size keys. Rather than comparing elements directly, Radix Sort distributes the elements into buckets based on each digit’s value. By repeatedly sorting the elements by their significant digits, from the least significant to the most significant, Radix Sort achieves the final sorted order. The key idea behind Radix Sort is to exploit the concept of place value. It assumes that sorting numbers digit by digit will eventually result in a fully sorted list. Radix Sort can be performed using different variations, such as Least Significant Digit (LSD) Radix Sort or Most Significant Digit (MSD) Radix Sort. To perform radix sort on the array [170, 45, 75, 90, 802, 24, 2, 66], we follow these steps: How does Radix Sort Algorithm work | Step 1 Step 1: Find the largest element in the array, which is 802. It has three digits, so we will iterate three times, once for each significant place. Step 2: Sort the elements based on the unit place digits (X=0). We use a stable sorting technique, such as counting sort, to sort the digits at each significant place. It’s important to understand that the default implementation of counting sort is unstable i.e. same keys can be in a different order than the input array. To solve this problem, We can iterate the input array in reverse order to build the output array. This strategy helps us to keep the same keys in the same order as they appear in the input array. Sorting based on the unit place: How does Radix Sort Algorithm work | Step 2 Step 3: Sort the elements based on the tens place digits. Sorting based on the tens place: How does Radix Sort Algorithm work | Step 3 Step 4: Sort the elements based on the hundreds place digits. Sorting based on the hundreds place: How does Radix Sort Algorithm work | Step 4 Step 5: The array is now sorted in ascending order. The final sorted array using radix sort is [2, 24, 45, 66, 75, 90, 170, 802]. How does Radix Sort Algorithm work | Step 5 Below is the implementation for the above illustrations: Time Complexity: Auxiliary Space:  ",
        "code": "// C++ implementation of Radix Sort\n\n#include <iostream>\nusing namespace std;\n\n// A utility function to get maximum\n// value in arr[]\nint getMax(int arr[], int n)\n{\n    int mx = arr[0];\n    for (int i = 1; i < n; i++)\n        if (arr[i] > mx)\n            mx = arr[i];\n    return mx;\n}\n\n// A function to do counting sort of arr[]\n// according to the digit\n// represented by exp.\nvoid countSort(int arr[], int n, int exp)\n{\n\n    // Output array\n    int output[n];\n    int i, count[10] = { 0 };\n\n    // Store count of occurrences\n    // in count[]\n    for (i = 0; i < n; i++)\n        count[(arr[i] / exp) % 10]++;\n\n    // Change count[i] so that count[i]\n    // now contains actual position\n    // of this digit in output[]\n    for (i = 1; i < 10; i++)\n        count[i] += count[i - 1];\n\n    // Build the output array\n    for (i = n - 1; i >= 0; i--) {\n        output[count[(arr[i] / exp) % 10] - 1] = arr[i];\n        count[(arr[i] / exp) % 10]--;\n    }\n\n    // Copy the output array to arr[],\n    // so that arr[] now contains sorted\n    // numbers according to current digit\n    for (i = 0; i < n; i++)\n        arr[i] = output[i];\n}\n\n// The main function to that sorts arr[]\n// of size n using Radix Sort\nvoid radixsort(int arr[], int n)\n{\n\n    // Find the maximum number to\n    // know number of digits\n    int m = getMax(arr, n);\n\n    // Do counting sort for every digit.\n    // Note that instead of passing digit\n    // number, exp is passed. exp is 10^i\n    // where i is current digit number\n    for (int exp = 1; m / exp > 0; exp *= 10)\n        countSort(arr, n, exp);\n}\n\n// A utility function to print an array\nvoid print(int arr[], int n)\n{\n    for (int i = 0; i < n; i++)\n        cout << arr[i] << \" \";\n}\n\n// Driver Code\nint main()\n{\n    int arr[] = { 170, 45, 75, 90, 802, 24, 2, 66 };\n    int n = sizeof(arr) / sizeof(arr[0]);\n\n    // Function Call\n    radixsort(arr, n);\n    print(arr, n);\n    return 0;\n}\n#include <stdio.h>\n\n// A utility function to get the maximum \n// value in arr[]\nint getMax(int arr[], int n) {\n    int mx = arr[0];\n    for (int i = 1; i < n; i++)\n        if (arr[i] > mx)\n            mx = arr[i];\n    return mx;\n}\n\n// A function to do counting sort of arr[] \n// according to the digit represented by exp\nvoid countSort(int arr[], int n, int exp) {\n    int output[n]; // Output array\n    int count[10] = {0}; // Initialize count array as 0\n\n    // Store count of occurrences in count[]\n    for (int i = 0; i < n; i++)\n        count[(arr[i] / exp) % 10]++;\n\n    // Change count[i] so that count[i] now \n    // contains actual position of this digit\n    // in output[]\n    for (int i = 1; i < 10; i++)\n        count[i] += count[i - 1];\n\n    // Build the output array\n    for (int i = n - 1; i >= 0; i--) {\n        output[count[(arr[i] / exp) % 10] - 1] = arr[i];\n        count[(arr[i] / exp) % 10]--;\n    }\n\n    // Copy the output array to arr[], \n    // so that arr[] now contains sorted \n    // numbers according to current digit\n    for (int i = 0; i < n; i++)\n        arr[i] = output[i];\n}\n\n// The main function to sort arr[] of size \n// n using Radix Sort\nvoid radixSort(int arr[], int n) {\n  \n    // Find the maximum number to know \n    // the number of digits\n    int m = getMax(arr, n); \n\n    // Do counting sort for every digit\n    // exp is 10^i where i is the current \n    // digit number\n    for (int exp = 1; m / exp > 0; exp *= 10)\n        countSort(arr, n, exp);\n}\n\n// A utility function to print an array\nvoid printArray(int arr[], int n) {\n    for (int i = 0; i < n; i++)\n        printf(\"%d \", arr[i]);\n    printf(\"\\n\");\n}\n\n// Driver code\nint main() {\n    int arr[] = {170, 45, 75, 90, 802, 24, 2, 66};\n    int n = sizeof(arr) / sizeof(arr[0]);\n\n    // Function call\n    radixSort(arr, n);\n    printArray(arr, n);\n    return 0;\n}\n// Radix sort Java implementation\n\nimport java.io.*;\nimport java.util.*;\n\nclass Radix {\n\n    // A utility function to get maximum value in arr[]\n    static int getMax(int arr[], int n)\n    {\n        int mx = arr[0];\n        for (int i = 1; i < n; i++)\n            if (arr[i] > mx)\n                mx = arr[i];\n        return mx;\n    }\n\n    // A function to do counting sort of arr[] according to\n    // the digit represented by exp.\n    static void countSort(int arr[], int n, int exp)\n    {\n        int output[] = new int[n]; // output array\n        int i;\n        int count[] = new int[10];\n        Arrays.fill(count, 0);\n\n        // Store count of occurrences in count[]\n        for (i = 0; i < n; i++)\n            count[(arr[i] / exp) % 10]++;\n\n        // Change count[i] so that count[i] now contains\n        // actual position of this digit in output[]\n        for (i = 1; i < 10; i++)\n            count[i] += count[i - 1];\n\n        // Build the output array\n        for (i = n - 1; i >= 0; i--) {\n            output[count[(arr[i] / exp) % 10] - 1] = arr[i];\n            count[(arr[i] / exp) % 10]--;\n        }\n\n        // Copy the output array to arr[], so that arr[] now\n        // contains sorted numbers according to current\n        // digit\n        for (i = 0; i < n; i++)\n            arr[i] = output[i];\n    }\n\n    // The main function to that sorts arr[] of\n    // size n using Radix Sort\n    static void radixsort(int arr[], int n)\n    {\n        // Find the maximum number to know number of digits\n        int m = getMax(arr, n);\n\n        // Do counting sort for every digit. Note that\n        // instead of passing digit number, exp is passed.\n        // exp is 10^i where i is current digit number\n        for (int exp = 1; m / exp > 0; exp *= 10)\n            countSort(arr, n, exp);\n    }\n\n    // A utility function to print an array\n    static void print(int arr[], int n)\n    {\n        for (int i = 0; i < n; i++)\n            System.out.print(arr[i] + \" \");\n    }\n\n    // Main driver method\n    public static void main(String[] args)\n    {\n        int arr[] = { 170, 45, 75, 90, 802, 24, 2, 66 };\n        int n = arr.length;\n\n        // Function Call\n        radixsort(arr, n);\n        print(arr, n);\n    }\n}\n# Python program for implementation of Radix Sort\n# A function to do counting sort of arr[] according to\n# the digit represented by exp.\n\n\ndef countingSort(arr, exp1):\n\n    n = len(arr)\n\n    # The output array elements that will have sorted arr\n    output = [0] * (n)\n\n    # initialize count array as 0\n    count = [0] * (10)\n\n    # Store count of occurrences in count[]\n    for i in range(0, n):\n        index = arr[i] // exp1\n        count[index % 10] += 1\n\n    # Change count[i] so that count[i] now contains actual\n    # position of this digit in output array\n    for i in range(1, 10):\n        count[i] += count[i - 1]\n\n    # Build the output array\n    i = n - 1\n    while i >= 0:\n        index = arr[i] // exp1\n        output[count[index % 10] - 1] = arr[i]\n        count[index % 10] -= 1\n        i -= 1\n\n    # Copying the output array to arr[],\n    # so that arr now contains sorted numbers\n    i = 0\n    for i in range(0, len(arr)):\n        arr[i] = output[i]\n\n# Method to do Radix Sort\n\n\ndef radixSort(arr):\n\n    # Find the maximum number to know number of digits\n    max1 = max(arr)\n\n    # Do counting sort for every digit. Note that instead\n    # of passing digit number, exp is passed. exp is 10^i\n    # where i is current digit number\n    exp = 1\n    while max1 / exp >= 1:\n        countingSort(arr, exp)\n        exp *= 10\n\n\n# Driver code\narr = [170, 45, 75, 90, 802, 24, 2, 66]\n\n# Function Call\nradixSort(arr)\n\nfor i in range(len(arr)):\n    print(arr[i], end=\" \")\n\n# This code is contributed by Mohit Kumra\n# Edited by Patrick Gallagher\n// C# implementation of Radix Sort\nusing System;\n\nclass GFG {\n    public static int getMax(int[] arr, int n)\n    {\n        int mx = arr[0];\n        for (int i = 1; i < n; i++)\n            if (arr[i] > mx)\n                mx = arr[i];\n        return mx;\n    }\n\n    // A function to do counting sort of arr[] according to\n    // the digit represented by exp.\n    public static void countSort(int[] arr, int n, int exp)\n    {\n        int[] output = new int[n]; // output array\n        int i;\n        int[] count = new int[10];\n\n        // initializing all elements of count to 0\n        for (i = 0; i < 10; i++)\n            count[i] = 0;\n\n        // Store count of occurrences in count[]\n        for (i = 0; i < n; i++)\n            count[(arr[i] / exp) % 10]++;\n\n        // Change count[i] so that count[i] now contains\n        // actual\n        //  position of this digit in output[]\n        for (i = 1; i < 10; i++)\n            count[i] += count[i - 1];\n\n        // Build the output array\n        for (i = n - 1; i >= 0; i--) {\n            output[count[(arr[i] / exp) % 10] - 1] = arr[i];\n            count[(arr[i] / exp) % 10]--;\n        }\n\n        // Copy the output array to arr[], so that arr[] now\n        // contains sorted numbers according to current\n        // digit\n        for (i = 0; i < n; i++)\n            arr[i] = output[i];\n    }\n\n    // The main function to that sorts arr[] of size n using\n    // Radix Sort\n    public static void radixsort(int[] arr, int n)\n    {\n        // Find the maximum number to know number of digits\n        int m = getMax(arr, n);\n\n        // Do counting sort for every digit. Note that\n        // instead of passing digit number, exp is passed.\n        // exp is 10^i where i is current digit number\n        for (int exp = 1; m / exp > 0; exp *= 10)\n            countSort(arr, n, exp);\n    }\n\n    // A utility function to print an array\n    public static void print(int[] arr, int n)\n    {\n        for (int i = 0; i < n; i++)\n            Console.Write(arr[i] + \" \");\n    }\n\n    // Driver Code\n    public static void Main()\n    {\n        int[] arr = { 170, 45, 75, 90, 802, 24, 2, 66 };\n        int n = arr.Length;\n\n        // Function Call\n        radixsort(arr, n);\n        print(arr, n);\n    }\n\n    // This code is contributed by DrRoot_\n}\n// Radix sort JavaScript implementation\n\n\"use strict\";\n\n// A utility function to get maximum value in arr[]\nfunction getMax(arr) {\n  const length = arr.length;\n  let mx = arr[0];\n  for (let i = 1; i < length; i++) {\n    if (arr[i] > mx) mx = arr[i];\n  }\n  return mx;\n}\n\n// A function to do counting sort of arr[] according to\n// the digit represented by exp.\nfunction countSort(arr, exp) {\n  const length = arr.length;\n  let output = Array(length); // output array\n  let count = Array(10).fill(0, 0);\n\n  // Store count of occurrences in count[]\n  for (let i = 0; i < length; i++) {\n    const digit = Math.floor(arr[i] / exp) % 10;\n    count[digit]++;\n  }\n\n  // Change count[i] so that count[i] now contains\n  // actual position of this digit in output[]\n  for (let i = 1; i < 10; i++) {\n    count[i] += count[i - 1];\n  }\n\n  // Build the output array\n  for (let i = length - 1; i >= 0; i--) {\n    const digit = Math.floor(arr[i] / exp) % 10;\n    output[count[digit] - 1] = arr[i];\n    count[digit]--;\n  }\n\n  return output;\n}\n\n// The main function to that sorts arr[] using Radix Sort\nfunction radixSort(arr) {\n  // Find the maximum number to know number of digits\n  const maxNumber = getMax(arr);\n  // Create a shallow copy where the sorted values will be kept\n  let sortedArr = [...arr];\n\n  // Do counting sort for every digit. Note that\n  // instead of passing digit number, exp is passed.\n  // exp is 10^i where i is current digit number\n  for (let exp = 1; Math.floor(maxNumber / exp) > 0; exp *= 10) {\n    // Get the Count sort iteration\n    const sortedIteration = countSort(sortedArr, exp);\n    sortedArr = sortedIteration;\n  }\n\n  return sortedArr;\n}\n\n/*Driver Code*/\nconst arr = [170, 45, 75, 90, 802, 24, 2, 66];\n\n// Function Call\nconst sortedArr = radixSort(arr);\n\nconsole.log(sortedArr.join(\" \"));\n\n// This code is contributed by beeduhboodee\n<?php\n// PHP implementation of Radix Sort \n\n\n// A function to do counting sort of arr[] \n// according to the digit represented by exp. \nfunction countSort(&$arr, $n, $exp) \n{ \n    $output = array_fill(0, $n, 0); // output array \n    $count = array_fill(0, 10, 0); \n\n    // Store count of occurrences in count[] \n    for ($i = 0; $i < $n; $i++) \n        $count[ ($arr[$i] / $exp) % 10 ]++; \n\n    // Change count[i] so that count[i] \n    // now contains actual position of \n    // this digit in output[] \n    for ($i = 1; $i < 10; $i++) \n        $count[$i] += $count[$i - 1]; \n\n    // Build the output array \n    for ($i = $n - 1; $i >= 0; $i--) \n    { \n        $output[$count[ ($arr[$i] / \n                         $exp) % 10 ] - 1] = $arr[$i]; \n        $count[ ($arr[$i] / $exp) % 10 ]--; \n    } \n\n    // Copy the output array to arr[], so \n    // that arr[] now contains sorted numbers\n    // according to current digit \n    for ($i = 0; $i < $n; $i++) \n        $arr[$i] = $output[$i]; \n} \n\n// The main function to that sorts arr[] \n// of size n using Radix Sort \nfunction radixsort(&$arr, $n) \n{ \n    \n    // Find the maximum number to know\n    // number of digits \n    $m = max($arr); \n\n    // Do counting sort for every digit. Note \n    // that instead of passing digit number, \n    // exp is passed. exp is 10^i where i is \n    // current digit number \n    for ($exp = 1; $m / $exp > 0; $exp *= 10) \n        countSort($arr, $n, $exp); \n} \n\n// A utility function to print an array \nfunction PrintArray(&$arr,$n) \n{ \n    for ($i = 0; $i < $n; $i++) \n        echo $arr[$i] . \" \"; \n} \n\n// Driver Code \n$arr = array(170, 45, 75, 90, 802, 24, 2, 66); \n$n = count($arr); \n\n// Function Call\nradixsort($arr, $n); \nPrintArray($arr, $n); \n\n// This code is contributed by rathbhupendra\n?>\n// Radix sort Dart implementation\n\n/// A utility function to get the maximum value of a `List<int>` [array]\nint getMax(List<int> array) {\n  int max = array[0];\n\n  for (final it in array) {\n    if (it > max) {\n      max = it;\n    }\n  }\n\n  return max;\n}\n\n/// A function to do counting sort of `List<int>` [array] according to the\n/// digit represented by [exp].\nList<int> countSort(List<int> array, int exp) {\n  final length = array.length;\n  final outputArr = List.filled(length, 0);\n  // A list where index represents the digit and value represents the count of\n  // occurrences\n  final digitsCount = List.filled(10, 0);\n\n  // Store count of occurrences in digitsCount[]\n  for (final item in array) {\n    final digit = item ~/ exp % 10;\n    digitsCount[digit]++;\n  }\n\n  // Change digitsCount[i] so that digitsCount[i] now contains actual position\n  // of this digit in outputArr[]\n  for (int i = 1; i < 10; i++) {\n    digitsCount[i] += digitsCount[i - 1];\n  }\n\n  // Build the output array\n  for (int i = length - 1; i >= 0; i--) {\n    final item = array[i];\n    final digit = item ~/ exp % 10;\n    outputArr[digitsCount[digit] - 1] = item;\n    digitsCount[digit]--;\n  }\n\n  return outputArr;\n}\n\n/// The main function to that sorts a `List<int>` [array] using Radix sort\nList<int> radixSort(List<int> array) {\n  // Find the maximum number to know number of digits\n  final maxNumber = getMax(array);\n  // Shallow copy of the input array\n  final sortedArr = List.of(array);\n\n  // Do counting sort for every digit. Note that instead of passing digit\n  // number, exp is passed. exp is 10^i, where i is current digit number\n  for (int exp = 1; maxNumber ~/ exp > 0; exp *= 10) {\n    final sortedIteration = countSort(sortedArr, exp);\n    sortedArr.clear();\n    sortedArr.addAll(sortedIteration);\n  }\n\n  return sortedArr;\n}\n\nvoid main() {\n  const array = [170, 45, 75, 90, 802, 24, 2, 66];\n\n  final sortedArray = radixSort(array);\n\n  print(sortedArray);\n}\n\n// This code is contributed by beeduhboodee\n2 24 45 66 75 90 170 802\n",
        "complexity": {
            "time": "Time Complexity:",
            "space": ""
        },
        "tags": [
            "Sorting"
        ],
        "url": "https://www.geeksforgeeks.org/radix-sort/"
    },
    {
        "title": "Shell Sort",
        "description": "Shell sort is mainly a variation of Insertion Sort. In insertion sort, we move elements only one position ahead. When an element has to be moved far ahead, many movements are involved. The idea of ShellSort is to allow the exchange of far items. In Shell sort, we make the array h-sorted for a large value of h. We keep reducing the value of h until it becomes 1. An array is said to be h-sorted if all sublists of every h’th element are sorted. Algorithm: Step 1 − StartStep 2 − Initialize the value of gap size, say h.Step 3 − Divide the list into smaller sub-part. Each must have equal intervals to h.Step 4 − Sort these sub-lists using insertion sort.Step 5 – Repeat this step 2 until the list is sorted.Step 6 – Print a sorted list.Step 7 – Stop. Following is the implementation of ShellSort. Time Complexity: Time complexity of the above implementation of Shell sort is O(n2). In the above implementation, the gap is reduced by half in every iteration. There are many other ways to reduce gaps which leads to better time complexity. See this for more details. Worst Case ComplexityThe worst-case complexity for shell sort is O(n2)Best Case ComplexityWhen the given array list is already sorted the total count of comparisons of each interval is equal to the size of the given array.So best case complexity is Ω(n log(n))Average Case ComplexityThe Average Case Complexity: O(n*log n)~O(n1.25)Space ComplexityThe space complexity of the shell sort is O(1). 1. Which is more efficient shell or heap sort? Ans. As per big-O notation, shell sort has O(n^{1.25}) average time complexity whereas, heap sort has O(N log N) time complexity. According to a strict mathematical interpretation of the big-O notation, heap sort surpasses shell sort in efficiency as we approach 2000 elements to be sorted.Note:- Big-O is a rounded approximation and analytical evaluation is not always 100% correct, it depends on the algorithms’ implementation which can affect actual run time. Shell Sort Applications 1. Replacement for insertion sort, where it takes a long time to complete a given task.2. To call stack overhead we use shell sort.3. when recursion exceeds a particular limit we use shell sort.4. For medium to large-sized datasets.5. In insertion sort to reduce the number of operations. References: http://en.wikipedia.org/wiki/Shellsort Snapshots:            Other Sorting Algorithms on GeeksforGeeks/GeeksQuiz:  ",
        "code": "// C++ implementation of Shell Sort\n#include  <iostream>\nusing namespace std;\n\n/* function to sort arr using shellSort */\nint shellSort(int arr[], int n)\n{\n    // Start with a big gap, then reduce the gap\n    for (int gap = n/2; gap > 0; gap /= 2)\n    {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is\n        // gap sorted \n        for (int i = gap; i < n; i += 1)\n        {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            int temp = arr[i];\n\n            // shift earlier gap-sorted elements up until the correct \n            // location for a[i] is found\n            int j;            \n            for (j = i; j >= gap && arr[j - gap] > temp; j -= gap)\n                arr[j] = arr[j - gap];\n            \n            //  put temp (the original a[i]) in its correct location\n            arr[j] = temp;\n        }\n    }\n    return 0;\n}\n\nvoid printArray(int arr[], int n)\n{\n    for (int i=0; i<n; i++)\n        cout << arr[i] << \" \";\n}\n\nint main()\n{\n    int arr[] = {12, 34, 54, 2, 3}, i;\n    int n = sizeof(arr)/sizeof(arr[0]);\n\n    cout << \"Array before sorting: \\n\";\n    printArray(arr, n);\n\n    shellSort(arr, n);\n\n    cout << \"\\nArray after sorting: \\n\";\n    printArray(arr, n);\n\n    return 0;\n}\n// Java implementation of ShellSort\nclass ShellSort\n{\n    /* An utility function to print array of size n*/\n    static void printArray(int arr[])\n    {\n        int n = arr.length;\n        for (int i=0; i<n; ++i)\n            System.out.print(arr[i] + \" \");\n        System.out.println();\n    }\n\n    /* function to sort arr using shellSort */\n    int sort(int arr[])\n    {\n        int n = arr.length;\n\n        // Start with a big gap, then reduce the gap\n        for (int gap = n/2; gap > 0; gap /= 2)\n        {\n            // Do a gapped insertion sort for this gap size.\n            // The first gap elements a[0..gap-1] are already\n            // in gapped order keep adding one more element\n            // until the entire array is gap sorted\n            for (int i = gap; i < n; i += 1)\n            {\n                // add a[i] to the elements that have been gap\n                // sorted save a[i] in temp and make a hole at\n                // position i\n                int temp = arr[i];\n\n                // shift earlier gap-sorted elements up until\n                // the correct location for a[i] is found\n                int j;\n                for (j = i; j >= gap && arr[j - gap] > temp; j -= gap)\n                    arr[j] = arr[j - gap];\n\n                // put temp (the original a[i]) in its correct\n                // location\n                arr[j] = temp;\n            }\n        }\n        return 0;\n    }\n\n    // Driver method\n    public static void main(String args[])\n    {\n        int arr[] = {12, 34, 54, 2, 3};\n        System.out.println(\"Array before sorting\");\n        printArray(arr);\n\n        ShellSort ob = new ShellSort();\n        ob.sort(arr);\n\n        System.out.println(\"Array after sorting\");\n        printArray(arr);\n    }\n} \n/*This code is contributed by Rajat Mishra */\n# Python implementation of ShellSort\nclass ShellSort:\n    # An utility function to print array of size n\n    @staticmethod\n    def print_array(arr):\n        for i in arr:\n            print(i, end=\" \")\n        print()\n\n    # Function to sort arr using ShellSort\n    def sort(self, arr):\n        n = len(arr)\n\n        # Start with a big gap, then reduce the gap\n        gap = n // 2\n        while gap > 0:\n            # Do a gapped insertion sort for this gap size.\n            # The first gap elements arr[0..gap-1] are already\n            # in gapped order keep adding one more element\n            # until the entire array is gap sorted\n            for i in range(gap, n):\n                temp = arr[i]\n                j = i\n                while j >= gap and arr[j - gap] > temp:\n                    arr[j] = arr[j - gap]\n                    j -= gap\n                arr[j] = temp\n\n            gap //= 2\n        return 0\n\n# Driver code\nif __name__ == \"__main__\":\n    arr = [12, 34, 54, 2, 3]\n    print(\"Array before sorting:\")\n    ShellSort.print_array(arr)\n\n    ob = ShellSort()\n    ob.sort(arr)\n\n    print(\"Array after sorting:\")\n    ShellSort.print_array(arr)\n// C# implementation of ShellSort\nusing System;\n\nclass ShellSort\n{\n    /* An utility function to \n       print array of size n*/\n    static void printArray(int []arr)\n    {\n        int n = arr.Length;\n        for (int i=0; i<n; ++i)\n        Console.Write(arr[i] + \" \");\n        Console.WriteLine();\n    }\n\n    /* function to sort arr using shellSort */\n    int sort(int []arr)\n    {\n        int n = arr.Length;\n\n        // Start with a big gap, \n        // then reduce the gap\n        for (int gap = n/2; gap > 0; gap /= 2)\n        {\n            // Do a gapped insertion sort for this gap size.\n            // The first gap elements a[0..gap-1] are already\n            // in gapped order keep adding one more element\n            // until the entire array is gap sorted\n            for (int i = gap; i < n; i += 1)\n            {\n                // add a[i] to the elements that have\n                // been gap sorted save a[i] in temp and\n                // make a hole at position i\n                int temp = arr[i];\n\n                // shift earlier gap-sorted elements up until\n                // the correct location for a[i] is found\n                int j;\n                for (j = i; j >= gap && arr[j - gap] > temp; j -= gap)\n                    arr[j] = arr[j - gap];\n\n                // put temp (the original a[i]) \n                // in its correct location\n                arr[j] = temp;\n            }\n        }\n        return 0;\n    }\n\n    // Driver method\n    public static void Main()\n    {\n        int []arr = {12, 34, 54, 2, 3};\n        Console.Write(\"Array before sorting :\\n\");\n        printArray(arr);\n\n        ShellSort ob = new ShellSort();\n        ob.sort(arr);\n\n        Console.Write(\"Array after sorting :\\n\");\n        printArray(arr);\n    }\n} \n\n// This code is contributed by nitin mittal.\n// JavaScript implementation of ShellSort\nclass ShellSort {\n    // Utility function to print the array\n    static printArray(arr) {\n        console.log(arr.join(\" \"));\n    }\n\n    // Function to sort the array using ShellSort\n    sort(arr) {\n        let n = arr.length;\n\n        // Start with a big gap, then reduce the gap\n        for (let gap = Math.floor(n / 2); gap > 0; gap = Math.floor(gap / 2)) {\n            // Do a gapped insertion sort for this gap size.\n            for (let i = gap; i < n; i++) {\n                let temp = arr[i];\n                let j = i;\n                while (j >= gap && arr[j - gap] > temp) {\n                    arr[j] = arr[j - gap];\n                    j -= gap;\n                }\n                arr[j] = temp;\n            }\n        }\n    }\n}\n\n// Driver code\nlet arr = [12, 34, 54, 2, 3];\nconsole.log(\"Array before sorting:\");\nShellSort.printArray(arr);\n\nlet ob = new ShellSort();\nob.sort(arr);\n\nconsole.log(\"Array after sorting:\");\nShellSort.printArray(arr);\nArray before sorting: \n12 34 54 2 3 \nArray after sorting: \n2 3 12 34 54\n",
        "complexity": {
            "time": "Ans. As per big-O notation, shell sort has O(n^{1.25}) average time complexity whereas, heap sort has O(N log N) time complexity. According to a strict mathematical interpretation of the big-O notation, heap sort surpasses shell sort in efficiency as we approach 2000 elements to be sorted.Note:- Big-O is a rounded approximation and analytical evaluation is not always 100% correct, it depends on the algorithms’ implementation which can affect actual run time.",
            "space": "Worst Case ComplexityThe worst-case complexity for shell sort is O(n2)Best Case ComplexityWhen the given array list is already sorted the total count of comparisons of each interval is equal to the size of the given array.So best case complexity is Ω(n log(n))Average Case ComplexityThe Average Case Complexity: O(n*log n)~O(n1.25)Space ComplexityThe space complexity of the shell sort is O(1)."
        },
        "tags": [
            "Sorting"
        ],
        "url": "https://www.geeksforgeeks.org/shell-sort/"
    },
    {
        "title": "Counting Sort – Data Structures and Algorithms Tutorials",
        "description": "Counting Sort is a non-comparison-based sorting algorithm. It is particularly efficient when the range of input values is small compared to the number of elements to be sorted. The basic idea behind Counting Sort is to count the frequency of each distinct element in the input array and use that information to place the elements in their correct sorted positions. Step1 :  Step 2:  Step 3:  Step 4:  Step 5:  Step 6: For i = 6, Update outputArray[ countArray[ inputArray[6] ] – 1] = inputArray[6]Also, update countArray[ inputArray[6] ]  = countArray[ inputArray[6] ]- –  Step 7: For i = 5, Update outputArray[ countArray[ inputArray[5] ] – 1] = inputArray[5]Also, update countArray[ inputArray[5] ]  = countArray[ inputArray[5] ]- –  Step 8: For i = 4, Update outputArray[ countArray[ inputArray[4] ] – 1] = inputArray[4]Also, update countArray[ inputArray[4] ]  = countArray[ inputArray[4] ]- –  Step 9: For i = 3, Update outputArray[ countArray[ inputArray[3] ] – 1] = inputArray[3]Also, update countArray[ inputArray[3] ]  = countArray[ inputArray[3] ]- –  Step 10: For i = 2, Update outputArray[ countArray[ inputArray[2] ] – 1] = inputArray[2]Also, update countArray[ inputArray[2] ]  = countArray[ inputArray[2] ]- –  Step 11: For i = 1, Update outputArray[ countArray[ inputArray[1] ] – 1] = inputArray[1]Also, update countArray[ inputArray[1] ]  = countArray[ inputArray[1] ]- –  Step 12: For i = 0, Update outputArray[ countArray[ inputArray[0] ] – 1] = inputArray[0]Also, update countArray[ inputArray[0] ]  = countArray[ inputArray[0] ]- –  Below is the implementation of the above algorithm:  ",
        "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> countSort(vector<int>& inputArray)\n{\n\n    int N = inputArray.size();\n\n    // Finding the maximum element of array inputArray[].\n    int M = 0;\n\n    for (int i = 0; i < N; i++)\n        M = max(M, inputArray[i]);\n\n    // Initializing countArray[] with 0\n    vector<int> countArray(M + 1, 0);\n\n    // Mapping each element of inputArray[] as an index\n    // of countArray[] array\n\n    for (int i = 0; i < N; i++)\n        countArray[inputArray[i]]++;\n\n    // Calculating prefix sum at every index\n    // of array countArray[]\n    for (int i = 1; i <= M; i++)\n        countArray[i] += countArray[i - 1];\n\n    // Creating outputArray[] from countArray[] array\n    vector<int> outputArray(N);\n\n    for (int i = N - 1; i >= 0; i--)\n\n    {\n        outputArray[countArray[inputArray[i]] - 1]\n            = inputArray[i];\n\n        countArray[inputArray[i]]--;\n    }\n\n    return outputArray;\n}\n\n// Driver code\nint main()\n\n{\n\n    // Input array\n    vector<int> inputArray = { 4, 3, 12, 1, 5, 5, 3, 9 };\n\n    // Output array\n    vector<int> outputArray = countSort(inputArray);\n\n    for (int i = 0; i < inputArray.size(); i++)\n        cout << outputArray[i] << \" \";\n\n    return 0;\n}\n#include <stdio.h>\n#include <stdlib.h>\n\nvoid countSort(int inputArray[], int N) {\n  \n    // Finding the maximum element of \n    // array inputArray[]\n    int M = 0;\n    for (int i = 0; i < N; i++)\n        if (inputArray[i] > M)\n            M = inputArray[i];\n    \n    // Initializing countArray[] with 0\n    int* countArray = (int*)calloc(M + 1, sizeof(int));\n    \n    // Mapping each element of inputArray[] \n    // as an index of countArray[] array\n    for (int i = 0; i < N; i++)\n        countArray[inputArray[i]]++;\n    \n    // Calculating prefix sum at every index\n    // of array countArray[]\n    for (int i = 1; i <= M; i++)\n        countArray[i] += countArray[i - 1];\n    \n    // Creating outputArray[] from countArray[] array\n    int* outputArray = (int*)malloc(N * sizeof(int));\n    for (int i = N - 1; i >= 0; i--) {\n        outputArray[countArray[inputArray[i]] - 1] = inputArray[i];\n        countArray[inputArray[i]]--;\n    }\n    \n    // Copying sorted elements back to inputArray[]\n    for (int i = 0; i < N; i++)\n        inputArray[i] = outputArray[i];\n    \n    // Freeing dynamically allocated memory\n    free(countArray);\n    free(outputArray);\n}\n\n// Driver code\nint main() {\n  \n    // Input array\n    int inputArray[] = {4, 3, 12, 1, 5, 5, 3, 9};\n    int N = sizeof(inputArray) / sizeof(inputArray[0]);\n    \n    // Sorting the array\n    countSort(inputArray, N);\n    \n    // Printing the sorted array\n    for (int i = 0; i < N; i++)\n        printf(\"%d \", inputArray[i]);\n    \n    return 0;\n}\nimport java.util.Arrays;\n\npublic class CountSort {\n    public static int[] countSort(int[] inputArray) {\n        int N = inputArray.length;\n        int M = 0;\n\n        for (int i = 0; i < N; i++) {\n            M = Math.max(M, inputArray[i]);\n        }\n\n        int[] countArray = new int[M + 1];\n\n        for (int i = 0; i < N; i++) {\n            countArray[inputArray[i]]++;\n        }\n\n        for (int i = 1; i <= M; i++) {\n            countArray[i] += countArray[i - 1];\n        }\n\n        int[] outputArray = new int[N];\n\n        for (int i = N - 1; i >= 0; i--) {\n            outputArray[countArray[inputArray[i]] - 1] = inputArray[i];\n            countArray[inputArray[i]]--;\n        }\n\n        return outputArray;\n    }\n\n    public static void main(String[] args) {\n        int[] inputArray = {4, 3, 12, 1, 5, 5, 3, 9};\n        int[] outputArray = countSort(inputArray);\n\n        for (int i = 0; i < inputArray.length; i++) {\n            System.out.print(outputArray[i] + \" \");\n        }\n    }\n}\ndef count_sort(input_array):\n    # Finding the maximum element of input_array.\n    M = max(input_array)\n\n    # Initializing count_array with 0\n    count_array = [0] * (M + 1)\n\n    # Mapping each element of input_array as an index of count_array\n    for num in input_array:\n        count_array[num] += 1\n\n    # Calculating prefix sum at every index of count_array\n    for i in range(1, M + 1):\n        count_array[i] += count_array[i - 1]\n\n    # Creating output_array from count_array\n    output_array = [0] * len(input_array)\n\n    for i in range(len(input_array) - 1, -1, -1):\n        output_array[count_array[input_array[i]] - 1] = input_array[i]\n        count_array[input_array[i]] -= 1\n\n    return output_array\n\n# Driver code\nif __name__ == \"__main__\":\n    # Input array\n    input_array = [4, 3, 12, 1, 5, 5, 3, 9]\n\n    # Output array\n    output_array = count_sort(input_array)\n\n    for num in output_array:\n        print(num, end=\" \")\nusing System;\nusing System.Collections.Generic;\n\nclass GFG\n{\n    static List<int> CountSort(List<int> inputArray)\n    {\n        int N = inputArray.Count;\n        // Finding the maximum element of the array inputArray[].\n        int M = 0;\n        for (int i = 0; i < N; i++)\n            M = Math.Max(M, inputArray[i]);\n        // Initializing countArray[] with 0\n        List<int> countArray = new List<int>(new int[M + 1]);\n        // Mapping each element of inputArray[] as an index\n        // of countArray[] array\n        for (int i = 0; i < N; i++)\n            countArray[inputArray[i]]++;\n        // Calculating prefix sum at every index\n        // of array countArray[]\n        for (int i = 1; i <= M; i++)\n            countArray[i] += countArray[i - 1];\n        // Creating outputArray[] from the countArray[] array\n        List<int> outputArray = new List<int>(new int[N]);\n        for (int i = N - 1; i >= 0; i--)\n        {\n            outputArray[countArray[inputArray[i]] - 1] = inputArray[i];\n            countArray[inputArray[i]]--;\n        }\n        return outputArray;\n    }\n    // Driver code\n    static void Main()\n    {\n        // Input array\n        List<int> inputArray = new List<int> { 4, 3, 12, 1, 5, 5, 3, 9 };\n        // Output array\n        List<int> outputArray = CountSort(inputArray);\n        for (int i = 0; i < inputArray.Count; i++)\n            Console.Write(outputArray[i] + \" \");\n        Console.WriteLine();\n    }\n}\nfunction countSort(inputArray) {\n    const N = inputArray.length;\n\n    // Finding the maximum element of inputArray\n    let M = 0;\n    for (let i = 0; i < N; i++) {\n        M = Math.max(M, inputArray[i]);\n    }\n\n    // Initializing countArray with 0\n    const countArray = new Array(M + 1).fill(0);\n\n    // Mapping each element of inputArray as an index of countArray\n    for (let i = 0; i < N; i++) {\n        countArray[inputArray[i]]++;\n    }\n\n    // Calculating prefix sum at every index of countArray\n    for (let i = 1; i <= M; i++) {\n        countArray[i] += countArray[i - 1];\n    }\n\n    // Creating outputArray from countArray\n    const outputArray = new Array(N);\n    for (let i = N - 1; i >= 0; i--) {\n        outputArray[countArray[inputArray[i]] - 1] = inputArray[i];\n        countArray[inputArray[i]]--;\n    }\n\n    return outputArray;\n}\n\n// Driver code\nconst inputArray = [4, 3, 12, 1, 5, 5, 3, 9];\n\n// Sorting the input array\nconst outputArray = countSort(inputArray);\n\n// Printing the sorted array\nconsole.log(outputArray.join(' '));\n//This code is contributed by Utkarsh\n1 3 3 4 5 5 9 12\n",
        "complexity": {
            "time": "",
            "space": ""
        },
        "tags": [
            "Sorting"
        ],
        "url": "https://www.geeksforgeeks.org/counting-sort/"
    },
    {
        "title": "Bucket Sort – Data Structures and Algorithms Tutorials",
        "description": "Bucket sort is a sorting technique that involves dividing elements into various groups, or buckets. These buckets are formed by uniformly distributing the elements. Once the elements are divided into buckets, they can be sorted using any other sorting algorithm. Finally, the sorted elements are gathered together in an ordered fashion. Create n empty buckets (Or lists) and do the following for every array element arr[i]. To apply bucket sort on the input array [0.78, 0.17, 0.39, 0.26, 0.72, 0.94, 0.21, 0.12, 0.23, 0.68], we follow these steps: Step 1: Create an array of size 10, where each slot represents a bucket. Creating Buckets for sorting Step 2: Insert elements into the buckets from the input array based on their range. Inserting elements into the buckets: Inserting Array elements into respective buckets Step 3: Sort the elements within each bucket. In this example, we use quicksort (or any stable sorting algorithm) to sort the elements within each bucket. Sorting the elements within each bucket: Sorting individual bucket Step 4: Gather the elements from each bucket and put them back into the original array. Gathering elements from each bucket: Inserting buckets in ascending order into the resultant array Step 5: The original array now contains the sorted elements. The final sorted array using bucket sort for the given input is [0.12, 0.17, 0.21, 0.23, 0.26, 0.39, 0.68, 0.72, 0.78, 0.94]. Return the Sorted Array Below is the implementation for the Bucket Sort: Worst Case Time Complexity: O(n2)  The worst case happens when one bucket gets all the elements. In this case, we will be running insertion sort on all items which will make the time complexity as O(n2).  We can reduce the worst case time complexity to O(n Log n) by using a O(n Log n) algorithm like Merge Sort or Heap Sort to sort the individual buckets, but that will improve the algorithm time for cases when buckets have small number of items as insertion sort works better for small arrays. Best Case Time Complexity : O(n + k)  The best case happens when every bucket gets equal number of elements. In this case every call to insertion sort will take constant time as the number of items in every bucket would be constant (Assuming that k is linearly proportional to n). Auxiliary Space: O(n+k)  ",
        "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n// Insertion sort function to sort individual buckets\nvoid insertionSort(vector<float>& bucket) {\n    for (int i = 1; i < bucket.size(); ++i) {\n        float key = bucket[i];\n        int j = i - 1;\n        while (j >= 0 && bucket[j] > key) {\n            bucket[j + 1] = bucket[j];\n            j--;\n        }\n        bucket[j + 1] = key;\n    }\n}\n\n// Function to sort arr[] of size n using bucket sort\nvoid bucketSort(float arr[], int n) {\n    // 1) Create n empty buckets\n    vector<float> b[n];\n\n    // 2) Put array elements in different buckets\n    for (int i = 0; i < n; i++) {\n        int bi = n * arr[i];\n        b[bi].push_back(arr[i]);\n    }\n\n    // 3) Sort individual buckets using insertion sort\n    for (int i = 0; i < n; i++) {\n        insertionSort(b[i]);\n    }\n\n    // 4) Concatenate all buckets into arr[]\n    int index = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < b[i].size(); j++) {\n            arr[index++] = b[i][j];\n        }\n    }\n}\n\n// Driver program to test above function\nint main() {\n    float arr[] = {0.897, 0.565, 0.656, 0.1234, 0.665, 0.3434};\n    int n = sizeof(arr) / sizeof(arr[0]);\n    bucketSort(arr, n);\n\n    cout << \"Sorted array is \\n\";\n    for (int i = 0; i < n; i++) {\n        cout << arr[i] << \" \";\n    }\n    return 0;\n}\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Main {\n    // Insertion sort function to sort individual buckets\n    public static void insertionSort(List<Float> bucket) {\n        for (int i = 1; i < bucket.size(); ++i) {\n            float key = bucket.get(i);\n            int j = i - 1;\n            while (j >= 0 && bucket.get(j) > key) {\n                bucket.set(j + 1, bucket.get(j));\n                j--;\n            }\n            bucket.set(j + 1, key);\n        }\n    }\n\n    // Function to sort arr[] of size n using bucket sort\n    public static void bucketSort(float[] arr) {\n        int n = arr.length;\n\n        // 1) Create n empty buckets\n        List<Float>[] buckets = new ArrayList[n];\n        for (int i = 0; i < n; i++) {\n            buckets[i] = new ArrayList<>();\n        }\n\n        // 2) Put array elements in different buckets\n        for (int i = 0; i < n; i++) {\n            int bi = (int) (n * arr[i]);\n            buckets[bi].add(arr[i]);\n        }\n\n        // 3) Sort individual buckets using insertion sort\n        for (int i = 0; i < n; i++) {\n            insertionSort(buckets[i]);\n        }\n\n        // 4) Concatenate all buckets into arr[]\n        int index = 0;\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < buckets[i].size(); j++) {\n                arr[index++] = buckets[i].get(j);\n            }\n        }\n    }\n\n    // Driver program to test above function\n    public static void main(String[] args) {\n        float[] arr = {0.897f, 0.565f, 0.656f, 0.1234f, 0.665f, 0.3434f};\n        bucketSort(arr);\n\n        System.out.println(\"Sorted array is:\");\n        for (float num : arr) {\n            System.out.print(num + \" \");\n        }\n    }\n}\ndef insertion_sort(bucket):\n    for i in range(1, len(bucket)):\n        key = bucket[i]\n        j = i - 1\n        while j >= 0 and bucket[j] > key:\n            bucket[j + 1] = bucket[j]\n            j -= 1\n        bucket[j + 1] = key\n\ndef bucket_sort(arr):\n    n = len(arr)\n    buckets = [[] for _ in range(n)]\n\n    # Put array elements in different buckets\n    for num in arr:\n        bi = int(n * num)\n        buckets[bi].append(num)\n\n    # Sort individual buckets using insertion sort\n    for bucket in buckets:\n        insertion_sort(bucket)\n\n    # Concatenate all buckets into arr[]\n    index = 0\n    for bucket in buckets:\n        for num in bucket:\n            arr[index] = num\n            index += 1\n\narr = [0.897, 0.565, 0.656, 0.1234, 0.665, 0.3434]\nbucket_sort(arr)\nprint(\"Sorted array is:\")\nprint(\" \".join(map(str, arr)))\nusing System;\nusing System.Collections.Generic;\n\nclass Program\n{\n    // Insertion sort function to sort individual buckets\n    static void InsertionSort(List<float> bucket)\n    {\n        for (int i = 1; i < bucket.Count; ++i)\n        {\n            float key = bucket[i];\n            int j = i - 1;\n            while (j >= 0 && bucket[j] > key)\n            {\n                bucket[j + 1] = bucket[j];\n                j--;\n            }\n            bucket[j + 1] = key;\n        }\n    }\n\n    // Function to sort arr[] of size n using bucket sort\n    static void BucketSort(float[] arr)\n    {\n        int n = arr.Length;\n\n        // 1) Create n empty buckets\n        List<float>[] buckets = new List<float>[n];\n        for (int i = 0; i < n; i++)\n        {\n            buckets[i] = new List<float>();\n        }\n\n        // 2) Put array elements in different buckets\n        for (int i = 0; i < n; i++)\n        {\n            int bi = (int)(n * arr[i]);\n            buckets[bi].Add(arr[i]);\n        }\n\n        // 3) Sort individual buckets using insertion sort\n        for (int i = 0; i < n; i++)\n        {\n            InsertionSort(buckets[i]);\n        }\n\n        // 4) Concatenate all buckets into arr[]\n        int index = 0;\n        for (int i = 0; i < n; i++)\n        {\n            for (int j = 0; j < buckets[i].Count; j++)\n            {\n                arr[index++] = buckets[i][j];\n            }\n        }\n    }\n\n    // Driver program to test above function\n    static void Main(string[] args)\n    {\n        float[] arr = { 0.897f, 0.565f, 0.656f, 0.1234f, 0.665f, 0.3434f };\n        BucketSort(arr);\n\n        Console.WriteLine(\"Sorted array is:\");\n        foreach (float num in arr)\n        {\n            Console.Write(num + \" \");\n        }\n    }\n}\nfunction insertionSort(bucket) {\n    for (let i = 1; i < bucket.length; ++i) {\n        let key = bucket[i];\n        let j = i - 1;\n        while (j >= 0 && bucket[j] > key) {\n            bucket[j + 1] = bucket[j];\n            j--;\n        }\n        bucket[j + 1] = key;\n    }\n}\n\nfunction bucketSort(arr) {\n    let n = arr.length;\n    let buckets = Array.from({length: n}, () => []);\n\n    // Put array elements in different buckets\n    for (let i = 0; i < n; i++) {\n        let bi = Math.floor(n * arr[i]);\n        buckets[bi].push(arr[i]);\n    }\n\n    // Sort individual buckets using insertion sort\n    for (let i = 0; i < n; i++) {\n        insertionSort(buckets[i]);\n    }\n\n    // Concatenate all buckets into arr[]\n    let index = 0;\n    for (let i = 0; i < n; i++) {\n        for (let j = 0; j < buckets[i].length; j++) {\n            arr[index++] = buckets[i][j];\n        }\n    }\n}\n\nlet arr = [0.897, 0.565, 0.656, 0.1234, 0.665, 0.3434];\nbucketSort(arr);\nconsole.log(\"Sorted array is:\");\nconsole.log(arr.join(\" \"));\nSorted array is \n0.1234 0.3434 0.565 0.656 0.665 0.897\n",
        "complexity": {
            "time": "Best Case Time Complexity : O(n + k)  The best case happens when every bucket gets equal number of elements. In this case every call to insertion sort will take constant time as the number of items in every bucket would be constant (Assuming that k is linearly proportional to n).",
            "space": ""
        },
        "tags": [
            "Sorting"
        ],
        "url": "https://www.geeksforgeeks.org/bucket-sort-2/"
    },
    {
        "title": "TimSort – Data Structures and Algorithms Tutorials",
        "description": "Tim Sort is a hybrid sorting algorithm derived from merge sort and insertion sort. It was designed to perform well on many kinds of real-world data. Tim Sort is the default sorting algorithm used by Python’s sorted() and list.sort() functions. The main idea behind Tim Sort is to exploit the existing order in the data to minimize the number of comparisons and swaps. It achieves this by dividing the array into small subarrays called runs, which are already sorted, and then merging these runs using a modified merge sort algorithm. Let’s consider the following array as an example: arr[] = {4, 2, 8, 6, 1, 5, 9, 3, 7}. Step 1: Define the size of the run Step 2: Divide the array into runs Step 3: Merge the runs Step 4: Adjust the run size Step 5: Continue merging The final sorted array is [1, 2, 3, 4, 5, 6, 7, 8, 9]. Below is the implementation for the TimSort:                Complexity Analysis: Case Complexity Best Case O(n) Average Case O(n*log(n)) Worst Case O(n*log(n)) Space O(n) Stable YES Complexity Comparison with Merge and Quick Sort: Algorithm Time Complexity  Best Average Worst Quick Sort Ω(n*log(n)) θ(n*log(n)) O(n^2) Merge Sort Ω(n*log(n)) θ(n*log(n)) O(n*log(n)) Tim Sort Ω(n) θ(n*log(n)) O(n*log(n))  ",
        "code": "\n\n\n\n\n\n\n\n\n\nGiven Array is\r\n-2  7  15  -14  0  15  0  7  -7  -4  -13  5  8  -14  12  \r\nAfter Sorting Array is\r\n-14  -14  -13  -7  -4  -2  0  0  5  7  7  8  12  15  15\n",
        "complexity": {
            "time": "Time Complexity",
            "space": ""
        },
        "tags": [
            "Sorting"
        ],
        "url": "https://www.geeksforgeeks.org/timsort/"
    },
    {
        "title": "Bitonic Sort",
        "description": "Background Bitonic Sort is a classic parallel algorithm for sorting. To understand Bitonic Sort, we must first understand what is Bitonic Sequence and how to make a given sequence Bitonic. Bitonic Sequence A sequence is called Bitonic if it is first increasing, then decreasing. In other words, an array arr[0..n-i] is Bitonic if there exists an index I, where 0<=i<=n-1 such that How to form a Bitonic Sequence from a random input? We start by forming 4-element bitonic sequences the from consecutive 2-element sequences. Consider 4-element in sequence x0, x1, x2, x3. We sort x0 and x1 in ascending order and x2 and x3 in descending order. We then concatenate the two pairs to form a 4 element bitonic sequence. Next, we take two 4-element bitonic sequences, sorting one in ascending order, the other in descending order (using the Bitonic Sort which we will discuss below), and so on, until we obtain the bitonic sequence. Example: Convert the following sequence to a bitonic sequence: 3, 7, 4, 8, 6, 2, 1, 5 Step 1: Consider each 2-consecutive element as a bitonic sequence and apply bitonic sort on each 2- pair element. In the next step, take 4-element bitonic sequences and so on.  Note: x0 and x1 are sorted in ascending order and x2 and x3 in descending order and so on Step 2: Two 4 element bitonic sequences: A(3,7,8,4) and B(2,6,5,1) with comparator length as 2  After this step, we’ll get a Bitonic sequence of length 8. Bitonic Sorting Bitonic Sort Algorithm: It mainly involves two steps.  Below are implementations of Bitonic Sort.                Output: Analysis of Bitonic Sort To form a sorted sequence of length n from two sorted sequences of length n/2, log(n) comparisons are required. For example: log(8) = 3 when sequence size. Therefore, The number of comparisons T(n) of the entire sorting is given by: The solution of this recurrence equation is As each stage of the sorting network consists of n/2 comparators. Therefore total O(n log2n) comparators. Time complexity: Space Complexity: O(n.log2n) Stable: Yes Important Points:  R  ",
        "code": "x0 <= x1 …..<= xi  and  xi >= xi+1….. >= xn-1\n3, 4, 7, 8, 6, 5, 2, 1\n\n\n\n\n\n\n\n\n\n\nSorted array: 1 2 3 4 5 6 7 8\nT(n) = log(n) + T(n/2)\nT(n) = log(n) + log(n)-1 + log(n)-2 + ... + 1 = log(n) · (log(n)+1) / 2\n",
        "complexity": {
            "time": "Time complexity:",
            "space": "Space Complexity: O(n.log2n)"
        },
        "tags": [
            "Sorting"
        ],
        "url": "https://www.geeksforgeeks.org/bitonic-sort/"
    },
    {
        "title": "When to use each Sorting Algorithm",
        "description": "A sorting algorithm is an algorithm that makes the input data set arranged in a certain order. The fundamental task is to put the items in the desired order so that the records are re-arranged for making searching easier. Below is one by one description of when to use which sorting algorithm for better performance: This sorting algorithm sorts an array by repeatedly finding the minimum element (considering ascending order) from the unsorted part and putting it at the beginning. The algorithm maintains two subarrays in a given array, the subarray which is already sorted, and the remaining subarray which is unsorted. In every iteration of the selection sort, the minimum element (considering ascending order) from the unsorted subarray is picked and moved to the sorted subarray. We can use Selection Sort as per the below constraints: This sorting algorithm is the simplest sorting algorithm that works by repeatedly swapping the adjacent elements if they are in the wrong order. If we have total N elements, then we need to repeat the above process for N-1 times. We can use Bubble Sort as per the below constraints: This sorting algorithm is a simple sorting algorithm that works the way we sort playing cards in our hands. It places an unsorted element at its suitable place in each iteration. We can use Insertion Sort as per the below constraints: This sorting algorithm is based on the Divide and Conquer algorithm. It divides the input array into two halves, calls itself for the two halves, and then merges the two sorted halves. The merge() function is used for merging two halves. The merge(arr, l, m, r) is a key process that assumes that arr[l . . . m] and arr[m+1 . . . r] are sorted and merges the two sorted sub-arrays into one. We can use Merge Sort as per the below constraints: This sorting algorithm is also based on the Divide and Conquer algorithm. It picks an element as a pivot and partitions the given list around the picked pivot. After partitioning the list on the basis of the pivot element, the Quick is again applied recursively to two sublists i.e., the sublist to the left of the pivot element and the sublist to the right of the pivot element. We can use Quick Sort as per the below constraints: A  ",
        "code": "",
        "complexity": {
            "time": "",
            "space": ""
        },
        "tags": [
            "Sorting"
        ],
        "url": "https://www.geeksforgeeks.org/when-to-use-each-sorting-algorithms/"
    },
    {
        "title": "DSA Tutorial - Learn Data Structures and Algorithms",
        "description": "DSA (Data Structures and Algorithms)  is the study of organizing data efficiently using data structures like arrays, stacks, and trees, paired with step-by-step procedures (or algorithms) to solve problems effectively. Data structures manage how data is stored and accessed, while algorithms focus on processing this data. Hoping you have learned a programming language of your choice, here comes the next stage of the roadmap - Learn about Time and Space Complexities. Once you have learned basics of a programming language, it is recommended that you learn basic logic building To analyze algorithms, we mainly measure order of growth of time or space taken in terms of input size.  We do this in the worst case scenario in most of the cases. Please refer the below links for a clear understanding of these concepts. Array is a linear data structure where elements are allocated contiguous memory, allowing for constant-time access. Searching algorithms are used to locate specific data within a large set of data. It helps find a target value within the data. There are various types of searching algorithms, each with its own approach and efficiency. Sorting algorithms are used to arrange the elements of a list in a specific order, such as numerical or alphabetical. It organizes the items in a systematic way, making it easier to search for and access specific elements. Hashing is a technique that generates a fixed-size output (hash value) from an input of variable size using mathematical formulas called hash functions. Hashing is commonly used in data structures for efficient searching, insertion and deletion. In Two Pointer Technique, we typically use two index variables from two corners of an array. We use the two pointer technique for searching a required point or value in an array. In Window Sliding Technique, we use the result of previous subarray to quickly compute the result of current. In Prefix Sum Technique, we compute prefix sums of an array to quickly find results for a subarray. String is a sequence of characters, typically immutable and have limited set of elements (lower case or all English alphabets). Recursion is a programming technique where a function calls itself within its own definition. It is usually used to solve problems that can be broken down into smaller instances of the same problem. Matrix is a two-dimensional array of elements, arranged in rows and columns. It is represented as a rectangular grid, with each element at the intersection of a row and column. Linked list is a linear data structure that stores data in nodes, which are connected by pointers. Unlike arrays, nodes of linked lists are not stored in contiguous memory locations and can only be accessed sequentially, starting from the head of list. Stack is a linear data structure that follows the Last In, First Out (LIFO) principle. Stacks play an important role in managing function calls, memory, and are widely used in algorithms like stock span problem, next greater element and largest area in a histogram. Queue is a linear data structure that follows the First In, First Out (FIFO) principle. Queues play an important role in managing tasks or data in order, scheduling and message handling systems. A deque (double-ended queue) is a data structure that allows elements to be added or removed from both ends efficiently. Tree is a non-linear, hierarchical data structure consisting of nodes connected by edges, with a top node called the root and nodes having child nodes. It is widely used in file systems, databases, decision-making algorithms, etc. Heap is a complete binary tree data structure that satisfies the heap property. Heaps are usually used to implement priority queues, where the smallest or largest element is always at the root of the tree. Graph is a non-linear data structure consisting of a finite set of vertices(or nodes) and a set of edges(or links)that connect a pair of nodes. Graphs are widely used to represent relationships between entities. Greedy Algorithm builds up the solution one piece at a time and chooses the next piece which gives the most obvious and immediate benefit i.e., which is the most optimal choice at that moment. So the problems where choosing locally optimal also leads to the global solutions are best fit for Greedy. Dynamic Programming is a method used to solve complex problems by breaking them down into simpler subproblems. By solving each subproblem only once and storing the results, it avoids redundant computations, leading to more efficient solutions for a wide range of problems. Bitwise Algorithms: Operate on individual bits of numbers. Backtracking Algorithm : Follow Recursion  with the option to revert and traces back if the solution from current point is not feasible. Divide and conquer:  A strategy to solve problems by dividing them into smaller subproblems, solving those subproblems, and combining the solutions to obtain the final solution. Branch and Bound : Used in combinatorial optimization problems to systematically search for the best solution. It works by dividing the problem into smaller subproblems, or branches, and then eliminating certain branches based on bounds on the optimal solution. This process continues until the best solution is found or all branches have been explored. Geometric algorithms are a set of algorithms that solve problems related to shapes, points, lines and polygons. Randomized algorithms are algorithms that use randomness to solve problems. They make use of random input to achieve their goals, often leading to simpler and more efficient solutions. These algorithms may not product same result but are particularly useful in situations when a probabilistic approach is acceptable. Advanced Data Structures like Trie, Segment Tree, Red-Black Tree and Binary Indexed Tree offer significant performance improvements for specific problem domains. They provide efficient solutions for tasks like fast prefix searches, range queries, dynamic updates, and maintaining balanced data structures, which are crucial for handling large datasets and real-time processing. By optimizing time complexity, they enable better scalability and faster execution in many computational problems. R  ",
        "code": "",
        "complexity": {
            "time": "Advanced Data Structures like Trie, Segment Tree, Red-Black Tree and Binary Indexed Tree offer significant performance improvements for specific problem domains. They provide efficient solutions for tasks like fast prefix searches, range queries, dynamic updates, and maintaining balanced data structures, which are crucial for handling large datasets and real-time processing. By optimizing time complexity, they enable better scalability and faster execution in many computational problems.",
            "space": ""
        },
        "tags": [
            "Searching"
        ],
        "url": "https://www.geeksforgeeks.org/learn-data-structures-and-algorithms-dsa-tutorial/"
    },
    {
        "title": "No Title",
        "description": "",
        "code": "",
        "complexity": {
            "time": "",
            "space": ""
        },
        "tags": [
            "Searching"
        ],
        "url": "https://www.geeksforgeeks.org/explore?page=1&category=Searching&sortBy=submissions"
    },
    {
        "title": "Top MCQs on Searching Algorithm with Answers",
        "description": "Question 1 Linear search is also called------ Random Search Sequential search Perfect search None Question 2 Given a sorted array of integers, what can be the minimum worst-case time complexity to find ceiling of a number x in given array? The ceiling of an element x is the smallest element present in array which is greater than or equal to x. Ceiling is not present if x is greater than the maximum element present in array. For example, if the given array is {12, 67, 90, 100, 300, 399} and x = 95, then the output should be 100. O(loglogn) O(n) O(log(n)) O(log(n) * log(n)) Question 3 The increasing order of performance  of the searching algorithms are: linear search  <  jump search  <  binary search linear search  >  jump search  <  binary search linear search  <  jump search  >  binary search linear search  >  jump search  >  binary search Question 4 The average case occurs in the Linear Search Algorithm when: The item to be searched is in some where middle of the Array The item to be searched is not in the array The item to be searched is in the last of the array The item to be searched is either in the last or not in the array Question 5 Consider the C function given below. Assume that the array listA contains n (> 0) elements, sorted in ascending order. Which one of the following statements about the function ProcessArray is CORRECT? It will run into an infinite loop when x is not in listA. It is an implementation of binary search. It will always find the maximum element in listA. It will return −1 even when x is present in listA. Question 6 The average number of key comparisons done in a successful sequential search in a list of length n is log n (n-1)/2 n/2 (n+1)/2 Question 7 Consider the following program that attempts to locate an element x in a sorted array a[ ] using binary search. Assume N>1. The program is erroneous. Under what conditions does the program fail?  x is the last element of the array a[] x is greater than all elements of the array a[] Both of the Above x is less than the last element of the array a[] Question 8 The necessary condition for using binary search in an array is :- The array should not be too long The array should of more size The array should be sorted None of these Question 9 what is the name of the below searching Algorithm? Linear Search Sequential Search Jump  Search Exponential Search Question 10 What is the time complexity for performing Jump search? O(LogN) O(N) O(N^2) O(√N) There are 15 questions to complete. ",
        "code": "#include <iostream>\nusing namespace std;\n\nint ProcessArray(int *listA, int x, int n)\n{\n    int i, j, k;\n    i = 0;\n    j = n-1;\n    do\n    {\n        k = (i+j)/2;\n        if (x <= listA[k])\n            j = k-1;\n        if (listA[k] <= x)\n            i = k+1;\n    }\n    while (i <= j);\n    if (listA[k] == x)\n        return(k);\n    else\n        return -1;\n}\n#include <stdio.h>\n\nint ProcessArray(int *listA, int x, int n)\n{\n    int i, j, k;\n    i = 0;\n    j = n-1;\n    do\n    {\n        k = (i+j)/2;\n        if (x <= listA[k])\n            j = k-1;\n        if (listA[k] <= x)\n            i = k+1;\n    }\n    while (i <= j);\n    if (listA[k] == x)\n        return(k);\n    else\n        return -1;\n}\npublic class Main {\n    public static int ProcessArray(int[] listA, int x, int n) {\n        int i = 0, j = n - 1, k;\n        do {\n            k = (i + j) / 2;\n            if (x <= listA[k])\n                j = k - 1;\n            if (listA[k] <= x)\n                i = k + 1;\n        } while (i <= j);\n        if (listA[k] == x)\n            return k;\n        else\n            return -1;\n    }\n}\ndef ProcessArray(listA, x, n):\n    i = 0\n    j = n - 1\n    while i <= j:\n        k = (i + j) // 2\n        if x <= listA[k]:\n            j = k - 1\n        if listA[k] <= x:\n            i = k + 1\n    if listA[k] == x:\n        return k\n    else:\n        return -1\nfunction ProcessArray(listA, x, n) {\n    let i = 0;\n    let j = n - 1;\n    let k;\n    do {\n        k = Math.floor((i + j) / 2);\n        if (x <= listA[k])\n            j = k - 1;\n        if (listA[k] <= x)\n            i = k + 1;\n    } while (i <= j);\n    if (listA[k] === x)\n        return k;\n    else\n        return -1;\n}\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nint find(vector<int>a, int n) {\n    int i = 1, j = n;\n    int x;\n    do {\n        int k = (i + j) / 2;\n        if (a[k] < x) i = k + 1;\n        else j = k;\n    } while (a[k] != x && i < j);\n    \n    if (a[k] == x)\n        cout << \"x is in the array\" << endl;\n    else\n        cout << \"x is not in the array\" << endl;\n    return 0;\n}\n#include <stdio.h>\n#include <stdbool.h>\n\nint find(int a[], int n, int x) {\n    int i = 1, j = n;\n    int k;\n    do {\n        k = (i + j) / 2;\n        if (a[k] < x) i = k + 1;\n        else j = k;\n    } while (a[k] != x && i < j);\n    \n    if (a[k] == x)\n        printf(\"x is in the array\\n\");\n    else\n        printf(\"x is not in the array\\n\");\n    return 0;\n}\nimport java.util.List;\n\npublic class Main {\n    public static void find(int arr[], int n, int x) {\n        int i = 0, j = n;\n        int k;\n        do {\n            k = (i + j) / 2;\n            if (arr[k] < x) i = k + 1;\n            else j = k;\n        } while (i < j && arr[k] != x);\n\n        if (arr[k] == x)\n            System.out.println(\"x is in the array\");\n        else\n            System.out.println(\"x is not in the array\");\n    }\n}\ndef find(a, n, x):\n    i = 0\n    j = n\n    while i < j:\n        k = (i + j) // 2\n        if a[k] < x:\n            i = k + 1\n        else:\n            j = k\n    \n    if i < len(a) and a[i] == x:\n        print(\"x is in the array\")\n    else:\n        print(\"x is not in the array\")\nfunction find(a, n, x) {\n    let i = 0, j = n;\n    let k;\n    do {\n        k = Math.floor((i + j) / 2);\n        if (a[k] < x) i = k + 1;\n        else j = k;\n    } while (a[k] !== x && i < j);\n    \n    if (a[k] === x)\n        console.log(\"x is in the array\");\n    else\n        console.log(\"x is not in the array\");\n}\nint function(vector<int> arr,int x){\n\tint n = arr.size();\n\t\n\tif(n == 0)\n\t\treturn -1;\n\n\t// Find range for binary search by repeatedly doubling i\n\tint i = 1;\n\twhile(i < n and arr[i] < x)\n\t\ti *= 2;\n\n\t// Perform binary search on the range [i/2, min(i, n-1)]\n\tint left = i /2;\n\tint right = min(i, n-1);\n\n\twhile(left <= right){\n\t\tint mid = (left + right)/2;\n\t\t\n\t\tif(arr[mid] == x) return mid;\n\t\telse if(arr[mid] < x) left = mid + 1;\n\t\telse right = mid - 1;\n\t}\n\n\treturn -1;\n}\n#include <stdio.h>\n#include <stddef.h>\n\nint binary_search(int arr[], int n, int x) {\n    if(n == 0)\n        return -1;\n\n    // Find range for binary search by repeatedly doubling i\n    int i = 1;\n    while(i < n && arr[i] < x)\n        i *= 2;\n\n    // Perform binary search on the range [i/2, min(i, n-1)]\n    int left = i / 2;\n    int right = (i < n) ? i : n - 1;\n\n    while(left <= right) {\n        int mid = (left + right) / 2;\n        \n        if(arr[mid] == x) return mid;\n        else if(arr[mid] < x) left = mid + 1;\n        else right = mid - 1;\n    }\n\n    return -1;\n}\nimport java.util.*;\n\npublic class Main {\n    public static int function(List<Integer> arr, int x) {\n        int n = arr.size();\n        \n        if (n == 0)\n            return -1;\n\n        // Find range for binary search by repeatedly doubling i\n        int i = 1;\n        while (i < n && arr.get(i) < x)\n            i *= 2;\n\n        // Perform binary search on the range [i/2, min(i, n-1)]\n        int left = i / 2;\n        int right = Math.min(i, n - 1);\n\n        while (left <= right) {\n            int mid = (left + right) / 2;\n\n            if (arr.get(mid) == x) return mid;\n            else if (arr.get(mid) < x) left = mid + 1;\n            else right = mid - 1;\n        }\n\n        return -1;\n    }\n}\ndef function(arr, x):\n    n = len(arr)\n    \n    if n == 0:\n        return -1\n\n    # Find range for binary search by repeatedly doubling i\n    i = 1\n    while i < n and arr[i] < x:\n        i *= 2\n\n    # Perform binary search on the range [i/2, min(i, n-1)]\n    left = i // 2\n    right = min(i, n - 1)\n\n    while left <= right:\n        mid = (left + right) // 2\n\n        if arr[mid] == x:\n            return mid\n        elif arr[mid] < x:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1\nfunction functionSearch(arr, x) {\n    let n = arr.length;\n    \n    if (n === 0)\n        return -1;\n\n    // Find range for binary search by repeatedly doubling i\n    let i = 1;\n    while (i < n && arr[i] < x)\n        i *= 2;\n\n    // Perform binary search on the range [i/2, Math.min(i, n-1)]\n    let left = Math.floor(i / 2);\n    let right = Math.min(i, n - 1);\n\n    while (left <= right) {\n        let mid = Math.floor((left + right) / 2);\n\n        if (arr[mid] === x) return mid;\n        else if (arr[mid] < x) left = mid + 1;\n        else right = mid - 1;\n    }\n\n    return -1;\n}\n",
        "complexity": {
            "time": "What is the time complexity for performing Jump search?",
            "space": ""
        },
        "tags": [
            "Searching"
        ],
        "url": "https://www.geeksforgeeks.org/algorithms-gq/top-mcqs-on-searching-algorithm-with-answers/"
    },
    {
        "title": "Introduction to Searching - Data Structure and Algorithm Tutorial",
        "description": "Searching is the fundamental process of locating a specific element or item within a collection of data. This collection of data can take various forms, such as arrays, lists, trees, or other structured representations. The primary objective of searching is to determine whether the desired element exists within the data, and if so, to identify its precise location or retrieve it. It plays an important role in various computational tasks and real-world applications, including information retrieval, data analysis, decision-making processes, and more. Understanding the characteristics of searching in data structures and algorithms is crucial for designing efficient algorithms and making informed decisions about which searching technique to employ. Here, we explore key aspects and characteristics associated with searching: In searching, there is always a specific target element or item that you want to find within the data collection. This target could be a value, a record, a key, or any other data entity of interest. The search space refers to the entire collection of data within which you are looking for the target element. Depending on the data structure used, the search space may vary in size and organization. Searching can have different levels of complexity depending on the data structure and the algorithm used. The complexity is often measured in terms of time and space requirements. Some searching algorithms, like binary search, are deterministic, meaning they follow a clear and systematic approach. Others, such as linear search, are non-deterministic, as they may need to examine the entire search space in the worst case. Searching algorithms have numerous applications across various fields. Here are some common applications: Searching Algorithms are designed to check for an element or retrieve an element from any data structure where it is stored. Below are some searching algorithms: Linear Search, also known as Sequential Search, is one of the simplest and most straightforward searching algorithms. It works by sequentially examining each element in a collection of data(array or list) until a match is found or the entire collection has been traversed.  Consider the array arr[] = {10, 50, 30, 70, 80, 20, 90, 40} and key = 30 Start from the first element (index 0) and compare key with each element (arr[i]). Comparing key with first element arr[0]. Since not equal, the iterator moves to the next element as a potential match.  Comparing key with next element arr[1]. Since not equal, the iterator moves to the next element as a potential match.  Now when comparing arr[2] with key, the value matches. So the Linear Search Algorithm will yield a successful message and return the index of the element when key is found.  LinearSearch(collection, key): for each element in collection: if element is equal to key: return the index of the element return \"Not found\" Binary Search is defined as a searching algorithm used in a sorted array by repeatedly dividing the search interval in half. The idea of binary search is to use the information that the array is sorted and reduce the time complexity to O(log N). Consider an array arr[] = {2, 5, 8, 12, 16, 23, 38, 56, 72, 91}, and the target = 23.    Below is the pseudo code for implementing binary search: binarySearch(collection, key): left = 0 right = length(collection) - 1 while left <= right: mid = (left + right) // 2 if collection[mid] == key: return mid elif collection[mid] < key: left = mid + 1 else: right = mid - 1 return \"Not found\" Ternary Search is a searching algorithm that divides the search space into three parts instead of two, as in Binary Search. It is very useful in the case of unimodal functions. Consider an array arr[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}, and the target = 6. Jump Search is another searching algorithm that can be used on sorted collections (arrays or lists). The idea is to reduce the number of comparisons by jumping ahead by fixed steps or skipping some elements in place of searching all elements. Let’s consider the following array: (0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610). The length of the array is 16. The Jump search will find the value of 55 with the following steps assuming that the block size to be jumped is 4. linear search < jump search < binary search Interpolation Search is an efficient searching algorithm for sorted collections of data, such as arrays or lists. It is an improvement over Binary Search, particularly when the data is uniformly distributed. Fibonacci Search is an efficient searching algorithm used for finding a target value in a sorted collection, such as an array or list. It is similar in principle to Binary Search but uses Fibonacci numbers to determine the positions to be compared. Exponential Search is a searching algorithm designed to find a target value in a sorted collection, such as an array or list. It combines elements of Binary Search and Linear Search to efficiently locate the target, especially when its position is near the beginning of the collection.  M  ",
        "code": "",
        "complexity": {
            "time": "Binary Search is defined as a searching algorithm used in a sorted array by repeatedly dividing the search interval in half. The idea of binary search is to use the information that the array is sorted and reduce the time complexity to O(log N).",
            "space": ""
        },
        "tags": [
            "Searching"
        ],
        "url": "https://www.geeksforgeeks.org/introduction-to-searching-data-structure-and-algorithm-tutorial/"
    },
    {
        "title": "Linear Search Algorithm",
        "description": "Given an array, arr of n integers, and an integer element x, find whether element x is present in the array. Return the index of the first occurrence of x in the array, or -1 if it doesn’t exist. Input: arr[] = [1, 2, 3, 4], x = 3Output: 2Explanation: There is one test case with array as [1, 2, 3 4] and element to be searched as 3. Since 3 is present at index 2, the output is 2. Input: arr[] = [10, 8, 30, 4, 5], x = 5Output: 4Explanation: For array [10, 8, 30, 4, 5], the element to be searched is 5 and it is at index 4. So, the output is 4. Input: arr[] = [10, 8, 30], x = 6Output: -1Explanation: The element to be searched is 6 and its not present, so we return -1. In Linear Search, we iterate over all the elements of the array and check if it the current element is equal to the target element. If we find any element to be equal to the target element, then return the index of the current element. Otherwise, if no element is equal to the target element, then return -1 as the element is not found. Linear search is also known as sequential search. For example: Consider the array arr[] = {10, 50, 30, 70, 80, 20, 90, 40} and key = 30  Below is the implementation of the linear search algorithm: Time Complexity: Auxiliary Space: O(1) as except for the variable to iterate through the list, no other variable is used.  ",
        "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint search(vector<int>& arr, int x) {\n    for (int i = 0; i < arr.size(); i++)\n        if (arr[i] == x)\n            return i;\n    return -1;\n}\n\nint main() {\n    vector<int> arr = {2, 3, 4, 10, 40};\n    int x = 10;\n    int res = search(arr, x);\n    if (res == -1)\n       cout << \"Not Present\";\n    else\n       cout << \"Present at Index \" << res;\n    return 0;\n}\n// C code to linearly search x in arr[].\n\n#include <stdio.h>\n\nint search(int arr[], int N, int x)\n{\n    for (int i = 0; i < N; i++)\n        if (arr[i] == x)\n            return i;\n    return -1;\n}\n\n// Driver code\nint main(void)\n{\n    int arr[] = { 2, 3, 4, 10, 40 };\n    int x = 10;\n    int N = sizeof(arr) / sizeof(arr[0]);\n\n    // Function call\n    int result = search(arr, N, x);\n    (result == -1)\n        ? printf(\"Element is not present in array\")\n        : printf(\"Element is present at index %d\", result);\n    return 0;\n}\n// Java code for linearly searching x in arr[]. \n\nimport java.io.*;\n\nclass GFG {\n    public static int search(int arr[], int N, int x)\n    {\n        for (int i = 0; i < N; i++) {\n            if (arr[i] == x)\n                return i;\n        }\n        return -1;\n    }\n\n    // Driver code\n    public static void main(String args[])\n    {\n        int arr[] = { 2, 3, 4, 10, 40 };\n        int x = 10;\n\n        // Function call\n        int result = search(arr, arr.length, x);\n        if (result == -1)\n            System.out.print(\n                \"Element is not present in array\");\n        else\n            System.out.print(\"Element is present at index \"\n                             + result);\n    }\n}\n# Python3 code to linearly search x in arr[].\n\n\ndef search(arr, N, x):\n\n    for i in range(0, N):\n        if (arr[i] == x):\n            return i\n    return -1\n\n\n# Driver Code\nif __name__ == \"__main__\":\n    arr = [2, 3, 4, 10, 40]\n    x = 10\n    N = len(arr)\n\n    # Function call\n    result = search(arr, N, x)\n    if(result == -1):\n        print(\"Element is not present in array\")\n    else:\n        print(\"Element is present at index\", result)\n// C# code to linearly search x in arr[].\n\nusing System;\n\nclass GFG {\n    public static int search(int[] arr, int N, int x)\n    {\n        for (int i = 0; i < N; i++) {\n            if (arr[i] == x)\n                return i;\n        }\n        return -1;\n    }\n\n    // Driver's code\n    public static void Main()\n    {\n        int[] arr = { 2, 3, 4, 10, 40 };\n        int x = 10;\n\n        // Function call\n        int result = search(arr, arr.Length, x);\n        if (result == -1)\n            Console.WriteLine(\n                \"Element is not present in array\");\n        else\n            Console.WriteLine(\"Element is present at index \"\n                              + result);\n    }\n}\n\n// This code is contributed by DrRoot_\n// Javascript code to linearly search x in arr[].\n\nfunction search(arr, n, x)\n{\n    for (let i = 0; i < n; i++)\n        if (arr[i] == x)\n            return i;\n    return -1;\n}\n\n// Driver code\n\n    let arr = [ 2, 3, 4, 10, 40 ];\n    let x = 10;\n    let n = arr.length;\n\n    // Function call\n    let result = search(arr, n, x);\n    (result == -1)\n        ? console.log(\"Element is not present in array\")\n        : console.log(\"Element is present at index \" + result);\n\n// This code is contributed by Manoj\n<?php\n// PHP code for linearly search x in arr[].\n\nfunction search($arr, $n, $x)\n{\n    for($i = 0; $i < $n; $i++) {\n        if($arr[$i] == $x)\n            return $i;\n    }\n    return -1;\n}\n\n// Driver Code\n$arr = array(2, 3, 4, 10, 40); \n$x = 10;\n\n// Function call\n$result = search($arr, sizeof($arr), $x);\nif($result == -1)\n    echo \"Element is not present in array\";\nelse\n    echo \"Element is present at index \" ,\n                                 $result;\n\n// This code is contributed\n// by jit_t\n?>\nPresent at Index 3\n",
        "complexity": {
            "time": "Time Complexity:",
            "space": ""
        },
        "tags": [
            "Searching"
        ],
        "url": "https://www.geeksforgeeks.org/linear-search/"
    },
    {
        "title": "Binary Search Algorithm – Iterative and Recursive Implementation",
        "description": "Binary Search Algorithm is a searching algorithm used in a sorted array by repeatedly dividing the search interval in half. The idea of binary search is to use the information that the array is sorted and reduce the time complexity to O(log N). Binary Search Algorithm To apply Binary Search algorithm: Below is the step-by-step algorithm for Binary Search: To understand the working of binary search, consider the following illustration: Consider an array arr[] = {2, 5, 8, 12, 16, 23, 38, 56, 72, 91}, and the target = 23.  The Binary Search Algorithm can be implemented in the following two ways Given below are the pseudocodes for the approaches. Here we use a while loop to continue the process of comparing the key and splitting the search space in two halves. Time Complexity: O(log N)Auxiliary Space: O(1) Create a recursive function and compare the mid of the search space with the key. And based on the result either return the index where the key is found or call the recursive function for the next search space. Please refer Time and Space Complexity Analysis of Binary Search for more details.  ",
        "code": "// C++ program to implement iterative Binary Search\n#include <bits/stdc++.h>\nusing namespace std;\n\n// An iterative binary search function.\nint binarySearch(int arr[], int low, int high, int x)\n{\n    while (low <= high) {\n        int mid = low + (high - low) / 2;\n\n        // Check if x is present at mid\n        if (arr[mid] == x)\n            return mid;\n\n        // If x greater, ignore left half\n        if (arr[mid] < x)\n            low = mid + 1;\n\n        // If x is smaller, ignore right half\n        else\n            high = mid - 1;\n    }\n\n    // If we reach here, then element was not present\n    return -1;\n}\n\n// Driver code\nint main(void)\n{\n    int arr[] = { 2, 3, 4, 10, 40 };\n    int x = 10;\n    int n = sizeof(arr) / sizeof(arr[0]);\n    int result = binarySearch(arr, 0, n - 1, x);\n    if(result == -1) cout << \"Element is not present in array\";\n    else cout << \"Element is present at index \" << result;\n    return 0;\n}\n// C program to implement iterative Binary Search\n#include <stdio.h>\n\n// An iterative binary search function.\nint binarySearch(int arr[], int low, int high, int x)\n{\n    while (low <= high) {\n        int mid = low + (high - low) / 2;\n\n        // Check if x is present at mid\n        if (arr[mid] == x)\n            return mid;\n\n        // If x greater, ignore left half\n        if (arr[mid] < x)\n            low = mid + 1;\n\n        // If x is smaller, ignore right half\n        else\n            high = mid - 1;\n    }\n\n    // If we reach here, then element was not present\n    return -1;\n}\n\n// Driver code\nint main(void)\n{\n    int arr[] = { 2, 3, 4, 10, 40 };\n    int n = sizeof(arr) / sizeof(arr[0]);\n    int x = 10;\n    int result = binarySearch(arr, 0, n - 1, x);\n   if(result == -1) printf(\"Element is not present in array\");\n   else printf(\"Element is present at index %d\",result);\n\n}\n// Java implementation of iterative Binary Search\n\nimport java.io.*;\n\nclass BinarySearch {\n  \n    // Returns index of x if it is present in arr[].\n    int binarySearch(int arr[], int x)\n    {\n        int low = 0, high = arr.length - 1;\n        while (low <= high) {\n            int mid = low + (high - low) / 2;\n\n            // Check if x is present at mid\n            if (arr[mid] == x)\n                return mid;\n\n            // If x greater, ignore left half\n            if (arr[mid] < x)\n                low = mid + 1;\n\n            // If x is smaller, ignore right half\n            else\n                high = mid - 1;\n        }\n\n        // If we reach here, then element was\n        // not present\n        return -1;\n    }\n\n    // Driver code\n    public static void main(String args[])\n    {\n        BinarySearch ob = new BinarySearch();\n        int arr[] = { 2, 3, 4, 10, 40 };\n        int n = arr.length;\n        int x = 10;\n        int result = ob.binarySearch(arr, x);\n        if (result == -1)\n            System.out.println(\n                \"Element is not present in array\");\n        else\n            System.out.println(\"Element is present at \"\n                               + \"index \" + result);\n    }\n}\n# Python3 code to implement iterative Binary\n# Search.\n\n\n# It returns location of x in given array arr\ndef binarySearch(arr, low, high, x):\n\n    while low <= high:\n\n        mid = low + (high - low) // 2\n\n        # Check if x is present at mid\n        if arr[mid] == x:\n            return mid\n\n        # If x is greater, ignore left half\n        elif arr[mid] < x:\n            low = mid + 1\n\n        # If x is smaller, ignore right half\n        else:\n            high = mid - 1\n\n    # If we reach here, then the element\n    # was not present\n    return -1\n\n\n# Driver Code\nif __name__ == '__main__':\n    arr = [2, 3, 4, 10, 40]\n    x = 10\n\n    # Function call\n    result = binarySearch(arr, 0, len(arr)-1, x)\n    if result != -1:\n        print(\"Element is present at index\", result)\n    else:\n        print(\"Element is not present in array\")\n// C# implementation of iterative Binary Search\nusing System;\n\nclass GFG {\n    \n    // Returns index of x if it is present in arr[]\n    static int binarySearch(int[] arr, int x)\n    {\n        int low = 0, high = arr.Length - 1;\n        while (low <= high) {\n            int mid = low + (high - low) / 2;\n\n            // Check if x is present at mid\n            if (arr[mid] == x)\n                return mid;\n\n            // If x greater, ignore left half\n            if (arr[mid] < x)\n                low = mid + 1;\n\n            // If x is smaller, ignore right half\n            else\n                high = mid - 1;\n        }\n\n        // If we reach here, then element was\n        // not present\n        return -1;\n    }\n\n    // Driver code\n    public static void Main()\n    {\n        int[] arr = { 2, 3, 4, 10, 40 };\n        int n = arr.Length;\n        int x = 10;\n        int result = binarySearch(arr, x);\n        if (result == -1)\n            Console.WriteLine(\n                \"Element is not present in array\");\n        else\n            Console.WriteLine(\"Element is present at \"\n                              + \"index \" + result);\n    }\n}\n// Program to implement iterative Binary Search\n\n// A iterative binary search function. It returns\n// location of x in given array arr[l..r] is present,\n// otherwise -1\n\nfunction binarySearch(arr, x)\n{\n    let low = 0;\n    let high = arr.length - 1;\n    let mid;\n    while (high >= low) {\n        mid = low + Math.floor((high - low) / 2);\n\n        // If the element is present at the middle\n        // itself\n        if (arr[mid] == x)\n            return mid;\n\n        // If element is smaller than mid, then\n        // it can only be present in left subarray\n        if (arr[mid] > x)\n            high = mid - 1;\n\n        // Else the element can only be present\n        // in right subarray\n        else\n            low = mid + 1;\n    }\n\n    // We reach here when element is not\n    // present in array\n    return -1;\n}\n\narr = new Array(2, 3, 4, 10, 40);\nx = 10;\nn = arr.length;\nresult = binarySearch(arr, x);\nif (result == -1)\n    console.log(\"Element is not present in array\")\n    else\n    {\n        console.log(\"Element is present at index \"\n                    + result);\n    }\n<?php\n// PHP program to implement\n// iterative Binary Search\n\n// An iterative binary search \n// function\nfunction binarySearch($arr, $low, \n                      $high, $x)\n{\n    while ($low <= $high)\n    {\n        $mid = $low + ($high - $low) / 2;\n\n        // Check if x is present at mid\n        if ($arr[$mid] == $x)\n            return floor($mid);\n\n        // If x greater, ignore\n        // left half\n        if ($arr[$mid] < $x)\n            $low = $mid + 1;\n\n        // If x is smaller, \n        // ignore right half\n        else\n            $high = $mid - 1;\n    }\n\n    // If we reach here, then \n    // element was not present\n    return -1;\n}\n\n// Driver Code\n$arr = array(2, 3, 4, 10, 40);\n$n = count($arr);\n$x = 10;\n$result = binarySearch($arr, 0, \n                       $n - 1, $x);\nif(($result == -1))\necho \"Element is not present in array\";\nelse\necho \"Element is present at index \", \n                            $result;\n\n?>\nElement is present at index 3\n#include <bits/stdc++.h>\nusing namespace std;\n\n// A recursive binary search function. It returns\n// location of x in given array arr[low..high] is present,\n// otherwise -1\nint binarySearch(int arr[], int low, int high, int x)\n{\n    if (high >= low) {\n        int mid = low + (high - low) / 2;\n\n        // If the element is present at the middle\n        // itself\n        if (arr[mid] == x)\n            return mid;\n\n        // If element is smaller than mid, then\n        // it can only be present in left subarray\n        if (arr[mid] > x)\n            return binarySearch(arr, low, mid - 1, x);\n\n        // Else the element can only be present\n        // in right subarray\n        return binarySearch(arr, mid + 1, high, x);\n    }\n  return -1;\n}\n\n// Driver code\nint main()\n{\n    int arr[] = { 2, 3, 4, 10, 40 };\n    int query = 90;\n    int n = sizeof(arr) / sizeof(arr[0]);\n    int result = binarySearch(arr, 0, n - 1, query);\n    if (result == -1) cout << \"Element is not present in array\";\n    else cout << \"Element is present at index \" << result;\n    return 0;\n}\n// C program to implement recursive Binary Search\n#include <stdio.h>\n\n// A recursive binary search function. It returns\n// location of x in given array arr[low..high] is present,\n// otherwise -1\nint binarySearch(int arr[], int low, int high, int x)\n{\n    if (high >= low) {\n        int mid = low + (high - low) / 2;\n\n        // If the element is present at the middle\n        // itself\n        if (arr[mid] == x)\n            return mid;\n\n        // If element is smaller than mid, then\n        // it can only be present in left subarray\n        if (arr[mid] > x)\n            return binarySearch(arr, low, mid - 1, x);\n\n        // Else the element can only be present\n        // in right subarray\n        return binarySearch(arr, mid + 1, high, x);\n    }\n\n    // We reach here when element is not\n    // present in array\n    return -1;\n}\n\n// Driver code\nint main()\n{\n    int arr[] = { 2, 3, 4, 10, 40 };\n    int n = sizeof(arr) / sizeof(arr[0]);\n    int x = 10;\n    int result = binarySearch(arr, 0, n - 1, x);\n    if (result == -1) printf(\"Element is not present in array\");\n    else printf(\"Element is present at index %d\", result);\n    return 0;\n}\n// Java implementation of recursive Binary Search\nclass BinarySearch {\n\n    // Returns index of x if it is present in arr[low..\n    // high], else return -1\n    int binarySearch(int arr[], int low, int high, int x)\n    {\n        if (high >= low) {\n            int mid = low + (high - low) / 2;\n\n            // If the element is present at the\n            // middle itself\n            if (arr[mid] == x)\n                return mid;\n\n            // If element is smaller than mid, then\n            // it can only be present in left subarray\n            if (arr[mid] > x)\n                return binarySearch(arr, low, mid - 1, x);\n\n            // Else the element can only be present\n            // in right subarray\n            return binarySearch(arr, mid + 1, high, x);\n        }\n\n        // We reach here when element is not present\n        // in array\n        return -1;\n    }\n\n    // Driver code\n    public static void main(String args[])\n    {\n        BinarySearch ob = new BinarySearch();\n        int arr[] = { 2, 3, 4, 10, 40 };\n        int n = arr.length;\n        int x = 10;\n        int result = ob.binarySearch(arr, 0, n - 1, x);\n        if (result == -1)\n            System.out.println(\n                \"Element is not present in array\");\n        else\n            System.out.println(\n                \"Element is present at index \" + result);\n    }\n}\n# Python3 Program for recursive binary search.\n\n\n# Returns index of x in arr if present, else -1\ndef binarySearch(arr, low, high, x):\n\n    # Check base case\n    if high >= low:\n\n        mid = low + (high - low) // 2\n\n        # If element is present at the middle itself\n        if arr[mid] == x:\n            return mid\n\n        # If element is smaller than mid, then it\n        # can only be present in left subarray\n        elif arr[mid] > x:\n            return binarySearch(arr, low, mid-1, x)\n\n        # Else the element can only be present\n        # in right subarray\n        else:\n            return binarySearch(arr, mid + 1, high, x)\n\n    # Element is not present in the array\n    else:\n        return -1\n\n\n# Driver Code\nif __name__ == '__main__':\n    arr = [2, 3, 4, 10, 40]\n    x = 10\n    \n    # Function call\n    result = binarySearch(arr, 0, len(arr)-1, x)\n    \n    if result != -1:\n        print(\"Element is present at index\", result)\n    else:\n        print(\"Element is not present in array\")\n// C# implementation of recursive Binary Search\nusing System;\n\nclass GFG {\n\n    // Returns index of x if it is present in\n    // arr[low..high], else return -1\n    static int binarySearch(int[] arr, int low, int high, int x)\n    {\n        if (high >= low) {\n            int mid = low + (high - low) / 2;\n\n            // If the element is present at the\n            // middle itself\n            if (arr[mid] == x)\n                return mid;\n\n            // If element is smaller than mid, then\n            // it can only be present in left subarray\n            if (arr[mid] > x)\n                return binarySearch(arr, low, mid - 1, x);\n\n            // Else the element can only be present\n            // in right subarray\n            return binarySearch(arr, mid + 1, high, x);\n        }\n\n        // We reach here when element is not present\n        // in array\n        return -1;\n    }\n\n    // Driver code\n    public static void Main()\n    {\n\n        int[] arr = { 2, 3, 4, 10, 40 };\n        int n = arr.Length;\n        int x = 10;\n\n        int result = binarySearch(arr, 0, n - 1, x);\n\n        if (result == -1)\n            Console.WriteLine(\n                \"Element is not present in arrau\");\n        else\n            Console.WriteLine(\"Element is present at index \"\n                              + result);\n    }\n}\n// JavaScript program to implement recursive Binary Search\n\n// A recursive binary search function. It returns\n// location of x in given array arr[low..high] is present,\n// otherwise -1\nfunction binarySearch(arr, low, high, x)\n{\n    if (high >= low) {\n        let mid = low + Math.floor((high - low) / 2);\n\n        // If the element is present at the middle\n        // itself\n        if (arr[mid] == x)\n            return mid;\n\n        // If element is smaller than mid, then\n        // it can only be present in left subarray\n        if (arr[mid] > x)\n            return binarySearch(arr, low, mid - 1, x);\n\n        // Else the element can only be present\n        // in right subarray\n        return binarySearch(arr, mid + 1, high, x);\n    }\n\n    // We reach here when element is not\n    // present in array\n    return -1;\n}\n\nlet arr = [ 2, 3, 4, 10, 40 ];\nlet x = 10;\nlet n = arr.length\nlet result = binarySearch(arr, 0, n - 1, x);\nif (result == -1)\n    console.log(\"Element is not present in array\");\nelse\n    console.log(\"Element is present at index \" + result);\n<?php\n// PHP program to implement\n// recursive Binary Search\n\n// A recursive binary search\n// function. It returns location\n// of x in given array arr[low..high] \n// is present, otherwise -1\nfunction binarySearch($arr, $low, $high, $x)\n{\nif ($high >= $low)\n{\n        $mid = ceil($low + ($high - $low) / 2);\n\n        // If the element is present \n        // at the middle itself\n        if ($arr[$mid] == $x) \n            return floor($mid);\n\n        // If element is smaller than \n        // mid, then it can only be \n        // present in left subarray\n        if ($arr[$mid] > $x) \n            return binarySearch($arr, $low, \n                                $mid - 1, $x);\n\n        // Else the element can only \n        // be present in right subarray\n        return binarySearch($arr, $mid + 1, \n                            $high, $x);\n}\n\n// We reach here when element \n// is not present in array\nreturn -1;\n}\n\n// Driver Code\n$arr = array(2, 3, 4, 10, 40);\n$n = count($arr);\n$x = 10;\n$result = binarySearch($arr, 0, $n - 1, $x);\nif(($result == -1))\necho \"Element is not present in array\";\nelse\necho \"Element is present at index \",\n                            $result;\n                          \n?>\nElement is present at index 3\n",
        "complexity": {
            "time": "Time Complexity: O(log N)Auxiliary Space: O(1)",
            "space": "Please refer Time and Space Complexity Analysis of Binary Search for more details."
        },
        "tags": [
            "Searching"
        ],
        "url": "https://www.geeksforgeeks.org/binary-search/"
    },
    {
        "title": "Ternary Search",
        "description": "Computer systems use different methods to find specific data. There are various search algorithms, each better suited for certain situations. For instance, a binary search divides information into two parts, while a ternary search does the same but into three equal parts. It’s worth noting that ternary search is only effective for sorted data. In this article, we’re going to uncover the secrets of Ternary Search – how it works, why it’s faster in some situations. Table of Content Ternary search is a search algorithm that is used to find the position of a target value within a sorted array. It operates on the principle of dividing the array into three parts instead of two, as in binary search. The basic idea is to narrow down the search space by comparing the target value with elements at two points that divide the array into three equal parts. The concept involves dividing the array into three equal segments and determining in which segment the key element is located. It works similarly to a binary search, with the distinction of reducing time complexity by dividing the array into three parts instead of two. Below are the step-by-step explanation of working of Ternary Search: Illustration: Ternary Search Below is the implementation of Ternary Search Approach: Time Complexity: O(2 * log3n)Auxiliary Space: O(log3n) Iterative Approach of Ternary Search: Time Complexity: O(2 * log3n), where n is the size of the array.Auxiliary Space: O(1) Time Complexity: Auxiliary Space: O(1) The time complexity of the binary search is less than the ternary search as the number of comparisons in ternary search is much more than binary search. Binary Search is used to find the maxima/minima of monotonic functions where as Ternary Search is used to find the maxima/minima of unimodal functions. Note: We can also use ternary search for monotonic functions but the time complexity will be slightly higher as compared to binary search. S  ",
        "code": "// C++ program to illustrate\n// recursive approach to ternary search\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Function to perform Ternary Search\nint ternarySearch(int l, int r, int key, int ar[])\n{\n    if (r >= l) {\n\n        // Find the mid1 and mid2\n        int mid1 = l + (r - l) / 3;\n        int mid2 = r - (r - l) / 3;\n\n        // Check if key is present at any mid\n        if (ar[mid1] == key) {\n            return mid1;\n        }\n        if (ar[mid2] == key) {\n            return mid2;\n        }\n\n        // Since key is not present at mid,\n        // check in which region it is present\n        // then repeat the Search operation\n        // in that region\n        if (key < ar[mid1]) {\n\n            // The key lies in between l and mid1\n            return ternarySearch(l, mid1 - 1, key, ar);\n        }\n        else if (key > ar[mid2]) {\n\n            // The key lies in between mid2 and r\n            return ternarySearch(mid2 + 1, r, key, ar);\n        }\n        else {\n\n            // The key lies in between mid1 and mid2\n            return ternarySearch(mid1 + 1, mid2 - 1, key, ar);\n        }\n    }\n\n    // Key not found\n    return -1;\n}\n\n// Driver code\nint main()\n{\n    int l, r, p, key;\n\n    // Get the array\n    // Sort the array if not sorted\n    int ar[] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };\n\n    // Starting index\n    l = 0;\n\n    // end element index\n    r = 9;\n\n    // Checking for 5\n\n    // Key to be searched in the array\n    key = 5;\n\n    // Search the key using ternarySearch\n    p = ternarySearch(l, r, key, ar);\n\n    // Print the result\n    cout << \"Index of \" << key\n         << \" is \" << p << endl;\n\n    // Checking for 50\n\n    // Key to be searched in the array\n    key = 50;\n\n    // Search the key using ternarySearch\n    p = ternarySearch(l, r, key, ar);\n\n    // Print the result\n    cout << \"Index of \" << key\n         << \" is \" << p << endl;\n}\n\n// This code is contributed\n// by Akanksha_Rai\n// C program to illustrate\n// recursive approach to ternary search\n\n#include <stdio.h>\n\n// Function to perform Ternary Search\nint ternarySearch(int l, int r, int key, int ar[])\n{\n    if (r >= l) {\n\n        // Find the mid1 and mid2\n        int mid1 = l + (r - l) / 3;\n        int mid2 = r - (r - l) / 3;\n\n        // Check if key is present at any mid\n        if (ar[mid1] == key) {\n            return mid1;\n        }\n        if (ar[mid2] == key) {\n            return mid2;\n        }\n\n        // Since key is not present at mid,\n        // check in which region it is present\n        // then repeat the Search operation\n        // in that region\n\n        if (key < ar[mid1]) {\n\n            // The key lies in between l and mid1\n            return ternarySearch(l, mid1 - 1, key, ar);\n        }\n        else if (key > ar[mid2]) {\n\n            // The key lies in between mid2 and r\n            return ternarySearch(mid2 + 1, r, key, ar);\n        }\n        else {\n\n            // The key lies in between mid1 and mid2\n            return ternarySearch(mid1 + 1, mid2 - 1, key, ar);\n        }\n    }\n\n    // Key not found\n    return -1;\n}\n\n// Driver code\nint main()\n{\n    int l, r, p, key;\n\n    // Get the array\n    // Sort the array if not sorted\n    int ar[] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };\n\n    // Starting index\n    l = 0;\n\n    // end element index\n    r = 9;\n\n    // Checking for 5\n\n    // Key to be searched in the array\n    key = 5;\n\n    // Search the key using ternarySearch\n    p = ternarySearch(l, r, key, ar);\n\n    // Print the result\n    printf(\"Index of %d is %d\\n\", key, p);\n\n    // Checking for 50\n\n    // Key to be searched in the array\n    key = 50;\n\n    // Search the key using ternarySearch\n    p = ternarySearch(l, r, key, ar);\n\n    // Print the result\n    printf(\"Index of %d is %d\", key, p);\n}\n// Java program to illustrate\n// recursive approach to ternary search\n\nclass GFG {\n\n    // Function to perform Ternary Search\n    static int ternarySearch(int l, int r, int key, int ar[])\n    {\n        if (r >= l) {\n\n            // Find the mid1 and mid2\n            int mid1 = l + (r - l) / 3;\n            int mid2 = r - (r - l) / 3;\n\n            // Check if key is present at any mid\n            if (ar[mid1] == key) {\n                return mid1;\n            }\n            if (ar[mid2] == key) {\n                return mid2;\n            }\n\n            // Since key is not present at mid,\n            // check in which region it is present\n            // then repeat the Search operation\n            // in that region\n\n            if (key < ar[mid1]) {\n\n                // The key lies in between l and mid1\n                return ternarySearch(l, mid1 - 1, key, ar);\n            }\n            else if (key > ar[mid2]) {\n\n                // The key lies in between mid2 and r\n                return ternarySearch(mid2 + 1, r, key, ar);\n            }\n            else {\n\n                // The key lies in between mid1 and mid2\n                return ternarySearch(mid1 + 1, mid2 - 1, key, ar);\n            }\n        }\n\n        // Key not found\n        return -1;\n    }\n\n    // Driver code\n    public static void main(String args[])\n    {\n        int l, r, p, key;\n\n        // Get the array\n        // Sort the array if not sorted\n        int ar[] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };\n\n        // Starting index\n        l = 0;\n\n        // end element index\n        r = 9;\n\n        // Checking for 5\n\n        // Key to be searched in the array\n        key = 5;\n\n        // Search the key using ternarySearch\n        p = ternarySearch(l, r, key, ar);\n\n        // Print the result\n        System.out.println(\"Index of \" + key + \" is \" + p);\n\n        // Checking for 50\n\n        // Key to be searched in the array\n        key = 50;\n\n        // Search the key using ternarySearch\n        p = ternarySearch(l, r, key, ar);\n\n        // Print the result\n        System.out.println(\"Index of \" + key + \" is \" + p);\n    }\n}\n# Python3 program to illustrate\n# recursive approach to ternary search\nimport math as mt\n\n# Function to perform Ternary Search\ndef ternarySearch(l, r, key, ar):\n\n    if (r >= l):\n\n        # Find the mid1 and mid2\n        mid1 = l + (r - l) //3\n        mid2 = r - (r - l) //3\n\n        # Check if key is present at any mid\n        if (ar[mid1] == key): \n            return mid1\n        \n        if (ar[mid2] == key): \n            return mid2\n        \n        # Since key is not present at mid,\n        # check in which region it is present\n        # then repeat the Search operation\n        # in that region\n        if (key < ar[mid1]): \n\n            # The key lies in between l and mid1\n            return ternarySearch(l, mid1 - 1, key, ar)\n        \n        elif (key > ar[mid2]): \n\n            # The key lies in between mid2 and r\n            return ternarySearch(mid2 + 1, r, key, ar)\n        \n        else: \n\n            # The key lies in between mid1 and mid2\n            return ternarySearch(mid1 + 1, \n                                 mid2 - 1, key, ar)\n        \n    # Key not found\n    return -1\n\n# Driver code\nl, r, p = 0, 9, 5\n\n# Get the array\n# Sort the array if not sorted\nar = [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ]\n\n# Starting index\nl = 0\n\n# end element index\nr = 9\n\n# Checking for 5\n\n# Key to be searched in the array\nkey = 5\n\n# Search the key using ternarySearch\np = ternarySearch(l, r, key, ar)\n\n# Print the result\nprint(\"Index of\", key, \"is\", p)\n\n# Checking for 50\n\n# Key to be searched in the array\nkey = 50\n\n# Search the key using ternarySearch\np = ternarySearch(l, r, key, ar)\n\n# Print the result\nprint(\"Index of\", key, \"is\", p)\n\n# This code is contributed by \n# Mohit kumar 29\n// CSharp program to illustrate\n// recursive approach to ternary search\nusing System;\n\nclass GFG {\n\n    // Function to perform Ternary Search\n    static int ternarySearch(int l, int r, int key, int[] ar)\n    {\n        if (r >= l) {\n\n            // Find the mid1 and mid2\n            int mid1 = l + (r - l) / 3;\n            int mid2 = r - (r - l) / 3;\n\n            // Check if key is present at any mid\n            if (ar[mid1] == key) {\n                return mid1;\n            }\n            if (ar[mid2] == key) {\n                return mid2;\n            }\n\n            // Since key is not present at mid,\n            // check in which region it is present\n            // then repeat the Search operation\n            // in that region\n\n            if (key < ar[mid1]) {\n\n                // The key lies in between l and mid1\n                return ternarySearch(l, mid1 - 1, key, ar);\n            }\n            else if (key > ar[mid2]) {\n\n                // The key lies in between mid2 and r\n                return ternarySearch(mid2 + 1, r, key, ar);\n            }\n            else {\n\n                // The key lies in between mid1 and mid2\n                return ternarySearch(mid1 + 1, mid2 - 1, key, ar);\n            }\n        }\n\n        // Key not found\n        return -1;\n    }\n\n    // Driver code\n    public static void Main()\n    {\n        int l, r, p, key;\n\n        // Get the array\n        // Sort the array if not sorted\n        int[] ar = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };\n\n        // Starting index\n        l = 0;\n\n        // end element index\n        r = 9;\n\n        // Checking for 5\n\n        // Key to be searched in the array\n        key = 5;\n\n        // Search the key using ternarySearch\n        p = ternarySearch(l, r, key, ar);\n\n        // Print the result\n        Console.WriteLine(\"Index of \" + key + \" is \" + p);\n\n        // Checking for 50\n\n        // Key to be searched in the array\n        key = 50;\n\n        // Search the key using ternarySearch\n        p = ternarySearch(l, r, key, ar);\n\n        // Print the result\n        Console.WriteLine(\"Index of \" + key + \" is \" + p);\n    }\n}\n\n// This code is contributed by Ryuga\n<script>\n\n    // JavaScript program to illustrate\n    // recursive approach to ternary search\n    \n    // Function to perform Ternary Search\n    function ternarySearch(l, r, key, ar)\n    {\n        if (r >= l) {\n \n            // Find the mid1 and mid2\n            let mid1 = l + parseInt((r - l) / 3, 10);\n            let mid2 = r - parseInt((r - l) / 3, 10);\n \n            // Check if key is present at any mid\n            if (ar[mid1] == key) {\n                return mid1;\n            }\n            if (ar[mid2] == key) {\n                return mid2;\n            }\n \n            // Since key is not present at mid,\n            // check in which region it is present\n            // then repeat the Search operation\n            // in that region\n \n            if (key < ar[mid1]) {\n \n                // The key lies in between l and mid1\n                return ternarySearch(l, mid1 - 1, key, ar);\n            }\n            else if (key > ar[mid2]) {\n \n                // The key lies in between mid2 and r\n                return ternarySearch(mid2 + 1, r, key, ar);\n            }\n            else {\n \n                // The key lies in between mid1 and mid2\n                return ternarySearch(mid1 + 1, mid2 - 1, key, ar);\n            }\n        }\n \n        // Key not found\n        return -1;\n    }\n    \n    let l, r, p, key;\n \n    // Get the array\n    // Sort the array if not sorted\n    let ar = [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ];\n\n    // Starting index\n    l = 0;\n\n    // end element index\n    r = 9;\n\n    // Checking for 5\n\n    // Key to be searched in the array\n    key = 5;\n\n    // Search the key using ternarySearch\n    p = ternarySearch(l, r, key, ar);\n\n    // Print the result\n    document.write(\"Index of \" + key + \" is \" + p + \"</br>\");\n\n    // Checking for 50\n\n    // Key to be searched in the array\n    key = 50;\n\n    // Search the key using ternarySearch\n    p = ternarySearch(l, r, key, ar);\n\n    // Print the result\n    document.write(\"Index of \" + key + \" is \" + p);\n        \n</script>\n<?php\n// PHP program to illustrate\n// recursive approach to ternary search\n\n// Function to perform Ternary Search\nfunction ternarySearch($l, $r, $key, $ar)\n{\n    if ($r >= $l)\n    {\n\n        // Find the mid1 and mid2\n        $mid1 = (int)($l + ($r - $l) / 3);\n        $mid2 = (int)($r - ($r - $l) / 3);\n\n        // Check if key is present at any mid\n        if ($ar[$mid1] == $key) \n        {\n            return $mid1;\n        }\n        if ($ar[$mid2] == $key)\n        {\n            return $mid2;\n        }\n\n        // Since key is not present at mid,\n        // check in which region it is present\n        // then repeat the Search operation\n        // in that region\n        if ($key < $ar[$mid1]) \n        {\n\n            // The key lies in between l and mid1\n            return ternarySearch($l, $mid1 - 1, \n                                     $key, $ar);\n        }\n        else if ($key > $ar[$mid2]) \n        {\n\n            // The key lies in between mid2 and r\n            return ternarySearch($mid2 + 1, $r,     \n                                 $key, $ar);\n        }\n        else\n        {\n\n            // The key lies in between mid1 and mid2\n            return ternarySearch($mid1 + 1, $mid2 - 1,\n                                            $key, $ar);\n        }\n    }\n\n    // Key not found\n    return -1;\n}\n\n// Driver code\n\n// Get the array\n// Sort the array if not sorted\n$ar = array( 1, 2, 3, 4, 5, \n             6, 7, 8, 9, 10 );\n\n// Starting index\n$l = 0;\n\n// end element index\n$r = 9;\n\n// Checking for 5\n\n// Key to be searched in the array\n$key = 5;\n\n// Search the key using ternarySearch\n$p = ternarySearch($l, $r, $key, $ar);\n\n// Print the result\necho \"Index of \", $key,\n     \" is \", (int)$p, \"\\n\";\n\n// Checking for 50\n\n// Key to be searched in the array\n$key = 50;\n\n// Search the key using ternarySearch\n$p = ternarySearch($l, $r, $key, $ar);\n\n// Print the result\necho \"Index of \", $key, \n     \" is \", (int)$p, \"\\n\";\n\n// This code is contributed by Arnab Kundu\n?>\nIndex of 5 is 4\nIndex of 50 is -1\n// C program to illustrate\n// iterative approach to ternary search\n\n#include <stdio.h>\n\n// Function to perform Ternary Search\nint ternarySearch(int l, int r, int key, int ar[])\n\n{\n    while (r >= l) {\n\n        // Find the mid1 and mid2\n        int mid1 = l + (r - l) / 3;\n        int mid2 = r - (r - l) / 3;\n\n        // Check if key is present at any mid\n        if (ar[mid1] == key) {\n            return mid1;\n        }\n        if (ar[mid2] == key) {\n            return mid2;\n        }\n\n        // Since key is not present at mid,\n        // check in which region it is present\n        // then repeat the Search operation\n        // in that region\n\n        if (key < ar[mid1]) {\n\n            // The key lies in between l and mid1\n            r = mid1 - 1;\n        }\n        else if (key > ar[mid2]) {\n\n            // The key lies in between mid2 and r\n            l = mid2 + 1;\n        }\n        else {\n\n            // The key lies in between mid1 and mid2\n            l = mid1 + 1;\n            r = mid2 - 1;\n        }\n    }\n\n    // Key not found\n    return -1;\n}\n\n// Driver code\nint main()\n{\n    int l, r, p, key;\n\n    // Get the array\n    // Sort the array if not sorted\n    int ar[] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };\n\n    // Starting index\n    l = 0;\n\n    // end element index\n    r = 9;\n\n    // Checking for 5\n\n    // Key to be searched in the array\n    key = 5;\n\n    // Search the key using ternarySearch\n    p = ternarySearch(l, r, key, ar);\n\n    // Print the result\n    printf(\"Index of %d is %d\\n\", key, p);\n\n    // Checking for 50\n\n    // Key to be searched in the array\n    key = 50;\n\n    // Search the key using ternarySearch\n    p = ternarySearch(l, r, key, ar);\n\n    // Print the result\n    printf(\"Index of %d is %d\", key, p);\n}\n// Java program to illustrate\n// the iterative approach to ternary search\n\nclass GFG {\n\n    // Function to perform Ternary Search\n    static int ternarySearch(int l, int r, int key, int ar[])\n\n    {\n        while (r >= l) {\n\n            // Find the mid1  mid2\n            int mid1 = l + (r - l) / 3;\n            int mid2 = r - (r - l) / 3;\n\n            // Check if key is present at any mid\n            if (ar[mid1] == key) {\n                return mid1;\n            }\n            if (ar[mid2] == key) {\n                return mid2;\n            }\n\n            // Since key is not present at mid,\n            // check in which region it is present\n            // then repeat the Search operation\n            // in that region\n\n            if (key < ar[mid1]) {\n\n                // The key lies in between l and mid1\n                r = mid1 - 1;\n            }\n            else if (key > ar[mid2]) {\n\n                // The key lies in between mid2 and r\n                l = mid2 + 1;\n            }\n            else {\n\n                // The key lies in between mid1 and mid2\n                l = mid1 + 1;\n                r = mid2 - 1;\n            }\n        }\n\n        // Key not found\n        return -1;\n    }\n\n    // Driver code\n    public static void main(String args[])\n    {\n        int l, r, p, key;\n\n        // Get the array\n        // Sort the array if not sorted\n        int ar[] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };\n\n        // Starting index\n        l = 0;\n\n        // end element index\n        r = 9;\n\n        // Checking for 5\n\n        // Key to be searched in the array\n        key = 5;\n\n        // Search the key using ternarySearch\n        p = ternarySearch(l, r, key, ar);\n\n        // Print the result\n        System.out.println(\"Index of \" + key + \" is \" + p);\n\n        // Checking for 50\n\n        // Key to be searched in the array\n        key = 50;\n\n        // Search the key using ternarySearch\n        p = ternarySearch(l, r, key, ar);\n\n        // Print the result\n        System.out.println(\"Index of \" + key + \" is \" + p);\n    }\n}\n# Python 3 program to illustrate iterative\n# approach to ternary search\n\n# Function to perform Ternary Search\ndef ternarySearch(l, r, key, ar):\n    while r >= l:\n        \n        # Find mid1 and mid2\n        mid1 = l + (r-l) // 3\n        mid2 = r - (r-l) // 3\n\n        # Check if key is at any mid\n        if key == ar[mid1]:\n            return mid1\n        if key == ar[mid2]:\n            return mid2\n\n        # Since key is not present at mid, \n        # Check in which region it is present\n        # Then repeat the search operation in that region\n        if key < ar[mid1]:\n            # key lies between l and mid1\n            r = mid1 - 1\n        elif key > ar[mid2]:\n            # key lies between mid2 and r\n            l = mid2 + 1\n        else:\n            # key lies between mid1 and mid2\n            l = mid1 + 1\n            r = mid2 - 1\n\n    # key not found\n    return -1\n\n# Driver code\n\n# Get the list\n# Sort the list if not sorted\nar = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\n# Starting index\nl = 0\n\n# end element index\nr = 9\n\n# Checking for 5\n# Key to be searched in the list\nkey = 5\n\n# Search the key using ternary search\np = ternarySearch(l, r, key, ar)\n\n# Print the result\nprint(\"Index of\", key, \"is\", p)\n\n# Checking for 50\n# Key to be searched in the list\nkey = 50\n\n# Search the key using ternary search\np = ternarySearch(l, r, key, ar)\n\n# Print the result\nprint(\"Index of\", key, \"is\", p)\n\n# This code has been contributed by Sujal Motagi\n// C# program to illustrate the iterative\n// approach to ternary search\nusing System;\n\npublic class GFG {\n\n    // Function to perform Ternary Search\n    static int ternarySearch(int l, int r,\n                             int key, int[] ar)\n\n    {\n        while (r >= l) {\n\n            // Find the mid1 and mid2\n            int mid1 = l + (r - l) / 3;\n            int mid2 = r - (r - l) / 3;\n\n            // Check if key is present at any mid\n            if (ar[mid1] == key) {\n                return mid1;\n            }\n            if (ar[mid2] == key) {\n                return mid2;\n            }\n\n            // Since key is not present at mid,\n            // check in which region it is present\n            // then repeat the Search operation\n            // in that region\n\n            if (key < ar[mid1]) {\n\n                // The key lies in between l and mid1\n                r = mid1 - 1;\n            }\n            else if (key > ar[mid2]) {\n\n                // The key lies in between mid2 and r\n                l = mid2 + 1;\n            }\n            else {\n\n                // The key lies in between mid1 and mid2\n                l = mid1 + 1;\n                r = mid2 - 1;\n            }\n        }\n\n        // Key not found\n        return -1;\n    }\n\n    // Driver code\n    public static void Main(String[] args)\n    {\n        int l, r, p, key;\n\n        // Get the array\n        // Sort the array if not sorted\n        int[] ar = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };\n\n        // Starting index\n        l = 0;\n\n        // end element index\n        r = 9;\n\n        // Checking for 5\n\n        // Key to be searched in the array\n        key = 5;\n\n        // Search the key using ternarySearch\n        p = ternarySearch(l, r, key, ar);\n\n        // Print the result\n        Console.WriteLine(\"Index of \" + key + \" is \" + p);\n\n        // Checking for 50\n\n        // Key to be searched in the array\n        key = 50;\n\n        // Search the key using ternarySearch\n        p = ternarySearch(l, r, key, ar);\n\n        // Print the result\n        Console.WriteLine(\"Index of \" + key + \" is \" + p);\n    }\n}\n\n// This code has been contributed by 29AjayKumar\n<script>\n\n    // JavaScript program to illustrate the iterative\n    // approach to ternary search\n    \n    // Function to perform Ternary Search\n    function ternarySearch(l, r, key, ar)\n \n    {\n        while (r >= l) {\n \n            // Find the mid1 and mid2\n            let mid1 = l + parseInt((r - l) / 3, 10);\n            let mid2 = r - parseInt((r - l) / 3, 10);\n \n            // Check if key is present at any mid\n            if (ar[mid1] == key) {\n                return mid1;\n            }\n            if (ar[mid2] == key) {\n                return mid2;\n            }\n \n            // Since key is not present at mid,\n            // check in which region it is present\n            // then repeat the Search operation\n            // in that region\n \n            if (key < ar[mid1]) {\n \n                // The key lies in between l and mid1\n                r = mid1 - 1;\n            }\n            else if (key > ar[mid2]) {\n \n                // The key lies in between mid2 and r\n                l = mid2 + 1;\n            }\n            else {\n \n                // The key lies in between mid1 and mid2\n                l = mid1 + 1;\n                r = mid2 - 1;\n            }\n        }\n \n        // Key not found\n        return -1;\n    }\n    \n    let l, r, p, key;\n \n    // Get the array\n    // Sort the array if not sorted\n    let ar = [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ];\n\n    // Starting index\n    l = 0;\n\n    // end element index\n    r = 9;\n\n    // Checking for 5\n\n    // Key to be searched in the array\n    key = 5;\n\n    // Search the key using ternarySearch\n    p = ternarySearch(l, r, key, ar);\n\n    // Print the result\n    document.write(\"Index of \" + key + \" is \" + p + \"</br>\");\n\n    // Checking for 50\n\n    // Key to be searched in the array\n    key = 50;\n\n    // Search the key using ternarySearch\n    p = ternarySearch(l, r, key, ar);\n\n    // Print the result\n    document.write(\"Index of \" + key + \" is \" + p);\n    \n</script>\n<?php\n\n// Function to perform Ternary Search\nfunction ternarySearch(int $l, int $r, int $key, array $ar): int\n{\n    while ($r >= $l) {\n\n        // Find the mid1  mid2\n        $mid1 = $l + (int) (($r - $l) / 3);\n        $mid2 = $r - (int) (($r - $l) / 3);\n\n        // Check if key is present at any mid\n        if ($ar[$mid1] == $key) {\n            return $mid1;\n        }\n        if ($ar[$mid2] == $key) {\n            return $mid2;\n        }\n\n        // Since key is not present at mid,\n        // check in which region it is present\n        // then repeat the Search operation\n        // in that region\n\n        if ($key < $ar[$mid1]) {\n\n            // The key lies in between l and mid1\n            $r = $mid1 - 1;\n        } elseif ($key > $ar[$mid2]) {\n\n            // The key lies in between mid2 and r\n            $l = $mid2 + 1;\n        } else {\n\n            // The key lies in between mid1 and mid2\n            $l = $mid1 + 1;\n            $r = $mid2 - 1;\n        }\n    }\n\n    // Key not found\n    return -1;\n}\n\n// Get the array\n// Sort the array if not sorted\n$ar = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n\n// Starting index\n$l = 0;\n\n// end element index\n$r = 9;\n\n// Checking for 5\n\n// Key to be searched in the array\n$key = 5;\n\n// Search the key using ternarySearch\n$p = ternarySearch($l, $r, $key, $ar);\n\n// Print the result\necho \"Index of $key is $p\\n\";\n\n// Checking for 50\n\n// Key to be searched in the array\n$key = 50;\n\n// Search the key using ternarySearch\n$p = ternarySearch($l, $r, $key, $ar);\n\n// Print the result\necho \"Index of $key is $p\\n\";\n//This code is contributed by faizan sayeed\n?>\n// C++ program to illustrate\n// iterative approach to ternary search\n\n#include <iostream>\nusing namespace std;\n\n// Function to perform Ternary Search\nint ternarySearch(int l, int r, int key, int ar[])\n\n{\n    while (r >= l) {\n\n        // Find the mid1 and mid2\n        int mid1 = l + (r - l) / 3;\n        int mid2 = r - (r - l) / 3;\n\n        // Check if key is present at any mid\n        if (ar[mid1] == key) {\n            return mid1;\n        }\n        if (ar[mid2] == key) {\n            return mid2;\n        }\n\n        // Since key is not present at mid,\n        // check in which region it is present\n        // then repeat the Search operation\n        // in that region\n\n        if (key < ar[mid1]) {\n\n            // The key lies in between l and mid1\n            r = mid1 - 1;\n        }\n        else if (key > ar[mid2]) {\n\n            // The key lies in between mid2 and r\n            l = mid2 + 1;\n        }\n        else {\n\n            // The key lies in between mid1 and mid2\n            l = mid1 + 1;\n            r = mid2 - 1;\n        }\n    }\n\n    // Key not found\n    return -1;\n}\n\n// Driver code\nint main()\n{\n    int l, r, p, key;\n\n    // Get the array\n    // Sort the array if not sorted\n    int ar[] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };\n\n    // Starting index\n    l = 0;\n\n    // end element index\n    r = 9;\n\n    // Checking for 5\n\n    // Key to be searched in the array\n    key = 5;\n\n    // Search the key using ternarySearch\n    p = ternarySearch(l, r, key, ar);\n\n    // Print the result\n    cout << \"Index of \"<<key<<\" is \" << p << endl;\n\n    // Checking for 50\n\n    // Key to be searched in the array\n    key = 50;\n\n    // Search the key using ternarySearch\n    p = ternarySearch(l, r, key, ar);\n\n    // Print the result\n    cout << \"Index of \"<<key<<\" is \" << p;\n}\nIndex of 5 is 4\nIndex of 50 is -1\n",
        "complexity": {
            "time": "Note: We can also use ternary search for monotonic functions but the time complexity will be slightly higher as compared to binary search.",
            "space": ""
        },
        "tags": [
            "Searching"
        ],
        "url": "https://www.geeksforgeeks.org/ternary-search/"
    },
    {
        "title": "Jump Search",
        "description": "Like Binary Search, Jump Search is a searching algorithm for sorted arrays. The basic idea is to check fewer elements (than linear search) by jumping ahead by fixed steps or skipping some elements in place of searching all elements.For example, suppose we have an array arr[] of size n and a block (to be jumped) of size m. Then we search in the indexes arr[0], arr[m], arr[2m]…..arr[km], and so on. Once we find the interval (arr[km] < x < arr[(k+1)m]), we perform a linear search operation from the index km to find the element x.Let’s consider the following array: (0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610). The length of the array is 16. The Jump search will find the value of 55 with the following steps assuming that the block size to be jumped is 4. STEP 1: Jump from index 0 to index 4; STEP 2: Jump from index 4 to index 8; STEP 3: Jump from index 8 to index 12; STEP 4: Since the element at index 12 is greater than 55, we will jump back a step to come to index 8. STEP 5: Perform a linear search from index 8 to get the element 55. If we compare it with linear and binary search then it comes out then it is better than linear search but not better than binary search. The increasing order of performance is: linear search  <  jump search  <  binary search What is the optimal block size to be skipped? In the worst case, we have to do n/m jumps, and if the last checked value is greater than the element to be searched for, we perform m-1 comparisons more for linear search. Therefore, the total number of comparisons in the worst case will be ((n/m) + m-1). The value of the function ((n/m) + m-1) will be minimum when m = ?n. Therefore, the best step size is m = ?n.                      Output: Time Complexity : O(?n) Auxiliary Space : O(1) Important points: References: https://en.wikipedia.org/wiki/Jump_search If you like GeeksforGeeks and would like to contribute, you can also write an article using write.geeksforgeeks.org or mail your article to review-team@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks.Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above. H  ",
        "code": "\n\n\n\n\n\n\n\n\n\n\n\n\n\nNumber 55 is at index 10\n",
        "complexity": {
            "time": "Time Complexity : O(?n) Auxiliary Space : O(1)",
            "space": ""
        },
        "tags": [
            "Searching"
        ],
        "url": "https://www.geeksforgeeks.org/jump-search/"
    },
    {
        "title": "Sentinel Linear Search",
        "description": "Sentinel Linear Search as the name suggests is a type of Linear Search where the number of comparisons is reduced as compared to a traditional linear search. In a traditional linear search, only N comparisons are made, and in a Sentinel Linear Search, the sentinel value is used to avoid any out-of-bounds comparisons, but there is no additional comparison made specifically for the index of the element being searched.In this search, the last element of the array is replaced with the element to be searched and then the linear search is performed on the array without checking whether the current index is inside the index range of the array or not because the element to be searched will definitely be found inside the array even if it was not present in the original array since the last element got replaced with it. So, the index to be checked will never be out of the bounds of the array. The number of comparisons in the worst case there will be (N + 2). Although in worst-case time complexity both algorithms are O(n). Only the number of comparisons are less in sentinel linear search than linear search The basic idea of Sentinel Linear Search is to add an extra element at the end of the array (i.e., the sentinel value) that matches the search key. By doing so, we can avoid the conditional check for the end of the array in the loop and terminate the search early, as soon as we find the sentinel element. This eliminates the need for a separate check for the end of the array, resulting in a slight improvement in the average case performance of the algorithm. Here are the steps for Sentinel Linear Search algorithm: The key benefit of the Sentinel Linear Search algorithm is that it eliminates the need for a separate check for the end of the array, which can improve the average case performance of the algorithm. However, it does not improve the worst-case performance, which is still O(n) (where n is the size of the array), as we may need to scan the entire array to find the sentinel value.Examples: Input: arr[] = {10, 20, 180, 30, 60, 50, 110, 100, 70}, x = 180 Output: 180 is present at index 2Input: arr[] = {10, 20, 180, 30, 60, 50, 110, 100, 70}, x = 90 Output: Not found Below is the implementation of the above approach: Time Complexity: O(N)Auxiliary Space: O(1)  ",
        "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n// Function to search x in the given vector\nint sentinelSearch(vector<int>& arr, int key) {\n  \n    // Last element of the vector\n    int last = arr.back();\n\n    // Element to be searched is placed at the last index\n    arr.back() = key;\n    int i = 0;\n    while (arr[i] != key)\n        i++;\n\n    // Put the last element back\n    arr.back() = last;\n\n    // Return the index if found, otherwise return -1\n    if ((i < arr.size() - 1) || (arr.back() == key))\n        return i;\n    else\n        return -1;\n}\n\nint main() {\n    vector<int> arr = { 10, 20, 180, 30, 60, 50, 110, 100, 70 };\n    int key = 180;\n    int result = sentinelSearch(arr, key);\n    if (result != -1)\n        cout << key << \" is present at index \" << result;\n    else\n        cout << \"Element not found\";\n\n    return 0;\n}\n#include <stdio.h>\n\n// Function to search key in the given array\nint sentinelSearch(int arr[], int n, int key) {\n  \n    // Last element of the array\n    int last = arr[n - 1];\n\n    // Element to be searched is placed at the last index\n    arr[n - 1] = key;\n    int i = 0;\n\n    // Loop to find the element\n    while (arr[i] != key)\n        i++;\n\n    // Put the last element back\n    arr[n - 1] = last;\n\n    // Return the index if found, otherwise return -1\n    if ((i < n - 1) || (arr[n - 1] == key))\n        return i;\n    else\n        return -1;\n}\n\nint main() {\n    int arr[] = {10, 20, 180, 30, 60, 50, 110, 100, 70};\n    int n = sizeof(arr) / sizeof(arr[0]);\n    int key = 180;\n\n    int result = sentinelSearch(arr, n, key);\n\n    if (result != -1)\n        printf(\"%d is present at index %d\\n\", key, result);\n    else\n        printf(\"Element not found\\n\");\n\n    return 0;\n}\n// Java implementation of the approach\nclass GFG {\n\n    // Function to search x in the given array\n    static void sentinelSearch(int arr[], int n, int key)\n    {\n\n        // Last element of the array\n        int last = arr[n - 1];\n\n        // Element to be searched is\n        // placed at the last index\n        arr[n - 1] = key;\n        int i = 0;\n\n        while (arr[i] != key)\n            i++;\n\n        // Put the last element back\n        arr[n - 1] = last;\n\n        if ((i < n - 1) || (arr[n - 1] == key))\n            System.out.println(key + \" is present at index \"\n                               + i);\n        else\n            System.out.println(\"Element Not found\");\n    }\n\n    // Driver code\n    public static void main(String[] args)\n    {\n        int arr[]\n            = { 10, 20, 180, 30, 60, 50, 110, 100, 70 };\n        int n = arr.length;\n        int key = 180;\n\n        sentinelSearch(arr, n, key);\n    }\n}\n\n// This code is contributed by Ankit Rai, Mandeep Dalavi\n# Python3 implementation of the approach\n# Function to search key in the given array\n\n\ndef sentinelSearch(arr, n, key):\n\n    # Last element of the array\n    last = arr[n - 1]\n\n    # Element to be searched is\n    # placed at the last index\n    arr[n - 1] = key\n    i = 0\n\n    while (arr[i] != key):\n        i += 1\n\n    # Put the last element back\n    arr[n - 1] = last\n\n    if ((i < n - 1) or (arr[n - 1] == key)):\n        print(key, \"is present at index\", i)\n    else:\n        print(\"Element Not found\")\n\n\n# Driver code\narr = [10, 20, 180, 30, 60, 50, 110, 100, 70]\nn = len(arr)\nkey = 180\n\nsentinelSearch(arr, n, key)\n\n# This code is contributed by divyamohan123, Mandeep Dalavi\n// C# implementation of the approach\nusing System;\n\nclass GFG {\n\n    // Function to search x in the given array\n    static void sentinelSearch(int[] arr, int n, int key)\n    {\n\n        // Last element of the array\n        int last = arr[n - 1];\n\n        // Element to be searched is\n        // placed at the last index\n        arr[n - 1] = key;\n        int i = 0;\n\n        while (arr[i] != key)\n            i++;\n\n        // Put the last element back\n        arr[n - 1] = last;\n\n        if ((i < n - 1) || (arr[n - 1] == key))\n            Console.WriteLine(key + \" is present\"\n                              + \" at index \" + i);\n        else\n            Console.WriteLine(\"Element Not found\");\n    }\n\n    // Driver code\n    public static void Main()\n    {\n        int[] arr\n            = { 10, 20, 180, 30, 60, 50, 110, 100, 70 };\n        int n = arr.Length;\n        int key = 180;\n\n        sentinelSearch(arr, n, key);\n    }\n}\n\n// This code is contributed by Mohit kumar, Mandeep Dalavi\n<script>\n// javascript implementation of the approach    \n// Function to search x in the given array\n    function sentinelSearch(arr , n , key) {\n\n        // Last element of the array\n        var last = arr[n - 1];\n\n        // Element to be searched is\n        // placed at the last index\n        arr[n - 1] = key;\n        var i = 0;\n\n        while (arr[i] != key)\n            i++;\n\n        // Put the last element back\n        arr[n - 1] = last;\n\n        if ((i < n - 1) || (arr[n - 1] == key))\n            document.write(key + \" is present at index \" + i);\n        else\n            document.write(\"Element Not found\");\n    }\n\n    // Driver code\n    \n        var arr = [ 10, 20, 180, 30, 60, 50, 110, 100, 70 ];\n        var n = arr.length;\n        var key = 180;\n\n        sentinelSearch(arr, n, key);\n\n// This code is contributed by todaysgaurav \n</script>\n180 is present at index 2\n",
        "complexity": {
            "time": "Time Complexity: O(N)Auxiliary Space: O(1)",
            "space": ""
        },
        "tags": [
            "Searching"
        ],
        "url": "https://www.geeksforgeeks.org/sentinel-linear-search/"
    },
    {
        "title": "Interpolation Search",
        "description": "Given a sorted array of n uniformly distributed values arr[], write a function to search for a particular element x in the array. Linear Search finds the element in O(n) time, Jump Search takes O(n) time and Binary Search takes O(log n) time. The Interpolation Search is an improvement over Binary Search for instances, where the values in a sorted array are uniformly distributed. Interpolation constructs new data points within the range of a discrete set of known data points. Binary Search always goes to the middle element to check. On the other hand, interpolation search may go to different locations according to the value of the key being searched. For example, if the value of the key is closer to the last element, interpolation search is likely to start search toward the end side.To find the position to be searched, it uses the following formula. // The idea of formula is to return higher value of pos// when element to be searched is closer to arr[hi]. And// smaller value when closer to arr[lo] arr[] ==> Array where elements need to be searched x     ==> Element to be searched lo    ==> Starting index in arr[] hi    ==> Ending index in arr[] [Tex]pos = lo + [ \\frac{(x-arr[lo])*(hi-lo) }{ (arr[hi]-arr[Lo]) }]               [/Tex] There are many different interpolation methods and one such is known as linear interpolation. Linear interpolation takes two data points which we assume as (x1,y1) and (x2,y2) and the formula is :  at point(x,y). This algorithm works in a way we search for a word in a dictionary. The interpolation search algorithm improves the binary search algorithm.  The formula for finding a value is: K = data-low/high-low. K is a constant which is used to narrow the search space. In the case of binary search, the value for this constant is: K=(low+high)/2.  The formula for pos can be derived as follows. Let's assume that the elements of the array are linearly distributed. General equation of line : y = m*x + c.y is the value in the array and x is its index.Now putting value of lo,hi and x in the equationarr[hi] = m*hi+c ----(1)arr[lo] = m*lo+c ----(2)x = m*pos + c     ----(3)m = (arr[hi] - arr[lo] )/ (hi - lo)subtracting eqxn (2) from (3)x - arr[lo] = m * (pos - lo)lo + (x - arr[lo])/m = pospos = lo + (x - arr[lo]) *(hi - lo)/(arr[hi] - arr[lo]) Algorithm The rest of the Interpolation algorithm is the same except for the above partition logic. Below is the implementation of the algorithm. Time Complexity: O(log2(log2 n)) for the average case, and O(n) for the worst case Auxiliary Space Complexity: O(1) This is the iteration approach for the interpolation search. Below is the implementation of the algorithm. Time Complexity: O(log2(log2 n)) for the average case, and O(n) for the worst case Auxiliary Space Complexity: O(1)  A  ",
        "code": "// C++ program to implement interpolation\n// search with recursion\n#include <bits/stdc++.h>\nusing namespace std;\n\n// If x is present in arr[0..n-1], then returns\n// index of it, else returns -1.\nint interpolationSearch(int arr[], int lo, int hi, int x)\n{\n    int pos;\n\n    // Since array is sorted, an element present\n    // in array must be in range defined by corner\n    if (lo <= hi && x >= arr[lo] && x <= arr[hi]) {\n\n        // Probing the position with keeping\n        // uniform distribution in mind.\n        pos = lo\n              + (((double)(hi - lo) / (arr[hi] - arr[lo]))\n                 * (x - arr[lo]));\n\n        // Condition of target found\n        if (arr[pos] == x)\n            return pos;\n\n        // If x is larger, x is in right sub array\n        if (arr[pos] < x)\n            return interpolationSearch(arr, pos + 1, hi, x);\n\n        // If x is smaller, x is in left sub array\n        if (arr[pos] > x)\n            return interpolationSearch(arr, lo, pos - 1, x);\n    }\n    return -1;\n}\n\n// Driver Code\nint main()\n{\n\n    // Array of items on which search will\n    // be conducted.\n    int arr[] = { 10, 12, 13, 16, 18, 19, 20, 21,\n                  22, 23, 24, 33, 35, 42, 47 };\n\n    int n = sizeof(arr) / sizeof(arr[0]);\n\n    // Element to be searched\n    int x = 18;\n    int index = interpolationSearch(arr, 0, n - 1, x);\n\n    // If element was found\n    if (index != -1)\n        cout << \"Element found at index \" << index;\n    else\n        cout << \"Element not found.\";\n\n    return 0;\n}\n\n// This code is contributed by equbalzeeshan\n// C program to implement interpolation search\n// with recursion\n#include <stdio.h>\n\n// If x is present in arr[0..n-1], then returns\n// index of it, else returns -1.\nint interpolationSearch(int arr[], int lo, int hi, int x)\n{\n    int pos;\n    // Since array is sorted, an element present\n    // in array must be in range defined by corner\n    if (lo <= hi && x >= arr[lo] && x <= arr[hi]) {\n        // Probing the position with keeping\n        // uniform distribution in mind.\n        pos = lo\n              + (((double)(hi - lo) / (arr[hi] - arr[lo]))\n                 * (x - arr[lo]));\n\n        // Condition of target found\n        if (arr[pos] == x)\n            return pos;\n\n        // If x is larger, x is in right sub array\n        if (arr[pos] < x)\n            return interpolationSearch(arr, pos + 1, hi, x);\n\n        // If x is smaller, x is in left sub array\n        if (arr[pos] > x)\n            return interpolationSearch(arr, lo, pos - 1, x);\n    }\n    return -1;\n}\n\n// Driver Code\nint main()\n{\n    // Array of items on which search will\n    // be conducted.\n    int arr[] = { 10, 12, 13, 16, 18, 19, 20, 21,\n                  22, 23, 24, 33, 35, 42, 47 };\n    int n = sizeof(arr) / sizeof(arr[0]);\n\n    int x = 18; // Element to be searched\n    int index = interpolationSearch(arr, 0, n - 1, x);\n\n    // If element was found\n    if (index != -1)\n        printf(\"Element found at index %d\", index);\n    else\n        printf(\"Element not found.\");\n    return 0;\n}\n// Java program to implement interpolation\n// search with recursion\nimport java.util.*;\n\nclass GFG {\n\n    // If x is present in arr[0..n-1], then returns\n    // index of it, else returns -1.\n    public static int interpolationSearch(int arr[], int lo,\n                                          int hi, int x)\n    {\n        int pos;\n\n        // Since array is sorted, an element\n        // present in array must be in range\n        // defined by corner\n        if (lo <= hi && x >= arr[lo] && x <= arr[hi]) {\n\n            // Probing the position with keeping\n            // uniform distribution in mind.\n            pos = lo\n                  + (((hi - lo) / (arr[hi] - arr[lo]))\n                     * (x - arr[lo]));\n\n            // Condition of target found\n            if (arr[pos] == x)\n                return pos;\n\n            // If x is larger, x is in right sub array\n            if (arr[pos] < x)\n                return interpolationSearch(arr, pos + 1, hi,\n                                           x);\n\n            // If x is smaller, x is in left sub array\n            if (arr[pos] > x)\n                return interpolationSearch(arr, lo, pos - 1,\n                                           x);\n        }\n        return -1;\n    }\n\n    // Driver Code\n    public static void main(String[] args)\n    {\n\n        // Array of items on which search will\n        // be conducted.\n        int arr[] = { 10, 12, 13, 16, 18, 19, 20, 21,\n                      22, 23, 24, 33, 35, 42, 47 };\n\n        int n = arr.length;\n\n        // Element to be searched\n        int x = 18;\n        int index = interpolationSearch(arr, 0, n - 1, x);\n\n        // If element was found\n        if (index != -1)\n            System.out.println(\"Element found at index \"\n                               + index);\n        else\n            System.out.println(\"Element not found.\");\n    }\n}\n\n// This code is contributed by equbalzeeshan\n# Python3 program to implement\n# interpolation search\n# with recursion\n\n# If x is present in arr[0..n-1], then\n# returns index of it, else returns -1.\n\n\ndef interpolationSearch(arr, lo, hi, x):\n\n    # Since array is sorted, an element present\n    # in array must be in range defined by corner\n    if (lo <= hi and x >= arr[lo] and x <= arr[hi]):\n\n        # Probing the position with keeping\n        # uniform distribution in mind.\n        pos = lo + ((hi - lo) // (arr[hi] - arr[lo]) *\n                    (x - arr[lo]))\n\n        # Condition of target found\n        if arr[pos] == x:\n            return pos\n\n        # If x is larger, x is in right subarray\n        if arr[pos] < x:\n            return interpolationSearch(arr, pos + 1,\n                                       hi, x)\n\n        # If x is smaller, x is in left subarray\n        if arr[pos] > x:\n            return interpolationSearch(arr, lo,\n                                       pos - 1, x)\n    return -1\n\n# Driver code\n\n\n# Array of items in which\n# search will be conducted\narr = [10, 12, 13, 16, 18, 19, 20,\n       21, 22, 23, 24, 33, 35, 42, 47]\nn = len(arr)\n\n# Element to be searched\nx = 18\nindex = interpolationSearch(arr, 0, n - 1, x)\n\nif index != -1:\n    print(\"Element found at index\", index)\nelse:\n    print(\"Element not found\")\n\n# This code is contributed by Hardik Jain\n// C# program to implement \n// interpolation search\nusing System;\n\nclass GFG{\n\n// If x is present in \n// arr[0..n-1], then \n// returns index of it, \n// else returns -1.\nstatic int interpolationSearch(int []arr, int lo, \n                               int hi, int x)\n{\n    int pos;\n    \n    // Since array is sorted, an element\n    // present in array must be in range\n    // defined by corner\n    if (lo <= hi && x >= arr[lo] && \n                    x <= arr[hi])\n    {\n        \n        // Probing the position \n        // with keeping uniform \n        // distribution in mind.\n        pos = lo + (((hi - lo) / \n                (arr[hi] - arr[lo])) * \n                      (x - arr[lo]));\n\n        // Condition of \n        // target found\n        if(arr[pos] == x) \n        return pos; \n        \n        // If x is larger, x is in right sub array \n        if(arr[pos] < x) \n            return interpolationSearch(arr, pos + 1,\n                                       hi, x); \n        \n        // If x is smaller, x is in left sub array \n        if(arr[pos] > x) \n            return interpolationSearch(arr, lo, \n                                       pos - 1, x); \n    } \n    return -1;\n}\n\n// Driver Code \npublic static void Main() \n{\n    \n    // Array of items on which search will \n    // be conducted. \n    int []arr = new int[]{ 10, 12, 13, 16, 18, \n                           19, 20, 21, 22, 23, \n                           24, 33, 35, 42, 47 };\n                           \n    // Element to be searched                       \n    int x = 18; \n    int n = arr.Length;\n    int index = interpolationSearch(arr, 0, n - 1, x);\n    \n    // If element was found\n    if (index != -1)\n        Console.WriteLine(\"Element found at index \" + \n                           index);\n    else\n        Console.WriteLine(\"Element not found.\");\n}\n}\n\n// This code is contributed by equbalzeeshan\n<script>\n// Javascript program to implement Interpolation Search\n\n// If x is present in arr[0..n-1], then returns\n// index of it, else returns -1.\n\nfunction interpolationSearch(arr, lo, hi, x){\n  let pos;\n  \n  // Since array is sorted, an element present\n  // in array must be in range defined by corner\n  \n  if (lo <= hi && x >= arr[lo] && x <= arr[hi]) {\n    \n    // Probing the position with keeping\n    // uniform distribution in mind.\n    pos = lo + Math.floor(((hi - lo) / (arr[hi] - arr[lo])) * (x - arr[lo]));;\n    \n    // Condition of target found\n        if (arr[pos] == x){\n          return pos;\n        }\n \n        // If x is larger, x is in right sub array\n        if (arr[pos] < x){\n          return interpolationSearch(arr, pos + 1, hi, x);\n        }\n \n        // If x is smaller, x is in left sub array\n        if (arr[pos] > x){\n          return interpolationSearch(arr, lo, pos - 1, x);\n        }\n    }\n    return -1;\n}\n\n// Driver Code\nlet arr = [10, 12, 13, 16, 18, 19, 20, 21, \n           22, 23, 24, 33, 35, 42, 47];\n\nlet n = arr.length;\n\n// Element to be searched\nlet x = 18\nlet index = interpolationSearch(arr, 0, n - 1, x);\n\n// If element was found\nif (index != -1){\n   document.write(`Element found at index ${index}`)\n}else{\n   document.write(\"Element not found\");\n}\n\n// This code is contributed by _saurabh_jaiswal\n</script>\n<?php\n// PHP program to implement $erpolation search\n// with recursion\n\n// If x is present in arr[0..n-1], then returns\n// index of it, else returns -1.\nfunction interpolationSearch($arr, $lo, $hi, $x)\n{\n    // Since array is sorted, an element present\n    // in array must be in range defined by corner\n    if ($lo <= $hi && $x >= $arr[$lo] && $x <= $arr[$hi]) {\n        // Probing the position with keeping\n        // uniform distribution in mind.\n        $pos = (int)($lo\n                     + (((double)($hi - $lo)\n                         / ($arr[$hi] - $arr[$lo]))\n                        * ($x - $arr[$lo])));\n\n        // Condition of target found\n        if ($arr[$pos] == $x)\n            return $pos;\n\n        // If x is larger, x is in right sub array\n        if ($arr[$pos] < $x)\n            return interpolationSearch($arr, $pos + 1, $hi,\n                                       $x);\n\n        // If x is smaller, x is in left sub array\n        if ($arr[$pos] > $x)\n            return interpolationSearch($arr, $lo, $pos - 1,\n                                       $x);\n    }\n    return -1;\n}\n\n// Driver Code\n// Array of items on which search will\n// be conducted.\n$arr = array(10, 12, 13, 16, 18, 19, 20, 21, 22, 23, 24, 33,\n             35, 42, 47);\n$n = sizeof($arr);\n\n$x = 47; // Element to be searched\n$index = interpolationSearch($arr, 0, $n - 1, $x);\n\n// If element was found\nif ($index != -1)\n    echo \"Element found at index \".$index;\nelse\n    echo \"Element not found.\";\nreturn 0;\n#This code is contributed by Susobhan Akhuli\n?>\nElement found at index 4\n// C++ program to implement interpolation search by using iteration approach\n#include<bits/stdc++.h>\nusing namespace std;\n  \nint interpolationSearch(int arr[], int n, int x)\n{\n    // Find indexes of two corners\n    int low = 0, high = (n - 1);\n    // Since array is sorted, an element present\n    // in array must be in range defined by corner\n    while (low <= high && x >= arr[low] && x <= arr[high])\n    {\n        if (low == high)\n        {if (arr[low] == x) return low;\n        return -1;\n        }\n        // Probing the position with keeping\n        // uniform distribution in mind.\n        int pos = low + (((double)(high - low) /\n            (arr[high] - arr[low])) * (x - arr[low]));\n  \n        // Condition of target found\n        if (arr[pos] == x)\n            return pos;\n        // If x is larger, x is in upper part\n        if (arr[pos] < x)\n            low = pos + 1;\n        // If x is smaller, x is in the lower part\n        else\n            high = pos - 1;\n    }\n    return -1;\n}\n  \n// Main function\nint main()\n{\n    // Array of items on whighch search will\n    // be conducted.\n    int arr[] = {10, 12, 13, 16, 18, 19, 20, 21,\n                 22, 23, 24, 33, 35, 42, 47};\n    int n = sizeof(arr)/sizeof(arr[0]);\n  \n    int x = 18; // Element to be searched\n    int index = interpolationSearch(arr, n, x);\n  \n    // If element was found\n    if (index != -1)\n        cout << \"Element found at index \" << index;\n    else\n        cout << \"Element not found.\";\n    return 0;\n}\n //this code contributed by  Ajay Singh\n// Java program to implement interpolation\n// search with recursion\nimport java.util.*;\n\nclass GFG {\n\n    // If x is present in arr[0..n-1], then returns\n    // index of it, else returns -1.\n    public static int interpolationSearch(int arr[], int lo,\n                                        int hi, int x)\n    {\n        int pos;\n\n        if (lo <= hi && x >= arr[lo] && x <= arr[hi]) {\n\n            // Probing the position with keeping\n            // uniform distribution in mind.\n            pos = lo\n                + (((hi - lo) / (arr[hi] - arr[lo]))\n                    * (x - arr[lo]));\n\n            // Condition of target found\n            if (arr[pos] == x)\n                return pos;\n\n            // If x is larger, x is in right sub array\n            if (arr[pos] < x)\n                return interpolationSearch(arr, pos + 1, hi,\n                                        x);\n\n            // If x is smaller, x is in left sub array\n            if (arr[pos] > x)\n                return interpolationSearch(arr, lo, pos - 1,\n                                        x);\n        }\n        return -1;\n    }\n\n    // Driver Code\n    public static void main(String[] args)\n    {\n\n        // Array of items on which search will\n        // be conducted.\n        int arr[] = { 10, 12, 13, 16, 18, 19, 20, 21,\n                    22, 23, 24, 33, 35, 42, 47 };\n\n        int n = arr.length;\n\n        // Element to be searched\n        int x = 18;\n        int index = interpolationSearch(arr, 0, n - 1, x);\n\n        // If element was found\n        if (index != -1)\n            System.out.println(\"Element found at index \"\n                            + index);\n        else\n            System.out.println(\"Element not found.\");\n    }\n}\n# Python equivalent of above C++ code \n# Python program to implement interpolation search by using iteration approach\ndef interpolationSearch(arr, n, x): \n  \n    # Find indexes of two corners \n    low = 0\n    high = (n - 1) \n  \n    # Since array is sorted, an element present \n    # in array must be in range defined by corner \n    while low <= high and x >= arr[low] and x <= arr[high]: \n        if low == high: \n            if arr[low] == x: \n                return low; \n            return -1; \n  \n        # Probing the position with keeping \n        # uniform distribution in mind. \n        pos = int(low + (((float(high - low)/( arr[high] - arr[low])) * (x - arr[low])))) \n  \n        # Condition of target found \n        if arr[pos] == x: \n            return pos \n  \n        # If x is larger, x is in upper part \n        if arr[pos] < x: \n            low = pos + 1; \n  \n        # If x is smaller, x is in lower part \n        else: \n            high = pos - 1; \n      \n    return -1\n  \n# Main function\nif __name__ == \"__main__\":\n    # Array of items on whighch search will \n    # be conducted.\n    arr = [10, 12, 13, 16, 18, 19, 20, 21,\n           22, 23, 24, 33, 35, 42, 47]\n    n = len(arr) \n  \n    x = 18 # Element to be searched\n    index = interpolationSearch(arr, n, x) \n  \n    # If element was found\n    if index != -1: \n        print (\"Element found at index\",index)\n    else: \n        print (\"Element not found\")\n// C# program to implement interpolation search by using\n// iteration approach\nusing System;\n\nclass Program\n{\n    // Interpolation Search function\n    static int InterpolationSearch(int[] arr, int n, int x)\n    {\n        int low = 0;\n        int high = n - 1;\n  \n        while (low <= high && x >= arr[low] && x <= arr[high]) \n        {\n            if (low == high) \n            {\n                if (arr[low] == x) \n                    return low; \n                return -1; \n            }\n  \n            int pos = low + (int)(((float)(high - low) / (arr[high] - arr[low])) * (x - arr[low]));\n  \n            if (arr[pos] == x) \n                return pos; \n  \n            if (arr[pos] < x) \n                low = pos + 1; \n  \n            else \n                high = pos - 1; \n        }\n  \n        return -1;\n    }\n  \n    // Main function\n    static void Main(string[] args)\n    {\n        int[] arr = {10, 12, 13, 16, 18, 19, 20, 21, 22, 23, 24, 33, 35, 42, 47};\n        int n = arr.Length;\n  \n        int x = 18;\n        int index = InterpolationSearch(arr, n, x);\n  \n        if (index != -1) \n            Console.WriteLine(\"Element found at index \" + index);\n        else \n            Console.WriteLine(\"Element not found\");\n    }\n}\n\n// This code is contributed by Susobhan Akhuli\n// JavaScript program to implement interpolation search by using iteration approach\n\nfunction interpolationSearch(arr, n, x) {\n// Find indexes of two corners\nlet low = 0;\nlet high = n - 1;\n\n// Since array is sorted, an element present\n// in array must be in range defined by corner\nwhile (low <= high && x >= arr[low] && x <= arr[high]) {\n    if (low == high) {\n        if (arr[low] == x) {\n            return low;\n        }\n        return -1;\n    }\n\n    // Probing the position with keeping\n    // uniform distribution in mind.\n    let pos = Math.floor(low + (((high - low) / (arr[high] - arr[low])) * (x - arr[low])));\n\n    // Condition of target found\n    if (arr[pos] == x) {\n        return pos;\n    }\n\n    // If x is larger, x is in upper part\n    if (arr[pos] < x) {\n        low = pos + 1;\n    }\n\n    // If x is smaller, x is in lower part\n    else {\n        high = pos - 1;\n    }\n}\n\nreturn -1;\n}\n// Main function\nlet arr = [10, 12, 13, 16, 18, 19, 20, 21, 22, 23, 24, 33, 35, 42, 47];\nlet n = arr.length;\n\nlet x = 18; // Element to be searched\nlet index = interpolationSearch(arr, n, x);\n\n// If element was found\nif (index != -1) {\nconsole.log(\"Element found at index\", index);\n} else {\nconsole.log(\"Element not found\");\n}\nElement found at index 4\n",
        "complexity": {
            "time": "Time Complexity: O(log2(log2 n)) for the average case, and O(n) for the worst case Auxiliary Space Complexity: O(1)",
            "space": ""
        },
        "tags": [
            "Searching"
        ],
        "url": "https://www.geeksforgeeks.org/interpolation-search/"
    },
    {
        "title": "Exponential Search",
        "description": "The name of this searching algorithm may be misleading as it works in O(Log n) time. The name comes from the way it searches an element. Given a sorted array, and an element x to be searched, find position of x in the array. Input:  arr[] = {10, 20, 40, 45, 55}        x = 45Output: Element found at index 3Input:  arr[] = {10, 15, 25, 45, 55}        x = 15Output: Element found at index 1 We have discussed, linear search, binary search for this problem. Exponential search involves two steps: How to find the range where element may be present? The idea is to start with subarray size 1, compare its last element with x, then try size 2, then 4 and so on until last element of a subarray is not greater. Once we find an index i (after repeated doubling of i), we know that the element must be present between i/2 and i (Why i/2? because we could not find a greater value in previous iteration) We start with an index i equal to 1 and repeatedly double it until either i is greater than or equal to the length of the array or the value at index i is greater than or equal to the target value x.  We then perform a binary search on the range [i/2, min(i, n-1)], where n is the length of the array. This range is guaranteed to contain the target value, if it is present in the array, because we know that the target value must be greater than or equal to the value at index i/2 and less than or equal to the value at index min(i, n-1).   If we find the target value in the binary search, we return its index. Otherwise, we return -1 to indicate that the target value is not present in the array. We mainly use recursive implementation of binary search once we find the range. We use iterative code to find the range. Here we use iterative implementation of binary search with the same approach.  P  ",
        "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint binarySearch(vector<int>& arr, int l, int r, int x);\n\n// Returns position of first occurrence of\n// x in array\nint exponentialSearch(vector<int>& arr, int n, int x)\n{\n    // If x is present at first location itself\n    if (arr[0] == x)\n        return 0;\n\n    // Find range for binary search by\n    // repeated doubling\n    int i = 1;\n    while (i < n && arr[i] <= x)\n        i = i * 2;\n\n    //  Call binary search for the found range.\n    return binarySearch(arr, i / 2, min(i, n - 1), x);\n}\n\n// A recursive binary search function. It returns\n// location of x in given array arr[l..r] is\n// present, otherwise -1\nint binarySearch(vector<int>& arr, int l, int r, int x)\n{\n    if (r >= l)\n    {\n        int mid = l + (r - l) / 2;\n\n        // If the element is present at the middle\n        // itself\n        if (arr[mid] == x)\n            return mid;\n\n        // If element is smaller than mid, then it\n        // can only be present n left subarray\n        if (arr[mid] > x)\n            return binarySearch(arr, l, mid - 1, x);\n\n        // Else the element can only be present\n        // in right subarray\n        return binarySearch(arr, mid + 1, r, x);\n    }\n\n    // We reach here when element is not present\n    // in array\n    return -1;\n}\n\n// Driver code\nint main(void)\n{\n   vector<int> arr = {2, 3, 4, 10, 40};\n   int n = arr.size();\n   int x = 10;\n   int result = exponentialSearch(arr, n, x);\n   (result == -1) ? cout << \"Element is not present in array\"\n                  : cout << \"Element is present at index \" << result;\n   return 0;\n}\n// C++ program to find an element x in a\n// sorted array using Exponential search.\n#include <stdio.h>\n#include <time.h>\n#include <math.h>\n#define min\n\nint binarySearch(int arr[], int, int, int);\n\n// Returns position of first occurrence of\n// x in array\nint exponentialSearch(int arr[], int n, int x)\n{\n    // If x is present at first location itself\n    if (arr[0] == x)\n        return 0;\n\n    // Find range for binary search by\n    // repeated doubling\n    int i = 1;\n    while (i < n && arr[i] <= x)\n        i = i*2;\n\n    //  Call binary search for the found range.\n    return binarySearch(arr, i/2, \n                            min(i, n-1), x);\n}\n\n// A recursive binary search function. It returns\n// location of x in  given array arr[l..r] is\n// present, otherwise -1\nint binarySearch(int arr[], int l, int r, int x)\n{\n    if (r >= l)\n    {\n        int mid = l + (r - l)/2;\n\n        // If the element is present at the middle\n        // itself\n        if (arr[mid] == x)\n            return mid;\n\n        // If element is smaller than mid, then it\n        // can only be present n left subarray\n        if (arr[mid] > x)\n            return binarySearch(arr, l, mid-1, x);\n\n        // Else the element can only be present\n        // in right subarray\n        return binarySearch(arr, mid+1, r, x);\n    }\n\n    // We reach here when element is not present\n    // in array\n    return -1;\n}\n\n// Driver code\nint main(void)\n{\n   int arr[] = {2, 3, 4, 10, 40};\n   int n = sizeof(arr)/ sizeof(arr[0]);\n   int x = 10;\n   int result = exponentialSearch(arr, n, x);\n   (result == -1)? printf(\"Element is not \n                            present in array\")\n                 : printf(\"Element is present \n                                 at index %d\",\n                                       result);\n   return 0;\n}\n// Java program to \n// find an element x in a\n// sorted array using \n// Exponential search.\nimport java.util.Arrays;\n\nclass GFG\n{\n    // Returns position of \n    // first occurrence of\n    // x in array\n    static int exponentialSearch(int arr[],\n                                 int n, int x)\n    {\n        // If x is present at first location itself\n        if (arr[0] == x)\n            return 0;\n    \n        // Find range for binary search by\n        // repeated doubling\n        int i = 1;\n        while (i < n && arr[i] <= x)\n            i = i*2;\n    \n        // Call binary search for the found range.\n        return Arrays.binarySearch(arr, i/2, \n                              Math.min(i, n-1), x);\n    }\n    \n    // Driver code\n    public static void main(String args[])\n    {\n        int arr[] = {2, 3, 4, 10, 40};\n        int x = 10;\n        int result = exponentialSearch(arr, \n                                  arr.length, x);\n        \n        System.out.println((result < 0) ? \n          \"Element is not present in array\" :\n          \"Element is present at index \" + \n                             result);\n    }\n}\n# Python program to find an element x\n# in a sorted array using Exponential Search\n\n# A recursive binary search function returns \n# location  of x in given array arr[l..r] is \n# present, otherwise -1\ndef binarySearch( arr, l, r, x):\n    if r >= l:\n        mid = l + ( r-l ) // 2\n        \n        # If the element is present at \n        # the middle itself\n        if arr[mid] == x:\n            return mid\n        \n        # If the element is smaller than mid, \n        # then it can only be present in the \n        # left subarray\n        if arr[mid] > x:\n            return binarySearch(arr, l, \n                                mid - 1, x)\n        \n        # Else he element can only be\n        # present in the right\n        return binarySearch(arr, mid + 1, r, x)\n        \n    # We reach here if the element is not present\n    return -1\n\n# Returns the position of first\n# occurrence of x in array\ndef exponentialSearch(arr, n, x):\n    # IF x is present at first \n    # location itself\n    if arr[0] == x:\n        return 0\n        \n    # Find range for binary search \n    # j by repeated doubling\n    i = 1\n    while i < n and arr[i] <= x:\n        i = i * 2\n    \n    # Call binary search for the found range\n    return binarySearch( arr, i // 2, \n                         min(i, n-1), x)\n    \n\n# Driver Code\narr = [2, 3, 4, 10, 40]\nn = len(arr)\nx = 10\nresult = exponentialSearch(arr, n, x)\nif result == -1:\n    print (\"Element not found in the array\")\nelse:\n    print (\"Element is present at index %d\" %(result))\n\n# This code is contributed by Harshit Agrawal\n// C# program to find an element x in a\n// sorted array using Exponential search.\nusing System;\nclass GFG {\n\n// Returns position of first\n// occurrence of x in array\nstatic int exponentialSearch(int []arr, \n                         int n, int x)\n{\n    \n    // If x is present at \n    // first location itself\n    if (arr[0] == x)\n        return 0;\n\n    // Find range for binary search \n    // by repeated doubling\n    int i = 1;\n    while (i < n && arr[i] <= x)\n        i = i * 2;\n\n    // Call binary search for\n    // the found range.\n    return binarySearch(arr, i/2, \n                       Math.Min(i, n - 1), x);\n}\n\n// A recursive binary search\n// function. It returns location\n// of x in given array arr[l..r] is\n// present, otherwise -1\nstatic int binarySearch(int []arr, int l,\n                        int r, int x)\n{\n    if (r >= l)\n    {\n        int mid = l + (r - l) / 2;\n\n        // If the element is present\n        // at the middle itself\n        if (arr[mid] == x)\n            return mid;\n\n        // If element is smaller than\n        // mid, then it can only be \n        // present n left subarray\n        if (arr[mid] > x)\n            return binarySearch(arr, l, mid - 1, x);\n\n        // Else the element can only \n        // be present in right subarray\n        return binarySearch(arr, mid + 1, r, x);\n    }\n\n    // We reach here when element\n    // is not present in array\n    return -1;\n}\n\n// Driver code\npublic static void Main()\n{\n    int []arr = {2, 3, 4, 10, 40};\n    int n = arr.Length;\n    int x = 10;\n    int result = exponentialSearch(arr, n, x);\n    if (result == -1)\n            Console.Write(\"Element is not \n                          present in array\");\n        else\n            Console.Write(\"Element is \n                           present at index \" \n                                   + result);\n}\n}\n\n// This code is contributed by Smitha\n<script>\n\n// Javascript program to find an element x\n// in a sorted array using Exponential Search \n \n// A recursive binary search\n// function. It returns location\n// of x in given array arr[l..r] is\n// present, otherwise -1\nfunction binarySearch(arr, l, r, x)\n{\n    if (r >= l)\n    {\n        let mid = l + (r - l) / 2;\n \n        // If the element is present\n        // at the middle itself\n        if (arr[mid] == x)\n            return mid;\n \n        // If element is smaller than\n        // mid, then it can only be \n        // present n left subarray\n        if (arr[mid] > x)\n            return binarySearch(arr, l, mid - 1, x);\n \n        // Else the element can only \n        // be present in right subarray\n        return binarySearch(arr, mid + 1, r, x);\n    }\n \n    // We reach here when element\n    // is not present in array\n    return -1;\n}\n\n // Returns position of first\n// occurrence of x in array\nfunction exponentialSearch(arr, n, x)\n{\n     \n    // If x is present at \n    // first location itself\n    if (arr[0] == x)\n        return 0;\n \n    // Find range for binary search \n    // by repeated doubling\n    let i = 1;\n    while (i < n && arr[i] <= x)\n        i = i * 2;\n \n    // Call binary search for\n    // the found range.\n    return binarySearch(arr, i/2, \n                       Math.min(i, n - 1), x);\n}\n    \n\n// Driver Code\n    \n    let arr = [2, 3, 4, 10, 40];\n    let n = arr.length;\n    let x = 10;\n    let result = exponentialSearch(arr, n, x);\n    if (result == -1)\n         document.write(\"Element is not present in array\");\n    else\n        document.write(\"Element is present at index \" + result);\n\n</script>\n<?php\n// PHP program to find an element x in a\n// sorted array using Exponential search.\n\n// Returns position of first \n// occurrence of x in array\nfunction exponentialSearch($arr, $n, $x)\n{\n    \n    // If x is present at \n    // first location itself\n    if ($arr[0] == $x)\n        return 0;\n\n    // Find range for binary search\n    // by repeated doubling\n    $i = 1;\n    while ($i< $n and $arr[$i] <=$x)\n        $i = $i * 2;\n\n    // Call binary search \n    // for the found range.\n    return binarySearch($arr, $i / 2, \n                        min($i, $n - 1), $x);\n}\n\n// A recursive binary search\n// function. It returns location\n// of x in given array arr[l..r] is\n// present, otherwise -1\nfunction binarySearch($arr, $l, \n                      $r, $x)\n{\n    if ($r >= $l)\n    {\n        $mid = $l + ($r - $l)/2;\n\n        // If the element is\n        // present at the middle\n        // itself\n        if ($arr[$mid] == $x)\n            return $mid;\n\n        // If element is smaller\n        // than mid, then it\n        // can only be present \n        // n left subarray\n        if ($arr[$mid] > $x)\n            return binarySearch($arr, $l, \n                                $mid - 1, $x);\n\n        // Else the element \n        // can only be present\n        // in right subarray\n        return binarySearch($arr, $mid + 1,\n                                    $r, $x);\n    }\n\n    // We reach here when\n    // element is not present\n    // in array\n    return -1;\n}\n\n// Driver code\n$arr = array(2, 3, 4, 10, 40);\n$n = count($arr);\n$x = 10;\n$result = exponentialSearch($arr, $n, $x);\nif($result == -1)\n    echo \"Element is not present in array\";\nelse\n    echo \"Element is present at index \",\n                                $result;\n\n// This code is contributed by anuj_67\n?>\nElement is present at index 3\n#include<bits/stdc++.h>\nusing namespace std;\n\n\nint exponential_search(vector<int> arr,int x){\n    int n = arr.size();\n    \n    if(n == 0)\n        return -1;\n\n    // Find range for binary search by repeatedly doubling i\n    int i = 1;\n    while(i < n and arr[i] < x)\n        i *= 2;\n\n    // Perform binary search on the range [i/2, min(i, n-1)]\n    int left = i/2;\n    int right = min(i, n-1);\n    while(left <= right){\n        int mid = (left + right)/2;\n        if(arr[mid] == x) return mid;\n        else if(arr[mid] < x) left = mid + 1;\n        else right = mid - 1;\n    }\n\n    return -1;\n}\n    \n\n// Driver Code\nint main(){\n    vector<int> arr = {2, 3, 4, 10, 40};\n    int n = arr.size();\n    int x = 10;\n    int result = exponential_search(arr, x);\n    \n    if(result == -1){\n        cout << \"Element not found in the array\";\n    }\n    else{\n        cout << \"Element is present at index \" << result << endl;\n    }\n    return 0;\n}\n\n// This code is contributed by Ajay singh\n// Java implementation of above approach\nimport java.util.*;\n\nclass Main {\n  \n  // Exponential search function\n    public static int exponential_search(ArrayList<Integer> arr, int x) {\n    int n = arr.size();\n    \n    if (n == 0)\n        return -1;\n    \n    // Find range for binary search by repeatedly doubling i\n    int i = 1;\n    while (i < n && arr.get(i) < x)\n        i *= 2;\n    \n    // Perform binary search on the range [i/2, min(i, n-1)]\n    int left = i / 2;\n    int right = Math.min(i, n - 1);\n    \n    while (left <= right) {\n        int mid = (left + right) / 2;  // finding mid\n        \n        if (arr.get(mid) == x)\n            return mid;\n        else if (arr.get(mid) < x)\n            left = mid + 1;\n        else\n            right = mid - 1;\n    }\n    \n    return -1;\n}\n\n// Driver Code\npublic static void main(String[] args) {\n    ArrayList<Integer> arr = new ArrayList<>(Arrays.asList(2, 3, 4, 10, 40));\n    int n = arr.size();\n    int x = 10;\n    int result = exponential_search(arr, x);\n    \n    if (result == -1) {\n        System.out.println(\"Element not found in the array\");\n    }\n    else {\n        System.out.println(\"Element is present at index \" + result);\n    }\n}\n\n}\ndef exponential_search(arr, x):\n    n = len(arr)\n    if n == 0:\n        return -1\n\n    # Find range for binary search by repeatedly doubling i\n    i = 1\n    while i < n and arr[i] < x:\n        i *= 2\n\n    # Perform binary search on the range [i/2, min(i, n-1)]\n    left = i // 2\n    right = min(i, n-1)\n\n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] == x:\n            return mid\n        elif arr[mid] < x:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1\n\n    \n\n# Driver Code\narr = [2, 3, 4, 10, 40]\nn = len(arr)\nx = 10\nresult = exponential_search(arr, x)\nif result == -1:\n    print (\"Element not found in the array\")\nelse:\n    print (\"Element is present at index %d\" %(result))\n\n# This code is contributed by Ajay singh\n// C# Program for the above approach\n\nusing System;\nusing System.Collections.Generic;\n\nclass Program\n{\n    static int exponential_search(List<int> arr, int x)\n    {\n        int n = arr.Count;\n\n        if (n == 0)\n            return -1;\n\n        // Find range for binary search by repeatedly doubling i\n        int i = 1;\n        while (i < n && arr[i] < x)\n            i *= 2;\n\n        // Perform binary search on the range [i/2, min(i, n-1)]\n        int left = i / 2;\n        int right = Math.Min(i, n - 1);\n\n        while (left <= right)\n        {\n            int mid = (left + right) / 2;\n\n            if (arr[mid] == x) return mid;\n            else if (arr[mid] < x) left = mid + 1;\n            else right = mid - 1;\n        }\n\n        return -1;\n    }\n\n    static void Main(string[] args)\n    {\n        List<int> arr = new List<int> { 2, 3, 4, 10, 40 };\n        int n = arr.Count;\n        int x = 10;\n        int result = exponential_search(arr, x);\n\n        if (result == -1)\n        {\n            Console.WriteLine(\"Element not found in the array\");\n        }\n        else\n        {\n            Console.WriteLine(\"Element is present at index \" + result);\n        }\n    }\n}\n\n// This code is contributed by princekumaras\nfunction exponential_search(arr, x) {\n  const n = arr.length;\n  if (n == 0) { // if array is empty, return -1\n    return -1;\n  }\n\n  let i = 1;\n  while (i < n && arr[i] < x) { // Find the range for binary search by repeatedly doubling i\n    i *= 2;\n  }\n\n  const left = Math.floor(i / 2); // Set left boundary for binary search\n  const right = Math.min(i, n - 1); // Set right boundary for binary search\n\n  while (left <= right) { // Perform binary search on the range [i/2, min(i, n-1)]\n    const mid = Math.floor((left + right) / 2); // Find middle index\n    if (arr[mid] == x) { // If element is found at mid index, return mid\n      return mid;\n    } else if (arr[mid] < x) { // If element is less than mid index, search the right half of array\n      left = mid + 1;\n    } else { // If element is greater than mid index, search the left half of array\n      right = mid - 1;\n    }\n  }\n\n  return -1; // If element is not found in array, return -1\n}\n\n// Driver Code\nconst arr = [2, 3, 4, 10, 40];\nconst n = arr.length;\nconst x = 10;\nconst result = exponential_search(arr, x);\nif (result == -1) {\n  console.log(\"Element not found in the array\");\n} else {\n  console.log(`Element is present at index ${result}`);\n}\nElement is present at index 3\n",
        "complexity": {
            "time": "",
            "space": ""
        },
        "tags": [
            "Searching"
        ],
        "url": "https://www.geeksforgeeks.org/exponential-search/"
    },
    {
        "title": "Fibonacci Search",
        "description": "Given a sorted array arr[] of size n and an element x to be searched in it. Return index of x if it is present in array else return -1. Examples: Input:  arr[] = {2, 3, 4, 10, 40}, x = 10Output:  3Element x is present at index 3. Input:  arr[] = {2, 3, 4, 10, 40}, x = 11Output:  -1Element x is not present. Fibonacci Search is a comparison-based technique that uses Fibonacci numbers to search an element in a sorted array.Similarities with Binary Search: Differences with Binary Search: Background: Fibonacci Numbers are recursively defined as F(n) = F(n-1) + F(n-2), F(0) = 0, F(1) = 1. First few Fibonacci Numbers are 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, …Observations: Below observation is used for range elimination, and hence for the O(log(n)) complexity. Algorithm: Let the searched element be x.The idea is to first find the smallest Fibonacci number that is greater than or equal to the length of the given array. Let the found Fibonacci number be fib (m’th Fibonacci number). We use (m-2)’th Fibonacci number as the index (If it is a valid index). Let (m-2)’th Fibonacci Number be i, we compare arr[i] with x, if x is same, we return i. Else if x is greater, we recur for subarray after i, else we recur for subarray before i.Below is the complete algorithm Let arr[0..n-1] be the input array and the element to be searched be x. Illustration: Let us understand the algorithm with the below example:  Illustration assumption: 1-based indexing. Target element x is 85. Length of array n = 11.Smallest Fibonacci number greater than or equal to 11 is 13. As per our illustration, fibMm2 = 5, fibMm1 = 8, and fibM = 13.Another implementation detail is the offset variable (zero-initialized). It marks the range that has been eliminated, starting from the front. We will update it from time to time.Now since the offset value is an index and all indices including it and below it have been eliminated, it only makes sense to add something to it. Since fibMm2 marks approximately one-third of our array, as well as the indices it marks, are sure to be valid ones, we can add fibMm2 to offset and check the element at index i = min(offset + fibMm2, n).  Visualization:  Time Complexity analysis: The worst-case will occur when we have our target in the larger (2/3) fraction of the array, as we proceed to find it. In other words, we are eliminating the smaller (1/3) fraction of the array every time. We call once for n, then for(2/3) n, then for (4/9) n, and henceforth.Consider that:  Auxiliary Space: O(1) References: https://en.wikipedia.org/wiki/Fibonacci_search_technique Approach 2: Iterative implementation Fibonacci Search is a searching algorithm used to find the position of an element in a sorted array. The basic idea behind Fibonacci Search is to use Fibonacci numbers to determine the split points in the array and perform binary search on the appropriate subarray. Here’s a Python implementation of Fibonacci Search using an iterative approach: The time complexity of Fibonacci Search is O(log n), where n is the length of the input array. This is because at each iteration of the algorithm, the search range is reduced by a factor of approximately 1/φ, where φ is the golden ratio (φ ≈ 1.618). The number of iterations required to reduce the search range to a single element is approximately logₑ(n), where logₑ denotes the natural logarithm. Since each iteration of Fibonacci Search requires constant time, the overall time complexity of the algorithm is O(log n). This makes Fibonacci Search a faster algorithm than linear search, but slower than binary search and other logarithmic search algorithms such as interpolation search and exponential search. Auxiliary Space: O(1) Y  ",
        "code": "F(n - 2) ≈ (1/3)*F(n) and F(n - 1) ≈ (2/3)*F(n).\n// C++ program of the above approach\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Utility function to find minimum of two elements\nint min(int x, int y) { return (x <= y) ? x : y; }\n \n/* Returns index of x if present,  else returns -1 */\nint fibMonaccianSearch(int arr[], int x, int n)\n{\n    /* Initialize fibonacci numbers */\n    int fibMMm2 = 0; // (m-2)'th Fibonacci No.\n    int fibMMm1 = 1; // (m-1)'th Fibonacci No.\n    int fibM = fibMMm2 + fibMMm1; // m'th Fibonacci\n \n    /* fibM is going to store the smallest Fibonacci\n       Number greater than or equal to n */\n    while (fibM < n) {\n        fibMMm2 = fibMMm1;\n        fibMMm1 = fibM;\n        fibM = fibMMm2 + fibMMm1;\n    }\n \n    // Marks the eliminated range from front\n    int offset = -1;\n \n    /* while there are elements to be inspected. Note that\n       we compare arr[fibMm2] with x. When fibM becomes 1,\n       fibMm2 becomes 0 */\n    while (fibM > 1) {\n        // Check if fibMm2 is a valid location\n        int i = min(offset + fibMMm2, n - 1);\n \n        /* If x is greater than the value at index fibMm2,\n           cut the subarray array from offset to i */\n        if (arr[i] < x) {\n            fibM = fibMMm1;\n            fibMMm1 = fibMMm2;\n            fibMMm2 = fibM - fibMMm1;\n            offset = i;\n        }\n \n        /* If x is greater than the value at index fibMm2,\n           cut the subarray after i+1  */\n        else if (arr[i] > x) {\n            fibM = fibMMm2;\n            fibMMm1 = fibMMm1 - fibMMm2;\n            fibMMm2 = fibM - fibMMm1;\n        }\n \n        /* element found. return index */\n        else\n            return i;\n    }\n \n    /* comparing the last element with x */\n    if (fibMMm1 && arr[offset + 1] == x)\n        return offset + 1;\n \n    /*element not found. return -1 */\n    return -1;\n}\n\n// Driver Code\nint main()\n{\n    int arr[]\n        = { 10, 22, 35, 40, 45, 50, 80, 82, 85, 90, 100,235};\n    int n = sizeof(arr) / sizeof(arr[0]);\n    int x = 235;\n      int ind = fibMonaccianSearch(arr, x, n);\n  if(ind>=0)\n    cout << \"Found at index: \" << ind;\n  else\n    cout << x << \" isn't present in the array\";\n\n    return 0;\n}\n\n// This code is contributed by code_hunt.\n// C program for Fibonacci Search\n#include <stdio.h>\n\n// Utility function to find minimum of two elements\nint min(int x, int y) { return (x <= y) ? x : y; }\n\n/* Returns index of x if present,  else returns -1 */\nint fibMonaccianSearch(int arr[], int x, int n)\n{\n    /* Initialize fibonacci numbers */\n    int fibMMm2 = 0; // (m-2)'th Fibonacci No.\n    int fibMMm1 = 1; // (m-1)'th Fibonacci No.\n    int fibM = fibMMm2 + fibMMm1; // m'th Fibonacci\n\n    /* fibM is going to store the smallest Fibonacci\n       Number greater than or equal to n */\n    while (fibM < n) {\n        fibMMm2 = fibMMm1;\n        fibMMm1 = fibM;\n        fibM = fibMMm2 + fibMMm1;\n    }\n\n    // Marks the eliminated range from front\n    int offset = -1;\n\n    /* while there are elements to be inspected. Note that\n       we compare arr[fibMm2] with x. When fibM becomes 1,\n       fibMm2 becomes 0 */\n    while (fibM > 1) {\n        // Check if fibMm2 is a valid location\n        int i = min(offset + fibMMm2, n - 1);\n\n        /* If x is greater than the value at index fibMm2,\n           cut the subarray array from offset to i */\n        if (arr[i] < x) {\n            fibM = fibMMm1;\n            fibMMm1 = fibMMm2;\n            fibMMm2 = fibM - fibMMm1;\n            offset = i;\n        }\n\n        /* If x is greater than the value at index fibMm2,\n           cut the subarray after i+1  */\n        else if (arr[i] > x) {\n            fibM = fibMMm2;\n            fibMMm1 = fibMMm1 - fibMMm2;\n            fibMMm2 = fibM - fibMMm1;\n        }\n\n        /* element found. return index */\n        else\n            return i;\n    }\n\n    /* comparing the last element with x */\n    if (fibMMm1 && arr[offset + 1] == x)\n        return offset + 1;\n\n    /*element not found. return -1 */\n    return -1;\n}\n\n/* driver function */\nint main(void)\n{\n    int arr[]\n        = { 10, 22, 35, 40, 45, 50, 80, 82, 85, 90, 100,235};\n    int n = sizeof(arr) / sizeof(arr[0]);\n    int x = 235;\n      int ind = fibMonaccianSearch(arr, x, n);\n  if(ind>=0)\n    printf(\"Found at index: %d\",ind);\n  else\n    printf(\"%d isn't present in the array\",x);\n    return 0;\n}\n// Java program for Fibonacci Search\nimport java.util.*;\n\nclass Fibonacci {\n    // Utility function to find minimum\n    // of two elements\n    public static int min(int x, int y)\n    {\n        return (x <= y) ? x : y;\n    }\n\n    /* Returns index of x if present, else returns -1 */\n    public static int fibMonaccianSearch(int arr[], int x,\n                                         int n)\n    {\n        /* Initialize fibonacci numbers */\n        int fibMMm2 = 0; // (m-2)'th Fibonacci No.\n        int fibMMm1 = 1; // (m-1)'th Fibonacci No.\n        int fibM = fibMMm2 + fibMMm1; // m'th Fibonacci\n\n        /* fibM is going to store the smallest\n        Fibonacci Number greater than or equal to n */\n        while (fibM < n) {\n            fibMMm2 = fibMMm1;\n            fibMMm1 = fibM;\n            fibM = fibMMm2 + fibMMm1;\n        }\n\n        // Marks the eliminated range from front\n        int offset = -1;\n\n        /* while there are elements to be inspected.\n        Note that we compare arr[fibMm2] with x.\n        When fibM becomes 1, fibMm2 becomes 0 */\n        while (fibM > 1) {\n            // Check if fibMm2 is a valid location\n            int i = min(offset + fibMMm2, n - 1);\n\n            /* If x is greater than the value at\n            index fibMm2, cut the subarray array\n            from offset to i */\n            if (arr[i] < x) {\n                fibM = fibMMm1;\n                fibMMm1 = fibMMm2;\n                fibMMm2 = fibM - fibMMm1;\n                offset = i;\n            }\n\n            /* If x is less than the value at index\n            fibMm2, cut the subarray after i+1 */\n            else if (arr[i] > x) {\n                fibM = fibMMm2;\n                fibMMm1 = fibMMm1 - fibMMm2;\n                fibMMm2 = fibM - fibMMm1;\n            }\n\n            /* element found. return index */\n            else\n                return i;\n        }\n\n        /* comparing the last element with x */\n        if (fibMMm1 == 1 && arr[n-1] == x)\n            return n-1;\n\n        /*element not found. return -1 */\n        return -1;\n    }\n\n    // driver code\n    public static void main(String[] args)\n    {\n        int arr[] = { 10, 22, 35, 40, 45, 50,\n                      80, 82, 85, 90, 100,235};\n        int n = 12;\n        int x = 235;\n      int ind = fibMonaccianSearch(arr, x, n);\n        if(ind>=0)\n        System.out.print(\"Found at index: \"\n                         +ind);\n      else\n        System.out.print(x+\" isn't present in the array\");\n    }\n}\n\n// This code is contributed by rishabh_jain\n# Python3 program for Fibonacci search.\nfrom bisect import bisect_left\n\n# Returns index of x if present,  else\n# returns -1\n\n\ndef fibMonaccianSearch(arr, x, n):\n\n    # Initialize fibonacci numbers\n    fibMMm2 = 0  # (m-2)'th Fibonacci No.\n    fibMMm1 = 1  # (m-1)'th Fibonacci No.\n    fibM = fibMMm2 + fibMMm1  # m'th Fibonacci\n\n    # fibM is going to store the smallest\n    # Fibonacci Number greater than or equal to n\n    while (fibM < n):\n        fibMMm2 = fibMMm1\n        fibMMm1 = fibM\n        fibM = fibMMm2 + fibMMm1\n\n    # Marks the eliminated range from front\n    offset = -1\n\n    # while there are elements to be inspected.\n    # Note that we compare arr[fibMm2] with x.\n    # When fibM becomes 1, fibMm2 becomes 0\n    while (fibM > 1):\n\n        # Check if fibMm2 is a valid location\n        i = min(offset+fibMMm2, n-1)\n\n        # If x is greater than the value at\n        # index fibMm2, cut the subarray array\n        # from offset to i\n        if (arr[i] < x):\n            fibM = fibMMm1\n            fibMMm1 = fibMMm2\n            fibMMm2 = fibM - fibMMm1\n            offset = i\n\n        # If x is less than the value at\n        # index fibMm2, cut the subarray\n        # after i+1\n        elif (arr[i] > x):\n            fibM = fibMMm2\n            fibMMm1 = fibMMm1 - fibMMm2\n            fibMMm2 = fibM - fibMMm1\n\n        # element found. return index\n        else:\n            return i\n\n    # comparing the last element with x */\n    if(fibMMm1 and arr[n-1] == x):\n        return n-1\n\n    # element not found. return -1\n    return -1\n\n\n# Driver Code\narr = [10, 22, 35, 40, 45, 50,\n       80, 82, 85, 90, 100,235]\nn = len(arr)\nx = 235\nind = fibMonaccianSearch(arr, x, n)\nif ind>=0:\n  print(\"Found at index:\",ind)\nelse:\n  print(x,\"isn't present in the array\");\n\n# This code is contributed by rishabh_jain\n// C# program for Fibonacci Search\nusing System;\n\nclass GFG {\n\n    // Utility function to find minimum\n    // of two elements\n    public static int min(int x, int y)\n    {\n        return (x <= y) ? x : y;\n    }\n\n    /* Returns index of x if present, else returns -1 */\n    public static int fibMonaccianSearch(int[] arr, int x,\n                                         int n)\n    {\n        /* Initialize fibonacci numbers */\n        int fibMMm2 = 0; // (m-2)'th Fibonacci No.\n        int fibMMm1 = 1; // (m-1)'th Fibonacci No.\n        int fibM = fibMMm2 + fibMMm1; // m'th Fibonacci\n\n        /* fibM is going to store the smallest\n        Fibonacci Number greater than or equal to n */\n        while (fibM < n) {\n            fibMMm2 = fibMMm1;\n            fibMMm1 = fibM;\n            fibM = fibMMm2 + fibMMm1;\n        }\n\n        // Marks the eliminated range from front\n        int offset = -1;\n\n        /* while there are elements to be inspected.\n        Note that we compare arr[fibMm2] with x.\n        When fibM becomes 1, fibMm2 becomes 0 */\n        while (fibM > 1) {\n            // Check if fibMm2 is a valid location\n            int i = min(offset + fibMMm2, n - 1);\n\n            /* If x is greater than the value at\n            index fibMm2, cut the subarray array\n            from offset to i */\n            if (arr[i] < x) {\n                fibM = fibMMm1;\n                fibMMm1 = fibMMm2;\n                fibMMm2 = fibM - fibMMm1;\n                offset = i;\n            }\n\n            /* If x is less than the value at index\n            fibMm2, cut the subarray after i+1 */\n            else if (arr[i] > x) {\n                fibM = fibMMm2;\n                fibMMm1 = fibMMm1 - fibMMm2;\n                fibMMm2 = fibM - fibMMm1;\n            }\n\n            /* element found. return index */\n            else\n                return i;\n        }\n\n        /* comparing the last element with x */\n        if (fibMMm1 == 1 && arr[n-1] == x)\n            return n-1;\n\n        /*element not found. return -1 */\n        return -1;\n    }\n\n    // driver code\n    public static void Main()\n    {\n        int[] arr = { 10, 22, 35, 40, 45, 50,\n                      80, 82, 85, 90, 100,235 };\n        int n = 12;\n        int x = 235;\n          int ind = fibMonaccianSearch(arr, x, n);\n          if(ind>=0)\n        Console.Write(\"Found at index: \"+ind);\n          else\n        Console.Write(x+\" isn't present in the array\");\n    }\n}\n\n// This code is contributed by nitin mittal.\n<script>\n\n// Javascript program for Fibonacci Search\n \n/* Returns index of x if present, else returns -1 */\nfunction fibMonaccianSearch(arr, x, n)\n{\n    /* Initialize fibonacci numbers */\n    let fibMMm2 = 0; // (m-2)'th Fibonacci No.\n    let fibMMm1 = 1; // (m-1)'th Fibonacci No.\n    let fibM = fibMMm2 + fibMMm1; // m'th Fibonacci\n \n    /* fibM is going to store the smallest Fibonacci\n    Number greater than or equal to n */\n    while (fibM < n)\n    {\n        fibMMm2 = fibMMm1;\n        fibMMm1 = fibM;\n        fibM = fibMMm2 + fibMMm1;\n    }\n \n    // Marks the eliminated range from front\n    let offset = -1;\n \n    /* while there are elements to be inspected. Note that\n    we compare arr[fibMm2] with x. When fibM becomes 1,\n    fibMm2 becomes 0 */\n  \n    while (fibM > 1)\n    {\n        // Check if fibMm2 is a valid location\n        let i = Math.min(offset + fibMMm2, n-1);\n \n        /* If x is greater than the value at index fibMm2,\n        cut the subarray array from offset to i */\n        if (arr[i] < x)\n        {\n            fibM = fibMMm1;\n            fibMMm1 = fibMMm2;\n            fibMMm2 = fibM - fibMMm1;\n            offset = i;\n        }\n \n        /* If x is less than the value at index fibMm2,\n        cut the subarray after i+1 */\n        else if (arr[i] > x)\n        {\n            fibM = fibMMm2;\n            fibMMm1 = fibMMm1 - fibMMm2;\n            fibMMm2 = fibM - fibMMm1;\n        }\n \n        /* element found. return index */\n        else return i;\n    }\n \n    /* comparing the last element with x */\n    if(fibMMm1 && arr[n-1] == x){\n      return n-1\n    }\n \n    /*element not found. return -1 */\n    return -1;\n}\n \n/* driver code */\n    let arr = [10, 22, 35, 40, 45, 50, 80, 82,85, 90, 100,235];\n    let n = arr.length;\n    let x = 235;\n    let ind = fibMonaccianSearch(arr, x, n);\n    if(ind>=0){\n       document.write(\"Found at index: \" + ind);\n    }else{\n       document.write(x + \" isn't present in the array\");\n    }\n \n// This code is contributed by _saurabh_jaiswal\n\n</script>\n<?php\n// PHP program for Fibonacci Search\n\n/* Returns index of x if present, else returns -1 */\nfunction fibMonaccianSearch($arr, $x, $n)\n{\n    /* Initialize fibonacci numbers */\n    $fibMMm2 = 0; // (m-2)'th Fibonacci No.\n    $fibMMm1 = 1; // (m-1)'th Fibonacci No.\n    $fibM = $fibMMm2 + $fibMMm1; // m'th Fibonacci\n\n    /* fibM is going to store the smallest Fibonacci\n    Number greater than or equal to n */\n    while ($fibM < $n)\n    {\n        $fibMMm2 = $fibMMm1;\n        $fibMMm1 = $fibM;\n        $fibM = $fibMMm2 + $fibMMm1;\n    }\n\n    // Marks the eliminated range from front\n    $offset = -1;\n\n    /* while there are elements to be inspected. Note that\n    we compare arr[fibMm2] with x. When fibM becomes 1,\n    fibMm2 becomes 0 */\n    while ($fibM > 1)\n    {\n        // Check if fibMm2 is a valid location\n        $i = min($offset+$fibMMm2, $n-1);\n\n        /* If x is greater than the value at index fibMm2,\n        cut the subarray array from offset to i */\n        if ($arr[$i] < $x)\n        {\n            $fibM = $fibMMm1;\n            $fibMMm1 = $fibMMm2;\n            $fibMMm2 = $fibM - $fibMMm1;\n            $offset = $i;\n        }\n\n        /* If x is less than the value at index fibMm2,\n        cut the subarray after i+1 */\n        else if ($arr[$i] > $x)\n        {\n            $fibM = $fibMMm2;\n            $fibMMm1 = $fibMMm1 - $fibMMm2;\n            $fibMMm2 = $fibM - $fibMMm1;\n        }\n\n        /* element found. return index */\n        else return $i;\n    }\n\n    /* comparing the last element with x */\n    if($fibMMm1 && $arr[$n-1] == $x)return $n-1;\n\n    /*element not found. return -1 */\n    return -1;\n}\n\n/* driver code */\n    $arr = array(10, 22, 35, 40, 45, 50, 80, 82,85, 90, 100,235);\n    $n = count($arr);\n    $x = 235;\n    $ind = fibMonaccianSearch($arr, $x, $n);\n    if($ind>=0)\n    printf(\"Found at index: \".$ind);\n    else\n    printf($x.\" isn't present in the array\");\n\n// This code is contributed by mits\n?>\nFound at index: 11\n// C++ code for above approach\n#include <iostream>\nusing namespace std;\n\nint fibonacciSearch(int arr[], int n, int x) {\nif (n == 0) {\nreturn -1;\n}\n// Initialize Fibonacci numbers\nint fib1 = 0, fib2 = 1, fib3 = fib1 + fib2;\n\n// Find the smallest Fibonacci number greater than or equal to n\nwhile (fib3 < n) {\n    fib1 = fib2;\n    fib2 = fib3;\n    fib3 = fib1 + fib2;\n}\n\n// Initialize variables for the current and previous split points\nint offset = -1;\nwhile (fib3 > 1) {\n    int i = min(offset + fib2, n-1);\n\n    // If x is greater than the value at index i, move the split point to the right\n    if (arr[i] < x) {\n        fib3 = fib2;\n        fib2 = fib1;\n        fib1 = fib3 - fib2;\n        offset = i;\n    }\n\n    // If x is less than the value at index i, move the split point to the left\n    else if (arr[i] > x) {\n        fib3 = fib1;\n        fib2 = fib2 - fib1;\n        fib1 = fib3 - fib2;\n    }\n\n    // If x is equal to the value at index i, return the index\n    else {\n        return i;\n    }\n}\n\n// If x is not found in the array, return -1\nif (fib2 == 1 && arr[offset+1] == x) {\n    return offset + 1;\n} else {\n    return -1;\n}\n}\n\n// Driver code\nint main() {\nint arr[] = {10, 22, 35, 40, 45, 50, 80, 82, 85, 90, 100, 235};\nint n = sizeof(arr)/sizeof(arr[0]);\nint x = 235;\nint ind = fibonacciSearch(arr, n, x);\nif (ind >= 0) {\ncout << \"Found at index: \" << ind << endl;\n} else {\ncout << x << \" isn't present in the array\" << endl;\n}\nreturn 0;\n}\nimport java.util.*;\n\nclass Main {\n  public static int fibonacciSearch(int[] arr, int x) {\n    int n = arr.length;\n    if (n == 0) {\n      return -1;\n    }\n\n    // Initialize Fibonacci numbers\n    int fib1 = 0, fib2 = 1, fib3 = fib1 + fib2;\n\n    // Find the smallest Fibonacci number greater than or equal to n\n    while (fib3 < n) {\n      fib1 = fib2;\n      fib2 = fib3;\n      fib3 = fib1 + fib2;\n    }\n\n    // Initialize variables for the current and previous split points\n    int offset = -1;\n    while (fib3 > 1) {\n      int i = Math.min(offset + fib2, n-1);\n\n      // If x is greater than the value at index i, move the split point to the right\n      if (arr[i] < x) {\n        fib3 = fib2;\n        fib2 = fib1;\n        fib1 = fib3 - fib2;\n        offset = i;\n      }\n\n      // If x is less than the value at index i, move the split point to the left\n      else if (arr[i] > x) {\n        fib3 = fib1;\n        fib2 = fib2 - fib1;\n        fib1 = fib3 - fib2;\n      }\n\n      // If x is equal to the value at index i, return the index\n      else {\n        return i;\n      }\n    }\n\n    // If x is not found in the array, return -1\n    if (fib2 == 1 && arr[offset+1] == x) {\n      return offset + 1;\n    } else {\n      return -1;\n    }\n  }\n\n  public static void main(String[] args) {\n    int[] arr = {10, 22, 35, 40, 45, 50, 80, 82, 85, 90, 100, 235};\n    int n = arr.length;\n    int x = 235;\n    int ind = fibonacciSearch(arr, x);\n    if (ind >= 0) {\n      System.out.println(\"Found at index: \" + ind);\n    } else {\n      System.out.println(x + \" isn't present in the array\");\n    }\n  }\n}\ndef fibonacci_search(arr, x):\n    n = len(arr)\n    if n == 0:\n        return -1\n\n    # Initialize Fibonacci numbers\n    fib1, fib2 = 0, 1\n    fib3 = fib1 + fib2\n\n    # Find the smallest Fibonacci number greater than or equal to n\n    while fib3 < n:\n        fib1, fib2 = fib2, fib3\n        fib3 = fib1 + fib2\n\n    # Initialize variables for the current and previous split points\n    offset = -1\n    while fib3 > 1:\n        i = min(offset + fib2, n-1)\n\n        # If x is greater than the value at index i, move the split point to the right\n        if arr[i] < x:\n            fib3 = fib2\n            fib2 = fib1\n            fib1 = fib3 - fib2\n            offset = i\n\n        # If x is less than the value at index i, move the split point to the left\n        elif arr[i] > x:\n            fib3 = fib1\n            fib2 = fib2 - fib1\n            fib1 = fib3 - fib2\n\n        # If x is equal to the value at index i, return the index\n        else:\n            return i\n\n    # If x is not found in the array, return -1\n    if fib2 == 1 and arr[offset+1] == x:\n        return offset + 1\n    else:\n        return -1\n\n\n\n\n# Driver Code\narr = [10, 22, 35, 40, 45, 50,\n    80, 82, 85, 90, 100,235]\nn = len(arr)\nx = 235\nind = fibonacci_search(arr, x)\nif ind>=0:\n    print(\"Found at index:\",ind)\nelse:\n    print(x,\"isn't present in the array\");\n\n# This code is contributed by ajay singh\nusing System;\n\nclass GFG {\n    public static int FibonacciSearch(int[] arr, int x) {\n        int n = arr.Length;\n        if (n == 0) {\n            return -1;\n        }\n\n        // Initialize Fibonacci numbers\n        int fib1 = 0, fib2 = 1, fib3 = fib1 + fib2;\n\n        // Find the smallest Fibonacci number greater than or equal to n\n        while (fib3 < n) {\n            fib1 = fib2;\n            fib2 = fib3;\n            fib3 = fib1 + fib2;\n        }\n\n        // Initialize variables for the current and previous split points\n        int offset = -1;\n        while (fib3 > 1) {\n            int i = Math.Min(offset + fib2, n - 1);\n\n            // If x is greater than the value at index i, move the split point to the right\n            if (arr[i] < x) {\n                fib3 = fib2;\n                fib2 = fib1;\n                fib1 = fib3 - fib2;\n                offset = i;\n            }\n\n            // If x is less than the value at index i, move the split point to the left\n            else if (arr[i] > x) {\n                fib3 = fib1;\n                fib2 = fib2 - fib1;\n                fib1 = fib3 - fib2;\n            }\n\n            // If x is equal to the value at index i, return the index\n            else {\n                return i;\n            }\n        }\n\n        // If x is not found in the array, return -1\n        if (fib2 == 1 && arr[offset + 1] == x) {\n            return offset + 1;\n        } else {\n            return -1;\n        }\n    }\n    \n      // Driver code\n    public static void Main(string[] args) {\n        int[] arr = { 10, 22, 35, 40, 45, 50, 80, 82, 85, 90, 100, 235 };\n        int n = arr.Length;\n        int x = 235;\n          \n          // function call\n        int ind = FibonacciSearch(arr, x);\n        if (ind >= 0) {\n            Console.WriteLine(\"Found at index: \" + ind);\n        } else {\n            Console.WriteLine(x + \" isn't present in the array\");\n        }\n    }\n}\n// Javascript equivalent\nfunction fibonacci_search(arr, x) {\n    var n = arr.length;\n    if (n === 0) {\n        return -1;\n    }\n\n    // Initialize Fibonacci numbers\n    var fib1 = 0;\n    var fib2 = 1;\n    var fib3 = fib1 + fib2;\n\n    // Find the smallest Fibonacci number greater than or equal to n\n    while (fib3 < n) {\n        fib1 = fib2;\n        fib2 = fib3;\n        fib3 = fib1 + fib2;\n    }\n\n    // Initialize variables for the current and previous split points\n    var offset = -1;\n    while (fib3 > 1) {\n        var i = Math.min(offset + fib2, n - 1);\n\n        // If x is greater than the value at index i, \n        // move the split point to the right\n        if (arr[i] < x) {\n            fib3 = fib2;\n            fib2 = fib1;\n            fib1 = fib3 - fib2;\n            offset = i;\n\n            // If x is less than the value at index i, \n            // move the split point to the left\n        } else if (arr[i] > x) {\n            fib3 = fib1;\n            fib2 = fib2 - fib1;\n            fib1 = fib3 - fib2;\n\n            // If x is equal to the value at index i, return the index\n        } else {\n            return i;\n        }\n    }\n\n    // If x is not found in the array, return -1\n    if (fib2 === 1 && arr[offset + 1] === x) {\n        return offset + 1;\n    } else {\n        return -1;\n    }\n}\n\n// Driver Code\nvar arr = [10, 22, 35, 40, 45, 50,\n    80, 82, 85, 90, 100,235];\nvar n = arr.length;\nvar x = 235;\nvar ind = fibonacci_search(arr, x);\nif (ind >= 0) {\n    console.log(\"Found at index:\", ind);\n} else {\n    console.log(x,\"isn't present in the array\");\n}\nFound at index: 11\n",
        "complexity": {
            "time": "Since each iteration of Fibonacci Search requires constant time, the overall time complexity of the algorithm is O(log n). This makes Fibonacci Search a faster algorithm than linear search, but slower than binary search and other logarithmic search algorithms such as interpolation search and exponential search.",
            "space": ""
        },
        "tags": [
            "Searching"
        ],
        "url": "https://www.geeksforgeeks.org/fibonacci-search/"
    },
    {
        "title": "The Ubiquitous Binary Search | Set 1",
        "description": "We are aware of the binary search algorithm. Binary search is the easiest algorithm to get right. I present some interesting problems that I collected on binary search. There were some requests on binary search. I request you to honor the code, “I sincerely attempt to solve the problem and ensure there are no corner cases”. After reading each problem, minimize the browser and try solving it. Problem Statement: Given a sorted array of N distinct elements, find a key in the array using the least number of comparisons. (Do you think binary search is optimal to search a key in sorted array?) Without much theory, here is typical binary search algorithm. Theoretically we need log N + 1 comparisons in worst case. If we observe, we are using two comparisons per iteration except during final successful match, if any. In practice, comparison would be costly operation, it won’t be just primitive type comparison. It is more economical to minimize comparisons as that of theoretical limit. See below figure on initialize of indices in the next implementation. The following implementation uses fewer number of comparisons. In the while loop we are depending only on one comparison. The search space converges to place l and r point two different consecutive elements. We need one more comparison to trace search status. You can see sample test case http://ideone.com/76bad0. (C++11 code) Problem Statement: Given an array of N distinct integers, find floor value of input ‘key’. Say, A = {-1, 2, 3, 5, 6, 8, 9, 10} and key = 7, we should return 6 as outcome. We can use the above optimized implementation to find floor value of key. We keep moving the left pointer to right most as long as the invariant holds. Eventually left pointer points an element less than or equal to key (by definition floor value). The following are possible corner cases, —> If all elements in the array are smaller than key, left pointer moves till last element. —> If all elements in the array are greater than key, it is an error condition. —> If all elements in the array equal and <= key, it is worst case input to our implementation. Here is implementation, You can see some test cases http://ideone.com/z0Kx4a. Problem Statement: Given a sorted array with possible duplicate elements. Find number of occurrences of input ‘key’ in log N time. The idea here is finding left and right most occurrences of key in the array using binary search. We can modify floor function to trace right most occurrence and left most occurrence. Here is implementation, Sample code http://ideone.com/zn6R6a. Problem Statement: Given a sorted array of distinct elements, and the array is rotated at an unknown position. Find minimum element in the array. We can see  pictorial representation of sample input array in the below figure. We converge the search space till l and r points single element. If the middle location falls in the first pulse, the condition A[m] < A[r] doesn’t satisfy, we converge our search space to A[m+1 … r]. If the middle location falls in the second pulse, the condition A[m] < A[r] satisfied, we converge our search space to A[1 … m]. At every iteration we check for search space size, if it is 1, we are done. Given below is implementation of algorithm. Can you come up with different implementation? See sample test cases http://ideone.com/KbwDrk. Exercises: 1. A function called signum(x, y) is defined as, Did you come across any instruction set in which a comparison behaves like signum function? Can it make the first implementation of binary search optimal? 2. Implement ceil function replica of floor function. 3. Discuss with your friends “Is binary search optimal (results in the least number of comparisons)? Why not ternary search or interpolation search on a sorted array? When do you prefer ternary or interpolation search over binary search?” 4. Draw a tree representation of binary search (believe me, it helps you a lot to understand much internals of binary search). Stay tuned, I will cover few more interesting problems using binary search in upcoming articles. I welcome your comments. – – – by Venki.  ",
        "code": "// Returns location of key, or -1 if not found\nint BinarySearch(int A[], int l, int r, int key){\n    int m;\n    while( l <= r ){\n        m = l + (r-l)/2;\n\n        if( A[m] == key ) // first comparison\n            return m;\n\n        if( A[m] < key ) // second comparison\n            l = m + 1;\n        else\n            r = m - 1;\n    }\n    return -1;\n}\n// THIS CODE IS CONTRIBUTED BY YASH AGARWAL(YASHAGARWAL2852002)\n// Returns location of key, or -1 if not found\nint BinarySearch(int A[], int l, int r, int key)\n{\n    int m;\n\n    while( l <= r )\n    {\n        m = l + (r-l)/2;\n\n        if( A[m] == key ) // first comparison\n            return m;\n\n        if( A[m] < key ) // second comparison\n            l = m + 1;\n        else\n            r = m - 1;\n    }\n\n    return -1;\n}\n// Java code to implement the approach\nimport java.util.*;\n\nclass GFG {\n\n// Returns location of key, or -1 if not found\nstatic int BinarySearch(int A[], int l, int r, int key)\n{\n    int m;\n\n    while( l < r )\n    {\n        m = l + (r-l)/2;\n\n        if( A[m] == key ) // first comparison\n            return m;\n\n        if( A[m] < key ) // second comparison\n            l = m + 1;\n        else\n            r = m - 1;\n    }\n\n    return -1;\n}\n}\n\n// This code is contributed by sanjoy_62.\n# Returns location of key, or -1 if not found\ndef BinarySearch(A, l, r, key):\n    while (l < r):\n        m = l + (r - l) // 2\n        if A[m] == key: #first comparison\n            return m\n        if A[m] < key: # second comparison\n            l = m + 1\n        else:\n            r = m - 1\n    return -1\n\"\"\" This code is contributed by Rajat Kumar \"\"\"\n// C# program to implement\n// the above approach\nusing System;\n\nclass GFG\n{\n\n// Returns location of key, or -1 if not found\nstatic int BinarySearch(int[] A, int l, int r, int key)\n{\n    int m;\n\n    while( l < r )\n    {\n        m = l + (r-l)/2;\n\n        if( A[m] == key ) // first comparison\n            return m;\n\n        if( A[m] < key ) // second comparison\n            l = m + 1;\n        else\n            r = m - 1;\n    }\n\n    return -1;\n}\n}\n\n// This code is contributed by code_hunt.\n<script>\n// Javascript code to implement the approach\n\n\n// Returns location of key, or -1 if not found\nfunction BinarySearch(A, l, r, key) {\n  let m;\n\n  while (l < r) {\n    m = l + (r - l) / 2;\n\n    if (A[m] == key) // first comparison\n      return m;\n\n    if (A[m] < key) // second comparison\n      l = m + 1;\n    else\n      r = m - 1;\n  }\n\n  return -1;\n}\n\n// This code is contributed by gfgking\n</script>\n// Invariant: A[l] &lt;= key and A[r] &gt; key\n// Boundary: |r - l| = 1\n// Input: A[l .... r-1]\nint BinarySearch(int A[], int l, int r, int key)\n{\n    int m;\n\n    while( r - l > 1 )\n    {\n        m = l + (r-l)/2;\n\n        if( A[m] <= key )\n            l = m;\n        else\n            r = m;\n    }\n\n    if( A[l] == key )\n        return l;\n    if( A[r] == key )\n        return r;\n    else\n        return -1;\n}\n//this code is contributed by aditya942003patil\n// Invariant: A[l] <= key and A[r] > key\n// Boundary: |r - l| = 1\n// Input: A[l .... r-1]\nint BinarySearch(int A[], int l, int r, int key)\n{\n    int m;\n\n    while( r - l > 1 )\n    {\n        m = l + (r-l)/2;\n\n        if( A[m] <= key )\n            l = m;\n        else\n            r = m;\n    }\n\n    if( A[l] == key )\n        return l;\n    if( A[r] == key )\n        return r;\n    else\n        return -1;\n}\n// Java function for above algorithm\n\n// Invariant: A[l] &lt;= key and A[r] &gt; key\n// Boundary: |r - l| = 1\n// Input: A[l .... r-1]\nint BinarySearch(int A[], int l, int r, int key)\n{\n  int m;\n\n  while( r - l k > 1 )\n\n  {\n    m = l + k(r - l)/2;\n\n    if( A[m]k <= key )\n      l = km;\n    elsek\n      r = m;\n  }\n\n  if( A[l] == key )\n    return l;\n  if( A[r] == key )\n    return r;\n  else\n    return -1;\n}\n//this code is contributed by Akshay Tripathi(akshaytripathi630)\n# Invariant: A[l] <= key and A[r] > key\n# Boundary: |r - l| = 1\n# Input: A[l .... r-1]\n\ndef BinarySearch(A, l, r, key):\n    while (r-l > 1):\n        m = l+(r-l)//2\n        if A[m] <= key:\n            l = m\n        else:\n            r = m\n    if A[l] == key:\n        return l\n    if A[r] == key:\n        return r\n    return -1\n\n\n\"\"\" Code is written by Rajat Kumar\"\"\"\n// C# conversion\n\n// Invariant: A[l] <= key and A[r] > key\n// Boundary: |r - l| = 1\n// Input: A[l .... r-1]\nint BinarySearch(int[] A, int l, int r, int key)\n{\n    int m;\n\n    while (r - l > 1) {\n        m = l + (r - l) / 2;\n\n        if (A[m] <= key)\n            l = m;\n        else\n            r = m;\n    }\n\n    if (A[l] == key)\n        return l;\n    if (A[r] == key)\n        return r;\n    else\n        return -1;\n}\n\n// This code is contributed by akashish__\n// Invariant: A[l] &lt;= key and A[r] &gt; key\n// Boundary: |r - l| = 1\n// Input: A[l .... r-1]\nfunction BinarySearch(A, l, r, key)\n{\n    let m;\n\n    while( r - l > 1 )\n    {\n        m = l + (r-l)/2;\n\n        if( A[m] <= key )\n            l = m;\n        else\n            r = m;\n    }\n\n    if( A[l] == key )\n        return l;\n    if( A[r] == key )\n        return r;\n    else\n        return -1;\n}\n// largest value <= key\n// Invariant: A[l] <= key and A[r] > key\n// Boundary: |r - l| = 1\n// Input: A[l .... r-1]\n// Precondition: A[l] <= key <= A[r]\nint Floor(int A[], int l, int r, int key)\n{\n    int m;\n\n    while( r - l > 1 )\n    {\n        m = l + (r - l)/2;\n\n        if( A[m] <= key )\n            l = m;\n        else\n            r = m;\n    }\n\n    return A[l];\n}\n\n// Initial call\nint Floor(int A[], int size, int key)\n{\n    // Add error checking if key < A[0]\n    if( key < A[0] )\n        return -1;\n\n    // Observe boundaries\n    return Floor(A, 0, size, key);\n}\n//this code is contributed by aditya942003patil\n// largest value <= key\n// Invariant: A[l] <= key and A[r] > key\n// Boundary: |r - l| = 1\n// Input: A[l .... r-1]\n// Precondition: A[l] <= key <= A[r]\nint Floor(int A[], int l, int r, int key)\n{\n    int m;\n\n    while( r - l > 1 )\n    {\n        m = l + (r - l)/2;\n\n        if( A[m] <= key )\n            l = m;\n        else\n            r = m;\n    }\n\n    return A[l];\n}\n\n// Initial call\nint Floor(int A[], int size, int key)\n{\n    // Add error checking if key < A[0]\n    if( key < A[0] )\n        return -1;\n\n    // Observe boundaries\n    return Floor(A, 0, size, key);\n}\npublic class Floor {\n    // This function returns the largest value in A that is\n    // less than or equal to key. Invariant: A[l] <= key and\n    // A[r] > key Boundary: |r - l| = 1 Input: A[l .... r-1]\n    // Precondition: A[l] <= key <= A[r]\n    static int floor(int[] A, int l, int r, int key)\n    {\n        int m;\n\n        while (r - l > 1) {\n            m = l + (r - l) / 2;\n\n            if (A[m] <= key)\n                l = m;\n            else\n                r = m;\n        }\n\n        return A[l];\n    }\n\n    // Initial call\n    static int floor(int[] A, int size, int key)\n    {\n        // Add error checking if key < A[0]\n        if (key < A[0])\n            return -1;\n\n        // Observe boundaries\n        return floor(A, 0, size, key);\n    }\n\n    public static void main(String[] args)\n    {\n        int[] arr = { 1, 2, 3, 4, 5 };\n        System.out.println(floor(arr, arr.length - 1, 3));\n    }\n}\n# largest value <= key\n# Invariant: A[l] <= key and A[r] > key\n# Boundary: |r - l| = 1\n# Input: A[l .... r-1]\n# Precondition: A[l] <= key <= A[r]\ndef Floor(A,l,r,key):\n    while (r-l>1):\n        m=l+(r-l)//2\n        if A[m]<=key:\n            l=m\n        else:\n            r=m\n    return A[l]\n# Initial call\ndef Floor(A,size,key):\n    # Add error checking if key < A[0]\n    if key<A[0]:\n        return -1\n    # Observe boundaries\n    return Floor(A,0,size,key)\n\n\"\"\"Code is written by Rajat Kumar\"\"\"\nusing System;\n\npublic class Floor {\n    // This function returns the largest value in A that is\n    // less than or equal to key. Invariant: A[l] <= key and\n    // A[r] > key Boundary: |r - l| = 1 Input: A[l .... r-1]\n    // Precondition: A[l] <= key <= A[r]\n    static int floor(int[] A, int l, int r, int key)\n    {\n        int m;\n\n        while (r - l > 1) {\n            m = l + (r - l) / 2;\n\n            if (A[m] <= key)\n                l = m;\n            else\n                r = m;\n        }\n\n        return A[l];\n    }\n\n    // Initial call\n    static int floor(int[] A, int size, int key)\n    {\n        // Add error checking if key < A[0]\n        if (key < A[0])\n            return -1;\n\n        // Observe boundaries\n        return floor(A, 0, size, key);\n    }\n\n    public static void Main(string[] args)\n    {\n        int[] arr = { 1, 2, 3, 4, 5 };\n        Console.WriteLine(floor(arr, arr.Length - 1, 3));\n    }\n}\n// This code is contributed by sarojmcy2e\n// largest value <= key\n// Invariant: A[l] <= key and A[r] > key\n// Boundary: |r - l| = 1\n// Input: A[l .... r-1]\n// Precondition: A[l] <= key <= A[r]\nfunction Floor(A, l, r, key){\n    let m;\n    while(r - l > 1){\n        m = l + parseInt((r-l)/2);\n        if(A[m] <= key) l = m;\n        else r = m;\n    }\n    return A[l];\n}\n\n// Initial call\nfunction Floor(A, size, key)\n{\n    // Add error checking if key < A[0]\n    if( key < A[0] )\n        return -1;\n \n    // Observe boundaries\n    return Floor(A, 0, size, key);\n}\n\n// THIS CODE IS CONTRIBUTED BY YASH AGARWAL(YASHAGAWRAL2852002)\n#include <iostream>\n\n// Input: Indices Range [l ... r)\n// Invariant: A[l] <= key and A[r] > key\nint GetRightPosition(int A[], int l, int r, int key)\n{\n    int m;\n\n    while( r - l > 1 )\n    {\n        m = l + (r - l)/2;\n\n        if( A[m] <= key )\n            l = m;\n        else\n            r = m;\n    }\n\n    return l;\n}\n\n// Input: Indices Range (l ... r]\n// Invariant: A[r] >= key and A[l] > key\nint GetLeftPosition(int A[], int l, int r, int key)\n{\n    int m;\n\n    while( r - l > 1 )\n    {\n        m = l + (r - l)/2;\n\n        if( A[m] >= key )\n            r = m;\n        else\n            l = m;\n    }\n\n    return r;\n}\n\nint CountOccurrences(int A[], int size, int key)\n{\n    // Observe boundary conditions\n    int left = GetLeftPosition(A, -1, size-1, key);\n    int right = GetRightPosition(A, 0, size, key);\n\n    // What if the element doesn't exists in the array?\n    // The checks helps to trace that element exists\n    return (A[left] == key && key == A[right])?\n           (right - left + 1) : 0;\n}\n\nint main()\n{\n    int A[] = {1, 1, 2, 3, 3, 3, 3, 3, 4, 4, 5};\n    int size = sizeof(A) / sizeof(A[0]);\n    int key = 3;\n\n    std::cout << \"Number of occurances of \" << key << \": \" << CountOccurances(A, size, key) << std::endl;\n\n    return 0;\n}\n\n\n//code is written by khushboogoyal499\n// Input: Indices Range [l ... r)\n// Invariant: A[l] <= key and A[r] > key\nint GetRightPosition(int A[], int l, int r, int key)\n{\n    int m;\n\n    while( r - l > 1 )\n    {\n        m = l + (r - l)/2;\n\n        if( A[m] <= key )\n            l = m;\n        else\n            r = m;\n    }\n\n    return l;\n}\n\n// Input: Indices Range (l ... r]\n// Invariant: A[r] >= key and A[l] > key\nint GetLeftPosition(int A[], int l, int r, int key)\n{\n    int m;\n\n    while( r - l > 1 )\n    {\n        m = l + (r - l)/2;\n\n        if( A[m] >= key )\n            r = m;\n        else\n            l = m;\n    }\n\n    return r;\n}\n\nint CountOccurrences(int A[], int size, int key)\n{\n    // Observe boundary conditions\n    int left = GetLeftPosition(A, -1, size-1, key);\n    int right = GetRightPosition(A, 0, size, key);\n\n    // What if the element doesn't exists in the array?\n    // The checks helps to trace that element exists\n    return (A[left] == key && key == A[right])?\n        (right - left + 1) : 0;\n}\npublic class OccurrencesInSortedArray {\n    // Returns the index of the leftmost occurrence of the\n    // given key in the array\n    private static int getLeftPosition(int[] arr, int left,\n                                       int right, int key)\n    {\n        while (right - left > 1) {\n            int mid = left + (right - left) / 2;\n            if (arr[mid] >= key) {\n                right = mid;\n            }\n            else {\n                left = mid;\n            }\n        }\n        return right;\n    }\n\n    // Returns the index of the rightmost occurrence of the\n    // given key in the array\n    private static int getRightPosition(int[] arr, int left,\n                                        int right, int key)\n    {\n        while (right - left > 1) {\n            int mid = left + (right - left) / 2;\n            if (arr[mid] <= key) {\n                left = mid;\n            }\n            else {\n                right = mid;\n            }\n        }\n        return left;\n    }\n\n    // Returns the count of occurrences of the given key in\n    // the array\n    public static int countOccurrences(int[] arr, int key)\n    {\n        int left\n            = getLeftPosition(arr, -1, arr.length - 1, key);\n        int right\n            = getRightPosition(arr, 0, arr.length, key);\n\n        if (arr[left] == key && key == arr[right]) {\n            return right - left + 1;\n        }\n        return 0;\n    }\n\n    public static void main(String[] args)\n    {\n        int[] arr = { 1, 2, 2, 2, 3, 4, 4, 5, 5 };\n        int key = 2;\n        System.out.println(\n            countOccurrences(arr, key)); // Output: 3\n    }\n}\n# Input: Indices Range [l ... r)\n# Invariant: A[l] <= key and A[r] > key\n\ndef GetRightPosition(A,l,r,key):\n    while r-l>1:\n        m=l+(r-l)//2\n        if A[m]<=key:\n            l=m\n        else:\n            r=m\n    return l\n# Input: Indices Range (l ... r]\n# Invariant: A[r] >= key and A[l] > key\ndef GetLeftPosition(A,l,r,key):\n    while r-l>1:\n        m=l+(r-l)//2\n        if A[m]>=key:\n            r=m\n        else:\n            l=m\n    return r\ndef countOccurrences(A,size,key):\n    #Observe boundary conditions\n    left=GetLeftPosition(A,-1,size-1,key)\n    right=GetRightPosition(A,0,size,key)\n    # What if the element doesn't exists in the array?\n    # The checks helps to trace that element exists\n\n    if A[left]==key and key==A[right]:\n        return right-left+1\n    return 0\n\"\"\"Code is written by Rajat Kumar\"\"\"\nusing System;\n\npublic class OccurrencesInSortedArray\n{\n    // Returns the index of the leftmost occurrence of the\n    // given key in the array\n    private static int getLeftPosition(int[] arr, int left,\n                                       int right, int key)\n    {\n        while (right - left > 1)\n        {\n            int mid = left + (right - left) / 2;\n            if (arr[mid] >= key)\n            {\n                right = mid;\n            }\n            else\n            {\n                left = mid;\n            }\n        }\n        return right;\n    }\n\n    // Returns the index of the rightmost occurrence of the\n    // given key in the array\n    private static int getRightPosition(int[] arr, int left,\n                                        int right, int key)\n    {\n        while (right - left > 1)\n        {\n            int mid = left + (right - left) / 2;\n            if (arr[mid] <= key)\n            {\n                left = mid;\n            }\n            else\n            {\n                right = mid;\n            }\n        }\n        return left;\n    }\n\n    // Returns the count of occurrences of the given key in\n    // the array\n    public static int countOccurrences(int[] arr, int key)\n    {\n        int left = getLeftPosition(arr, -1, arr.Length - 1, key);\n        int right = getRightPosition(arr, 0, arr.Length, key);\n\n        if (arr[left] == key && key == arr[right])\n        {\n            return right - left + 1;\n        }\n        return 0;\n    }\n\n    public static void Main(string[] args)\n    {\n        int[] arr = { 1, 2, 2, 2, 3, 4, 4, 5, 5 };\n        int key = 2;\n        Console.WriteLine(countOccurrences(arr, key)); // Output: 3\n    }\n}\n// Input: Indices Range [l ... r)\n// Invariant: A[l] <= key and A[r] > key\nfunction getRightPosition(A, l, r, key) {\n    while (r - l > 1) {\n        const m = l + Math.floor((r - l) / 2);\n        if (A[m] <= key) {\n            l = m;\n        } else {\n            r = m;\n        }\n    }\n    return l;\n}\n\n// Input: Indices Range (l ... r]\n// Invariant: A[r] >= key and A[l] > key\nfunction getLeftPosition(A, l, r, key) {\n    while (r - l > 1) {\n        const m = l + Math.floor((r - l) / 2);\n        if (A[m] >= key) {\n            r = m;\n        } else {\n            l = m;\n        }\n    }\n    return r;\n}\n\nfunction countOccurrences(A, size, key) {\n    // Observe boundary conditions\n    let left = getLeftPosition(A, -1, size - 1, key);\n    let right = getRightPosition(A, 0, size, key);\n\n    // What if the element doesn't exist in the array?\n    // The checks help to determine whether the element exists\n\n    if (A[left] === key && key === A[right]) {\n        return right - left + 1;\n    }\n    return 0;\n}\n\n// Example usage\nconst A = [1, 2, 2, 2, 3, 4, 4, 4, 5, 5, 6];\nconst key = 4;\nconst size = A.length;\nconst occurrences = countOccurrences(A, size, key);\nconsole.log(`The number of occurrences of ${key} is: ${occurrences}`);\nint BinarySearchIndexOfMinimumRotatedArray(int A[], int l, int r)\n{\n    // extreme condition, size zero or size two\n    int m;\n\n    // Precondition: A[l] > A[r]\n    if( A[l] >= A[r] )\n        return l;\n\n    while( l <= r )\n    {\n        // Termination condition (l will eventually falls on r, and r always\n        // point minimum possible value)\n        if( l == r )\n            return l;\n\n        m = l + (r-l)/2; // 'm' can fall in first pulse,\n                        // second pulse or exactly in the middle\n\n        if( A[m] < A[r] )\n            // min can't be in the range\n            // (m < i <= r), we can exclude A[m+1 ... r]\n            r = m;\n        else\n            // min must be in the range (m < i <= r),\n            // we must search in A[m+1 ... r]\n            l = m+1;\n    }\n\n    return -1;\n}\n\nint BinarySearchIndexOfMinimumRotatedArray(int A[], int size)\n{\n    return BinarySearchIndexOfMinimumRotatedArray(A, 0, size-1);\n}\n//this code is contributed by aditya942003patil\nint BinarySearchIndexOfMinimumRotatedArray(int A[], int l, int r)\n{\n    // extreme condition, size zero or size two\n    int m;\n\n    // Precondition: A[l] > A[r]\n    if( A[l] <= A[r] )\n        return l;\n\n    while( l <= r )\n    {\n        // Termination condition (l will eventually falls on r, and r always\n        // point minimum possible value)\n        if( l == r )\n            return l;\n\n        m = l + (r-l)/2; // 'm' can fall in first pulse,\n                        // second pulse or exactly in the middle\n\n        if( A[m] < A[r] )\n            // min can't be in the range\n            // (m < i <= r), we can exclude A[m+1 ... r]\n            r = m;\n        else\n            // min must be in the range (m < i <= r),\n            // we must search in A[m+1 ... r]\n            l = m+1;\n    }\n\n    return -1;\n}\n\nint BinarySearchIndexOfMinimumRotatedArray(int A[], int size)\n{\n    return BinarySearchIndexOfMinimumRotatedArray(A, 0, size-1);\n}\npublic static int binarySearchIndexOfMinimumRotatedArray(int A[], int l, int r)\n{\n\n  // extreme condition, size zero or size two  \n  int m;\n\n  // Precondition: A[l] > A[r]\n  if (A[l] >= A[r]) {\n    return l;\n  }\n\n  while (l <= r) {\n    // Termination condition (l will eventually falls on r, and r always\n    // point minimum possible value)\n    if (l == r) {\n      return l;\n    }\n\n    m = l + (r - l) / 2;\n\n    if (A[m] < A[r]) {\n      // min can't be in the range\n      // (m < i <= r), we can exclude A[m+1 ... r]\n      r = m;\n    } else {\n      // min must be in the range (m < i <= r),\n      // we must search in A[m+1 ... r]\n      l = m + 1;\n    }\n  }\n\n  return -1;\n}\n\npublic static int binarySearchIndexOfMinimumRotatedArray(int A[], int size) {\n  return binarySearchIndexOfMinimumRotatedArray(A, 0, size - 1);\n}\ndef BinarySearchIndexOfMinimumRotatedArray(A, l, r):\n    # extreme condition, size zero or size two\n    # Precondition: A[l] > A[r]\n    if A[l] >= A[r]:\n        return l\n    while (l <= r):\n        # Termination condition (l will eventually falls on r, and r always\n        # point minimum possible value)\n        if l == r:\n            return l\n        m = l+(r-l)//2  # 'm' can fall in first pulse,\n        # second pulse or exactly in the middle\n        if A[m] < A[r]:\n             # min can't be in the range\n             # (m < i <= r), we can exclude A[m+1 ... r]\n            r = m\n        else:\n             # min must be in the range (m < i <= r),\n             # we must search in A[m+1 ... r]\n\n            l = m+1\n    return -1\n\n\ndef BinarySearchIndexOfMinimumRotatedArray(A, size):\n    return BinarySearchIndexOfMinimumRotatedArray(A, 0, size-1)\n\n\n\"\"\"Code is written by Rajat Kumar\"\"\"\nusing System;\n\npublic class Program\n{\n    public static int BinarySearchIndexOfMinimumRotatedArray(int[] A, int l, int r)\n    {\n        // Extreme condition, size zero or size two\n        int m;\n\n        // Precondition: A[l] > A[r]\n        if (A[l] >= A[r])\n        {\n            return l;\n        }\n\n        while (l <= r)\n        {\n            // Termination condition (l will eventually fall on r, and r always\n            // points to the minimum possible value)\n            if (l == r)\n            {\n                return l;\n            }\n\n            m = l + (r - l) / 2;\n\n            if (A[m] < A[r])\n            {\n                // Minimum can't be in the range\n                // (m < i <= r), we can exclude A[m+1 ... r]\n                r = m;\n            }\n            else\n            {\n                // Minimum must be in the range (m < i <= r),\n                // we must search in A[m+1 ... r]\n                l = m + 1;\n            }\n        }\n\n        return -1;\n    }\n\n    public static int BinarySearchIndexOfMinimumRotatedArray(int[] A, int size)\n    {\n        return BinarySearchIndexOfMinimumRotatedArray(A, 0, size - 1);\n    }\n\n    public static void Main()\n    {\n        int[] A = { 6, 7, 8, 9, 1, 2, 3, 4, 5 };\n        int size = A.Length;\n\n        int minIndex = BinarySearchIndexOfMinimumRotatedArray(A, size);\n\n        Console.WriteLine(\"The index of the minimum element in the rotated array is: \" + minIndex);\n    }\n}\nfunction BinarySearchIndexOfMinimumRotatedArray(A, l, r){\n    // extreme condition, size zero or size two\n    let m;\n    \n    // Precondition: A[l] > A[r]\n    if(A[l] <= A[r]) return l;\n    \n    while(l <= r){\n        // Termination condition (l will eventually falls on r, and r always\n        // point minimum possible value)\n        if(l == r) return l;\n        m = l + (r-l)/2;\n        if(A[m] < A[r]){\n            // min can't be in the range\n            // (m < i <= r), we can exclude A[m+1 ... r]\n            r = m;\n        }else{\n            // min must be in the range (m < i <= r),\n            // we must search in A[m+1 ... r]\n            l = m+1;\n        }\n    }\n    return -1;\n}\n\nfunction BinarySearchIndexOfMinimumRotatedArray(A, size){\n    return BinarySearchIndexOfMinimumRotatedArray(A, 0, size-1);\n}\nsignum(x, y) = -1 if x < y             =  0 if x = y             =  1 if x > y\n",
        "complexity": {
            "time": "",
            "space": ""
        },
        "tags": [
            "Searching"
        ],
        "url": "https://www.geeksforgeeks.org/the-ubiquitous-binary-search-set-1/"
    },
    {
        "title": "Linear Search vs Binary Search",
        "description": "Prerequisite: LINEAR SEARCH Assume that item is in an array in random order and we have to find an item. Then the only way to search for a target item is, to begin with, the first position and compare it to the target. If the item is at the same, we will return the position of the current item. Otherwise, we will move to the next position. If we arrive at the last position of an array and still can not find the target, we return -1. This is called the Linear search or Sequential search. Below is the code syntax for the linear search.                   BINARY SEARCH In a binary search, however, cut down your search to half as soon as you find the middle of a sorted list. The middle element is looked at to check if it is greater than or less than the value to be searched. Accordingly, a search is done to either half of the given list Below is the code syntax for the binary search.                   Important Differences Linear Search Binary Search Let us look at an example to compare the two: Linear Search to find the element “J” in a given sorted list from A-X  Binary Search to find the element “J” in a given sorted list from A-X  LINEAR SEARCHING EXAMPLE:                   Time Complexity: O(n), where n is the size of the input array. The worst-case scenario is when the target element is not present in the array, and the function has to go through the entire array to figure that out.Auxiliary Space: O(1), the function uses only a constant amount of extra space to store variables. The amount of extra space used does not depend on the size of the input array. BINARY SEARCHING EXAMPLE:                   Time Complexity: O(log n) – Binary search algorithm divides the input array in half at every step, reducing the search space by half, and hence has a time complexity of logarithmic order.Auxiliary Space: O(1) – Binary search algorithm requires only constant space for storing the low, high, and mid indices, and does not require any additional data structures, so its auxiliary space complexity is O(1).  ",
        "code": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nElement found at index: 3\n\n\n\n\n\n\n\n\n\n\n\n\n7\n",
        "complexity": {
            "time": "Time Complexity: O(log n) – Binary search algorithm divides the input array in half at every step, reducing the search space by half, and hence has a time complexity of logarithmic order.Auxiliary Space: O(1) – Binary search algorithm requires only constant space for storing the low, high, and mid indices, and does not require any additional data structures, so its auxiliary space complexity is O(1).",
            "space": ""
        },
        "tags": [
            "Searching"
        ],
        "url": "https://www.geeksforgeeks.org/linear-search-vs-binary-search/"
    },
    {
        "title": "Interpolation search vs Binary search",
        "description": "Interpolation search works better than Binary Search for a Sorted and Uniformly Distributed array. Binary Search goes to the middle element to check irrespective of search-key. On the other hand, Interpolation Search may go to different locations according to search-key. If the value of the search-key is close to the last element, Interpolation Search is likely to start search toward the end side. Interpolation search and binary search are both algorithms for searching for a specific element in a sorted list or array. Both algorithms have an average-case time complexity of O(log n), which means that the time required to perform the search grows logarithmically with the size of the list. However, there are some key differences between interpolation search and binary search: Interpolation search estimates the position of the target element based on the values of the elements surrounding it, while binary search always starts by checking the middle element of the list. Interpolation search is more efficient than binary search when the elements in the list are uniformly distributed, while binary search is more efficient when the elements in the list are not uniformly distributed. Interpolation search can take longer to implement than binary search, as it requires the use of additional calculations to estimate the position of the target element. Example :                On average the interpolation search makes about log(log(n)) comparisons (if the elements are uniformly distributed), where n is the number of elements to be searched. In the worst case (for instance where the numerical values of the keys increase exponentially) it can make up to O(n) comparisons. Time Complexity : O(log(log n)) space complexity : O(1)Interpolation Search Article Sources: http://en.wikipedia.org/wiki/Interpolation_search  ",
        "code": "\n\n\n\n\n\n\n\n\n\n5 found at index 4\n",
        "complexity": {
            "time": "Time Complexity : O(log(log n))",
            "space": "space complexity : O(1)Interpolation Search Article Sources: http://en.wikipedia.org/wiki/Interpolation_search"
        },
        "tags": [
            "Searching"
        ],
        "url": "https://www.geeksforgeeks.org/g-fact-84/"
    },
    {
        "title": "Why is Binary Search preferred over Ternary Search?",
        "description": "The following is a simple recursive Binary Search function in C++ taken from here.                   The following is a simple recursive Ternary Search function :                      Which of the above two does less comparisons in worst case? From the first look, it seems the ternary search does less number of comparisons as it makes Log3n recursive calls, but binary search makes Log2n recursive calls. Let us take a closer look. The following is recursive formula for counting comparisons in worst case of Binary Search. The following is recursive formula for counting comparisons in worst case of Ternary Search. In binary search, there are 2Log2n + 1 comparisons in worst case. In ternary search, there are 4Log3n + 1 comparisons in worst case. Therefore, the comparison of Ternary and Binary Searches boils down the comparison of expressions 2Log3n and Log2n . The value of 2Log3n can be written as (2 / Log23) * Log2n . Since the value of (2 / Log23) is more than one, Ternary Search does more comparisons than Binary Search in worst case.Exercise: Why Merge Sort divides input array in two halves, why not in three or more parts?  A  ",
        "code": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nT(n) = T(n/2) + 2,  T(1) = 1\nT(n) = T(n/3) + 4, T(1) = 1\nTime Complexity for Binary search = 2clog2n + O(1)\nTime Complexity for Ternary search = 4clog3n + O(1)\n",
        "complexity": {
            "time": "",
            "space": ""
        },
        "tags": [
            "Searching"
        ],
        "url": "https://www.geeksforgeeks.org/binary-search-preferred-ternary-search/"
    },
    {
        "title": "Is Sentinel Linear Search better than normal Linear Search?",
        "description": "Sentinel Linear search is a type of linear search where the element to be searched is placed in the last position and then all the indices are checked for the presence of the element without checking for the index out of bound case. The number of comparisons is reduced in this search as compared to a traditional linear search. When a linear search is performed on an array of size N then in the worst case a total of N comparisons are made when the element to be searched is compared to all the elements of the array and (N + 1) comparisons are made for the index of the element to be compared so that the index is not out of bounds of the array which can be reduced in a Sentinel Linear Search. So total comparisons in the worst case can be 2*N + 1. But in this search, the last element of the array is replaced with the element to be searched and then the linear search is performed on the array without checking whether the current index is inside the index range of the array or not because the element to be searched will definitely be found inside the array even if it was not present in the original array. So, the index to be checked will never be out of the bounds of the array. The number of comparisons in the worst case there will be (N + 2). See below the implementations of both the searching algorithm: Time Complexity: O(n)Auxiliary Space: O(1) Below are the steps to implement the algorithm: Below is the code to implement the steps. Time Complexity: O(n)Auxiliary Space: O(1) In Sentinel Linear Search, we are doing one less comparison in each step. As mentioned earlier, we can see that in the worst case a traditional linear search utilizes 2*N+1 comparisons whereas the Sentinel linear search performs only N+2 comparisons. So we can conclude that Sentinel Linear Search is better than normal Linear Search.  ",
        "code": "// C++ code for traditional linear search\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Function for linear search\nint linearSearch(vector<int>& arr, int x) {\n    int n = arr.size();\n    \n    for (int i = 0; i < n; i++)\n        if (arr[i] == x)\n            return i;\n    return -1;\n}\n\nint main() {\n    vector<int> arr = { 2, 3, 4, 10, 40 };\n    int x = 10;\n\n    int result = linearSearch(arr, x);\n    if (result == -1)\n        cout << \"Element not present\";\n    else\n        cout << \"Element present at index \" << result << endl;\n\n    return 0;\n}\n// Java code for traditional linear search\nimport java.util.*;\n\nclass GfG {\n    \n    // Function for linear search\n    static int linearSearch(int[] arr, int x) {\n        int n = arr.length;\n        \n        for (int i = 0; i < n; i++)\n            if (arr[i] == x)\n                return i;\n        return -1;\n    }\n\n    public static void main(String[] args) {\n        int[] arr = { 2, 3, 4, 10, 40 };\n        int x = 10;\n\n        int result = linearSearch(arr, x);\n        if (result == -1)\n            System.out.println(\"Element not present\");\n        else\n            System.out.println(\"Element present at index \" + result);\n    }\n}\n# Python code for traditional linear search\n\n# Function for linear search\ndef linearSearch(arr, x):\n    n = len(arr)\n    \n    for i in range(n):\n        if arr[i] == x:\n            return i\n    return -1\n\nif __name__ == \"__main__\":\n    arr = [2, 3, 4, 10, 40]\n    x = 10\n\n    result = linearSearch(arr, x)\n    if result == -1:\n        print(\"Element not present\")\n    else:\n        print(\"Element present at index\", result)\n// C# code for traditional linear search\nusing System;\n\nclass GfG {\n    \n    // Function for linear search\n    static int linearSearch(int[] arr, int x) {\n        int n = arr.Length;\n        \n        for (int i = 0; i < n; i++)\n            if (arr[i] == x)\n                return i;\n        return -1;\n    }\n\n    static void Main() {\n        int[] arr = { 2, 3, 4, 10, 40 };\n        int x = 10;\n\n        int result = linearSearch(arr, x);\n        if (result == -1)\n            Console.WriteLine(\"Element not present\");\n        else\n            Console.WriteLine(\"Element present at index \" + result);\n    }\n}\n// JavaScript code for traditional linear search\n\n// Function for linear search\nfunction linearSearch(arr, x) {\n    let n = arr.length;\n    \n    for (let i = 0; i < n; i++)\n        if (arr[i] == x)\n            return i;\n    return -1;\n}\n\nlet arr = [2, 3, 4, 10, 40];\nlet x = 10;\n\nlet result = linearSearch(arr, x);\nif (result == -1)\n    console.log(\"Element not present\");\nelse\n    console.log(\"Element present at index \" + result);\nElement present at index 3\n// C++ implementation of Sentinel Linear Search\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Function to search Key in the given array\nint sentinelSearch(vector<int>& arr, int key) {\n    int n = arr.size();\n    \n    // Last element of the array\n    int last = arr[n - 1];\n\n    // Element to be searched is\n    // placed at the last index\n    arr[n - 1] = key;\n    int i = 0;\n\n    while (arr[i] != key)\n        i++;\n\n    // Put the last element back\n    arr[n - 1] = last;\n\n    if ((i < n - 1) || (arr[n - 1] == key))\n        return i;\n    else\n        return -1;\n}\n\nint main() {\n    vector<int> arr = { 2, 3, 4, 10, 40 };\n    int key = 10;\n    \n    int result = sentinelSearch(arr, key);\n    \n    if (result == -1) {\n        cout << \"Not found\" << endl;\n    }\n    else {\n        cout << \"Element found at index \" << result << endl;\n    }\n\n    return 0;\n}\n// Java implementation of Sentinel Linear Search\nimport java.util.*;\n\nclass GfG {\n    \n    // Function to search Key in the given array\n    static int sentinelSearch(int[] arr, int key) {\n        int n = arr.length;\n        \n        // Last element of the array\n        int last = arr[n - 1];\n\n        // Element to be searched is\n        // placed at the last index\n        arr[n - 1] = key;\n        int i = 0;\n\n        while (arr[i] != key)\n            i++;\n\n        // Put the last element back\n        arr[n - 1] = last;\n\n        if ((i < n - 1) || (arr[n - 1] == key))\n            return i;\n        else\n            return -1;\n    }\n\n    public static void main(String[] args) {\n        int[] arr = { 2, 3, 4, 10, 40 };\n        int key = 10;\n        \n        int result = sentinelSearch(arr, key);\n        \n        if (result == -1) {\n            System.out.println(\"Not found\");\n        } else {\n            System.out.println(\"Element found at index \" + result);\n        }\n    }\n}\n# Python implementation of Sentinel Linear Search\n\n# Function to search Key in the given array\ndef sentinelSearch(arr, key):\n    n = len(arr)\n    \n    # Last element of the array\n    last = arr[n - 1]\n\n    # Element to be searched is\n    # placed at the last index\n    arr[n - 1] = key\n    i = 0\n\n    while arr[i] != key:\n        i += 1\n\n    # Put the last element back\n    arr[n - 1] = last\n\n    if (i < n - 1) or (arr[n - 1] == key):\n        return i\n    else:\n        return -1\n\nif __name__ == \"__main__\":\n    arr = [2, 3, 4, 10, 40]\n    key = 10\n    \n    result = sentinelSearch(arr, key)\n    \n    if result == -1:\n        print(\"Not found\")\n    else:\n        print(\"Element found at index\", result)\n// C# implementation of Sentinel Linear Search\nusing System;\n\nclass GfG {\n    \n    // Function to search Key in the given array\n    static int sentinelSearch(int[] arr, int key) {\n        int n = arr.Length;\n        \n        // Last element of the array\n        int last = arr[n - 1];\n\n        // Element to be searched is\n        // placed at the last index\n        arr[n - 1] = key;\n        int i = 0;\n\n        while (arr[i] != key)\n            i++;\n\n        // Put the last element back\n        arr[n - 1] = last;\n\n        if ((i < n - 1) || (arr[n - 1] == key))\n            return i;\n        else\n            return -1;\n    }\n\n    static void Main() {\n        int[] arr = { 2, 3, 4, 10, 40 };\n        int key = 10;\n        \n        int result = sentinelSearch(arr, key);\n        \n        if (result == -1) {\n            Console.WriteLine(\"Not found\");\n        } else {\n            Console.WriteLine(\"Element found at index \" + result);\n        }\n    }\n}\n// JavaScript implementation of Sentinel Linear Search\n\n// Function to search Key in the given array\nfunction sentinelSearch(arr, key) {\n    let n = arr.length;\n    \n    // Last element of the array\n    let last = arr[n - 1];\n\n    // Element to be searched is\n    // placed at the last index\n    arr[n - 1] = key;\n    let i = 0;\n\n    while (arr[i] !== key)\n        i++;\n\n    // Put the last element back\n    arr[n - 1] = last;\n\n    if ((i < n - 1) || (arr[n - 1] === key))\n        return i;\n    else\n        return -1;\n}\n\nlet arr = [2, 3, 4, 10, 40];\nlet key = 10;\n\nlet result = sentinelSearch(arr, key);\n\nif (result === -1) {\n    console.log(\"Not found\");\n} else {\n    console.log(\"Element found at index \" + result);\n}\nElement found at index 3\n",
        "complexity": {
            "time": "Time Complexity: O(n)Auxiliary Space: O(1)",
            "space": ""
        },
        "tags": [
            "Searching"
        ],
        "url": "https://www.geeksforgeeks.org/is-sentinel-linear-search-better-than-normal-linear-search/"
    },
    {
        "title": "DSA Tutorial - Learn Data Structures and Algorithms",
        "description": "DSA (Data Structures and Algorithms)  is the study of organizing data efficiently using data structures like arrays, stacks, and trees, paired with step-by-step procedures (or algorithms) to solve problems effectively. Data structures manage how data is stored and accessed, while algorithms focus on processing this data. Hoping you have learned a programming language of your choice, here comes the next stage of the roadmap - Learn about Time and Space Complexities. Once you have learned basics of a programming language, it is recommended that you learn basic logic building To analyze algorithms, we mainly measure order of growth of time or space taken in terms of input size.  We do this in the worst case scenario in most of the cases. Please refer the below links for a clear understanding of these concepts. Array is a linear data structure where elements are allocated contiguous memory, allowing for constant-time access. Searching algorithms are used to locate specific data within a large set of data. It helps find a target value within the data. There are various types of searching algorithms, each with its own approach and efficiency. Sorting algorithms are used to arrange the elements of a list in a specific order, such as numerical or alphabetical. It organizes the items in a systematic way, making it easier to search for and access specific elements. Hashing is a technique that generates a fixed-size output (hash value) from an input of variable size using mathematical formulas called hash functions. Hashing is commonly used in data structures for efficient searching, insertion and deletion. In Two Pointer Technique, we typically use two index variables from two corners of an array. We use the two pointer technique for searching a required point or value in an array. In Window Sliding Technique, we use the result of previous subarray to quickly compute the result of current. In Prefix Sum Technique, we compute prefix sums of an array to quickly find results for a subarray. String is a sequence of characters, typically immutable and have limited set of elements (lower case or all English alphabets). Recursion is a programming technique where a function calls itself within its own definition. It is usually used to solve problems that can be broken down into smaller instances of the same problem. Matrix is a two-dimensional array of elements, arranged in rows and columns. It is represented as a rectangular grid, with each element at the intersection of a row and column. Linked list is a linear data structure that stores data in nodes, which are connected by pointers. Unlike arrays, nodes of linked lists are not stored in contiguous memory locations and can only be accessed sequentially, starting from the head of list. Stack is a linear data structure that follows the Last In, First Out (LIFO) principle. Stacks play an important role in managing function calls, memory, and are widely used in algorithms like stock span problem, next greater element and largest area in a histogram. Queue is a linear data structure that follows the First In, First Out (FIFO) principle. Queues play an important role in managing tasks or data in order, scheduling and message handling systems. A deque (double-ended queue) is a data structure that allows elements to be added or removed from both ends efficiently. Tree is a non-linear, hierarchical data structure consisting of nodes connected by edges, with a top node called the root and nodes having child nodes. It is widely used in file systems, databases, decision-making algorithms, etc. Heap is a complete binary tree data structure that satisfies the heap property. Heaps are usually used to implement priority queues, where the smallest or largest element is always at the root of the tree. Graph is a non-linear data structure consisting of a finite set of vertices(or nodes) and a set of edges(or links)that connect a pair of nodes. Graphs are widely used to represent relationships between entities. Greedy Algorithm builds up the solution one piece at a time and chooses the next piece which gives the most obvious and immediate benefit i.e., which is the most optimal choice at that moment. So the problems where choosing locally optimal also leads to the global solutions are best fit for Greedy. Dynamic Programming is a method used to solve complex problems by breaking them down into simpler subproblems. By solving each subproblem only once and storing the results, it avoids redundant computations, leading to more efficient solutions for a wide range of problems. Bitwise Algorithms: Operate on individual bits of numbers. Backtracking Algorithm : Follow Recursion  with the option to revert and traces back if the solution from current point is not feasible. Divide and conquer:  A strategy to solve problems by dividing them into smaller subproblems, solving those subproblems, and combining the solutions to obtain the final solution. Branch and Bound : Used in combinatorial optimization problems to systematically search for the best solution. It works by dividing the problem into smaller subproblems, or branches, and then eliminating certain branches based on bounds on the optimal solution. This process continues until the best solution is found or all branches have been explored. Geometric algorithms are a set of algorithms that solve problems related to shapes, points, lines and polygons. Randomized algorithms are algorithms that use randomness to solve problems. They make use of random input to achieve their goals, often leading to simpler and more efficient solutions. These algorithms may not product same result but are particularly useful in situations when a probabilistic approach is acceptable. Advanced Data Structures like Trie, Segment Tree, Red-Black Tree and Binary Indexed Tree offer significant performance improvements for specific problem domains. They provide efficient solutions for tasks like fast prefix searches, range queries, dynamic updates, and maintaining balanced data structures, which are crucial for handling large datasets and real-time processing. By optimizing time complexity, they enable better scalability and faster execution in many computational problems. R  ",
        "code": "",
        "complexity": {
            "time": "Advanced Data Structures like Trie, Segment Tree, Red-Black Tree and Binary Indexed Tree offer significant performance improvements for specific problem domains. They provide efficient solutions for tasks like fast prefix searches, range queries, dynamic updates, and maintaining balanced data structures, which are crucial for handling large datasets and real-time processing. By optimizing time complexity, they enable better scalability and faster execution in many computational problems.",
            "space": ""
        },
        "tags": [
            "Greedy"
        ],
        "url": "https://www.geeksforgeeks.org/learn-data-structures-and-algorithms-dsa-tutorial/"
    },
    {
        "title": "Algorithms Tutorial",
        "description": "Algorithm is a step-by-step procedure for solving a problem or accomplishing a task. In the context of data structures and algorithms, it is a set of well-defined instructions for performing a specific computational task. Algorithms are fundamental to computer science and play a very important role in designing efficient solutions for various problems. Understanding algorithms is essential for anyone interested in mastering data structures and algorithms.  An algorithm is a finite sequence of well-defined instructions that can be used to solve a computational problem. It provides a step-by-step procedure that convert an input into a desired output. Algorithms typically follow a logical structure: Algorithms are essential for solving complex computational problems efficiently and effectively. They provide a systematic approach to: Please refer Complete Data Structures & Algorithms Tutorial for topic-wise guide, practice problems and interview questions.  H  ",
        "code": "",
        "complexity": {
            "time": "",
            "space": ""
        },
        "tags": [
            "Greedy"
        ],
        "url": "https://www.geeksforgeeks.org/fundamentals-of-algorithms/"
    },
    {
        "title": "Analysis of Algorithms",
        "description": "Analysis of Algorithms is a fundamental aspect of computer science that involves evaluating performance of algorithms and programs. Efficiency is measured in terms of time and space. H  ",
        "code": "",
        "complexity": {
            "time": "",
            "space": ""
        },
        "tags": [
            "Greedy"
        ],
        "url": "https://www.geeksforgeeks.org/design-and-analysis-of-algorithms/"
    },
    {
        "title": "Sorting Algorithms",
        "description": "A Sorting Algorithm is used to rearrange a given array or list of elements in an order.  For example, a given array [10, 20, 5, 2] becomes [2, 5, 10, 20] after sorting in increasing order and becomes [20, 10, 5, 2] after sorting in decreasing order. Comparison Based : Selection Sort,  Bubble Sort,  Insertion Sort,  Merge Sort,  Quick Sort,  Heap Sort, Cycle Sort, 3-way Merge SortNon Comparison Based :  Counting Sort, Radix Sort, Bucket Sort,  TimSort, Comb Sort, Pigeonhole SortHybrid Sorting Algorithms : IntroSort, Tim Sort Quick Links : Recommended: H  ",
        "code": "",
        "complexity": {
            "time": "",
            "space": ""
        },
        "tags": [
            "Greedy"
        ],
        "url": "https://www.geeksforgeeks.org/sorting-algorithms/"
    },
    {
        "title": "Searching Algorithms",
        "description": "Searching algorithms are essential tools in computer science used to locate specific items within a collection of data. In this tutorial, we are mainly going to focus upon searching in an array. When we search an item in an array, there are two most common algorithms used based on the type of input array. One more common search technique is Two Pointers Technique where we begin searching from both ends of the array.  Quick Links: H  ",
        "code": "",
        "complexity": {
            "time": "",
            "space": ""
        },
        "tags": [
            "Greedy"
        ],
        "url": "https://www.geeksforgeeks.org/searching-algorithms/"
    },
    {
        "title": "Greedy Algorithms",
        "description": "Greedy algorithms are a class of algorithms that make locally optimal choices at each step with the hope of finding a global optimum solution. H  ",
        "code": "",
        "complexity": {
            "time": "",
            "space": ""
        },
        "tags": [
            "Greedy"
        ],
        "url": "https://www.geeksforgeeks.org/greedy-algorithms/"
    },
    {
        "title": "Recursive Algorithms",
        "description": "Recursion is technique used in computer science to solve big problems by breaking them into smaller, similar problems. The process in which a function calls itself directly or indirectly is called recursion and the corresponding function is called a recursive function. Using a recursive algorithm, certain problems can be solved quite easily.  Quiz based on Recursion: A recursive algorithm is an algorithm that uses recursion to solve a problem. Recursive algorithms typically have two parts: There are several different recursion types and terms. These include: Recursion is a powerful technique that can be used to solve a wide variety of problems. However, it is important to use recursion carefully, as it can lead to stack overflows if not used properly. Recursion should be used when: Here are some common examples of recursion: Example 1: Factorial: The factorial of a number n is the product of all the integers from 1 to n. The factorial of n can be defined recursively as: Example 2: Fibonacci sequence: The Fibonacci sequence is a sequence of numbers where each number is the sum of the two preceding numbers. The Fibonacci sequence can be defined recursively as: Here are some common applications of recursion:  ",
        "code": "factorial(n) = n * factorial(n-1)\nfib(n) = fib(n-1) + fib(n-2)\n",
        "complexity": {
            "time": "",
            "space": ""
        },
        "tags": [
            "Greedy"
        ],
        "url": "https://www.geeksforgeeks.org/recursion-algorithms/"
    },
    {
        "title": "Backtracking Algorithm",
        "description": "Backtracking algorithms are like problem-solving strategies that help explore different options to find the best solution. They work by trying out different paths and if one doesn't work, they backtrack and try another until they find the right one. It's like solving a puzzle by testing different pieces until they fit together perfectly. Quick Links : Backtracking is a problem-solving algorithmic technique that involves finding a solution incrementally by trying different options and undoing them if they lead to a dead end. It is commonly used in situations where you need to explore multiple possibilities to solve a problem, like searching for a path in a maze or solving puzzles like Sudoku. When a dead end is reached, the algorithm backtracks to the previous decision point and explores a different path until a solution is found or all possibilities have been exhausted. A backtracking algorithm works by recursively exploring all possible solutions to a problem. It starts by choosing an initial solution, and then it explores all possible extensions of that solution. If an extension leads to a solution, the algorithm returns that solution. If an extension does not lead to a solution, the algorithm backtracks to the previous solution and tries a different extension. The following is a general outline of how a backtracking algorithm works: Example: Finding the shortest path through a maze Input: A maze represented as a 2D array, where 0 represents an open space and 1 represents a wall. Algorithm: Backtracking algorithms are best used to solve problems that have the following characteristics: Backtracking algorithms are used in a wide variety of applications, including: H  ",
        "code": "",
        "complexity": {
            "time": "",
            "space": ""
        },
        "tags": [
            "Greedy"
        ],
        "url": "https://www.geeksforgeeks.org/backtracking-algorithms/"
    },
    {
        "title": "Dynamic Programming or DP",
        "description": "Dynamic Programming is an algorithmic technique with the following properties.  Quick Links: H  ",
        "code": "",
        "complexity": {
            "time": "",
            "space": ""
        },
        "tags": [
            "Greedy"
        ],
        "url": "https://www.geeksforgeeks.org/dynamic-programming/"
    },
    {
        "title": "Divide and Conquer Algorithm",
        "description": "Divide and Conquer algorithm is a problem-solving strategy that involves. Examples of Divide and Conquer are Merge Sort, Quick Sort, Binary Search and Closest Pair of Points.  Quick Links : H  ",
        "code": "",
        "complexity": {
            "time": "",
            "space": ""
        },
        "tags": [
            "Greedy"
        ],
        "url": "https://www.geeksforgeeks.org/divide-and-conquer/"
    },
    {
        "title": "Geometric Algorithms",
        "description": "Geometric algorithms are a type of algorithm that deal with solving problems related to geometry. These algorithms are used to solve various geometric problems such as computing the area of a polygon, finding the intersection of geometric shapes, determining the convex hull of a set of points, and many other tasks related to geometric objects and their properties. Geometric algorithms are important in various fields such as computer graphics, computer-aided design, robotics, and geographical information systems. Table of Content Quick Links : H  ",
        "code": "",
        "complexity": {
            "time": "",
            "space": ""
        },
        "tags": [
            "Greedy"
        ],
        "url": "https://www.geeksforgeeks.org/geometric-algorithms/"
    },
    {
        "title": "Mathematical Algorithms",
        "description": "The following is the list of mathematical coding problem ordered topic wise. Please refer Mathematical Algorithms (Difficulty Wise) for the difficulty wise list of problems. Quick Links : H  ",
        "code": "",
        "complexity": {
            "time": "",
            "space": ""
        },
        "tags": [
            "Greedy"
        ],
        "url": "https://www.geeksforgeeks.org/mathematical-algorithms/"
    },
    {
        "title": "Pattern Searching",
        "description": "Pattern searching algorithms are essential tools in computer science and data processing. These algorithms are designed to efficiently find a particular pattern within a larger set of data. Pattern searching algorithms have numerous applications, including: Recommended: H  ",
        "code": "",
        "complexity": {
            "time": "",
            "space": ""
        },
        "tags": [
            "Greedy"
        ],
        "url": "https://www.geeksforgeeks.org/pattern-searching/"
    },
    {
        "title": "Bitwise Algorithms",
        "description": "Bitwise algorithms in Data Structures and Algorithms (DSA) involve manipulating individual bits of binary representations of numbers to perform operations efficiently. These algorithms utilize bitwise operators like AND, OR, XOR, NOT, Left Shift, and Right Shift. Quick Links : Bitwise algorithms are algorithms that operate on individual bits of data rather than on larger data types like integers or floating-point numbers. These algorithms manipulate bits directly, typically using bitwise operators such as AND, OR, XOR, shift left, shift right, and complement. Here are some common bitwise algorithms and operations: Quick Links :  H  ",
        "code": "",
        "complexity": {
            "time": "",
            "space": ""
        },
        "tags": [
            "Greedy"
        ],
        "url": "https://www.geeksforgeeks.org/bitwise-algorithms/"
    },
    {
        "title": "Branch and Bound Algorithm",
        "description": "The Branch and Bound Algorithm is a method used in combinatorial optimization problems to systematically search for the best solution. It works by dividing the problem into smaller subproblems, or branches, and then eliminating certain branches based on bounds on the optimal solution. This process continues until the best solution is found or all branches have been explored. Branch and Bound is commonly used in problems like the traveling salesman and job scheduling. Branch and Bound Algorithm Quick Links: H  ",
        "code": "",
        "complexity": {
            "time": "",
            "space": ""
        },
        "tags": [
            "Greedy"
        ],
        "url": "https://www.geeksforgeeks.org/branch-and-bound-algorithm/"
    },
    {
        "title": "Randomized Algorithms",
        "description": "Randomized algorithms in data structures and algorithms (DSA) are algorithms that use randomness in their computations to achieve a desired outcome. These algorithms introduce randomness to improve efficiency or simplify the algorithm design. By incorporating random choices into their processes, randomized algorithms can often provide faster solutions or better approximations compared to deterministic algorithms. They are particularly useful in situations where exact solutions are difficult to find or when a probabilistic approach is acceptable. For example, in Randomized Quick Sort, we use a random number to pick the next pivot (or we randomly shuffle the array). Typically, this randomness is used to reduce time complexity or space complexity in other standard algorithms. Recommended: H  ",
        "code": "",
        "complexity": {
            "time": "For example, in Randomized Quick Sort, we use a random number to pick the next pivot (or we randomly shuffle the array). Typically, this randomness is used to reduce time complexity or space complexity in other standard algorithms.",
            "space": ""
        },
        "tags": [
            "Greedy"
        ],
        "url": "https://www.geeksforgeeks.org/randomized-algorithms/"
    },
    {
        "title": "DSA Tutorial - Learn Data Structures and Algorithms",
        "description": "DSA (Data Structures and Algorithms)  is the study of organizing data efficiently using data structures like arrays, stacks, and trees, paired with step-by-step procedures (or algorithms) to solve problems effectively. Data structures manage how data is stored and accessed, while algorithms focus on processing this data. Hoping you have learned a programming language of your choice, here comes the next stage of the roadmap - Learn about Time and Space Complexities. Once you have learned basics of a programming language, it is recommended that you learn basic logic building To analyze algorithms, we mainly measure order of growth of time or space taken in terms of input size.  We do this in the worst case scenario in most of the cases. Please refer the below links for a clear understanding of these concepts. Array is a linear data structure where elements are allocated contiguous memory, allowing for constant-time access. Searching algorithms are used to locate specific data within a large set of data. It helps find a target value within the data. There are various types of searching algorithms, each with its own approach and efficiency. Sorting algorithms are used to arrange the elements of a list in a specific order, such as numerical or alphabetical. It organizes the items in a systematic way, making it easier to search for and access specific elements. Hashing is a technique that generates a fixed-size output (hash value) from an input of variable size using mathematical formulas called hash functions. Hashing is commonly used in data structures for efficient searching, insertion and deletion. In Two Pointer Technique, we typically use two index variables from two corners of an array. We use the two pointer technique for searching a required point or value in an array. In Window Sliding Technique, we use the result of previous subarray to quickly compute the result of current. In Prefix Sum Technique, we compute prefix sums of an array to quickly find results for a subarray. String is a sequence of characters, typically immutable and have limited set of elements (lower case or all English alphabets). Recursion is a programming technique where a function calls itself within its own definition. It is usually used to solve problems that can be broken down into smaller instances of the same problem. Matrix is a two-dimensional array of elements, arranged in rows and columns. It is represented as a rectangular grid, with each element at the intersection of a row and column. Linked list is a linear data structure that stores data in nodes, which are connected by pointers. Unlike arrays, nodes of linked lists are not stored in contiguous memory locations and can only be accessed sequentially, starting from the head of list. Stack is a linear data structure that follows the Last In, First Out (LIFO) principle. Stacks play an important role in managing function calls, memory, and are widely used in algorithms like stock span problem, next greater element and largest area in a histogram. Queue is a linear data structure that follows the First In, First Out (FIFO) principle. Queues play an important role in managing tasks or data in order, scheduling and message handling systems. A deque (double-ended queue) is a data structure that allows elements to be added or removed from both ends efficiently. Tree is a non-linear, hierarchical data structure consisting of nodes connected by edges, with a top node called the root and nodes having child nodes. It is widely used in file systems, databases, decision-making algorithms, etc. Heap is a complete binary tree data structure that satisfies the heap property. Heaps are usually used to implement priority queues, where the smallest or largest element is always at the root of the tree. Graph is a non-linear data structure consisting of a finite set of vertices(or nodes) and a set of edges(or links)that connect a pair of nodes. Graphs are widely used to represent relationships between entities. Greedy Algorithm builds up the solution one piece at a time and chooses the next piece which gives the most obvious and immediate benefit i.e., which is the most optimal choice at that moment. So the problems where choosing locally optimal also leads to the global solutions are best fit for Greedy. Dynamic Programming is a method used to solve complex problems by breaking them down into simpler subproblems. By solving each subproblem only once and storing the results, it avoids redundant computations, leading to more efficient solutions for a wide range of problems. Bitwise Algorithms: Operate on individual bits of numbers. Backtracking Algorithm : Follow Recursion  with the option to revert and traces back if the solution from current point is not feasible. Divide and conquer:  A strategy to solve problems by dividing them into smaller subproblems, solving those subproblems, and combining the solutions to obtain the final solution. Branch and Bound : Used in combinatorial optimization problems to systematically search for the best solution. It works by dividing the problem into smaller subproblems, or branches, and then eliminating certain branches based on bounds on the optimal solution. This process continues until the best solution is found or all branches have been explored. Geometric algorithms are a set of algorithms that solve problems related to shapes, points, lines and polygons. Randomized algorithms are algorithms that use randomness to solve problems. They make use of random input to achieve their goals, often leading to simpler and more efficient solutions. These algorithms may not product same result but are particularly useful in situations when a probabilistic approach is acceptable. Advanced Data Structures like Trie, Segment Tree, Red-Black Tree and Binary Indexed Tree offer significant performance improvements for specific problem domains. They provide efficient solutions for tasks like fast prefix searches, range queries, dynamic updates, and maintaining balanced data structures, which are crucial for handling large datasets and real-time processing. By optimizing time complexity, they enable better scalability and faster execution in many computational problems. R  ",
        "code": "",
        "complexity": {
            "time": "Advanced Data Structures like Trie, Segment Tree, Red-Black Tree and Binary Indexed Tree offer significant performance improvements for specific problem domains. They provide efficient solutions for tasks like fast prefix searches, range queries, dynamic updates, and maintaining balanced data structures, which are crucial for handling large datasets and real-time processing. By optimizing time complexity, they enable better scalability and faster execution in many computational problems.",
            "space": ""
        },
        "tags": [
            "Recursion"
        ],
        "url": "https://www.geeksforgeeks.org/learn-data-structures-and-algorithms-dsa-tutorial/"
    },
    {
        "title": "Top 50 Problems on Recursion Algorithm",
        "description": "Recursion is one of the most essential algorithms that uses the concept of code reusability and repeated usage of the same piece of code. In this post, we have curated an extensive list of interview questions asked around the Recursion Algorithm. The point that makes Recursion one of the most used algorithms is that it forms the base for many other algorithms,such as: To learn more about the Recursion Algorithm, Please refer to the Tutorial on Recursion Algorithms  R  ",
        "code": "",
        "complexity": {
            "time": "",
            "space": ""
        },
        "tags": [
            "Recursion"
        ],
        "url": "https://www.geeksforgeeks.org/top-50-interview-problems-on-recursion-algorithm/"
    },
    {
        "title": "No Title",
        "description": "",
        "code": "",
        "complexity": {
            "time": "",
            "space": ""
        },
        "tags": [
            "Recursion"
        ],
        "url": "https://www.geeksforgeeks.org/explore?page=1&category=Recursion&sortBy=submissions"
    },
    {
        "title": "Top MCQs on Recursion Algorithm with Answers",
        "description": "Question 1 Predict output of following program 4 8 16 Runtime Error Question 2 Consider the following recursive function fun(x, y). What is the value of fun(4, 3) 13 12 9 10 Question 3 What does the following function print for n = 25? 11001 10011 11111 00000 Question 4 What does the following function do? x + y x + x*y x*y xy Question 5 What does fun2() do in general? x*y x+x*y xy yx Question 6 Output of following program? 1000 2000 4000 1000 2000 4000 4000 2000 1000 1000 2000 4000 2000 1000 1000 2000 2000 1000 Question 7 What does the following function do? It returns 1 when n is a multiple of 3, otherwise returns 0 It returns 1 when n is a power of 3, otherwise returns 0 It returns 0 when n is a multiple of 3, otherwise returns 1 It returns 0 when n is a power of 3, otherwise returns 1 Question 8 Predict the output of following program Stack Overflow 3 4 5 Question 9 Predict the output: Question 10 Consider the following recursive C++ function that takes two arguments What is the return value of the function foo when it is called foo(345, 10)? 345 12 5 3 There are 30 questions to complete. ",
        "code": "#include <iostream>\n\nint fun(int n)\n{\n    if (n == 4)\n       return n;\n    else return 2 * fun(n + 1);\n}\n\nint main()\n{\n   std::cout << fun(2);\n   return 0;\n}\n#include <stdio.h>\n\nint fun(int n)\n{\n    if (n == 4)\n       return n;\n    else return 2*fun(n+1);\n}\n\n\nint main()\n{\n   printf(\"%d\", fun(2));\n   return 0;\n}\npublic class Main {\n    public static int fun(int n) {\n        if (n == 4)\n            return n;\n        else return 2 * fun(n + 1);\n    }\n\n    public static void main(String[] args) {\n        System.out.println(fun(2));\n    }\n}\ndef fun(n):\n    if n == 4:\n        return n\n    else:\n        return 2 * fun(n + 1)\n\nprint(fun(2))\nfunction fun(n) {\n    if (n === 4)\n        return n;\n    else return 2 * fun(n + 1);\n}\n\nconsole.log(fun(2));\nint fun(int x, int y) {\n  if (x == 0)\n    return y;\n  return fun(x - 1, x + y);\n}\nint fun(int x, int y) \n{\n  if (x == 0)\n    return y;\n  return fun(x - 1,  x + y);\n}\nint fun(int x, int y) {\n  if (x == 0)\n    return y;\n  return fun(x - 1, x + y);\n}\ndef fun(x, y):\n  if x == 0:\n    return y\n  return fun(x - 1, x + y)\nfunction fun(x, y) {\n  if (x === 0)\n    return y;\n  return fun(x - 1, x + y);\n}\n#include <iostream>\nusing namespace std;\n\nvoid fun(int n) {\n    if (n == 0)\n        return;\n\n    cout << n % 2;\n    fun(n / 2);\n}\nvoid fun(int n)\n{\n  if (n == 0)\n    return;\n\n  printf(\"%d\", n%2);\n  fun(n/2);\n}\npublic class Main {\n    public static void fun(int n) {\n        if (n == 0)\n            return;\n\n        System.out.print(n % 2);\n        fun(n / 2);\n    }\n\n    public static void main(String[] args) {\n        fun(10); // Example call\n    }\n}\ndef fun(n):\n    if n == 0:\n        return\n\n    print(n % 2, end='')\n    fun(n // 2)\nfunction fun(n) {\n    if (n === 0)\n        return;\n\n    process.stdout.write((n % 2).toString());\n    fun(Math.floor(n / 2));\n}\nint fun(int x, int y)\n{\n    if (y == 0)   return 0;\n    return (x + fun(x, y-1));\n}\n#include <iostream>\n\nint fun(int x, int y) {\n    if (y == 0) return 0;\n    return (x + fun(x, y-1));\n}\n\nint fun2(int a, int b) {\n    if (b == 0) return 1;\n    return fun(a, fun2(a, b-1));\n}\nint fun(int x, int y)\n{\n    if (y == 0)   return 0;\n    return (x + fun(x, y-1));\n}\n\nint fun2(int a, int b)\n{\n    if (b == 0) return 1;\n    return fun(a, fun2(a, b-1));\n}\npublic class Main {\n    public static int fun(int x, int y) {\n        if (y == 0) return 0;\n        return (x + fun(x, y - 1));\n    }\n\n    public static int fun2(int a, int b) {\n        if (b == 0) return 1;\n        return fun(a, fun2(a, b - 1));\n    }\n\n    public static void main(String[] args) {\n        // Example usage\n    }\n}\ndef fun(x, y):\n    if y == 0:\n        return 0\n    return x + fun(x, y - 1)\n\ndef fun2(a, b):\n    if b == 0:\n        return 1\n    return fun(a, fun2(a, b - 1))\nfunction fun(x, y) {\n    if (y === 0) return 0;\n    return x + fun(x, y - 1);\n}\n\nfunction fun2(a, b) {\n    if (b === 0) return 1;\n    return fun(a, fun2(a, b - 1));\n}\n#include <iostream>\nusing namespace std;\n\nvoid print(int n) {\n    if (n > 4000)\n        return;\n    cout << n << \" \";\n    print(2 * n);\n    cout << n << \" \";\n}\n\nint main() {\n    print(1000);\n    cin.get();\n    return 0;\n}\n#include<stdio.h>\nvoid print(int n)\n{\n    if (n > 4000)\n        return;\n    printf(\"%d \", n);\n    print(2*n);\n    printf(\"%d \", n);\n}\n\nint main()\n{\n    print(1000);\n    getchar();\n    return 0;\n}\npublic class Main {\n    public static void print(int n) {\n        if (n > 4000)\n            return;\n        System.out.print(n + \" \");\n        print(2 * n);\n        System.out.print(n + \" \");\n    }\n\n    public static void main(String[] args) {\n        print(1000);\n    }\n}\ndef print_numbers(n):\n    if n > 4000:\n        return\n    print(n, end=' ')\n    print_numbers(2 * n)\n    print(n, end=' ')\n\nprint_numbers(1000)\nfunction print(n) {\n    if (n > 4000)\n        return;\n    process.stdout.write(n + ' ');\n    print(2 * n);\n    process.stdout.write(n + ' ');\n}\n\nprint(1000);\nint fun(unsigned int n) {\n    if (n == 0 || n == 1)\n        return n;\n\n    if (n % 3 != 0)\n        return 0;\n\n    return fun(n / 3);\n}\nint fun(unsigned int n)\n{\n    if (n == 0 || n == 1)\n        return n;\n\n    if (n%3 != 0)\n        return 0;\n\n    return fun(n/3);\n}\nint fun(unsigned int n) {\n    if (n == 0 || n == 1)\n        return n;\n\n    if (n % 3 != 0)\n        return 0;\n\n    return fun(n / 3);\n}\ndef fun(n):\n    if n == 0 or n == 1:\n        return n\n\n    if n % 3 != 0:\n        return 0\n\n    return fun(n // 3)\nfunction fun(n) {\n    if (n === 0 || n === 1)\n        return n;\n\n    if (n % 3 !== 0)\n        return 0;\n\n    return fun(n / 3);\n}\n#include <iostream>\nusing namespace std;\n\nint f(int n) {\n    if(n <= 1)\n        return 1;\n    if(n % 2 == 0)\n        return f(n / 2);\n    return f(n / 2) + f(n / 2 + 1);\n}\n\nint main() {\n    cout << f(11);\n    return 0;\n}\n#include <stdio.h>\nint f(int n)\n{\n    if(n <= 1)\n        return 1;\n    if(n%2 == 0)\n        return f(n/2);\n    return f(n/2) + f(n/2+1);\n}\n\n\nint main()\n{\n    printf(\"%d\", f(11));\n    return 0;\n}\npublic class Main {\n    public static int f(int n) {\n        if(n <= 1)\n            return 1;\n        if(n % 2 == 0)\n            return f(n / 2);\n        return f(n / 2) + f(n / 2 + 1);\n    }\n\n    public static void main(String[] args) {\n        System.out.println(f(11));\n    }\n}\ndef f(n):\n    if n <= 1:\n        return 1\n    if n % 2 == 0:\n        return f(n // 2)\n    return f(n // 2) + f(n // 2 + 1)\n\nprint(f(11))\nfunction f(n) {\n    if (n <= 1)\n        return 1;\n    if (n % 2 === 0)\n        return f(n / 2);\n    return f(Math.floor(n / 2)) + f(Math.floor(n / 2) + 1);\n}\n\nconsole.log(f(11));\n#include <iostream>\nusing namespace std;\n\nvoid crazy(int n, int a, int b)\n{\n    if (n <= 0)\n        return;\n    crazy(n - 1, a, b + n);\n    cout << n << \" \" << a << \" \" << b << endl;\n    crazy(n - 1, b, a + n);\n}\n\nint main()\n{\n    crazy(3, 4, 5);\n    return 0;\n}\n#include <stdio.h>\nvoid crazy(int n, int a, int b)\n{\n    if (n <= 0)\n        return;\n    crazy(n - 1, a, b + n);\n    printf(\"%d %d %d \\n\",n,a,b);\n    crazy(n-1, b, a+n);\n}\n\nint main()\n{\n    crazy(3, 4, 5);\n    return 0;\n}\npublic class Crazy {\n    public static void crazy(int n, int a, int b) {\n        if (n <= 0)\n            return;\n        crazy(n - 1, a, b + n);\n        System.out.println(n + \" \" + a + \" \" + b);\n        crazy(n - 1, b, a + n);\n    }\n\n    public static void main(String[] args) {\n        crazy(3, 4, 5);\n    }\n}\ndef crazy(n, a, b):\n    if n <= 0:\n        return\n    crazy(n - 1, a, b + n)\n    print(n, a, b)\n    crazy(n - 1, b, a + n)\ncrazy(3, 4, 5)\nfunction crazy(n, a, b) {\n    if (n <= 0)\n        return;\n    crazy(n - 1, a, b + n);\n    console.log(n, a, b);\n    crazy(n - 1, b, a + n);\n}\n\ncrazy(3, 4, 5);\n1 4 102 4 81 8 63 4 51 5 92 5 71 7 7\n3 4 51 4 102 4 81 8 61 5 92 5 71 7 7\n1 4 102 4 81 8 63 4 5\n3 4 51 5 92 5 71 7 7\nunsigned int foo(unsigned int n, unsigned int r) {\n  if (n  > 0) return (n%r +  foo (n/r, r ));\n  else return 0;\n}\nunsigned int foo(unsigned int n, unsigned int r) {\n    if (n > 0) return (n % r + foo(n / r, r));\n    else return 0;\n}\npublic class Main {\n    public static int foo(int n, int r) {\n        if (n > 0) return (n % r + foo(n / r, r));\n        else return 0;\n    }\n}\ndef foo(n, r):\n    if n > 0:\n        return (n % r + foo(n // r, r))\n    else:\n        return 0\nfunction foo(n, r) {\n    if (n > 0) return (n % r + foo(Math.floor(n / r), r));\n    else return 0;\n}\n",
        "complexity": {
            "time": "",
            "space": ""
        },
        "tags": [
            "Recursion"
        ],
        "url": "https://www.geeksforgeeks.org/quizzes/top-mcqs-on-recursion-algorithm-with-answers/"
    },
    {
        "title": "Introduction to Recursion",
        "description": "The process in which a function calls itself directly or indirectly is called recursion and the corresponding function is called a recursive function. Need of Recursion Steps to Implement Recursion Step1 – Define a base case: Identify the simplest (or base) case for which the solution is known or trivial. This is the stopping condition for the recursion, as it prevents the function from infinitely calling itself.Step2 – Define a recursive case: Define the problem in terms of smaller subproblems. Break the problem down into smaller versions of itself, and call the function recursively to solve each subproblem.Step3 – Ensure the recursion terminates: Make sure that the recursive function eventually reaches the base case, and does not enter an infinite loop.Step4 – Combine the solutions: Combine the solutions of the subproblems to solve the original problem. Example 1 : Sum of Natural Numbers Let us consider a problem to find the sum of natural numbers, there are several ways of doing that but the simplest approach is simply to add the numbers starting from 0 to n. What is the base condition in recursion? A recursive program stops at a base condition.  There can be more than one base conditions in a recursion. In the above program, the base condition is when n = 1. How a particular problem is solved using recursion? The idea is to represent a problem in terms of one or more smaller problems, and add one or more base conditions that stop the recursion. Example 2 : Factorial of a Number The factorial of a number n (where n >= 0) is the product of all positive integers from 1 to n. To compute the factorial recursively, we calculate the factorial of n by using the factorial of (n-1). The base case for the recursive function is when n = 0, in which case we return 1. Illustration of the above code: When does Stack Overflow error occur in recursion? If the base case is not reached or not defined, then the stack overflow problem may arise. Let us take an example to understand this. int fact(int n){    // wrong base case (it may cause stack overflow).    if (n == 100)         return 1;    else        return n*fact(n-1);} What is the difference between direct and indirect recursion? A function is called direct recursive if it calls itself directly during its execution. In other words, the function makes a recursive call to itself within its own body. An indirect recursive function is one that calls another function, and that other function, in turn, calls the original function either directly or through other functions. This creates a chain of recursive calls involving multiple functions, as opposed to direct recursion, where a function calls itself. // An example of direct recursionvoid directRecFun(){    // Some code….    directRecFun();    // Some code…}// An example of indirect recursionvoid indirectRecFun1(){    // Some code…    indirectRecFun2();    // Some code…}void indirectRecFun2(){    // Some code…    indirectRecFun1();    // Some code…} What is the difference between tail and non-tail recursion? A recursive function is tail recursive when a recursive call is the last thing executed by the function. Please refer tail recursion for details. How memory is allocated to different function calls in recursion? Recursion uses more memory to store data of every recursive call in an internal function call stack. When any function is called from main(), the memory is allocated to it on the stack. A recursive function calls itself, the memory for a called function is allocated on top of memory allocated to the calling function and a different copy of local variables is created for each function call. When the base case is reached, the function returns its value to the function by whom it is called and memory is de-allocated and the process continues.Let us take the example of how recursion works by taking a simple function. Initial Call: When printFun(3) is called from main(), memory is allocated for printFun(3). The local variable test is initialized to 3, and statements 1 to 4 are pushed onto the stack. First Recursive Call: Second Recursive Call: Third Recursive Call: Base Case: When printFun(0) is called, it hits the base case (if statement) and returns control to printFun(1). Returning from Recursion: Output: As a result, the output will print the values in the following order: The memory stack grows with each function call and shrinks as the recursion unwinds, following the LIFO structure.  Recursion VS Iteration What are the advantages of recursive programming over iterative programming? What are the disadvantages of recursive programming over iterative programming? Note every recursive program can be written iteratively and vice versa is also true. Example 3 : Fibonacci with Recursion Write a program and recurrence relation to find the Fibonacci series of n where n >= 0. Mathematical Equation: n if n == 0, n == 1;      fib(n) = fib(n-1) + fib(n-2) otherwise; Recurrence Relation: T(n) = T(n-1) + T(n-2) + O(1) Recursion Tree for the above Code: fibonacci series These are just a few examples of the many applications of recursion in computer science and programming. Recursion is a versatile and powerful tool that can be used to solve many different types of problems. Summary of Recursion: Output based practice problems for beginners: Practice Questions for Recursion | Set 1 Practice Questions for Recursion | Set 2 Practice Questions for Recursion | Set 3 Practice Questions for Recursion | Set 4 Practice Questions for Recursion | Set 5 Practice Questions for Recursion | Set 6 Practice Questions for Recursion | Set 7Quiz on Recursion Coding Practice on Recursion: All Articles on Recursion Recursive Practice Problems with Solutions S  ",
        "code": "#include <iostream>\nusing namespace std;\n\n// Recursive function to find the sum of \n// numbers from 0 to n\nint findSum(int n)\n{\n    // Base case \n    if (n == 1) \n        return 1; \n  \n    // Recursive case \n    return n + findSum(n - 1);\n}\n\nint main()\n{\n    int n = 5;\n    cout << findSum(n);\n    return 0;\n}\n#include <stdio.h>\n\n// Recursive function to find the sum of \n// numbers from 0 to n\nint findSum(int n)\n{\n    // Base case \n    if (n == 1) \n        return 1; \n  \n    // Recursive case \n    return n + findSum(n - 1);\n}\n\nint main()\n{\n    int n = 5;\n    printf(\"%d\", findSum(n));\n    return 0;\n}\npublic class Main {\n    // Recursive function to find the sum of \n    // numbers from 0 to n\n    static int findSum(int n) {\n        // Base case \n        if (n == 1) \n            return 1; \n        \n        // Recursive case \n        return n + findSum(n - 1);\n    }\n\n    public static void main(String[] args) {\n        int n = 5;\n        System.out.println(findSum(n));\n    }\n}\ndef findSum(n):\n    # Base case \n    if n == 1:\n        return 1\n    \n    # Recursive case \n    return n + findSum(n - 1)\n\nn = 5\nprint(findSum(n))\nusing System;\n\nclass Program {\n    // Recursive function to find the sum of \n    // numbers from 0 to n\n    static int FindSum(int n) {\n        // Base case \n        if (n == 1) \n            return 1;\n        \n        // Recursive case \n        return n + FindSum(n - 1);\n    }\n\n    static void Main() {\n        int n = 5;\n        Console.WriteLine(FindSum(n));\n    }\n}\n// Recursive function to find the sum of \n// numbers from 0 to n\nfunction findSum(n) {\n    // Base case \n    if (n === 1) \n        return 1;\n    \n    // Recursive case \n    return n + findSum(n - 1);\n}\n\nlet n = 5;\nconsole.log(findSum(n));\n15\n#include <iostream>\nusing namespace std;\n\nint fact(int n)\n{\n    // BASE CONDITION\n    if (n == 0)\n        return 1;\n  \n    return n * fact(n - 1);\n}\n\nint main()\n{\n    cout << \"Factorial of 5 : \" << fact(5);\n    return 0;\n}\n#include <stdio.h>\n\nint fact(int n) {\n  \n    // BASE CONDITION\n    if (n == 0)\n        return 1;\n  \n    return n * fact(n - 1);\n}\n\nint main() {\n    printf(\"Factorial of 5 : %d\\n\", fact(5));\n    return 0;\n}\npublic class GfG {\n    public static int fact(int n) {\n      \n        // BASE CONDITION\n        if (n == 0)\n            return 1;\n      \n        return n * fact(n - 1);\n    }\n\n    public static void main(String[] args) {\n        System.out.println(\"Factorial of 5 : \" + fact(5));\n    }\n}\ndef fact(n):\n  \n    # BASE CONDITION\n    if n == 0:\n        return 1\n    return n * fact(n - 1)\n\nprint(\"Factorial of 5 : \", fact(5))\nusing System;\n\nclass Program {\n    static int Fact(int n) {\n      \n        // BASE CONDITION\n        if (n == 0)\n            return 1;\n        \n        return n * Fact(n - 1);\n    }\n\n    static void Main() {\n        Console.WriteLine(\"Factorial of 5 : \" + Fact(5));\n    }\n}\nfunction fact(n) {\n\n    // BASE CONDITION\n    if (n === 0)\n        return 1;\n    \n    return n * fact(n - 1);\n}\n\nconsole.log(\"Factorial of 5 : \" + fact(5));\n<?php\nfunction fact($n) {\n  \n    // BASE CONDITION\n    if ($n == 0)\n        return 1;\n  \n    return $n * fact($n - 1);\n}\n\necho \"Factorial of 5 : \" . fact(5);\n?>\nFactorial of 5 : 120\n// A C++ program to demonstrate working of\n// recursion\n#include <bits/stdc++.h>\nusing namespace std;\n\nvoid printFun(int test)\n{\n    if (test < 1)\n        return;\n    else {\n        cout << test << \" \";\n        printFun(test - 1); // statement 2\n        cout << test << \" \";\n        return;\n    }\n}\n\n// Driver Code\nint main()\n{\n    int test = 3;\n    printFun(test);\n}\n// A C program to demonstrate working of recursion\n#include <stdio.h>\n\nvoid printFun(int test)\n{\n    if (test < 1)\n        return;\n    else {\n        printf(\"%d \", test);\n        printFun(test - 1); // statement 2\n        printf(\"%d \", test);\n        return;\n    }\n}\n\n// Driver Code\nint main()\n{\n    int test = 3;\n    printFun(test);\n    return 0;\n}\n// A Java program to demonstrate working of\n// recursion\nclass GFG {\n    static void printFun(int test)\n    {\n        if (test < 1)\n            return;\n        else {\n            System.out.printf(\"%d \", test);\n            printFun(test - 1); // statement 2\n            System.out.printf(\"%d \", test);\n            return;\n        }\n    }\n\n    // Driver Code\n    public static void main(String[] args)\n    {\n        int test = 3;\n        printFun(test);\n    }\n}\n\n// This code is contributed by\n// Smitha Dinesh Semwal\n# A Python 3 program to\n# demonstrate working of\n# recursion\n\n\ndef printFun(test):\n\n    if (test < 1):\n        return\n    else:\n\n        print(test, end=\" \")\n        printFun(test-1)  # statement 2\n        print(test, end=\" \")\n        return\n\n# Driver Code\ntest = 3\nprintFun(test)\n\n# This code is contributed by\n# Smitha Dinesh Semwal\n// A C# program to demonstrate\n// working of recursion\nusing System;\n\nclass GFG {\n\n    // function to demonstrate\n    // working of recursion\n    static void printFun(int test)\n    {\n        if (test < 1)\n            return;\n        else {\n            Console.Write(test + \" \");\n\n            // statement 2\n            printFun(test - 1);\n\n            Console.Write(test + \" \");\n            return;\n        }\n    }\n\n    // Driver Code\n    public static void Main(String[] args)\n    {\n        int test = 3;\n        printFun(test);\n    }\n}\n\n// This code is contributed by Anshul Aggarwal.\n// A JavaScript program to demonstrate working of recursion\nfunction printFun(test) {\n    if (test < 1)\n        return;\n    else {\n        console.log(test);\n        printFun(test - 1); // statement 2\n        console.log(test);\n        return;\n    }\n}\n\n// Driver Code\nlet test = 3;\nprintFun(test);\n<?php\n// PHP program to demonstrate \n// working of recursion\n\n// function to demonstrate \n// working of recursion\nfunction printFun($test)\n{\n    if ($test < 1)\n        return;\n    else\n    {\n        echo(\"$test \");\n        \n        // statement 2\n        printFun($test-1); \n        \n        echo(\"$test \");\n        return;\n    }\n}\n\n// Driver Code\n$test = 3;\nprintFun($test);\n\n// This code is contributed by\n// Smitha Dinesh Semwal.\n?>\n3 2 1 1 2 3\n// C++ code to implement Fibonacci series\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Function for fibonacci\n\nint fib(int n)\n{\n    // Stop condition\n    if (n == 0)\n        return 0;\n\n    // Stop condition\n    if (n == 1 || n == 2)\n        return 1;\n\n    // Recursion function\n    else\n        return (fib(n - 1) + fib(n - 2));\n}\n\n// Driver Code\nint main()\n{\n    // Initialize variable n.\n    int n = 5;\n    cout<<\"Fibonacci series of 5 numbers is: \";\n\n    // for loop to print the fibonacci series.\n    for (int i = 0; i < n; i++) \n    {\n        cout<<fib(i)<<\" \";\n    }\n    return 0;\n}\n// C code to implement Fibonacci series\n#include <stdio.h>\n\n// Function for fibonacci\nint fib(int n)\n{\n    // Stop condition\n    if (n == 0)\n        return 0;\n\n    // Stop condition\n    if (n == 1 || n == 2)\n        return 1;\n\n    // Recursion function\n    else\n        return (fib(n - 1) + fib(n - 2));\n}\n\n// Driver Code\nint main()\n{\n    // Initialize variable n.\n    int n = 5;\n    printf(\"Fibonacci series \"\n           \"of %d numbers is: \",\n           n);\n\n    // for loop to print the fibonacci series.\n    for (int i = 0; i < n; i++) {\n        printf(\"%d \", fib(i));\n    }\n    return 0;\n}\n// Java code to implement Fibonacci series\nimport java.util.*;\n\nclass GFG\n{\n\n// Function for fibonacci\nstatic int fib(int n)\n{\n    // Stop condition\n    if (n == 0)\n        return 0;\n\n    // Stop condition\n    if (n == 1 || n == 2)\n        return 1;\n\n    // Recursion function\n    else\n        return (fib(n - 1) + fib(n - 2));\n}\n\n// Driver Code\npublic static void main(String []args)\n{\n  \n    // Initialize variable n.\n    int n = 5;\n    System.out.print(\"Fibonacci series of 5 numbers is: \");\n\n    // for loop to print the fibonacci series.\n    for (int i = 0; i < n; i++) \n    {\n        System.out.print(fib(i)+\" \");\n    }\n}\n}\n\n// This code is contributed by rutvik_56.\n# Python code to implement Fibonacci series\n\n# Function for fibonacci\ndef fib(n):\n\n    # Stop condition\n    if (n == 0):\n        return 0\n\n    # Stop condition\n    if (n == 1 or n == 2):\n        return 1\n\n    # Recursion function\n    else:\n        return (fib(n - 1) + fib(n - 2))\n\n\n# Driver Code\n\n# Initialize variable n.\nn = 5;\nprint(\"Fibonacci series of 5 numbers is :\",end=\" \")\n\n# for loop to print the fibonacci series.\nfor i in range(0,n): \n    print(fib(i),end=\" \")\nusing System;\n\npublic class GFG\n{\n\n  // Function for fibonacci\n  static int fib(int n)\n  {\n\n    // Stop condition\n    if (n == 0)\n      return 0;\n\n    // Stop condition\n    if (n == 1 || n == 2)\n      return 1;\n\n    // Recursion function\n    else\n      return (fib(n - 1) + fib(n - 2));\n  }\n\n  // Driver Code\n  static public void Main ()\n  {\n\n    // Initialize variable n.\n    int n = 5;\n    Console.Write(\"Fibonacci series of 5 numbers is: \");\n\n    // for loop to print the fibonacci series.\n    for (int i = 0; i < n; i++) \n    {\n      Console.Write(fib(i) + \" \");\n    }\n  }\n}\n\n// This code is contributed by avanitrachhadiya2155\n// Function for fibonacci\nfunction fib(n) {\n    // Stop condition\n    if (n === 0) return 0;\n\n    // Stop condition\n    if (n === 1 || n === 2) return 1;\n\n    // Recursion function\n    return fib(n - 1) + fib(n - 2);\n}\n\n// Driver Code\nlet n = 5;\nconsole.log(\"Fibonacci series of 5 numbers is:\");\n\n// for loop to print the fibonacci series.\nfor (let i = 0; i < n; i++) {\n    console.log(fib(i) + \" \");\n}\nFibonacci series of 5 numbers is: 0 1 1 2 3\n",
        "complexity": {
            "time": "",
            "space": ""
        },
        "tags": [
            "Recursion"
        ],
        "url": "https://www.geeksforgeeks.org/introduction-to-recursion-2/"
    },
    {
        "title": "Recursive Functions",
        "description": "A Recursive function can be defined as a routine that calls itself directly or indirectly. In other words, a recursive function is a function that solves a problem by solving smaller instances of the same problem. This technique is commonly used in programming to solve problems that can be broken down into simpler, similar subproblems.  A recursive function is a function that solves a problem by solving smaller instances of the same problem. This technique is often used in programming to solve problems that can be broken down into simpler, similar subproblems. Recursive functions break complex problems into smaller instances of the same problem, resulting in compact and readable code. Recursive functions are suitable for divide-and-conquer algorithms such as merge sort and quicksort, breaking problems into smaller subproblems, solving them recursively, and merging the solutions with the original problem. Recursive backtracking is ideal for exploring and solving problems like N-Queens and Sudoku. Recursive functions efficiently solve dynamic programming problems by solving subproblems and combining their solutions into a complete solution. Recursive functions are great for working with tree and graph structures, simplifying traversal and pattern recognition tasks. Base case: Every recursive function must have a base case. The base case is the simplest scenario that does not require further recursion. This is a termination condition that prevents the function from calling itself indefinitely. Without a proper base case, a recursive function can lead to infinite recursion. Recursive case: In the recursive case, the function calls itself with the modified arguments. This is the essence of recursion – solving a larger problem by breaking it down into smaller instances of the same problem. The recursive case should move closer to the base case with each iteration. Let’s consider the example of factorial of number: In this example, the base case is when n is 0, and the function returns 1. The recursive case multiplies n with the result of the function called with parameter n – 1. The process continues until the base case is reached. It’s essential to ensure that the recursive function has a correct base case and that the recursive calls lead to the base case, otherwise, the procedure might run indefinitely, leading to a stack overflow (exceeding the available memory allocated for function calls). Below is the implementation of factorial of a number: Time Complexity: O(n)Auxiliary Space: O(n)  ",
        "code": "#include <iostream>\nusing namespace std;\n\n// Recursive Function to calculate Factorial of a number\nint factorial(int n)\n{\n    // Base case\n    if (n == 0) {\n        return 1;\n    }\n\n    // Recursive case\n    return n * factorial(n - 1);\n}\n\n// Driver Code\n\nint main()\n{\n    int n = 4;\n\n    cout << \"Factorial of \" << n\n         << \" is:\" << factorial(n);\n    return 0;\n}\nimport java.util.Scanner;\n\npublic class Factorial {\n    // Recursive Function to calculate the factorial of a number\n    static int factorial(int n) {\n        // Base case: If n is 0, the factorial is 1.\n        if (n == 0) {\n            return 1;\n        }\n\n        // Recursive case: Calculate the factorial by multiplying n with the factorial of (n - 1).\n        return n * factorial(n - 1);\n    }\n\n    public static void main(String[] args) {\n        int n = 4;\n\n        // Calculate and print the factorial of n.\n        int result = factorial(n);\n        System.out.println(\"Factorial of \" + n + \" is: \" + result);\n    }\n}\n# Recursive Function to calculate Factorial of a number\ndef factorial(n):\n    # Base case\n    if n == 0:\n        return 1\n\n    # Recursive case\n    return n * factorial(n - 1)\n\n# Driver Code\nif __name__ == \"__main__\":\n    n = 4\n\n    print(\"Factorial of\", n, \"is:\", factorial(n))\nusing System;\n\nclass Program\n{\n    // Recursive Function to calculate Factorial of a number\n    static int Factorial(int n)\n    {\n        // Base case\n        if (n == 0)\n        {\n            return 1;\n        }\n\n        // Recursive case\n        return n * Factorial(n - 1);\n    }\n\n    // Driver Code\n    static void Main()\n    {\n        int n = 4;\n\n        Console.WriteLine(\"Factorial of \" + n + \" is: \" + Factorial(n));\n    }\n}\n// Function to calculate the factorial of a number using recursion\nfunction factorial(n) {\n    // Base case: If n is 0, the factorial is 1.\n    if (n === 0) {\n        return 1;\n    }\n\n    // Recursive case: Calculate the factorial by multiplying n with the factorial of (n - 1).\n    return n * factorial(n - 1);\n}\n\n// Main function\nfunction main() {\n    // Given number\n    let n = 4;\n\n    // Calculate the factorial of n.\n    let result = factorial(n);\n\n    // Print the result\n    console.log(\"Factorial of \" + n + \" is: \" + result);\n}\n\n// Call the main function\nmain();\nFactorial of 4 is:24\n",
        "complexity": {
            "time": "Time Complexity: O(n)Auxiliary Space: O(n)",
            "space": ""
        },
        "tags": [
            "Recursion"
        ],
        "url": "https://www.geeksforgeeks.org/recursive-functions/"
    },
    {
        "title": "Difference between Recursion and Iteration",
        "description": "A program is called recursive when an entity calls itself. A program is called iterative when there is a loop (or repetition). Example: Program to find the factorial of a number                      Below is a detailed explanation to illustrate the difference between the two using the above example. We will study the different aspects of both recursive and iterative approaches. The time complexity of the method may vary depending on whether the algorithm is implemented using recursion or iteration. Usage of either of these techniques is a trade-off between time complexity and size of code. If time complexity is the point of focus, and the number of recursive calls would be large, it is better to use iteration. However, if time complexity is not an issue and shortness of code is, recursion would be the way to go. Recursion has a large amount of Overhead as compared to Iteration. Infinite Repetition in recursion can lead to a CPU crash but in iteration, it will stop when memory is exhausted. The following table lists the major differences between iteration and recursion: Property Recursion Iteration  ",
        "code": "\n\n\n\n\n\n\n\n\n\n\n\n\n\nFactorial of 5 using Recursion is: 120\nFactorial of 5 using Iteration is: 120\nTime Complexity: O(2n)\nAuxiliary Space: O(n)\n",
        "complexity": {
            "time": "Usage of either of these techniques is a trade-off between time complexity and size of code. If time complexity is the point of focus, and the number of recursive calls would be large, it is better to use iteration. However, if time complexity is not an issue and shortness of code is, recursion would be the way to go.",
            "space": ""
        },
        "tags": [
            "Recursion"
        ],
        "url": "https://www.geeksforgeeks.org/difference-between-recursion-and-iteration/"
    },
    {
        "title": "Types of Recursions",
        "description": "What is Recursion? The process in which a function calls itself directly or indirectly is called recursion and the corresponding function is called a recursive function. Using recursive algorithm, certain problems can be solved quite easily. Examples of such problems are Towers of Hanoi (TOH), Inorder/Preorder/Postorder Tree Traversals, DFS of Graph, etc. Types of Recursions: Recursion are mainly of two types depending on whether a function calls itself from within itself or more than one function call one another mutually. The first one is called direct recursion and another one is called indirect recursion. Thus, the two types of recursion are: 1. Direct Recursion: These can be further categorized into four types:                   Let’s understand the example by tracing tree of recursive function. That is how the calls are made and how the outputs are produced.  Time Complexity For Tail Recursion : O(n) Space Complexity For Tail Recursion : O(n)Note: Time & Space Complexity is given for this specific example. It may vary for another example. Let’s now converting Tail Recursion into Loop and compare each other in terms of Time & Space Complexity and decide which is more efficient.                   Time Complexity: O(n) Space Complexity: O(1) Note: Time & Space Complexity is given for this specific example. It may vary for another example.So it was seen that in case of loop the Space Complexity is O(1) so it was better to write code in loop instead of tail recursion in terms of Space Complexity which is more efficient than tail recursion. Why space complexity is less in case of loop ?Before explaining this I am assuming that you are familiar with the knowledge that’s how the data stored in main memory during execution of a program. In brief,when the program executes,the main memory divided into three parts. One part for code section, the second one is heap memory and another one is stack memory. Remember that the program can directly access only the stack memory, it can’t directly access the heap memory so we need the help of pointer to access the heap memory. Let’s now understand why space complexity is less in case of loop ?In case of loop when function “(void fun(int y))” executes there only one activation record created in stack memory(activation record created for only ‘y’ variable) so it takes only ‘one’ unit of memory inside stack so it’s space complexity is O(1) but in case of recursive function every time it calls itself for each call a separate activation record created in stack.So if there’s ‘n’ no of call then it takes ‘n’ unit of memory inside stack so it’s space complexity is O(n).                   Let’s understand the example by tracing tree of recursive function. That is how the calls are made and how the outputs are produced.  Time Complexity For Head Recursion: O(n) Space Complexity For Head Recursion: O(n) Note: Time & Space Complexity is given for this specific example. It may vary for another example.Note: Head recursion can’t easily convert into loop as Tail Recursion but it can. Let’s convert the above code into the loop.                   Program for tree recursion                   Let’s understand the example by tracing tree of recursive function. That is how the calls are made and how the outputs are produced.  Time Complexity For Tree Recursion: O(2^n) Space Complexity For Tree Recursion: O(n)Note: Time & Space Complexity is given for this specific example. It may vary for another example.                   Let’s understand the example by tracing tree of recursive function. That is how the calls are made and how the outputs are produced.  2. Indirect Recursion: In this recursion, there may be more than one functions and they are calling one another in a circular manner.  From the above diagram fun(A) is calling for fun(B), fun(B) is calling for fun(C) and fun(C) is calling for fun(A) and thus it makes a cycle. Example:                   Let’s understand the example by tracing tree of recursive function. That is how the calls are made and how the outputs are produced.   A  ",
        "code": "\n\n\n\n\n\n\n\n\n\n\n\n3 2 1\n\n\n\n\n\n\n\n\n\n\n\n\n3 2 1\n\n\n\n\n\n\n\n\n\n\n\n\n1 2 3\n\n\n\n\n\n\n\n\n\n\n\n\n1 2 3\nfun(n)\r\n{\r\n    // some code\r\n    if(n>0)\r\n    {\r\n        fun(n-1); // Calling itself only once\r\n    }\r\n    // some code\r\n}\n\n\n\n\n\n\n\n\n\n\n\n\n3 2 1 1 2 1 1\n\n\n\n\n\n\n\n\n\n\n\n\n91\n\n\n\n\n\n\n\n\n\n\n\n\n20 19 9 8 4 3 1\n",
        "complexity": {
            "time": "Time Complexity For Tree Recursion: O(2^n) Space Complexity For Tree Recursion: O(n)Note: Time & Space Complexity is given for this specific example. It may vary for another example.",
            "space": "Note: Time & Space Complexity is given for this specific example. It may vary for another example.Note: Head recursion can’t easily convert into loop as Tail Recursion but it can. Let’s convert the above code into the loop."
        },
        "tags": [
            "Recursion"
        ],
        "url": "https://www.geeksforgeeks.org/types-of-recursions/"
    },
    {
        "title": "What is Tail Recursion",
        "description": "Tail recursion is defined as a recursive function in which the recursive call is the last statement that is executed by the function. So basically nothing is left to execute after the recursion call. For example the following function print() is tail recursive. The tail recursive functions are considered better than non-tail recursive functions as tail-recursion can be optimized by the compiler. Compilers usually execute recursive procedures by using a stack. This stack consists of all the pertinent information, including the parameter values, for each recursive call. When a procedure is called, its information is pushed onto a stack, and when the function terminates the information is popped out of the stack. Thus for the non-tail-recursive functions, the stack depth (maximum amount of stack space used at any time during compilation) is more. The idea used by compilers to optimize tail-recursive functions is simple, since the recursive call is the last statement, there is nothing left to do in the current function, so saving the current function’s stack frame is of no use (See this for more details). Consider the following function to calculate the factorial of n. It is a non-tail-recursive function. Although it looks like a tail recursive at first look. If we take a closer look, we can see that the value returned by fact(n-1) is used in fact(n). So the call to fact(n-1) is not the last thing done by fact(n). The above function can be written as a tail-recursive function. The idea is to use one more argument and accumulate the factorial value in the second argument. When n reaches 0, return the accumulated value. Below is the implementation using a tail-recursive function. Next articles on this topic:   ",
        "code": "// An example of tail recursive function\n\nstatic void print(int n)\n{\n    if (n < 0)\n        return;\n    cout << \" \" << n;\n \n    // The last executed statement is recursive call\n    print(n - 1);\n}\n// An example of tail recursive function\n\nvoid print(int n)\n{\n    if (n < 0)\n        return;\n    printf(\"%d \", n);\n\n    // The last executed statement is recursive call\n    print(n - 1);\n}\n// An example of tail recursive function\n\nstatic void print(int n)\n{\n    if (n < 0)\n        return;\n\n    System.out.print(\" \" + n);\n\n    // The last executed statement\n    // is recursive call\n    print(n - 1);\n}\n# An example of tail recursive function\n\n\ndef prints(n):\n\n    if (n < 0):\n        return\n    print(str(n), end=' ')\n\n    # The last executed statement is recursive call\n    prints(n-1)\n// An example of tail recursive function\n\nstatic void print(int n)\n{\n    if (n < 0)\n        return;\n\n    Console.Write(\" \" + n);\n\n    // The last executed statement\n    // is recursive call\n    print(n - 1);\n}\nfunction prints(n) {\n    if (n < 0) {\n        return;\n    }\n    console.log(n);\n    \n    // The last executed statement\n    // is recursive call\n    prints(n - 1);\n}\n#include <iostream>\nusing namespace std;\n\n// A NON-tail-recursive function.  The function is not tail\n// recursive because the value returned by fact(n-1) is used\n// in fact(n) and call to fact(n-1) is not the last thing\n// done by fact(n)\nunsigned int fact(unsigned int n)\n{\n    if (n <= 0)\n        return 1;\n\n    return n * fact(n - 1);\n}\n\n// Driver program to test above function\nint main()\n{\n    cout << fact(5);\n    return 0;\n}\nclass GFG {\n\n    // A NON-tail-recursive function.\n    // The function is not tail\n    // recursive because the value\n    // returned by fact(n-1) is used\n    // in fact(n) and call to fact(n-1)\n    // is not the last thing done by\n    // fact(n)\n    static int fact(int n)\n    {\n        if (n == 0)\n            return 1;\n\n        return n * fact(n - 1);\n    }\n\n    // Driver program\n    public static void main(String[] args)\n    {\n        System.out.println(fact(5));\n    }\n}\n\n// This code is contributed by Smitha.\n# A NON-tail-recursive function.\n# The function is not tail\n# recursive because the value\n# returned by fact(n-1) is used\n# in fact(n) and call to fact(n-1)\n# is not the last thing done by\n# fact(n)\n\n\ndef fact(n):\n    if (n == 0):\n        return 1\n    return n * fact(n-1)\n\n\n# Driver program to test\n# above function\nif __name__ == '__main__':\n    print(fact(5))\nusing System;\n\nclass GFG {\n\n    // A NON-tail-recursive function.\n    // The function is not tail\n    // recursive because the value\n    // returned by fact(n-1) is used\n    // in fact(n) and call to fact(n-1)\n    // is not the last thing done by\n    // fact(n)\n    static int fact(int n)\n    {\n        if (n == 0)\n            return 1;\n\n        return n * fact(n - 1);\n    }\n\n    // Driver program to test\n    // above function\n    public static void Main() { Console.Write(fact(5)); }\n}\n\n// This code is contributed by Smitha\n// A NON-tail-recursive function\n// The function is not tail\n// recursive because the value\n// returned by fact(n-1) is used\n// in fact(n) and call to fact(n-1)\n// is not the last thing done by\n// fact(n)\n\nfunction fact(n) {\n    if (n === 0) {\n        return 1;\n    }\n    return n * fact(n - 1);\n}\n\n// Driver program to test\n// above function\nconsole.log(fact(5));\n<?php\n// A NON-tail-recursive function. \n// The function is not tail\n// recursive because the value \n// returned by fact(n-1) is used in\n// fact(n) and call to fact(n-1) is\n// not the last thing done by fact(n)\n\nfunction fact( $n)\n{\n    if ($n == 0) return 1;\n\n    return $n * fact($n - 1);\n}\n\n    // Driver Code\n    echo fact(5);\n\n?>\n120\n#include <iostream>\nusing namespace std;\n\n// A tail recursive function to calculate factorial\nunsigned factTR(unsigned int n, unsigned int a)\n{\n    if (n <= 1)\n        return a;\n\n    return factTR(n - 1, n * a);\n}\n\n// A wrapper over factTR\nunsigned int fact(unsigned int n) { return factTR(n, 1); }\n\n// Driver program to test above function\nint main()\n{\n    cout << fact(5);\n    return 0;\n}\n// Java Code for Tail Recursion\n\nclass GFG {\n\n    // A tail recursive function\n    // to calculate factorial\n    static int factTR(int n, int a)\n    {\n        if (n <= 0)\n            return a;\n\n        return factTR(n - 1, n * a);\n    }\n\n    // A wrapper over factTR\n    static int fact(int n) { return factTR(n, 1); }\n\n    // Driver code\n    static public void main(String[] args)\n    {\n        System.out.println(fact(5));\n    }\n}\n\n// This code is contributed by Smitha.\n# A tail recursive function\n# to calculate factorial\n\n\ndef fact(n, a=1):\n\n    if (n <= 1):\n        return a\n\n    return fact(n - 1, n * a)\n\n\n# Driver program to test\n# above function\nprint(fact(5))\n\n# This code is contributed\n# by Smitha\n# improved by Ujwal, ashish2021\n// C# Code for Tail Recursion\n\nusing System;\n\nclass GFG {\n\n    // A tail recursive function\n    // to calculate factorial\n    static int factTR(int n, int a)\n    {\n        if (n <= 0)\n            return a;\n\n        return factTR(n - 1, n * a);\n    }\n\n    // A wrapper over factTR\n    static int fact(int n) { return factTR(n, 1); }\n\n    // Driver code\n    static public void Main()\n    {\n        Console.WriteLine(fact(5));\n    }\n}\n\n// This code is contributed by Ajit.\n<script>\n\n// Javascript Code for Tail Recursion\n\n// A tail recursive function\n// to calculate factorial\nfunction factTR(n, a)\n{\n    if (n <= 0)\n        return a;\n \n    return factTR(n - 1, n * a);\n}\n \n// A wrapper over factTR\nfunction fact(n)\n{\n    return factTR(n, 1);\n}\n\n// Driver code \ndocument.write(fact(5));\n\n// This code is contributed by rameshtravel07\n    \n</script>\n<?php\n\n// A tail recursive function\n// to calculate factorial\nfunction factTR($n, $a)\n{\n    if ($n <= 0) return $a;\n\n    return factTR($n - 1, $n * $a);\n}\n\n// A wrapper over factTR\nfunction fact($n)\n{\n    return factTR($n, 1);\n}\n\n// Driver program to test \n// above function\necho fact(5);\n\n// This code is contributed\n// by Smitha\n?>\n120\n",
        "complexity": {
            "time": "",
            "space": ""
        },
        "tags": [
            "Recursion"
        ],
        "url": "https://www.geeksforgeeks.org/tail-recursion/"
    },
    {
        "title": "Josephus Problem",
        "description": "There are N people standing in a circle waiting to be executed. The counting out begins at some point in the circle and proceeds around the circle in a fixed direction. In each step, a certain number of people are skipped and the next person is executed. The elimination proceeds around the circle (which is becoming smaller and smaller as the executed people are removed), until only the last person remains, who is given freedom. Given the total number of persons N and a number k which indicates that k-1 persons are skipped and the kth person is killed in a circle. The task is to choose the person in the initial circle that survives. Examples: Input: N = 5 and k = 2Output: 3Explanation: Firstly, the person at position 2 is killed, then the person at position 4 is killed, then the person at position 1 is killed. Finally, the person at position 5 is killed. So the person at position 3 survives. Input: N = 7 and k = 3Output: 4Explanations: The persons at positions 3, 6, 2, 7, 5, and 1 are killed in order, and the person at position 4 survives. Input: N = 6 and k = 2Output: 5Explanation: The persons at positions 2, 4, 6, 3, and 1 are killed in order, and the person at position 5 survives. The simple approach is to create a list and add all values from 1 to N to it. Create a recursive function that takes a list, start (position at which counting will start), and k ( number of people to be skipped) as an argument. Follow the below steps to Implement the idea: Time Complexity: O(N2)Auxiliary Space: O(N), For recursion stack Illustration: Follow the below steps to Implement the idea: Time Complexity: O(n2)Auxiliary Space: O(n) Follow the below steps: Time Complexity: O(n)Auxiliary Space: O(1) The problem has the following recursive structure. josephus(n, k) = (josephus(n – 1, k) + k-1) % n + 1 and josephus(1, k) = 1 After the first person (kth from the beginning) is killed, n-1 persons are left. Make recursive call for Josephus(n – 1, k) to get the position with n-1 persons. But the position returned by Josephus(n – 1, k) will consider the position starting from k%n + 1. So make adjustments to the position returned by Josephus(n – 1, k). Time Complexity: O(n)Auxiliary Space: O(n) the space used in recursion call stack Related Article: Josephus problem | Set 2 (A Simple Solution when k = 2)   ",
        "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nvoid Josh(vector<int> person, int k, int index)\n{\n    // Base case , when only one person is left\n    if (person.size() == 1) {\n        cout << person[0] << endl;\n        return;\n    }\n\n    // find the index of first person which will die\n    index = ((index + k) % person.size());\n\n    // remove the first person which is going to be killed\n    person.erase(person.begin() + index);\n\n    // recursive call for n-1 persons\n    Josh(person, k, index);\n}\n\nint main()\n{\n    int n = 14; // specific n and k  values for original\n                // josephus problem\n    int k = 2;\n    k--; // (k-1)th person will be killed\n    int index\n        = 0; // The index where the person which will die\n\n    vector<int> person;\n    // fill the person vector\n    for (int i = 1; i <= n; i++) {\n        person.push_back(i);\n    }\n\n    Josh(person, k, index);\n}\nimport java.util.*;\n\nclass GFG{\n\n\n  static void Josh(List<Integer> person, int k, int index)\n  {\n    \n    // Base case , when only one person is left\n    if (person.size() == 1) {\n      System.out.println(person.get(0));\n      return;\n    }\n\n    // find the index of first person which will die\n    index = ((index + k) % person.size());\n\n    // remove the first person which is going to be killed\n    person.remove(index);\n\n    // recursive call for n-1 persons\n    Josh(person, k, index);\n  }\n\n  // Driver code\n  public static void main(String [] args)\n  {\n    int n = 14; // specific n and k  values for original\n    // josephus problem\n    int k = 2;\n    k--; // (k-1)th person will be killed\n    int index\n      = 0; // The index where the person which will die\n\n    List<Integer> person = new ArrayList<>();\n    \n    // fill the person vector\n    for (int i = 1; i <= n; i++) {\n      person.add(i);\n    }\n\n    Josh(person, k, index);\n  }\n}\n# Python code for Josephus Problem\ndef Josh(person, k, index):\n  \n  # Base case , when only one person is left\n  if len(person) == 1:\n    print(person[0])\n    return\n  \n  # find the index of first person which will die\n  index = ((index+k)%len(person))\n  \n   # remove the first person which is going to be killed\n  person.pop(index)\n  \n  # recursive call for n-1 persons\n  Josh(person,k,index)\n\n# Driver Program to test above function\nn = 14 # specific n and k  values for original josephus problem\nk = 2\nk-=1   # (k-1)th person will be killed\n\nindex = 0 \n\n# fill the person vector\nperson=[]\nfor i in range(1,n+1):\n  person.append(i)\n\nJosh(person,k,index)\nusing System;\nusing System.Collections.Generic;\nclass GFG {\n    \n    static void Josh(List<int> person, int k, int index)\n    {\n        // Base case , when only one person is left\n        if (person.Count == 1) {\n            Console.WriteLine(person[0]);\n            return;\n        }\n     \n        // find the index of first person which will die\n        index = ((index + k) % person.Count);\n     \n        // remove the first person which is going to be killed\n        person.RemoveAt(index);\n     \n        // recursive call for n-1 persons\n        Josh(person, k, index);\n    }\n\n  // Driver code\n  static void Main()\n  {\n    int n = 14; // specific n and k  values for original\n                // josephus problem\n    int k = 2;\n    k--; // (k-1)th person will be killed\n    int index\n        = 0; // The index where the person which will die\n \n    List<int> person = new List<int>();\n    // fill the person vector\n    for (int i = 1; i <= n; i++) {\n        person.Add(i);\n    }\n \n    Josh(person, k, index);\n  }\n}\nfunction Josh( person , k , index) {\n\n        // Base case , when only one person is left\n        if (person.length == 1) {\n            console.log(person[0]);\n            return;\n        }\n\n        // find the index of first person which will die\n        index = ((index + k) % person.length);\n\n        // remove the first person which is going to be killed\n         if (index > -1) {\n       person.splice(index, 1);\n    }\n\n        // recursive call for n-1 persons\n        Josh(person, k, index);\n    }\n\n    // Driver code\n    \n        var n = 14; // specific n and k values for original\n        // josephus problem\n        var k = 2;\n        k--; // (k-1)th person will be killed\n        var index = 0; // The index where the person which will die\n\n        var person = [];\n\n        // fill the person vector\n        for (var i = 1; i <= n; i++) {\n            person.push(i);\n        }\n\n        Josh(person, k, index);\n13\n#include <bits/stdc++.h>\nusing namespace std;\n\nint Josephus(int, int);\n\nint Josephus(int n, int k)\n{\n    k--;\n    int arr[n];\n\n    // Makes all the 'n' people alive by\n    // assigning them value = 1\n    for (int i = 0; i < n; i++) {\n        arr[i] = 1;\n    }\n    int cnt = 0, cut = 0,\n        // Cut = 0 gives the sword to 1st person.\n        num = 1;\n\n    // Loop continues till n-1 person dies.\n    while (cnt < (n - 1)) {\n\n        // Checks next (kth) alive persons.\n        while (num <= k) {\n            cut++;\n\n            // Checks and resolves overflow\n            // of Index.\n            cut = cut % n;\n            if (arr[cut] == 1) {\n                // Updates the number of persons\n                // alive.\n                num++;\n            }\n        }\n\n        // Refreshes value to 1 for next use.\n        num = 1;\n\n        // Kills the person at position of 'cut'\n        arr[cut] = 0;\n\n        // Updates the no. of killed persons.\n        cnt++;\n        cut++;\n\n        // Checks and resolves overflow of Index.\n        cut = cut % n;\n\n        // Checks the next alive person the\n        // sword is to be given.\n        while (arr[cut] == 0) {\n            cut++;\n\n            // Checks and resolves overflow\n            // of Index.\n            cut = cut % n;\n        }\n    }\n\n    // Output is the position of the last\n    // man alive(Index + 1);\n    return cut + 1;\n}\n\n// Driver code\nint main()\n{\n    int n = 14, k = 2;\n    cout << Josephus(n, k);\n    return 0;\n}\n// Java code to implement the above approach\nimport java.io.*;\nclass GFG {\n\n    public static void main(String[] args)\n    {\n        int n = 14, k = 2;\n        System.out.println(Josephus(n, k));\n    }\n\n    public static int Josephus(int n, int k)\n    {\n        k--;\n        int arr[] = new int[n];\n        for (int i = 0; i < n; i++) {\n            arr[i] = 1; // Makes all the 'n' people alive by\n            // assigning them value = 1\n        }\n        int cnt = 0, cut = 0,\n            num\n            = 1; // Cut = 0 gives the sword to 1st person.\n        while (\n            cnt\n            < (n\n               - 1)) // Loop continues till n-1 person dies.\n        {\n            while (num\n                   <= k) // Checks next (kth) alive persons.\n            {\n                cut++;\n                cut = cut\n                      % n; // Checks and resolves overflow\n                // of Index.\n                if (arr[cut] == 1) {\n                    num++; // Updates the number of persons\n                    // alive.\n                }\n            }\n            num = 1; // refreshes value to 1 for next use.\n            arr[cut] = 0; // Kills the person at position of\n                          // 'cut'\n            cnt++; // Updates the no. of killed persons.\n            cut++;\n            cut = cut % n; // Checks and resolves overflow\n                           // of Index.\n            while (arr[cut]\n                   == 0) // Checks the next alive person the\n            // sword is to be given.\n            {\n                cut++;\n                cut = cut\n                      % n; // Checks and resolves overflow\n                // of Index.\n            }\n        }\n        return cut\n            + 1; \n        \n    }\n}\ndef Josephus(n, k):\n    \n    k -= 1\n    arr = [0]*n\n    for i in range(n):\n        arr[i] = 1 # Makes all the 'n' people alive by\n        # assigning them value = 1\n    cnt = 0\n    cut = 0\n    num = 1 # Cut = 0 gives the sword to 1st person.\n    while (cnt < (n - 1)):\n      \n        # Loop continues till n-1 person dies.\n        while (num <= k):\n          \n            # Checks next (kth) alive persons.\n            cut += 1\n            cut = cut % n # Checks and resolves overflow\n            # of Index.\n            if (arr[cut] == 1):\n                num+=1 # Updates the number of persons\n                # alive.\n        \n        num = 1 # refreshes value to 1 for next use.\n        arr[cut] = 0 # Kills the person at position of 'cut'\n        cnt += 1 # Updates the no. of killed persons.\n        cut += 1\n        cut = cut % n # Checks and resolves overflow of Index.\n        while (arr[cut] == 0):\n          \n            # Checks the next alive person the\n            # sword is to be given.\n            cut += 1\n            cut = cut % n # Checks and resolves overflow\n            # of Index.\n    \n    return cut + 1 # Output is the position of the last\n                    # man alive(Index + 1)\n\n# Driver Code\nn, k = 14, 2 #map (int, input().splut())\nprint(Josephus(n, k))\n\n# This code is contributed by ShubhamSingh\n// C# code to implement the above approach\nusing System;\nusing System.Linq;\n\npublic class GFG{\n\n  public static void Main ()\n  {\n    int n = 14, k = 2;\n    Console.Write(Josephus(n, k));\n  }\n\n  public static int Josephus(int n, int k)\n  {\n    k--;\n    int[] arr = new int[n];\n    for (int i = 0; i < n; i++) {\n      arr[i] = 1; // Makes all the 'n' people alive by\n      // assigning them value = 1\n    }\n    int cnt = 0, cut = 0,\n    num = 1; // Cut = 0 gives the sword to 1st person.\n    while (\n      cnt\n      < (n - 1)) // Loop continues till n-1 person dies.\n    {\n      while (num <= k) // Checks next (kth) alive persons.\n      {\n        cut++;\n        cut = cut % n; \n        \n        // Checks and resolves overflow\n        // of Index.\n        if (arr[cut] == 1)\n        {\n          num++; // Updates the number of persons\n          // alive.\n        }\n      }\n      num = 1; // refreshes value to 1 for next use.\n      arr[cut]\n        = 0; // Kills the person at position of 'cut'\n      cnt++; // Updates the no. of killed persons.\n      cut++;\n      cut = cut\n        % n; // Checks and resolves overflow of Index.\n      while (arr[cut]\n             == 0) // Checks the next alive person the\n        // sword is to be given.\n      {\n        cut++;\n        cut = cut % n; // Checks and resolves overflow\n        // of Index.\n      }\n    }\n    return cut + 1; // Output is the position of the last\n    // man alive(Index + 1);\n  }\n}\n\n// This code is contributed by Shubham Singh\n// Javascript code to implement the above approach\n    \n    let n = 14, k = 2;\n    console.log(Josephus(n, k));\n    \n    function Josephus(n, k)\n    {\n      k--;\n      let arr = new Array(n);\n      for (let i = 0; i < n; i++)\n      {\n      \n          // Makes all the 'n' people alive by\n        // assigning them value = 1\n        arr[i] = 1; \n      }\n      \n      // Cut = 0 gives the sword to 1st person.\n      let cnt = 0, cut = 0,\n      num = 1; \n      \n      // Loop continues till n-1 person dies.\n      while (cnt < (n - 1)) \n      {\n      \n       // Checks next (kth) alive persons.\n        while (num <= k)\n        {\n          cut++;\n          cut = cut % n;\n\n          // Checks and resolves overflow\n          // of Index.\n          if (arr[cut] == 1)\n          {\n          \n               // Updates the number of persons\n            // alive.\n            num++;\n          }\n        }\n        \n        // refreshes value to 1 for next use.\n        num = 1; \n        arr[cut] = 0; // Kills the person at position of 'cut'\n        \n         // Updates the no. of killed persons.\n        cnt++;\n        cut++;\n        \n        // Checks and resolves overflow of Index.\n        cut = cut % n; \n        \n        // Checks the next alive person the\n        // sword is to be given.\n        while (arr[cut] == 0) \n        {\n          cut++;\n          \n          // Checks and resolves overflow\n          // of Index.\n          cut = cut % n; \n        }\n      }\n      \n       // Output is the position of the last\n      // man alive(Index + 1);\n      return cut + 1;\n    }\n13\n// C++ code to Implement Josephus Problem\n\n#include <iostream>\nusing namespace std;\n\nint Josephus(int N, int k)\n{\n\n    // Initialize variables i and ans with 1 and 0\n    // respectively.\n\n    int i = 1, ans = 0;\n\n    // Run a while loop till i <= N\n\n    while (i <= N) {\n\n        // Update the Value of ans and Increment i by 1\n        ans = (ans + k) % i;\n        i++;\n    }\n\n    // Return required answer\n    return ans + 1;\n}\n\n// main function\nint main()\n{\n\n    int N = 14, k = 2;\n    cout << Josephus(N, k) << endl;\n    return 0;\n}\n// C Program to Implement Josephus Problem\n\n#include <stdio.h>\n\nint Josephus(int N, int k)\n{\n\n    // Initialize variables i and ans with 1 and 0\n    // respectively.\n\n    int i = 1, ans = 0;\n\n    // Run a while loop till i <= N\n\n    while (i <= N) {\n\n        // Update the Value of ans and Increment i by 1\n        ans = (ans + k) % i;\n        i++;\n    }\n\n    // Return required answer\n    return ans + 1;\n}\n\n// main function\nint main()\n{\n\n    int N = 14, k = 2;\n    printf(\"%d\", Josephus(N, k));\n    return 0;\n}\n// Java code to Implement Josephus Problem\nimport java.io.*;\n\nclass GFG {\n  public static int Josephus(int N, int k) {\n\n    // Initialize variables i and ans with 1 and 0 respectively.\n    int i = 1, ans = 0;\n\n    // Run a while loop till i <= N\n    while (i <= N) {\n\n      // Update the Value of ans and Increment i by 1\n      ans = (ans + k) % i;\n      i++;\n    }\n\n    // Return required answer\n    return ans + 1;\n  }\n\n\n  // main function\n  public static void main (String[] args) {\n\n    int N = 14, k = 2;\n    int ans = Josephus(N, k);\n    System.out.println(ans);\n  }\n}\n# python code to implement Josephus problem \n\n# Josephus function which will take \n# two parameter N and K, number of people and positions respectively\n# return the position of person survives\ndef Josephus(n, k):\n\n    # initialize two variables i and ans\n    i = 1\n    ans = 0\n    while(i <= n):\n\n        # update the value of ans\n        ans = (ans + k) % i\n        i += 1\n    \n    # returning the required answer\n    return ans + 1\n\n# driver code\n# let \nn = 14\nk = 2\n\nresult = Josephus(n, k)\nprint(result)\n// C# code to Implement Josephus Problem\nusing System;\n\nclass GFG\n{\n    public static int Josephus(int N, int k)\n    {\n        // Initialize variables i and ans with 1 and 0 respectively.\n        int i = 1, ans = 0;\n\n        // Run a while loop till i <= N\n        while (i <= N)\n        {\n            // Update the Value of ans and Increment i by 1\n            ans = (ans + k) % i;\n            i++;\n        }\n\n        // Return required answer\n        return ans + 1;\n    }\n\n\n    // main function\n    static void Main(string[] args)\n    {\n        int N = 14, k = 2;\n        int ans = Josephus(N, k);\n        Console.WriteLine(ans);\n    }\n}\n// driver code\nlet n = 14, k = 2;\nconsole.log(Josephus(n,k));\n\n// Josephus function \n// return the position of last man survives\nfunction Josephus(n, k)\n{\n    let i = 1, ans = 0;\n    while(i <= n ){\n\n        // update the value of ans \n        ans = (ans + k) % i;\n        i++;\n    }\n    return ans + 1;\n}\n13\n// C++ code to implement the idea\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Recursive function to implement the Josephus problem\nint josephus(int n, int k)\n{\n    if (n == 1)\n        return 1;\n    else\n        // The position returned by josephus(n - 1, k)\n        // is adjusted because the recursive call\n        // josephus(n - 1, k) considers the\n        // original position k % n + 1 as position 1\n        return (josephus(n - 1, k) + k - 1) % n + 1;\n}\n\n// Driver code\nint main()\n{\n    int n = 14;\n    int k = 2;\n    cout << \"The chosen place is \" << josephus(n, k);\n    return 0;\n}\n#include <stdio.h>\n\nint josephus(int n, int k)\n{\n    if (n == 1)\n        return 1;\n    else\n        /* The position returned by josephus(n - 1, k) is\n           adjusted because the recursive call josephus(n -\n           1, k) considers the original position\n           k%n + 1 as position 1 */\n        return (josephus(n - 1, k) + k - 1) % n + 1;\n}\n\n// Driver Program to test above function\nint main()\n{\n    int n = 14;\n    int k = 2;\n    printf(\"The chosen place is %d\", josephus(n, k));\n    return 0;\n}\n// Java code for Josephus Problem\nimport java.io.*;\n\nclass GFG {\n\n    static int josephus(int n, int k)\n    {\n        if (n == 1)\n            return 1;\n        else\n            /* The position returned by josephus(n - 1, k)\n            is adjusted because the recursive call\n            josephus(n - 1, k) considers the original\n            position k%n + 1 as position 1 */\n            return (josephus(n - 1, k) + k - 1) % n + 1;\n    }\n\n    // Driver Program to test above function\n    public static void main(String[] args)\n    {\n        int n = 14;\n        int k = 2;\n        System.out.println(\"The chosen place is \"\n                           + josephus(n, k));\n    }\n}\n# Python code for Josephus Problem\n\n\ndef josephus(n, k):\n\n    if (n == 1):\n        return 1\n    else:\n\n        # The position returned by\n        # josephus(n - 1, k) is adjusted\n        # because the recursive call\n        # josephus(n - 1, k) considers\n        # the original position\n        # k%n + 1 as position 1\n        return (josephus(n - 1, k) + k-1) % n + 1\n\n# Driver Program to test above function\n\n\nn = 14\nk = 2\n\nprint(\"The chosen place is \", josephus(n, k))\n// C# code for Josephus Problem\nusing System;\n\nclass GFG {\n\n    static int josephus(int n, int k)\n    {\n        if (n == 1)\n            return 1;\n        else\n            /* The position returned\n            by josephus(n - 1, k) is\n            adjusted because the\n            recursive call josephus(n\n            - 1, k) considers the\n            original position k%n + 1\n            as position 1 */\n            return (josephus(n - 1, k) + k - 1) % n + 1;\n    }\n\n    // Driver Program to test above\n    // function\n    public static void Main()\n    {\n        int n = 14;\n        int k = 2;\n        Console.WriteLine(\"The chosen \"\n                          + \"place is \" + josephus(n, k));\n    }\n}\n\n// This code is contributed by anuj_67.\n// Javascript code for Josephus Problem\n    \n    function josephus(n, k)\n    {\n        if (n == 1)\n            return 1;\n        else\n            /* The position returned\n            by josephus(n - 1, k) is\n            adjusted because the\n            recursive call josephus(n\n            - 1, k) considers the\n            original position k%n + 1\n            as position 1 */\n            return (josephus(n - 1, k)\n                       + k-1) % n + 1;\n    }\n      \n    let n = 14;\n    let k = 2;\n    console.log(\"The chosen \" + \"place is \" + josephus(n, k));\n<?php\n// PHP code for \n// Josephus Problem\n\nfunction josephus($n, $k)\n{\n    if ($n == 1)\n        return 1;\n    else\n        /* The position returned by \n           josephus(n - 1, k) is \n           adjusted because the\n           recursive call josephus\n           (n - 1, k) considers the \n           original position k%n + 1 \n           as position 1 */\n        return (josephus($n - 1, $k) + \n                    $k - 1) % $n + 1;\n}\n\n    // Driver Code\n    $n = 14;\n    $k = 2;\n    echo \"The chosen place is \", josephus($n, $k);\n\n?>\nThe chosen place is 13\n",
        "complexity": {
            "time": "Time Complexity: O(n)Auxiliary Space: O(n) the space used in recursion call stack",
            "space": ""
        },
        "tags": [
            "Recursion"
        ],
        "url": "https://www.geeksforgeeks.org/josephus-problem/"
    },
    {
        "title": "Program for Tower of Hanoi Algorithm",
        "description": "Tower of Hanoi is a mathematical puzzle where we have three rods (A, B, and C) and N disks. Initially, all the disks are stacked in decreasing value of diameter i.e., the smallest disk is placed on the top and they are on rod A. The objective of the puzzle is to move the entire stack to another rod (here considered C), obeying the following simple rules: Input: 2Output: Disk 1 moved from A to BDisk 2 moved from A to CDisk 1 moved from B to C Input: 3Output: Disk 1 moved from A to CDisk 2 moved from A to BDisk 1 moved from C to BDisk 3 moved from A to CDisk 1 moved from B to ADisk 2 moved from B to CDisk 1 moved from A to C Input: 4Output: Disk 1 moved from A to B Disk 2 moved from A to C Disk 1 moved from B to C Disk 3 moved from A to B Disk 1 moved from C to A Disk 2 moved from C to B Disk 1 moved from A to B Disk 4 moved from A to C Disk 1 moved from B to C Disk 2 moved from B to A Disk 1 moved from C to A Disk 3 moved from B to C Disk 1 moved from A to B Disk 2 moved from A to C Disk 1 moved from B to C The following video shows the solution of Tower of Hanoi for input (N) = 3 The idea is to use the helper node to reach the destination using recursion. Below is the pattern for this problem: Image illustration for 3 disks Follow the steps below to solve the problem: Time complexity: O(2N), There are two possibilities for every disk. Therefore, 2 * 2 * 2 * . . . * 2(N times) is 2NAuxiliary Space: O(N), Function call stack space Related Articles   ",
        "code": "// C++ recursive function to\n// solve tower of hanoi puzzle\n#include <bits/stdc++.h>\nusing namespace std;\n\nvoid towerOfHanoi(int n, char from_rod, char to_rod,\n                  char aux_rod)\n{\n    if (n == 0) {\n        return;\n    }\n    towerOfHanoi(n - 1, from_rod, aux_rod, to_rod);\n    cout << \"Move disk \" << n << \" from rod \" << from_rod\n         << \" to rod \" << to_rod << endl;\n    towerOfHanoi(n - 1, aux_rod, to_rod, from_rod);\n}\n\n// Driver code\nint main()\n{\n    int N = 3;\n\n    // A, B and C are names of rods\n    towerOfHanoi(N, 'A', 'C', 'B');\n    return 0;\n}\n\n// This is code is contributed by rathbhupendra\n#include <stdio.h>\n\nvoid towerOfHanoi(int n, char from_rod, char to_rod, char aux_rod) {\n    if (n == 0) {\n        return;\n    }\n    towerOfHanoi(n - 1, from_rod, aux_rod, to_rod);\n    printf(\"Move disk %d from rod %c to rod %c\\n\", n, from_rod, to_rod);\n    towerOfHanoi(n - 1, aux_rod, to_rod, from_rod);\n}\n\n// Driver code\nint main() {\n    int N = 3;\n\n    // A, B and C are names of rods\n    towerOfHanoi(N, 'A', 'C', 'B');\n    return 0;\n}\n// JAVA recursive function to\n// solve tower of hanoi puzzle\nimport java.io.*;\nimport java.math.*;\nimport java.util.*;\nclass GFG {\n    static void towerOfHanoi(int n, char from_rod,\n                             char to_rod, char aux_rod)\n    {\n        if (n == 0) {\n            return;\n        }\n        towerOfHanoi(n - 1, from_rod, aux_rod, to_rod);\n        System.out.println(\"Move disk \" + n + \" from rod \"\n                           + from_rod + \" to rod \"\n                           + to_rod);\n        towerOfHanoi(n - 1, aux_rod, to_rod, from_rod);\n    }\n\n    // Driver code\n    public static void main(String args[])\n    {\n        int N = 3;\n\n        // A, B and C are names of rods\n        towerOfHanoi(N, 'A', 'C', 'B');\n    }\n}\n\n// This code is contributed by jyoti369\n# Recursive Python function to solve tower of hanoi\n\n\ndef TowerOfHanoi(n, from_rod, to_rod, aux_rod):\n    if n == 0:\n        return\n    TowerOfHanoi(n-1, from_rod, aux_rod, to_rod)\n    print(\"Move disk\", n, \"from rod\", from_rod, \"to rod\", to_rod)\n    TowerOfHanoi(n-1, aux_rod, to_rod, from_rod)\n\n\n# Driver code\nN = 3\n\n# A, C, B are the name of rods\nTowerOfHanoi(N, 'A', 'C', 'B')\n\n# Contributed By Harshit Agrawal\n// C# recursive program to solve tower of hanoi puzzle\nusing System;\nclass GFG {\n    static void towerOfHanoi(int n, char from_rod,\n                             char to_rod, char aux_rod)\n    {\n        if (n == 0) {\n            return;\n        }\n        towerOfHanoi(n - 1, from_rod, aux_rod, to_rod);\n        Console.WriteLine(\"Move disk \" + n + \" from rod \"\n                          + from_rod + \" to rod \" + to_rod);\n        towerOfHanoi(n - 1, aux_rod, to_rod, from_rod);\n    }\n\n    //  Driver method\n    public static void Main(String[] args)\n    {\n        int N = 3;\n\n        // A, B and C are names of rods\n        towerOfHanoi(N, 'A', 'C', 'B');\n    }\n}\n\n// This code is contributed by shivanisinghss2110\n// javascript recursive function to \n// solve tower of hanoi puzzle \nfunction towerOfHanoi(n, from_rod,  to_rod,  aux_rod)\n{\n        if (n == 0)\n        {\n            return;\n        }\n        towerOfHanoi(n - 1, from_rod, aux_rod, to_rod);\n        console.log(\"Move disk \" + n + \" from rod \" + from_rod +\n        \" to rod \" + to_rod+\"<br/>\");\n        towerOfHanoi(n - 1, aux_rod, to_rod, from_rod);\n    }\n\n    // Driver code\n    var N = 3;\n    \n    // A, B and C are names of rods\n    towerOfHanoi(N, 'A', 'C', 'B');\n\n// This code is contributed by gauravrajput1\nMove disk 1 from rod A to rod C\nMove disk 2 from rod A to rod B\nMove disk 1 from rod C to rod B\nMove disk 3 from rod A to rod C\nMove disk 1 from rod B to rod A\nMove disk 2 from rod B to rod C\nMove disk 1 from rod A to rod C\n",
        "complexity": {
            "time": "Time complexity: O(2N), There are two possibilities for every disk. Therefore, 2 * 2 * 2 * . . . * 2(N times) is 2NAuxiliary Space: O(N), Function call stack space",
            "space": ""
        },
        "tags": [
            "Recursion"
        ],
        "url": "https://www.geeksforgeeks.org/c-program-for-tower-of-hanoi/"
    },
    {
        "title": "Check if a number is Palindrome",
        "description": "Given an integer n, find whether the number is Palindrome or not. A number is a Palindrome if it remains the same when its digits are reversed. Examples: Input: n = 12321Output: YesExplanation: 12321 is a Palindrome number because after reversing its digits, the number becomes 12321 which is the same as the original number. Input: n = 1234Output: NoExplanation: 1234 is not a Palindrome number because after reversing its digits, the number becomes 4321 which is different from the original number. Table of Content The idea is to find the reverse of the original number and then compare the reversed number with the original number. If the reversed number is same as the original number, the number is Palindrome. Otherwise, the number is not a Palindrome. Below is given the implementation: Time Complexity : O(log10(n)) = O(number of digits)Auxiliary space : O(1) When the input number exceeds 1018, then finding the reverse can cause overflow in languages like: C, C++, Java, etc. So, we can take the input number as a string and run a loop from starting to length/2 and compare the first character (numeric) with the last character of the string, second character to second last one, and so on. If any character mismatches, the string wouldn’t be a palindrome. Below is given the implementation: Time Complexity : O(log10(n)) = O(number of digits)Space Complexity : O(log10(n)) = O(number of digits), to store the number as string.  ",
        "code": "// C++ program to check if the given \n// number is a palindrome\n#include <iostream>\nusing namespace std;\n\n// Function to check if the number is palindrome\nbool isPalindrome(int n) {\n    int reverse = 0;\n  \n    // Copy of the original number so that the original\n    // number remains unchanged while finding the reverse\n    int temp = abs(n);\n    while (temp != 0) {\n        reverse = (reverse * 10) + (temp % 10);\n        temp = temp / 10;\n    }\n  \n    // If reverse is equal to the original number, the\n    // number is palindrome\n    return (reverse == abs(n));\n}\n\nint main() {\n    int n = 12321;\n    if (isPalindrome(n) == 1) {\n        cout << \"Yes\";\n    }\n    else {\n        cout << \"No\";\n    }\n    return 0;\n}\n// Java program to check if the given \n// number is a palindrome\nclass GFG {\n\n    // Function to check if the number is palindrome\n    static boolean isPalindrome(int n) {\n        int reverse = 0;\n\n        // Copy of the original number so that the original\n        // number remains unchanged while finding the reverse\n        int temp = Math.abs(n);\n        while (temp != 0) {\n            reverse = (reverse * 10) + (temp % 10);\n            temp = temp / 10;\n        }\n\n        // If reverse is equal to the original number, the\n        // number is palindrome\n        return (reverse == Math.abs(n));\n    }\n\n    public static void main(String[] args) {\n        int n = 12321;\n        if (isPalindrome(n) == true) {\n            System.out.println(\"Yes\");\n        }\n        else {\n            System.out.println(\"No\");\n        }\n    }\n}\n# Python program to check if the given \n# number is a palindrome\n\n# Function to check if the number is palindrome\ndef isPalindrome(n):\n    reverse = 0\n\n    # Copy of the original number so that the original\n    # number remains unchanged while finding the reverse\n    temp = abs(n)\n    while temp != 0:\n        reverse = (reverse * 10) + (temp % 10)\n        temp = temp // 10\n\n    # If reverse is equal to the original number, the\n    # number is palindrome\n    return (reverse == abs(n))\n\nn = 12321\nif isPalindrome(n) == True:\n    print(\"Yes\")\nelse:\n    print(\"No\")\n// C# program to check if the given \n// number is a palindrome\nusing System;\n\nclass GFG {\n\n    // Function to check if the number is palindrome\n    static bool isPalindrome(int n) {\n        int reverse = 0;\n\n        // Copy of the original number so that the original\n        // number remains unchanged while finding the reverse\n        int temp = Math.Abs(n);\n        while (temp != 0) {\n            reverse = (reverse * 10) + (temp % 10);\n            temp = temp / 10;\n        }\n\n        // If reverse is equal to the original number, the\n        // number is palindrome\n        return (reverse == Math.Abs(n));\n    }\n\n    static void Main() {\n        int n = 12321;\n        if (isPalindrome(n) == true) {\n            Console.WriteLine(\"Yes\");\n        }\n        else {\n            Console.WriteLine(\"No\");\n        }\n    }\n}\n// JavaScript program to check if the given \n// number is a palindrome\n\n// Function to check if the number is palindrome\nfunction isPalindrome(n) {\n    let reverse = 0;\n\n    // Copy of the original number so that the original\n    // number remains unchanged while finding the reverse\n    let temp = Math.abs(n);\n    while (temp != 0) {\n        reverse = (reverse * 10) + (temp % 10);\n        temp = Math.floor(temp / 10);\n    }\n\n    // If reverse is equal to the original number, the\n    // number is palindrome\n    return (reverse === Math.abs(n));\n}\n\nlet n = 12321;\nif (isPalindrome(n) === true) {\n    console.log(\"Yes\");\n}\nelse {\n    console.log(\"No\");\n}\ntrue\n// C++ program to check if the given \n// number is a palindrome\n#include <iostream>\nusing namespace std;\n\n// Function to check if the number is palindrome\nbool isPalindrome(int n) {\n\n    // Convert the absolute value\n    // of number to string\n    string s = to_string(abs(n));\n\tint len = s.length();\n\n    for (int i = 0; i < len / 2; i++) {\n\n        // Comparing i th character from starting\n        //  and len-i th character from end\n        if (s[i] != s[len - i - 1])\n            return false;\n    }\n    return true;\n}\n\nint main() {\n    int n = 12321;\n    if (isPalindrome(n) == 1) {\n        cout << \"Yes\";\n    }\n    else {\n        cout << \"No\";\n    }\n    return 0;\n}\n// Java program to check if the given \n// number is a palindrome\nclass GFG {\n\n    // Function to check if the number is palindrome\n    static boolean isPalindrome(int n) {\n\n        // Convert the absolute value\n        // of number to string\n        String s = Integer.toString(Math.abs(n));\n        int len = s.length();\n\n        for (int i = 0; i < len / 2; i++) {\n\n            // Comparing i th character from starting\n            //  and len-i th character from end\n            if (s.charAt(i) != s.charAt(len - i - 1))\n                return false;\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        int n = 12321;\n        if (isPalindrome(n) == true) {\n            System.out.println(\"Yes\");\n        }\n        else {\n            System.out.println(\"No\");\n        }\n    }\n}\n# Python program to check if the given \n# number is a palindrome\n\n# Function to check if the number is palindrome\ndef isPalindrome(n):\n\n    # Convert the absolute value\n    # of number to string\n    s = str(abs(n))\n    length = len(s)\n\n    for i in range(length // 2):\n\n        # Comparing i th character from starting\n        #  and len-i th character from end\n        if s[i] != s[length - i - 1]:\n            return False\n    return True\n\nn = 12321\nif isPalindrome(n) == True:\n    print(\"Yes\")\nelse:\n    print(\"No\")\n// C# program to check if the given \n// number is a palindrome\nusing System;\n\nclass GFG {\n\n    // Function to check if the number is palindrome\n    static bool isPalindrome(int n) {\n\n        // Convert the absolute value\n        // of number to string\n        string s = Math.Abs(n).ToString();\n        int len = s.Length;\n\n        for (int i = 0; i < len / 2; i++) {\n\n            // Comparing i th character from starting\n            //  and len-i th character from end\n            if (s[i] != s[len - i - 1])\n                return false;\n        }\n        return true;\n    }\n\n    static void Main() {\n        int n = 12321;\n        if (isPalindrome(n) == true) {\n            Console.WriteLine(\"Yes\");\n        }\n        else {\n            Console.WriteLine(\"No\");\n        }\n    }\n}\n// JavaScript program to check if the given \n// number is a palindrome\n\n// Function to check if the number is palindrome\nfunction isPalindrome(n) {\n\n    // Convert the absolute value\n    // of number to string\n    let s = Math.abs(n).toString();\n    let len = s.length;\n\n    for (let i = 0; i < len / 2; i++) {\n\n        // Comparing i th character from starting\n        //  and len-i th character from end\n        if (s[i] !== s[len - i - 1])\n            return false;\n    }\n    return true;\n}\n\nlet n = 12321;\nif (isPalindrome(n) === true) {\n    console.log(\"Yes\");\n}\nelse {\n    console.log(\"No\");\n}\nYes\n",
        "complexity": {
            "time": "Time Complexity : O(log10(n)) = O(number of digits)Space Complexity : O(log10(n)) = O(number of digits), to store the number as string.",
            "space": ""
        },
        "tags": [
            "Recursion"
        ],
        "url": "https://www.geeksforgeeks.org/check-if-a-number-is-palindrome/"
    },
    {
        "title": "DSA Tutorial - Learn Data Structures and Algorithms",
        "description": "DSA (Data Structures and Algorithms)  is the study of organizing data efficiently using data structures like arrays, stacks, and trees, paired with step-by-step procedures (or algorithms) to solve problems effectively. Data structures manage how data is stored and accessed, while algorithms focus on processing this data. Hoping you have learned a programming language of your choice, here comes the next stage of the roadmap - Learn about Time and Space Complexities. Once you have learned basics of a programming language, it is recommended that you learn basic logic building To analyze algorithms, we mainly measure order of growth of time or space taken in terms of input size.  We do this in the worst case scenario in most of the cases. Please refer the below links for a clear understanding of these concepts. Array is a linear data structure where elements are allocated contiguous memory, allowing for constant-time access. Searching algorithms are used to locate specific data within a large set of data. It helps find a target value within the data. There are various types of searching algorithms, each with its own approach and efficiency. Sorting algorithms are used to arrange the elements of a list in a specific order, such as numerical or alphabetical. It organizes the items in a systematic way, making it easier to search for and access specific elements. Hashing is a technique that generates a fixed-size output (hash value) from an input of variable size using mathematical formulas called hash functions. Hashing is commonly used in data structures for efficient searching, insertion and deletion. In Two Pointer Technique, we typically use two index variables from two corners of an array. We use the two pointer technique for searching a required point or value in an array. In Window Sliding Technique, we use the result of previous subarray to quickly compute the result of current. In Prefix Sum Technique, we compute prefix sums of an array to quickly find results for a subarray. String is a sequence of characters, typically immutable and have limited set of elements (lower case or all English alphabets). Recursion is a programming technique where a function calls itself within its own definition. It is usually used to solve problems that can be broken down into smaller instances of the same problem. Matrix is a two-dimensional array of elements, arranged in rows and columns. It is represented as a rectangular grid, with each element at the intersection of a row and column. Linked list is a linear data structure that stores data in nodes, which are connected by pointers. Unlike arrays, nodes of linked lists are not stored in contiguous memory locations and can only be accessed sequentially, starting from the head of list. Stack is a linear data structure that follows the Last In, First Out (LIFO) principle. Stacks play an important role in managing function calls, memory, and are widely used in algorithms like stock span problem, next greater element and largest area in a histogram. Queue is a linear data structure that follows the First In, First Out (FIFO) principle. Queues play an important role in managing tasks or data in order, scheduling and message handling systems. A deque (double-ended queue) is a data structure that allows elements to be added or removed from both ends efficiently. Tree is a non-linear, hierarchical data structure consisting of nodes connected by edges, with a top node called the root and nodes having child nodes. It is widely used in file systems, databases, decision-making algorithms, etc. Heap is a complete binary tree data structure that satisfies the heap property. Heaps are usually used to implement priority queues, where the smallest or largest element is always at the root of the tree. Graph is a non-linear data structure consisting of a finite set of vertices(or nodes) and a set of edges(or links)that connect a pair of nodes. Graphs are widely used to represent relationships between entities. Greedy Algorithm builds up the solution one piece at a time and chooses the next piece which gives the most obvious and immediate benefit i.e., which is the most optimal choice at that moment. So the problems where choosing locally optimal also leads to the global solutions are best fit for Greedy. Dynamic Programming is a method used to solve complex problems by breaking them down into simpler subproblems. By solving each subproblem only once and storing the results, it avoids redundant computations, leading to more efficient solutions for a wide range of problems. Bitwise Algorithms: Operate on individual bits of numbers. Backtracking Algorithm : Follow Recursion  with the option to revert and traces back if the solution from current point is not feasible. Divide and conquer:  A strategy to solve problems by dividing them into smaller subproblems, solving those subproblems, and combining the solutions to obtain the final solution. Branch and Bound : Used in combinatorial optimization problems to systematically search for the best solution. It works by dividing the problem into smaller subproblems, or branches, and then eliminating certain branches based on bounds on the optimal solution. This process continues until the best solution is found or all branches have been explored. Geometric algorithms are a set of algorithms that solve problems related to shapes, points, lines and polygons. Randomized algorithms are algorithms that use randomness to solve problems. They make use of random input to achieve their goals, often leading to simpler and more efficient solutions. These algorithms may not product same result but are particularly useful in situations when a probabilistic approach is acceptable. Advanced Data Structures like Trie, Segment Tree, Red-Black Tree and Binary Indexed Tree offer significant performance improvements for specific problem domains. They provide efficient solutions for tasks like fast prefix searches, range queries, dynamic updates, and maintaining balanced data structures, which are crucial for handling large datasets and real-time processing. By optimizing time complexity, they enable better scalability and faster execution in many computational problems. R  ",
        "code": "",
        "complexity": {
            "time": "Advanced Data Structures like Trie, Segment Tree, Red-Black Tree and Binary Indexed Tree offer significant performance improvements for specific problem domains. They provide efficient solutions for tasks like fast prefix searches, range queries, dynamic updates, and maintaining balanced data structures, which are crucial for handling large datasets and real-time processing. By optimizing time complexity, they enable better scalability and faster execution in many computational problems.",
            "space": ""
        },
        "tags": [
            "Backtracking"
        ],
        "url": "https://www.geeksforgeeks.org/learn-data-structures-and-algorithms-dsa-tutorial/"
    },
    {
        "title": "No Title",
        "description": "",
        "code": "",
        "complexity": {
            "time": "",
            "space": ""
        },
        "tags": [
            "Backtracking"
        ],
        "url": "https://www.geeksforgeeks.org/explore?page=1&category=Backtracking&sortBy=submissions"
    },
    {
        "title": "Top 20 Backtracking Algorithm Interview Questions",
        "description": "Backtracking is a powerful algorithmic technique used to solve problems by exploring all possible solutions in a systematic and recursive manner. It is particularly useful for problems that require searching through a vast solution space, such as combinatorial problems, constraint satisfaction problems, and optimization tasks. In backtracking, we build solutions incrementally, making safe choices at each step. If a choice leads to a dead end (invalid solution), we backtrack to the previous step and try a different path. This method ensures that we efficiently navigate the solution space while avoiding unnecessary computations. Further Practice: Coding Practice on Backtracking  A  ",
        "code": "",
        "complexity": {
            "time": "",
            "space": ""
        },
        "tags": [
            "Backtracking"
        ],
        "url": "https://www.geeksforgeeks.org/top-20-backtracking-algorithm-interview-questions/"
    },
    {
        "title": "Top MCQs on Backtracking Algorithm with Answers",
        "description": "Question 1 Question 2 Backtracking can be used to solve: Linear programming problems Problems with a single feasible solution Combinatorial optimization problems Problems with a fixed set of solutions Question 3 Backtracking may lead to a solution that is: Optimal Suboptimal Efficient Deterministic Question 4 Backtracking is best suited for solving problems that involve: Sorting elements Searching in a sorted list Dynamic programming Exploring all possible solutions Question 5 Which of the following is an example of a problem that can be solved using backtracking? Finding the median of an array Binary search in a sorted list Sudoku puzzle solving Calculating the sum of elements in an array Question 6 Which of the following is NOT a characteristic of the backtracking algorithm? Recursive approach Breadth-first exploration Depth-first exploration Trial and error Question 7 Backtracking involves: Starting from the end of the problem Using a stack to keep track of solutions Iterating through all elements in a list Going back to a previous step if the current step doesn't work Question 8 Who coined the term \"Backtracking\"? Lehmer Donald Ross Ford Question 9 The backtracking algorithm is implemented by constructing a tree of choices known as? State-chart-tree Node tree Backtracking tree State-space tree Question 10 What happens when the backtracking algorithm reaches a complete solution? It backtracks to the root It traverses from a different route it continues searching for other possible solutions Recursively traverses through the same route There are 10 questions to complete. ",
        "code": "",
        "complexity": {
            "time": "",
            "space": ""
        },
        "tags": [
            "Backtracking"
        ],
        "url": "https://www.geeksforgeeks.org/algorithms-gq/top-mcqs-on-backtracking-algorithm-with-answers/"
    },
    {
        "title": "Introduction to Backtracking",
        "description": "Backtracking is like trying different paths, and when you hit a dead end, you backtrack to the last choice and try a different route. In this article, we’ll explore the basics of backtracking, how it works, and how it can help solve all sorts of challenging problems. It’s like a method for finding the right way through a complex choices. Table of Content Backtracking is a problem-solving algorithmic technique that involves finding a solution incrementally by trying different options and undoing them if they lead to a dead end. It is commonly used in situations where you need to explore multiple possibilities to solve a problem, like searching for a path in a maze or solving puzzles like Sudoku. When a dead end is reached, the algorithm backtracks to the previous decision point and explores a different path until a solution is found or all possibilities have been exhausted. Backtracking can be defined as a general algorithmic technique that considers searching every possible combination in order to solve a computational problem. Introduction to Backtracking Problems associated with backtracking can be categorized into 3 categories: As we know backtracking algorithm explores each and every possible path in order to find a valid solution, this exploration of path can be easily understood via given images:  As shown in the image, “IS”  represents the Initial State where the recursion call starts to find a valid solution. C : it represents different Checkpoints for recursive calls TN: it represents the Terminal Nodes where no further recursive calls can be made, these nodes act as base case of recursion and we determine whether the current solution is valid or not at this state. At each Checkpoint, our program makes some decisions and move to other checkpoints untill it reaches a terminal Node, after determining whether a solution is valid or not, the program starts to revert back to the checkpoints and try to explore other paths. For example in the above image TN1…TN5 are the terminal node where the solution is not acceptable, while TN6 is the state where we found a valid solution. The back arrows in the images shows backtracking in actions, where we revert the changes made by some checkpoint. Generally every constraint satisfaction problem can be solved using backtracking but, Is it optimal to use backtracking every time? Turns out NO, there are a vast number of problem that can be solved using Greedy or Dynamic programming in logarithmic or polynomial time complexity which is far better than exponential complexity of Backtracking. However many problems still exists that can only be solved using Backtracking. To understand whether a problem is Backtracking based or not, let us take a simple problem:Problem: Imagine you have 3 closed boxes, among which 2 are empty and 1 has a gold coin. Your task is to get the gold coin. Why dynamic programming fails to solve this question: Does opening or closing one box has any effect on the other box? Turns out NO, each and every box is independent of each other and opening/closing state of one box can not determine the transition for other boxes. Hence DP fails. Why greedy fails to solve this question: Greedy algorithm chooses a local maxima in order to get global maxima, but in this problem each and every box has equal probability of having a gold coin i.e 1/3 hence there is no criteria to make a greedy choice. Why Backtracking works: As discussed already, backtracking algorithm is simply brute forcing each and every choice, hence we can one by one choose every box to find the gold coin, If a box is found empty we can close it back which acts as a Backtracking step. Technically, for backtracking problems: The best way to implement backtracking is through recursion, and all backtracking code can be summarised as per the given Pseudocode: void FIND_SOLUTIONS( parameters): if (valid solution): store the solution Return for (all choice): if (valid choice): APPLY (choice) FIND_SOLUTIONS (parameters) BACKTRACK (remove choice) Return Since backtracking algorithm is purely brute force therefore in terms of time complexity, it performs very poorly. Generally backtracking can be seen having below mentioned time complexities: These complexities are due to the fact that at each state we have multiple choices due to which the number of paths increases and sub-trees expand rapidly. Recursion and Backtracking are related concepts in computer science and programming, but they are not the same thing. Let’s explore the key differences between them: Recursion Backtracking Recursion does not always need backtracking Backtracking always uses recursion to solve problems Solving problems by breaking them into smaller, similar subproblems and solving them recursively. Solving problems with multiple choices and exploring options systematically, backtracking when needed. Controlled by function calls and call stack. Managed explicitly with loops and state. Applications of Recursion: Tree and Graph Traversal, Towers of Hanoi, Divide and Conquer Algorithms, Merge Sort, Quick Sort, and Binary Search. Application of Backtracking: N Queen problem, Rat in a Maze problem, Knight’s Tour Problem, Sudoku solver, and Graph coloring problems. For more practice problems: click here  ",
        "code": "",
        "complexity": {
            "time": "Since backtracking algorithm is purely brute force therefore in terms of time complexity, it performs very poorly. Generally backtracking can be seen having below mentioned time complexities:",
            "space": ""
        },
        "tags": [
            "Backtracking"
        ],
        "url": "https://www.geeksforgeeks.org/introduction-to-backtracking-data-structure-and-algorithm-tutorials/"
    },
    {
        "title": "What is the difference between Backtracking and Recursion?",
        "description": "The process in which a function calls itself directly or indirectly is called recursion and the corresponding function is called a recursive function. Imagine we have a set of boxes, each containing a smaller box. To find an item, we open the outermost box and continue opening the next inner one until we reach the smallest box. Once we find the item or reach the end, we close the boxes in reverse order.This resembles recursion, where we solve a problem by breaking it into smaller subproblems until we hit a base case, then return results back through the previous layers. Backtracking is an algorithmic technique for solving problems recursively by trying to build a solution incrementally, one piece at a time, removing those solutions that fail to satisfy the constraints of the problem at any point in time (by time, here, is referred to the time elapsed till reaching any level of the search tree). Backtracking can be defined as a general algorithmic technique that considers searching every possible combination in order to solve a computational problem. Think of navigating a maze. At each turn, we choose a path. If we reach a dead end, we go back to the previous turn and try a different route. We repeat this until we find the way out. This models backtracking, where we make a series of decisions, and if a choice leads to a failure, we backtrack to try other possible paths. It’s recursion with an added layer of pruning invalid choices. 5 Recursion usually involves O(n) stack space. Backtracking can be O(n!) or more depending on constraints. Examples: Examples:  ",
        "code": "",
        "complexity": {
            "time": "",
            "space": ""
        },
        "tags": [
            "Backtracking"
        ],
        "url": "https://www.geeksforgeeks.org/what-is-the-difference-between-backtracking-and-recursion/"
    },
    {
        "title": "Difference between Backtracking and Branch-N-Bound technique",
        "description": "Algorithms are the methodical sequence of steps which are defined to solve complex problems. In this article, we will see the difference between two such algorithms which are backtracking and branch and bound technique. Before getting into the differences, lets first understand each of these algorithms. Backtracking: Backtracking is a general algorithm for finding all the solutions to some computational problems, notably constraint satisfaction problems, that incrementally builds possible candidates to the solutions and abandons a candidate as soon as it determines that the candidate cannot possibly be completed to finally become a valid solution. It is an algorithmic-technique for solving problems recursively by trying to build a solution incrementally, one piece at a time, removing those solutions that fail to satisfy the constraints of the problem at any point of time (by time, here, is referred to the time elapsed till reaching any level of the search tree). Branch and Bound: Branch and bound is an algorithm design paradigm for discrete and combinatoric optimisation problems, as well as mathematical optimisation. A branch-and-bound algorithm consists of a systematic enumeration of candidate solutions. That is, the set of candidate solutions is thought of as forming a rooted tree with the full set at the root. The algorithm explores branches of this tree, which represent the subsets of the solution set. Before enumerating the candidate solutions of a branch, the branch is checked against upper and lower estimated bounds on the optimal solution and is discarded if it cannot produce a better solution than the best one found so far by the algorithm. Branch and bound algorithmic strategy for solving the problem- Branch and bound builds the state space tree and find the optimal solution quickly by pruning few of the tree branches which does not satisfy the bound. Backtracking can be useful where some other optimization techniques like greedy or dynamic programming fail. Such algorithms are typically slower than their counterparts. In the worst case, it may run in exponential time, but careful selection of bounds and branches makes an algorithm to run reasonably faster. Most of the terminologies of backtracking are used in this chapter too. In branch and bound, all the children of E nodes are generated before any other live node becomes E node. Branch and bound technique in which E-node puts its children in the queue is called FIFO branch and bound approach. And if E-node puts its children in the stack, then it is called LIFO branch and bound approach. Bounding functions are a heuristic function. Heuristic function computes the node which maximizes the probability of better search minimizes the probability of worst search. According to maximization or minimization problem, highest or lowest heuristic valued node is selected for further expansion from a set of nodes. The following table explains the difference between both the algorithms:  M  ",
        "code": "",
        "complexity": {
            "time": "",
            "space": ""
        },
        "tags": [
            "Backtracking"
        ],
        "url": "https://www.geeksforgeeks.org/difference-between-backtracking-and-branch-n-bound-technique/"
    },
    {
        "title": "Permutations of given String",
        "description": "Given a string s, the task is to return all permutations of a given string in lexicographically sorted order. Note: A permutation is the rearrangement of all the elements of a string. Duplicate arrangement can exist. Examples: Input:  s = “ABC”Output: “ABC”, “ACB”, “BAC”, “BCA”, “CAB”, “CBA” Input: s = “XY”Output: “XY”, “YX” Input: s = “AAA”Output: “AAA”, “AAA”, “AAA”, “AAA”, “AAA”, “AAA” The idea is to use backtracking to generate all possible permutations of given string s. To do so, first initialize an array of string ans[] to store all the permutations. Start from the 0th index and for each index i, swap the value s[i] with all the elements in its right i.e. from i+1 to n-1, and recur to the index i + 1. If the index i is equal to n, store the resultant string in ans[], else keep operating similarly for all other indices. Thereafter, swap back the values to original values to initiate backtracking. At last sort the array ans[]. illustration: Below is the implementation of the above approach: Time Complexity: O(n * n!) Auxiliary Space: O(n!) Related articles:  ",
        "code": "// C++ Program to generate all unique\n// permutations of a string\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Recursive function to generate \n// all permutations of string s\nvoid recurPermute(int index, string &s,\n                    vector<string> &ans) {\n\n    // Base Case\n    if (index == s.size()) {\n        ans.push_back(s);\n        return;\n    }\n\n    // Swap the current index with all\n    // possible indices and recur\n    for (int i = index; i < s.size(); i++) {\n        swap(s[index], s[i]);\n        recurPermute(index + 1, s, ans);\n        swap(s[index], s[i]);\n    }\n}\n\n// Function to find all unique permutations\nvector<string> findPermutation(string &s) {\n\n    // Stores the final answer\n    vector<string> ans;\n\n    recurPermute(0, s, ans);\n\n    // sort the resultant vector\n    sort(ans.begin(), ans.end());\n\n    return ans;\n}\n\nint main() {\n    string s = \"ABC\";\n    vector<string> res = findPermutation(s);\n    for(auto x: res) {\n        cout << x << \" \";\n    }\n    return 0;\n}\n// Java Program to generate all unique\n// permutations of a string\nimport java.util.*;\n\nclass GfG {\n\n    // Recursive function to generate \n    // all permutations of string s\n    static void recurPermute(int index, StringBuilder s, \n                            List<String> ans) {\n\n        // Base Case\n        if (index == s.length()) {\n            ans.add(s.toString());\n            return;\n        }\n\n        // Swap the current index with all\n        // possible indices and recur\n        for (int i = index; i < s.length(); i++) {\n            swap(s, index, i);\n            recurPermute(index + 1, s, ans);\n            swap(s, index, i);\n        }\n    }\n\n    // Swap characters at positions i and j\n    static void swap(StringBuilder s, int i, int j) {\n        char temp = s.charAt(i);\n        s.setCharAt(i, s.charAt(j));\n        s.setCharAt(j, temp);\n    }\n\n    // Function to find all unique permutations\n    static List<String> findPermutation(String s) {\n\n        // Stores the final answer\n        List<String> ans = new ArrayList<>();\n        StringBuilder str = new StringBuilder(s);\n\n        recurPermute(0, str, ans);\n\n        // sort the resultant list\n        Collections.sort(ans);\n\n        return ans;\n    }\n\n    public static void main(String[] args) {\n        String s = \"ABC\";\n        List<String> res = findPermutation(s);\n        for (String x : res) {\n            System.out.print(x + \" \");\n        }\n    }\n}\n# Python Program to generate all unique\n# permutations of a string\n\n# Recursive function to generate \n# all permutations of string s\ndef recurPermute(index, s, ans):\n\n    # Base Case\n    if index == len(s):\n        ans.append(\"\".join(s))\n        return\n\n    # Swap the current index with all\n    # possible indices and recur\n    for i in range(index, len(s)):\n        s[index], s[i] = s[i], s[index]\n        recurPermute(index + 1, s, ans)\n        s[index], s[i] = s[i], s[index]\n\n# Function to find all unique permutations\ndef findPermutation(s):\n\n    # Stores the final answer\n    ans = []\n\n    recurPermute(0, list(s), ans)\n\n    # sort the resultant list\n    ans.sort()\n\n    return ans\n\nif __name__ == \"__main__\":\n    s = \"ABC\"\n    res = findPermutation(s)\n    for x in res:\n        print(x, end=\" \")\n// C# Program to generate all unique\n// permutations of a string\nusing System;\nusing System.Collections.Generic;\n\nclass GfG {\n\n    // Recursive function to generate \n    // all permutations of string s\n    static void recurPermute(int index, char[] s, \n                            List<string> ans) {\n\n        // Base Case\n        if (index == s.Length) {\n            ans.Add(new string(s));\n            return;\n        }\n\n        // Swap the current index with all\n        // possible indices and recur\n        for (int i = index; i < s.Length; i++) {\n            Swap(s, index, i);\n            recurPermute(index + 1, s, ans);\n            Swap(s, index, i);\n        }\n    }\n\n    // Swap characters at positions i and j\n    static void Swap(char[] s, int i, int j) {\n        char temp = s[i];\n        s[i] = s[j];\n        s[j] = temp;\n    }\n\n    // Function to find all unique permutations\n    static List<string> findPermutation(string s) {\n\n        // Stores the final answer\n        List<string> ans = new List<string>();\n\n        recurPermute(0, s.ToCharArray(), ans);\n\n        // sort the resultant list\n        ans.Sort();\n\n        return ans;\n    }\n\n    static void Main(string[] args) {\n        string s = \"ABC\";\n        List<string> res = findPermutation(s);\n        foreach (string x in res) {\n            Console.Write(x + \" \");\n        }\n    }\n}\n// JavaScript Program to generate all unique\n// permutations of a string\n\n// Recursive function to generate \n// all permutations of string s\nfunction recurPermute(index, s, ans) {\n\n    // Base Case\n    if (index === s.length) {\n        ans.add(s.join(\"\"));\n        return;\n    }\n\n    // Swap the current index with all\n    // possible indices and recur\n    for (let i = index; i < s.length; i++) {\n        [s[index], s[i]] = [s[i], s[index]];\n        recurPermute(index + 1, s, ans);\n        [s[index], s[i]] = [s[i], s[index]];\n    }\n}\n\n// Function to find all unique permutations\nfunction findPermutation(s) {\n\n    // sort input string\n    s = s.split(\"\").sort();\n\n    // Stores all unique permutations\n    let res = new Set();\n    recurPermute(0, s, res);\n\n    // Convert Set to Array for the final answer\n    return Array.from(res).sort();\n}\n\nconst s = \"ABC\";\nconst res = findPermutation(s);\nconsole.log(res.join(\" \"));\nABC ACB BAC BCA CAB CBA\n",
        "complexity": {
            "time": "Time Complexity: O(n * n!) Auxiliary Space: O(n!)",
            "space": ""
        },
        "tags": [
            "Backtracking"
        ],
        "url": "https://www.geeksforgeeks.org/write-a-c-program-to-print-all-permutations-of-a-given-string/"
    },
    {
        "title": "Subset Sum Problem using Backtracking",
        "description": "Given a set[] of non-negative integers and a value sum, the task is to print the subset of the given set whose sum is equal to the given sum. Examples: Input: set[] = {1,2,1}, sum = 3Output: [1,2],[2,1]Explanation: There are subsets [1,2],[2,1] with sum 3. Input: set[] = {3, 34, 4, 12, 5, 2}, sum = 30Output: []Explanation: There is no subset that add up to 30. Subset sum can also be thought of as a special case of the 0–1 Knapsack problem. For each item, there are two possibilities: Finally, if Sum becomes 0 then print the elements of current subset. The recursion’s base case would be when no items are left, or the sum becomes negative, then simply return.  Implementation of the above approach:                Complexity analysis:  ",
        "code": "\n\n\n\n\n\n\n\n\n\nOutput 1:[ 2 1 ][ 1 2 ]Output 2:There is no such subset\n",
        "complexity": {
            "time": "",
            "space": ""
        },
        "tags": [
            "Backtracking"
        ],
        "url": "https://www.geeksforgeeks.org/subset-sum-problem/"
    },
    {
        "title": "N Queen Problem",
        "description": "Given an integer n, the task is to find the solution to the n-queens problem, where n queens are placed on an n*n chessboard such that no two queens can attack each other. The N Queen is the problem of placing N chess queens on an N×N chessboard so that no two queens attack each other. For example, the following is a solution for the 4 Queen problem. Examples: Input: 4Output: [2, 4, 1, 3]Explanation: [2, 4, 1, 3 ] and [3, 1, 4, 2] are the two possible solutions. Input: 1Output: [1]Explanation: Only one queen can be placed in the single cell available. The idea is to use backtracking to check all possible combinations of n queens in a chessboard of order n*n. To do so, first create an auxiliary matrix mat[][] of order n*n to mark the cellsoccupied by queens. Start from the first row and for each row  place queen at different columns and check for clashes with other queens. To check for clashes, iterate through all the rows of current column and both the diagonals. If it is safe to place queen in current column, mark the cell occupied in matrix mat[][] and move to the next row. If at any row, there is no safe column to place the queen, backtrack to previous row and place the queen in other safe column and again check for the next row. Below given is the recursive tree of the above approach: Recursive tree for N Queen problem Below given is the implementation: Time Complexity: O(n*n!)Auxiliary Space: O(n2) The above approach can be optimized by reducing the time required to check for clashes using isSafe() function. The idea is not to check every element in both the diagonals, instead use the property of diagonals: To do so, create three arrays cols[], rightDiagonal[] and leftDiagonal[] to mark the index of columns, left diagonal and right diagonals occupied by queens. For any cell, if all three arrays have value 0, we can place the queen at that cell. Below is the implementation: Time Complexity: O(n!) Auxiliary Space: O(n) Related Articles:   ",
        "code": "// C++ Program to solve the n-queens problem\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Function to check if it is safe to place\n// the queen at board[row][col]\nint isSafe(vector<vector<int>>& mat, \n                    int row, int col) {\n    int n = mat.size();\n    int i, j;\n\n    // Check this col on upper side\n    for (i = 0; i < row; i++)\n        if (mat[i][col])\n            return 0;\n\n    // Check upper diagonal on left side\n    for (i = row-1, j = col-1; i >= 0 && \n         j >= 0; i--, j--)\n        if (mat[i][j])\n            return 0;\n\n    // Check lower diagonal on left side\n    for (i = row-1, j = col+1; j < n && \n         i >= 0; i--, j++)\n        if (mat[i][j])\n            return 0;\n\n    return 1;\n}\n\nint placeQueens(int row, vector<vector<int>>& mat) {\n    int n = mat.size();\n\n    // base case: If all queens are placed\n    // then return true\n    if(row == n) return 1;\n\n    // Consider the row and try placing\n    // queen in all columns one by one\n    for(int i = 0; i < n; i++){\n\n        // Check if the queen can be placed\n        if(isSafe(mat, row, i)){\n            mat[row][i] = 1;\n            if(placeQueens(row + 1, mat)) \n                return 1;\n            mat[row][i] = 0;\n        }\n    }\n    return 0;\n}\n\n// Function to find the solution\n// to the N-Queens problem\nvector<int> nQueen(int n) {\n\n    // Initialize the board\n    vector<vector<int>> mat(n, vector<int>(n, 0));\n\n    // If the solution exists\n    if(placeQueens(0, mat)){\n\n        // to store the columns of the queens\n        vector<int> ans;\n        for(int i = 0; i < n; i++){\n            for(int j = 0; j < n; j++){\n                if(mat[i][j]){\n                    ans.push_back(j + 1);\n                }\n            }\n        }\n        return ans;\n    }\n    else return {-1};\n}\n\nint main() {\n    int n = 4;\n    vector<int> ans = nQueen(n);\n    for(auto i: ans){\n        cout << i << \" \";\n    }\n    return 0;\n}\n// Java Program to solve the n-queens problem\nimport java.util.*;\n\nclass GfG {\n\n    // Function to check if it is safe to place\n    // the queen at board[row][col]\n    static boolean isSafe(int[][] mat, \n                          \tint row, int col) {\n        int n = mat.length;\n\n        // Check this col on upper side\n        for (int i = 0; i < row; i++)\n            if (mat[i][col] == 1)\n                return false;\n\n        // Check upper diagonal on left side\n        for (int i = row - 1, j = col - 1; \n             \t\ti >= 0 && j >= 0; i--, j--)\n            if (mat[i][j] == 1)\n                return false;\n\n        // Check lower diagonal on left side\n        for (int i = row - 1, j = col + 1;\n             \t\tj < n && i >= 0; i--, j++)\n            if (mat[i][j] == 1)\n                return false;\n\n        return true;\n    }\n\n    static boolean placeQueens(int row, int[][] mat) {\n        int n = mat.length;\n\n        // base case: If all queens are placed\n        // then return true\n        if (row == n)\n            return true;\n\n        // Consider the row and try placing\n        // queen in all columns one by one\n        for (int i = 0; i < n; i++) {\n\n            // Check if the queen can be placed\n            if (isSafe(mat, row, i)) {\n                mat[row][i] = 1;\n                if (placeQueens(row + 1, mat))\n                    return true;\n                mat[row][i] = 0;\n            }\n        }\n        return false;\n    }\n\n    // Function to find the solution\n    // to the N-Queens problem\n    static List<Integer> nQueen(int n) {\n\n        // Initialize the board\n        int[][] mat = new int[n][n];\n\n        // If the solution exists\n        if (placeQueens(0, mat)) {\n\n            // to store the columns of the queens\n            List<Integer> ans = new ArrayList<>();\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < n; j++) {\n                    if (mat[i][j] == 1) {\n                        ans.add(j + 1);\n                    }\n                }\n            }\n          \n            return ans;\n        } \n      \telse\n            return Collections.singletonList(-1);\n    }\n\n    public static void main(String[] args) {\n        int n = 4;\n        List<Integer> ans = nQueen(n);\n        for (int i : ans) {\n            System.out.print(i + \" \");\n        }\n    }\n}\n# Python Program to solve the n-queens problem\n\n# Function to check if it is safe to place\n# the queen at board[row][col]\ndef isSafe(mat, row, col):\n    n = len(mat)\n\n    # Check this col on upper side\n    for i in range(row):\n        if mat[i][col]:\n            return False\n\n    # Check upper diagonal on left side\n    for i, j in zip(range(row - 1, -1, -1), \n                    range(col - 1, -1, -1)):\n        if mat[i][j]:\n            return False\n\n    # Check lower diagonal on left side\n    for i, j in zip(range(row - 1, -1, -1), \n                    \trange(col + 1, n)):\n        if mat[i][j]:\n            return False\n\n    return True\n\ndef placeQueens(row, mat):\n    n = len(mat)\n\n    # If all queens are placed\n    # then return true\n    if row == n:\n        return True\n\n    # Consider the row and try placing\n    # queen in all columns one by one\n    for i in range(n):\n\n        # Check if the queen can be placed\n        if isSafe(mat, row, i):\n            mat[row][i] = 1\n            if placeQueens(row + 1, mat):\n                return True\n            mat[row][i] = 0\n\n    return False\n\n# Function to find the solution\n# to the N-Queens problem\ndef nQueen(n):\n\n    # Initialize the board\n    mat = [[0 for _ in range(n)] for _ in range(n)]\n\n    # If the solution exists\n    if placeQueens(0, mat):\n\n        # to store the columns of the queens\n        ans = []\n        for i in range(n):\n            for j in range(n):\n                if mat[i][j]:\n                    ans.append(j + 1)\n        return ans\n    else:\n        return [-1]\n\nif __name__ == \"__main__\":\n    n = 4\n    ans = nQueen(n)\n    print(\" \".join(map(str, ans)))\n// C# Program to solve the n-queens problem\nusing System;\nusing System.Collections.Generic;\n\nclass GfG {\n\n    // Function to check if it is safe to place\n    // the queen at board[row][col]\n    static bool IsSafe(int[,] mat,\n                             int row, int col) {\n        int n = mat.GetLength(0);\n\n        // Check this col on upper side\n        for (int i = 0; i < row; i++)\n            if (mat[i, col] == 1)\n                return false;\n\n        // Check upper diagonal on left side\n        for (int i = row - 1, j = col - 1; \n             \t\ti >= 0 && j >= 0; i--, j--)\n            if (mat[i, j] == 1)\n                return false;\n\n        // Check lower diagonal on left side\n        for (int i = row - 1, j = col + 1;\n             \t\tj < n && i >= 0; i--, j++)\n            if (mat[i, j] == 1)\n                return false;\n\n        return true;\n    }\n\n    static bool PlaceQueens(int row, int[,] mat) {\n        int n = mat.GetLength(0);\n\n        // base case: If all queens are placed\n        // then return true\n        if (row == n)\n            return true;\n\n        // Consider the row and try placing\n        // queen in all columns one by one\n        for (int i = 0; i < n; i++) {\n\n            // Check if the queen can be placed\n            if (IsSafe(mat, row, i)) {\n                mat[row, i] = 1;\n                if (PlaceQueens(row + 1, mat))\n                    return true;\n                mat[row, i] = 0;\n            }\n        }\n        return false;\n    }\n\n    // Function to find the solution\n    // to the N-Queens problem\n    public static List<int> NQueen(int n) {\n\n        // Initialize the board\n        int[,] mat = new int[n, n];\n\n        // If the solution exists\n        if (PlaceQueens(0, mat)) {\n\n            // to store the columns of the queens\n            List<int> ans = new List<int>();\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < n; j++) {\n                    if (mat[i, j] == 1) {\n                        ans.Add(j + 1);\n                    }\n                }\n            }\n            return ans;\n        } else\n            return new List<int> { -1 };\n    }\n\n    static void Main(string[] args) {\n        int n = 4;\n        List<int> ans = NQueen(n);\n        Console.WriteLine(string.Join(\" \", ans));\n    }\n}\n// JavaScript Program to solve the n-queens problem\n\n// Function to check if it is safe to place\n// the queen at board[row][col]\nfunction isSafe(mat, row, col) {\n    const n = mat.length;\n\n    // Check this col on upper side\n    for (let i = 0; i < row; i++)\n        if (mat[i][col] === 1)\n            return false;\n\n    // Check upper diagonal on left side\n    for (let i = row - 1, j = col - 1; \n    \t\t\ti >= 0 && j >= 0; i--, j--)\n        if (mat[i][j] === 1)\n            return false;\n\n    // Check lower diagonal on left side\n    for (let i = row - 1, j = col + 1;\n    \t\t\tj < n && i >= 0; i--, j++)\n        if (mat[i][j] === 1)\n            return false;\n\n    return true;\n}\n\nfunction placeQueens(row, mat) {\n    const n = mat.length;\n\n    // base case: If all queens are placed\n    // then return true\n    if (row === n)\n        return true;\n\n    // Consider the row and try placing\n    // queen in all columns one by one\n    for (let i = 0; i < n; i++) {\n\n        // Check if the queen can be placed\n        if (isSafe(mat, row, i)) {\n            mat[row][i] = 1;\n            if (placeQueens(row + 1, mat))\n                return true;\n            mat[row][i] = 0;\n        }\n    }\n    return false;\n}\n\n// Function to find the solution\n// to the N-Queens problem\nfunction nQueen(n) {\n\n    // Initialize the board\n    const mat = Array.from({ length: n }, \n    \t\t\t\t\t() => Array(n).fill(0));\n\n    // If the solution exists\n    if (placeQueens(0, mat)) {\n\n        // to store the columns of the queens\n        const ans = [];\n        for (let i = 0; i < n; i++) {\n            for (let j = 0; j < n; j++) {\n                if (mat[i][j] === 1) {\n                    ans.push(j + 1);\n                }\n            }\n        }\n        return ans;\n    } else\n        return [-1];\n}\n\nconst n = 4;\nconst ans = nQueen(n);\nconsole.log(ans.join(\" \"));\n2 4 1 3\n// C++ Program to solve the n-queens problem\n#include <bits/stdc++.h>\nusing namespace std;\n\nint placeQueens(int i, vector<int> &cols, vector<int> &leftDiagonal,\n                     vector<int> &rightDiagonal, vector<int> &cur) {\n    int n = cols.size();\n\n    // base case: If all queens are placed\n    // then return true\n    if(i == n) return 1;\n\n    // Consider the row and try placing\n    // queen in all columns one by one\n    for(int j = 0; j < n; j++){\n\n        // Check if the queen can be placed\n        if(cols[j] || rightDiagonal[i + j] || \n                        leftDiagonal[i - j + n - 1]) \n            continue;\n        \n        // mark the cell occupied\n        cols[j] = 1;\n        rightDiagonal[i+j] = 1; \n        leftDiagonal[i - j + n - 1] = 1;\n        cur.push_back(j+1);\n\n        if(placeQueens(i + 1, cols, leftDiagonal, rightDiagonal, cur)) \n            return 1;\n\n        // remove the queen from current cell\n        cur.pop_back();\n        cols[j] = 0;\n        rightDiagonal[i+j] = 0; \n        leftDiagonal[i - j + n - 1] = 0;        \n    }\n    return 0;\n}\n\n// Function to find the solution\n// to the N-Queens problem\nvector<int> nQueen(int n) {\n\n    // array to mark the occupied cells\n    vector<int> cols(n, 0);\n    vector<int> leftDiagonal(n*2, 0);\n    vector<int> rightDiagonal(n*2, 0);\n    vector<int> cur;\n\n    // If the solution exists\n    if(placeQueens(0, cols, leftDiagonal, rightDiagonal, cur))\n        return cur;\n        \n    else return {-1};\n}\n\nint main() {\n    int n = 4;\n    vector<int> ans = nQueen(n);\n    for(auto i: ans){\n        cout << i << \" \";\n    }\n    return 0;\n}\n// Java Program to solve the n-queens problem\nimport java.util.*;\n\nclass GfG {\n\n    static boolean placeQueens(int i, int[] cols, int[] leftDiagonal, \n                             int[] rightDiagonal, List<Integer> cur) {\n        int n = cols.length;\n\n        // base case: If all queens are placed\n        // then return true\n        if (i == n) return true;\n\n        // Consider the row and try placing\n        // queen in all columns one by one\n        for (int j = 0; j < n; j++) {\n\n            // Check if the queen can be placed\n            if (cols[j] == 1 || rightDiagonal[i + j] == 1 || \n                leftDiagonal[i - j + n - 1] == 1) \n                continue;\n\n            // mark the cell occupied\n            cols[j] = 1;\n            rightDiagonal[i + j] = 1;\n            leftDiagonal[i - j + n - 1] = 1;\n            cur.add(j + 1);\n\n            if (placeQueens(i + 1, cols, leftDiagonal,\n                            rightDiagonal, cur)) \n                return true;\n\n            // remove the queen from current cell\n            cur.remove(cur.size() - 1);\n            cols[j] = 0;\n            rightDiagonal[i + j] = 0;\n            leftDiagonal[i - j + n - 1] = 0;\n        }\n        return false;\n    }\n\n    // Function to find the solution\n    // to the N-Queens problem\n    static List<Integer> nQueen(int n) {\n\n        // array to mark the occupied cells\n        int[] cols = new int[n];\n        int[] leftDiagonal = new int[n * 2];\n        int[] rightDiagonal = new int[n * 2];\n        List<Integer> cur = new ArrayList<>();\n\n        // If the solution exists\n        if (placeQueens(0, cols, leftDiagonal,\n                        rightDiagonal, cur))\n            return cur;\n\n        else return Collections.singletonList(-1);\n    }\n\n    public static void main(String[] args) {\n        int n = 4;\n        List<Integer> ans = nQueen(n);\n        for (int i : ans) {\n            System.out.print(i + \" \");\n        }\n    }\n}\n# Python Program to solve the n-queens problem\n\ndef placeQueens(i, cols, leftDiagonal, rightDiagonal, cur):\n    n = len(cols)\n\n    # base case: If all queens are placed\n    # then return true\n    if i == n:\n        return True\n\n    # Consider the row and try placing\n    # queen in all columns one by one\n    for j in range(n):\n\n        # Check if the queen can be placed\n        if cols[j] or rightDiagonal[i + j] or leftDiagonal[i - j + n - 1]:\n            continue\n\n        # mark the cell occupied\n        cols[j] = 1\n        rightDiagonal[i + j] = 1\n        leftDiagonal[i - j + n - 1] = 1\n        cur.append(j + 1)\n\n        if placeQueens(i + 1, cols, leftDiagonal, rightDiagonal, cur):\n            return True\n\n        # remove the queen from current cell\n        cur.pop()\n        cols[j] = 0\n        rightDiagonal[i + j] = 0\n        leftDiagonal[i - j + n - 1] = 0\n\n    return False\n\n# Function to find the solution\n# to the N-Queens problem\ndef nQueen(n):\n  \n    # array to mark the occupied cells\n    cols = [0] * n\n    leftDiagonal = [0] * (n * 2)\n    rightDiagonal = [0] * (n * 2)\n    cur = []\n\n    # If the solution exists\n    if placeQueens(0, cols, leftDiagonal, rightDiagonal, cur):\n        return cur\n    else:\n        return [-1]\n\nif __name__ == \"__main__\":\n    n = 4\n    ans = nQueen(n)\n    print(\" \".join(map(str, ans)))\n// C# Program to solve the n-queens problem\nusing System;\nusing System.Collections.Generic;\n\nclass GfG {\n\n    static bool PlaceQueens(int i, int[] cols, int[] leftDiagonal, \n                              int[] rightDiagonal, List<int> cur) {\n        int n = cols.Length;\n\n        // base case: If all queens are placed\n        // then return true\n        if (i == n) return true;\n\n        // Consider the row and try placing\n        // queen in all columns one by one\n        for (int j = 0; j < n; j++) {\n\n            // Check if the queen can be placed\n            if (cols[j] == 1 || rightDiagonal[i + j] == 1 || \n                leftDiagonal[i - j + n - 1] == 1)\n                continue;\n\n            // mark the cell occupied\n            cols[j] = 1;\n            rightDiagonal[i + j] = 1;\n            leftDiagonal[i - j + n - 1] = 1;\n            cur.Add(j + 1);\n\n            if (PlaceQueens(i + 1, cols, leftDiagonal,\n                            rightDiagonal, cur))\n                return true;\n\n            // remove the queen from current cell\n            cur.RemoveAt(cur.Count - 1);\n            cols[j] = 0;\n            rightDiagonal[i + j] = 0;\n            leftDiagonal[i - j + n - 1] = 0;\n        }\n        return false;\n    }\n\n    // Function to find the solution\n    // to the N-Queens problem\n    static List<int> NQueen(int n) {\n\n        // array to mark the occupied cells\n        int[] cols = new int[n];\n        int[] leftDiagonal = new int[n * 2];\n        int[] rightDiagonal = new int[n * 2];\n        List<int> cur = new List<int>();\n\n        // If the solution exists\n        if (PlaceQueens(0, cols, leftDiagonal,\n                        \trightDiagonal, cur))\n            return cur;\n\n        else return new List<int> { -1 };\n    }\n\n    static void Main(string[] args) {\n        int n = 4;\n        List<int> ans = NQueen(n);\n        foreach (int i in ans) {\n            Console.Write(i + \" \");\n        }\n    }\n}\n// JavaScript Program to solve the n-queens problem\n\nfunction placeQueens(i, cols, leftDiagonal, rightDiagonal, cur) {\n    const n = cols.length;\n\n    // base case: If all queens are placed\n    // then return true\n    if (i === n) return true;\n\n    // Consider the row and try placing\n    // queen in all columns one by one\n    for (let j = 0; j < n; j++) {\n\n        // Check if the queen can be placed\n        if (cols[j] || rightDiagonal[i + j] ||\n        \t\t\tleftDiagonal[i - j + n - 1])\n            continue;\n\n        // mark the cell occupied\n        cols[j] = 1;\n        rightDiagonal[i + j] = 1;\n        leftDiagonal[i - j + n - 1] = 1;\n        cur.push(j + 1);\n\n        if (placeQueens(i + 1, cols, leftDiagonal,\n        \t\t\t\t\t\trightDiagonal, cur))\n            return true;\n\n        // remove the queen from current cell\n        cur.pop();\n        cols[j] = 0;\n        rightDiagonal[i + j] = 0;\n        leftDiagonal[i - j + n - 1] = 0;\n    }\n    return false;\n}\n\n// Function to find the solution\n// to the N-Queens problem\nfunction nQueen(n) {\n\n    // array to mark the occupied cells\n    const cols = new Array(n).fill(0);\n    const leftDiagonal = new Array(n * 2).fill(0);\n    const rightDiagonal = new Array(n * 2).fill(0);\n    const cur = [];\n\n    // If the solution exists\n    if (placeQueens(0, cols, leftDiagonal, \n    \t\t\t\t\trightDiagonal, cur))\n        return cur;\n\n    else return [-1];\n}\n\nconst n = 4;\nconst ans = nQueen(n);\nconsole.log(ans.join(\" \"));\n2 4 1 3\n",
        "complexity": {
            "time": "Time Complexity: O(n!) Auxiliary Space: O(n)",
            "space": ""
        },
        "tags": [
            "Backtracking"
        ],
        "url": "https://www.geeksforgeeks.org/n-queen-problem-backtracking-3/"
    },
    {
        "title": "The Knight’s tour problem",
        "description": "Backtracking is an algorithmic paradigm that tries different solutions until finds a solution that “works”. Problems that are typically solved using the backtracking technique have the following property in common. These problems can only be solved by trying every possible configuration and each configuration is tried only once. A Naive solution for these problems is to try all configurations and output a configuration that follows given problem constraints. Backtracking works incrementally and is an optimization over the Naive solution where all possible configurations are generated and tried.For example, consider the following Knight’s Tour problem. Problem Statement:Given a N*N board with the Knight placed on the first block of an empty board. Moving according to the rules of chess knight must visit each square exactly once. Print the order of each cell in which they are visited. Example: The path followed by Knight to cover all the cellsFollowing is a chessboard with 8 x 8 cells. Numbers in cells indicate the move number of Knight. Let us first discuss the Naive algorithm for this problem and then the Backtracking algorithm. Naive Algorithm for Knight’s tour The Naive Algorithm is to generate all tours one by one and check if the generated tour satisfies the constraints. Backtracking works in an incremental way to attack problems. Typically, we start from an empty solution vector and one by one add items (Meaning of item varies from problem to problem. In the context of Knight’s tour problem, an item is a Knight’s move). When we add an item, we check if adding the current item violates the problem constraint, if it does then we remove the item and try other alternatives. If none of the alternatives works out then we go to the previous stage and remove the item added in the previous stage. If we reach the initial stage back then we say that no solution exists. If adding an item doesn’t violate constraints then we recursively add items one by one. If the solution vector becomes complete then we print the solution. Backtracking Algorithm for Knight’s tour Following is the Backtracking algorithm for Knight’s tour problem. Following are implementations for Knight’s tour problem. It prints one of the possible solutions in 2D matrix form. Basically, the output is a 2D 8*8 matrix with numbers from 0 to 63 and these numbers show steps made by Knight. Time Complexity : There are N2 Cells and for each, we have a maximum of 8 possible moves to choose from, so the worst running time is O(8N^2). Auxiliary Space: O(N2) Important Note:No order of the xMove, yMove is wrong, but they will affect the running time of the algorithm drastically. For example, think of the case where the 8th choice of the move is the correct one, and before that our code ran 7 different wrong paths. It’s always a good idea a have a heuristic than to try backtracking randomly. Like, in this case, we know the next step would probably be in the south or east direction, then checking the paths which lead their first is a better strategy. Note that Backtracking is not the best solution for the Knight’s tour problem. See the below article for other better solutions. The purpose of this post is to explain Backtracking with an example. Warnsdorff’s algorithm for Knight’s tour problem References: http://see.stanford.edu/materials/icspacs106b/H19-RecBacktrackExamples.pdf http://www.cis.upenn.edu/~matuszek/cit594-2009/Lectures/35-backtracking.ppt http://mathworld.wolfram.com/KnightsTour.html http://en.wikipedia.org/wiki/Knight%27s_tour  ",
        "code": "Input : N = 8Output:0  59  38  33  30  17   8  6337  34  31  60   9  62  29  1658   1  36  39  32  27  18   735  48  41  26  61  10  15  2842  57   2  49  40  23   6  1947  50  45  54  25  20  11  1456  43  52   3  22  13  24   551  46  55  44  53   4  21  12\nwhile there are untried tours{    generate the next tour    if this tour covers all squares    {       print this path;   }}\nIf all squares are visited     print the solutionElse   a) Add one of the next moves to solution vector and recursively    check if this move leads to a solution. (A Knight can make maximum    eight moves. We choose one of the 8 moves in this step).   b) If the move chosen in the above step doesn't lead to a solution   then remove this move from the solution vector and try other    alternative moves.   c) If none of the alternatives work then return false (Returning false    will remove the previously added item in recursion and if false is    returned by the initial call of recursion then \"no solution exists\" )\n// C++ program for Knight Tour problem\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define N 8\n\nint solveKTUtil(int x, int y, int movei, int sol[N][N],\n                int xMove[], int yMove[]);\n\n/* A utility function to check if i,j are\nvalid indexes for N*N chessboard */\nint isSafe(int x, int y, int sol[N][N])\n{\n    return (x >= 0 && x < N && y >= 0 && y < N\n            && sol[x][y] == -1);\n}\n\n/* A utility function to print\nsolution matrix sol[N][N] */\nvoid printSolution(int sol[N][N])\n{\n    for (int x = 0; x < N; x++) {\n        for (int y = 0; y < N; y++)\n            cout << \" \" << setw(2) << sol[x][y] << \" \";\n        cout << endl;\n    }\n}\n\n/* This function solves the Knight Tour problem using\nBacktracking. This function mainly uses solveKTUtil()\nto solve the problem. It returns false if no complete\ntour is possible, otherwise return true and prints the\ntour.\nPlease note that there may be more than one solutions,\nthis function prints one of the feasible solutions. */\nint solveKT()\n{\n    int sol[N][N];\n\n    /* Initialization of solution matrix */\n    for (int x = 0; x < N; x++)\n        for (int y = 0; y < N; y++)\n            sol[x][y] = -1;\n\n    /* xMove[] and yMove[] define next move of Knight.\n    xMove[] is for next value of x coordinate\n    yMove[] is for next value of y coordinate */\n    int xMove[8] = { 2, 1, -1, -2, -2, -1, 1, 2 };\n    int yMove[8] = { 1, 2, 2, 1, -1, -2, -2, -1 };\n\n    // Since the Knight is initially at the first block\n    sol[0][0] = 0;\n\n    /* Start from 0,0 and explore all tours using\n    solveKTUtil() */\n    if (solveKTUtil(0, 0, 1, sol, xMove, yMove) == 0) {\n        cout << \"Solution does not exist\";\n        return 0;\n    }\n    else\n        printSolution(sol);\n\n    return 1;\n}\n\n/* A recursive utility function to solve Knight Tour\nproblem */\nint solveKTUtil(int x, int y, int movei, int sol[N][N],\n                int xMove[8], int yMove[8])\n{\n    int k, next_x, next_y;\n    if (movei == N * N)\n        return 1;\n\n    /* Try all next moves from\n    the current coordinate x, y */\n    for (k = 0; k < 8; k++) {\n        next_x = x + xMove[k];\n        next_y = y + yMove[k];\n        if (isSafe(next_x, next_y, sol)) {\n            sol[next_x][next_y] = movei;\n            if (solveKTUtil(next_x, next_y, movei + 1, sol,\n                            xMove, yMove)\n                == 1)\n                return 1;\n            else\n               \n               // backtracking\n                sol[next_x][next_y] = -1;\n        }\n    }\n    return 0;\n}\n\n// Driver Code\nint main()\n{\n      // Function Call\n    solveKT();\n    return 0;\n}\n\n// This code is contributed by ShubhamCoder\n// C program for Knight Tour problem\n#include <stdio.h>\n#define N 8\n\nint solveKTUtil(int x, int y, int movei, int sol[N][N],\n                int xMove[], int yMove[]);\n\n/* A utility function to check if i,j are valid indexes\n   for N*N chessboard */\nint isSafe(int x, int y, int sol[N][N])\n{\n    return (x >= 0 && x < N && y >= 0 && y < N\n            && sol[x][y] == -1);\n}\n\n/* A utility function to print solution matrix sol[N][N] */\nvoid printSolution(int sol[N][N])\n{\n    for (int x = 0; x < N; x++) {\n        for (int y = 0; y < N; y++)\n            printf(\" %2d \", sol[x][y]);\n        printf(\"\\n\");\n    }\n}\n\n/* This function solves the Knight Tour problem using\n   Backtracking.  This function mainly uses solveKTUtil()\n   to solve the problem. It returns false if no complete\n   tour is possible, otherwise return true and prints the\n   tour.\n   Please note that there may be more than one solutions,\n   this function prints one of the feasible solutions.  */\nint solveKT()\n{\n    int sol[N][N];\n\n    /* Initialization of solution matrix */\n    for (int x = 0; x < N; x++)\n        for (int y = 0; y < N; y++)\n            sol[x][y] = -1;\n\n    /* xMove[] and yMove[] define next move of Knight.\n       xMove[] is for next value of x coordinate\n       yMove[] is for next value of y coordinate */\n    int xMove[8] = { 2, 1, -1, -2, -2, -1, 1, 2 };\n    int yMove[8] = { 1, 2, 2, 1, -1, -2, -2, -1 };\n\n    // Since the Knight is initially at the first block\n    sol[0][0] = 0;\n\n    /* Start from 0,0 and explore all tours using\n       solveKTUtil() */\n    if (solveKTUtil(0, 0, 1, sol, xMove, yMove) == 0) {\n        printf(\"Solution does not exist\");\n        return 0;\n    }\n    else\n        printSolution(sol);\n\n    return 1;\n}\n\n/* A recursive utility function to solve Knight Tour\n   problem */\nint solveKTUtil(int x, int y, int movei, int sol[N][N],\n                int xMove[N], int yMove[N])\n{\n    int k, next_x, next_y;\n    if (movei == N * N)\n        return 1;\n\n    /* Try all next moves from the current coordinate x, y\n     */\n    for (k = 0; k < 8; k++) {\n        next_x = x + xMove[k];\n        next_y = y + yMove[k];\n        if (isSafe(next_x, next_y, sol)) {\n            sol[next_x][next_y] = movei;\n            if (solveKTUtil(next_x, next_y, movei + 1, sol,\n                            xMove, yMove)\n                == 1)\n                return 1;\n            else\n                sol[next_x][next_y] = -1; // backtracking\n        }\n    }\n\n    return 0;\n}\n\n/* Driver Code */\nint main()\n{\n  \n      // Function Call\n    solveKT();\n    return 0;\n}\n// Java program for Knight Tour problem\nclass KnightTour {\n    static int N = 8;\n\n    /* A utility function to check if i,j are\n       valid indexes for N*N chessboard */\n    static boolean isSafe(int x, int y, int sol[][])\n    {\n        return (x >= 0 && x < N && y >= 0 && y < N\n                && sol[x][y] == -1);\n    }\n\n    /* A utility function to print solution\n       matrix sol[N][N] */\n    static void printSolution(int sol[][])\n    {\n        for (int x = 0; x < N; x++) {\n            for (int y = 0; y < N; y++)\n                System.out.print(sol[x][y] + \" \");\n            System.out.println();\n        }\n    }\n\n    /* This function solves the Knight Tour problem\n       using Backtracking.  This  function mainly\n       uses solveKTUtil() to solve the problem. It\n       returns false if no complete tour is possible,\n       otherwise return true and prints the tour.\n       Please note that there may be more than one\n       solutions, this function prints one of the\n       feasible solutions.  */\n    static boolean solveKT()\n    {\n        int sol[][] = new int[8][8];\n\n        /* Initialization of solution matrix */\n        for (int x = 0; x < N; x++)\n            for (int y = 0; y < N; y++)\n                sol[x][y] = -1;\n\n        /* xMove[] and yMove[] define next move of Knight.\n           xMove[] is for next value of x coordinate\n           yMove[] is for next value of y coordinate */\n        int xMove[] = { 2, 1, -1, -2, -2, -1, 1, 2 };\n        int yMove[] = { 1, 2, 2, 1, -1, -2, -2, -1 };\n\n        // Since the Knight is initially at the first block\n        sol[0][0] = 0;\n\n        /* Start from 0,0 and explore all tours using\n           solveKTUtil() */\n        if (!solveKTUtil(0, 0, 1, sol, xMove, yMove)) {\n            System.out.println(\"Solution does not exist\");\n            return false;\n        }\n        else\n            printSolution(sol);\n\n        return true;\n    }\n\n    /* A recursive utility function to solve Knight\n       Tour problem */\n    static boolean solveKTUtil(int x, int y, int movei,\n                               int sol[][], int xMove[],\n                               int yMove[])\n    {\n        int k, next_x, next_y;\n        if (movei == N * N)\n            return true;\n\n        /* Try all next moves from the current coordinate\n            x, y */\n        for (k = 0; k < 8; k++) {\n            next_x = x + xMove[k];\n            next_y = y + yMove[k];\n            if (isSafe(next_x, next_y, sol)) {\n                sol[next_x][next_y] = movei;\n                if (solveKTUtil(next_x, next_y, movei + 1,\n                                sol, xMove, yMove))\n                    return true;\n                else\n                    sol[next_x][next_y]\n                        = -1; // backtracking\n            }\n        }\n\n        return false;\n    }\n\n    /* Driver Code */\n    public static void main(String args[])\n    {\n        // Function Call\n        solveKT();\n    }\n}\n// This code is contributed by Abhishek Shankhadhar\n# Python3 program to solve Knight Tour problem using Backtracking\n\n# Chessboard Size\nn = 8\n\n\ndef isSafe(x, y, board):\n    '''\n        A utility function to check if i,j are valid indexes \n        for N*N chessboard\n    '''\n    if(x >= 0 and y >= 0 and x < n and y < n and board[x][y] == -1):\n        return True\n    return False\n\n\ndef printSolution(n, board):\n    '''\n        A utility function to print Chessboard matrix\n    '''\n    for i in range(n):\n        for j in range(n):\n            print(board[i][j], end=' ')\n        print()\n\n\ndef solveKT(n):\n    '''\n        This function solves the Knight Tour problem using \n        Backtracking. This function mainly uses solveKTUtil() \n        to solve the problem. It returns false if no complete \n        tour is possible, otherwise return true and prints the \n        tour. \n        Please note that there may be more than one solutions, \n        this function prints one of the feasible solutions.\n    '''\n\n    # Initialization of Board matrix\n    board = [[-1 for i in range(n)]for i in range(n)]\n\n    # move_x and move_y define next move of Knight.\n    # move_x is for next value of x coordinate\n    # move_y is for next value of y coordinate\n    move_x = [2, 1, -1, -2, -2, -1, 1, 2]\n    move_y = [1, 2, 2, 1, -1, -2, -2, -1]\n\n    # Since the Knight is initially at the first block\n    board[0][0] = 0\n\n    # Step counter for knight's position\n    pos = 1\n\n    # Checking if solution exists or not\n    if(not solveKTUtil(n, board, 0, 0, move_x, move_y, pos)):\n        print(\"Solution does not exist\")\n    else:\n        printSolution(n, board)\n\n\ndef solveKTUtil(n, board, curr_x, curr_y, move_x, move_y, pos):\n    '''\n        A recursive utility function to solve Knight Tour \n        problem\n    '''\n\n    if(pos == n**2):\n        return True\n\n    # Try all next moves from the current coordinate x, y\n    for i in range(8):\n        new_x = curr_x + move_x[i]\n        new_y = curr_y + move_y[i]\n        if(isSafe(new_x, new_y, board)):\n            board[new_x][new_y] = pos\n            if(solveKTUtil(n, board, new_x, new_y, move_x, move_y, pos+1)):\n                return True\n\n            # Backtracking\n            board[new_x][new_y] = -1\n    return False\n\n\n# Driver Code\nif __name__ == \"__main__\":\n    \n    # Function Call\n    solveKT(n)\n\n# This code is contributed by AAKASH PAL\n// C# program for\n// Knight Tour problem\nusing System;\n\nclass GFG {\n    static int N = 8;\n\n    /* A utility function to\n    check if i,j are valid\n    indexes for N*N chessboard */\n    static bool isSafe(int x, int y, int[, ] sol)\n    {\n        return (x >= 0 && x < N && y >= 0 && y < N\n                && sol[x, y] == -1);\n    }\n\n    /* A utility function to\n    print solution matrix sol[N][N] */\n    static void printSolution(int[, ] sol)\n    {\n        for (int x = 0; x < N; x++) {\n            for (int y = 0; y < N; y++)\n                Console.Write(sol[x, y] + \" \");\n            Console.WriteLine();\n        }\n    }\n\n    /* This function solves the\n    Knight Tour problem using\n    Backtracking. This function\n    mainly uses solveKTUtil() to\n    solve the problem. It returns\n    false if no complete tour is\n    possible, otherwise return true\n    and prints the tour. Please note\n    that there may be more than one\n    solutions, this function prints\n    one of the feasible solutions. */\n    static bool solveKT()\n    {\n        int[, ] sol = new int[8, 8];\n\n        /* Initialization of\n        solution matrix */\n        for (int x = 0; x < N; x++)\n            for (int y = 0; y < N; y++)\n                sol[x, y] = -1;\n\n        /* xMove[] and yMove[] define\n           next move of Knight.\n           xMove[] is for next\n           value of x coordinate\n           yMove[] is for next\n           value of y coordinate */\n        int[] xMove = { 2, 1, -1, -2, -2, -1, 1, 2 };\n        int[] yMove = { 1, 2, 2, 1, -1, -2, -2, -1 };\n\n        // Since the Knight is\n        // initially at the first block\n        sol[0, 0] = 0;\n\n        /* Start from 0,0 and explore\n        all tours using solveKTUtil() */\n        if (!solveKTUtil(0, 0, 1, sol, xMove, yMove)) {\n            Console.WriteLine(\"Solution does \"\n                              + \"not exist\");\n            return false;\n        }\n        else\n            printSolution(sol);\n\n        return true;\n    }\n\n    /* A recursive utility function\n    to solve Knight Tour problem */\n    static bool solveKTUtil(int x, int y, int movei,\n                            int[, ] sol, int[] xMove,\n                            int[] yMove)\n    {\n        int k, next_x, next_y;\n        if (movei == N * N)\n            return true;\n\n        /* Try all next moves from\n        the current coordinate x, y */\n        for (k = 0; k < 8; k++) {\n            next_x = x + xMove[k];\n            next_y = y + yMove[k];\n            if (isSafe(next_x, next_y, sol)) {\n                sol[next_x, next_y] = movei;\n                if (solveKTUtil(next_x, next_y, movei + 1,\n                                sol, xMove, yMove))\n                    return true;\n                else\n                    // backtracking\n                    sol[next_x, next_y] = -1;\n            }\n        }\n\n        return false;\n    }\n\n    // Driver Code\n    public static void Main()\n    {\n        // Function Call\n        solveKT();\n    }\n}\n\n// This code is contributed by mits.\n<script>\n\n// Javascript program for Knight Tour problem\nlet N = 8;\n\n// A utility function to check if i,j are\n// valid indexes for N*N chessboard \nfunction isSafe(x, y, sol)\n{\n    return(x >= 0 && x < N && y >= 0 && \n            y < N && sol[x][y] == -1);\n}\n\n// A utility function to print solution\n// matrix sol[N][N] \nfunction printSolution(sol)\n{\n    for(let x = 0; x < N; x++) \n    {\n        for(let y = 0; y < N; y++)\n            document.write(sol[x][y] + \" \");\n            \n        document.write(\"<br/>\");\n    }\n}\n\n// This function solves the Knight Tour problem\n// using Backtracking.  This  function mainly\n// uses solveKTUtil() to solve the problem. It\n// returns false if no complete tour is possible,\n// otherwise return true and prints the tour.\n// Please note that there may be more than one\n// solutions, this function prints one of the\n// feasible solutions.  \nfunction solveKT()\n{\n    let sol = new Array(N);\n    for(var i = 0; i < sol.length; i++)\n    {\n        sol[i] = new Array(N);\n    }\n\n    // Initialization of solution matrix \n    for(let x = 0; x < N; x++)\n        for(let y = 0; y < N; y++)\n            sol[x][y] = -1;\n\n    // xMove[] and yMove[] define next move of Knight.\n    // xMove[] is for next value of x coordinate\n    // yMove[] is for next value of y coordinate \n    let xMove = [ 2, 1, -1, -2, -2, -1, 1, 2 ];\n    let yMove = [ 1, 2, 2, 1, -1, -2, -2, -1 ];\n\n    // Since the Knight is initially at the first block\n    sol[0][0] = 0;\n\n    // Start from 0,0 and explore all tours using\n    // solveKTUtil() \n    if (!solveKTUtil(0, 0, 1, sol, xMove, yMove))\n    {\n        document.write(\"Solution does not exist\");\n        return false;\n    }\n    else\n        printSolution(sol);\n\n    return true;\n}\n\n// A recursive utility function to solve Knight\n// Tour problem \nfunction solveKTUtil(x, y, movei, sol, xMove, yMove)\n{\n    let k, next_x, next_y;\n    if (movei == N * N)\n        return true;\n\n    // Try all next moves from the \n    // current coordinate x, y \n    for(k = 0; k < 8; k++) \n    {\n        next_x = x + xMove[k];\n        next_y = y + yMove[k];\n        \n        if (isSafe(next_x, next_y, sol)) \n        {\n            sol[next_x][next_y] = movei;\n            if (solveKTUtil(next_x, next_y, movei + 1,\n                            sol, xMove, yMove))\n                return true;\n            else\n                sol[next_x][next_y] = -1; // backtracking\n        }\n    }\n    return false;\n}\n\n// Driver code\n\n// Function Call\nsolveKT();\n\n// This code is contributed by target_2\n\n</script>\n0  59  38  33  30  17   8  63 \n 37  34  31  60   9  62  29  16 \n 58   1  36  39  32  27  18   7 \n 35  48  41  26  61  10  15  28 \n 42  57   2  49  40  23   6  19 \n 47  50  45  54  25  20  11  14 \n 56  43  52   3  22  13  24   5 \n 51  46  55  44  53   4  21  12\n",
        "complexity": {
            "time": "Time Complexity : There are N2 Cells and for each, we have a maximum of 8 possible moves to choose from, so the worst running time is O(8N^2).",
            "space": ""
        },
        "tags": [
            "Backtracking"
        ],
        "url": "https://www.geeksforgeeks.org/the-knights-tour-problem/"
    },
    {
        "title": "Algorithm to Solve Sudoku | Sudoku Solver",
        "description": "Given an incomplete Sudoku in the form of matrix mat[][] of order 9*9, the task is to complete the Sudoku.A sudoku solution must satisfy all of the following rules: Note: Zeros in the mat[][] indicate blanks, which are to be filled with some number between 1 to 9. You can not replace the element in the cell which is not blank. Examples: Input: Output: Explanation: Each row, column and 3*3 box of the output matrix contains unique numbers. The idea is to use backtracking and recursively generate all possible configurations of numbers from 1 to 9 to fill the empty cells of matrix mat[][]. To do so, for every unassigned cell, fill the cell with a number from 1 to 9 one by one. After filling the unassigned cell check if the matrix is safe or not. If safe, move to the next cell else backtrack for other cases. To check if it is safe to place value num in the cell mat[i][j], iterate through all the columns of row i, rows of column j and the 3*3 matrix containing cell (i, j) and check if they already has value num, if so return false, else return true. Time complexity: O(n*9(n*n)), For every unassigned index, there are 9 possible options and for each index, we are checking other columns, rows and boxes.Auxiliary Space: O(1) In the above approach, isSafe() function which is used to check if it is safe to place number num in cell (i, j) searches for num in each row, col and box. The idea is to optimize this using Bit Masking. To do so, create three arrays rows[], cols[], boxs[] of size n to mark the used value in row, column and box respectively. The element row[i] marks the number already been used in row i, and so do cols[] and boxs[] for columns and boxes. To mark the number num of row i, set the bit num from left of row[i] and operate similarly for cols[] and boxs[]. Similarly, to unmark the value num, unset the bits set in current step. Time complexity: O(9(n*n))Auxiliary Space: O(n)   ",
        "code": "// C++ Program to solve Sudoku problem\n#include <iostream>\n#include <vector>\nusing namespace std;\n\n// Function to check if it is safe to place num at mat[row][col]\nbool isSafe(vector<vector<int>> &mat, int row, int col, int num) {\n\n    // Check if num exist in the row\n    for (int x = 0; x <= 8; x++)\n        if (mat[row][x] == num)\n            return false;\n\n    // Check if num exist in the col\n    for (int x = 0; x <= 8; x++)\n        if (mat[x][col] == num)\n            return false;\n\n    // Check if num exist in the 3x3 sub-matrix\n    int startRow = row - (row % 3), startCol = col - (col % 3);\n\n    for (int i = 0; i < 3; i++)\n        for (int j = 0; j < 3; j++)\n            if (mat[i + startRow][j + startCol] == num)\n                return false;\n\n    return true;\n}\n\n// Function to solve the Sudoku problem\nbool solveSudokuRec(vector<vector<int>> &mat, int row, int col) {\n    int n = mat.size();\n\n    // base case: Reached nth column of last row\n    if (row == n - 1 && col == n)\n        return true;\n\n    // If last column of the row go to next row\n    if (col == n) {\n        row++;\n        col = 0;\n    }\n\n    // If cell is already occupied then move forward\n    if (mat[row][col] != 0)\n        return solveSudokuRec(mat, row, col + 1);\n\n    for (int num = 1; num <= n; num++) {\n\n        // If it is safe to place num at current position\n        if (isSafe(mat, row, col, num)) {\n            mat[row][col] = num;\n            if (solveSudokuRec(mat, row, col + 1))\n                return true;\n            mat[row][col] = 0;\n        }\n    }\n  \n  \treturn false;\n}\n\nvoid solveSudoku(vector<vector<int>> &mat) {\n  \tsolveSudokuRec(mat, 0, 0);\n}\n\nint main() {\n    vector<vector<int>> mat = {\n        {3, 0, 6, 5, 0, 8, 4, 0, 0}, \n      \t{5, 2, 0, 0, 0, 0, 0, 0, 0}, \n      \t{0, 8, 7, 0, 0, 0, 0, 3, 1},\n        {0, 0, 3, 0, 1, 0, 0, 8, 0}, \n      \t{9, 0, 0, 8, 6, 3, 0, 0, 5}, \n      \t{0, 5, 0, 0, 9, 0, 6, 0, 0},\n        {1, 3, 0, 0, 0, 0, 2, 5, 0}, \n      \t{0, 0, 0, 0, 0, 0, 0, 7, 4}, \n      \t{0, 0, 5, 2, 0, 6, 3, 0, 0}};\n\n\tsolveSudoku(mat);\n    \n  \tfor (int i = 0; i < mat.size(); i++) {\n        for (int j = 0; j < mat.size(); j++)\n            cout << mat[i][j] << \" \";\n        cout << endl;\n    }\n\n    return 0;\n}\n// Java Program to solve Sudoku problem\nimport java.util.Arrays;\n\nclass GfG {\n\n    // Function to check if it is safe to place num at mat[row][col]\n    static boolean isSafe(int[][] mat, int row, int col, int num) {\n        // Check if num exists in the row\n        for (int x = 0; x < 9; x++)\n            if (mat[row][x] == num)\n                return false;\n\n        // Check if num exists in the col\n        for (int x = 0; x < 9; x++)\n            if (mat[x][col] == num)\n                return false;\n\n        // Check if num exists in the 3x3 sub-matrix\n        int startRow = row - (row % 3), startCol = col - (col % 3);\n\n        for (int i = 0; i < 3; i++)\n            for (int j = 0; j < 3; j++)\n                if (mat[i + startRow][j + startCol] == num)\n                    return false;\n\n        return true;\n    }\n\n    // Function to solve the Sudoku problem\n    static boolean solveSudokuRec(int[][] mat, int row, int col) {\n      \n        // base case: Reached nth column of the last row\n        if (row == 8 && col == 9)\n            return true;\n\n        // If last column of the row go to the next row\n        if (col == 9) {\n            row++;\n            col = 0;\n        }\n\n        // If cell is already occupied then move forward\n        if (mat[row][col] != 0)\n            return solveSudokuRec(mat, row, col + 1);\n\n        for (int num = 1; num <= 9; num++) {\n          \n            // If it is safe to place num at current position\n            if (isSafe(mat, row, col, num)) {\n                mat[row][col] = num;\n                if (solveSudokuRec(mat, row, col + 1))\n                    return true;\n                mat[row][col] = 0;\n            }\n        }\n\n        return false;\n    }\n\n    static void solveSudoku(int[][] mat) {\n        solveSudokuRec(mat, 0, 0);\n    }\n\n    public static void main(String[] args) {\n        int[][] mat = {\n            {3, 0, 6, 5, 0, 8, 4, 0, 0},\n            {5, 2, 0, 0, 0, 0, 0, 0, 0},\n            {0, 8, 7, 0, 0, 0, 0, 3, 1},\n            {0, 0, 3, 0, 1, 0, 0, 8, 0},\n            {9, 0, 0, 8, 6, 3, 0, 0, 5},\n            {0, 5, 0, 0, 9, 0, 6, 0, 0},\n            {1, 3, 0, 0, 0, 0, 2, 5, 0},\n            {0, 0, 0, 0, 0, 0, 0, 7, 4},\n            {0, 0, 5, 2, 0, 6, 3, 0, 0}\n        };\n\n        solveSudoku(mat);\n\n        for (int i = 0; i < mat.length; i++) {\n            for (int j = 0; j < mat[i].length; j++)\n                System.out.print(mat[i][j] + \" \");\n            System.out.println();\n        }\n    }\n}\n# Python Program to solve Sudoku problem\n\n# Function to check if it is safe to place num at mat[row][col]\ndef isSafe(mat, row, col, num):\n    # Check if num exists in the row\n    for x in range(9):\n        if mat[row][x] == num:\n            return False\n\n    # Check if num exists in the col\n    for x in range(9):\n        if mat[x][col] == num:\n            return False\n\n    # Check if num exists in the 3x3 sub-matrix\n    startRow = row - (row % 3)\n    startCol = col - (col % 3)\n\n    for i in range(3):\n        for j in range(3):\n            if mat[i + startRow][j + startCol] == num:\n                return False\n\n    return True\n\n# Function to solve the Sudoku problem\ndef solveSudokuRec(mat, row, col):\n    # base case: Reached nth column of the last row\n    if row == 8 and col == 9:\n        return True\n\n    # If last column of the row go to the next row\n    if col == 9:\n        row += 1\n        col = 0\n\n    # If cell is already occupied then move forward\n    if mat[row][col] != 0:\n        return solveSudokuRec(mat, row, col + 1)\n\n    for num in range(1, 10):\n        # If it is safe to place num at current position\n        if isSafe(mat, row, col, num):\n            mat[row][col] = num\n            if solveSudokuRec(mat, row, col + 1):\n                return True\n            mat[row][col] = 0\n\n    return False\n\ndef solveSudoku(mat):\n    solveSudokuRec(mat, 0, 0)\n\nif __name__ == \"__main__\":\n    mat = [\n        [3, 0, 6, 5, 0, 8, 4, 0, 0],\n        [5, 2, 0, 0, 0, 0, 0, 0, 0],\n        [0, 8, 7, 0, 0, 0, 0, 3, 1],\n        [0, 0, 3, 0, 1, 0, 0, 8, 0],\n        [9, 0, 0, 8, 6, 3, 0, 0, 5],\n        [0, 5, 0, 0, 9, 0, 6, 0, 0],\n        [1, 3, 0, 0, 0, 0, 2, 5, 0],\n        [0, 0, 0, 0, 0, 0, 0, 7, 4],\n        [0, 0, 5, 2, 0, 6, 3, 0, 0]\n    ]\n\n    solveSudoku(mat)\n\n    for row in mat:\n        print(\" \".join(map(str, row)))\n// C# Program to solve Sudoku problem\n\nusing System;\n\nclass GfG {\n\n    // Function to check if it is safe to place num at mat[row][col]\n    static bool isSafe(int[,] mat, int row, int col, int num) {\n        // Check if num exists in the row\n        for (int x = 0; x < 9; x++)\n            if (mat[row, x] == num)\n                return false;\n\n        // Check if num exists in the col\n        for (int x = 0; x < 9; x++)\n            if (mat[x, col] == num)\n                return false;\n\n        // Check if num exists in the 3x3 sub-matrix\n        int startRow = row - (row % 3), startCol = col - (col % 3);\n\n        for (int i = 0; i < 3; i++)\n            for (int j = 0; j < 3; j++)\n                if (mat[i + startRow, j + startCol] == num)\n                    return false;\n\n        return true;\n    }\n\n    // Function to solve the Sudoku problem\n    static bool solveSudokuRec(int[,] mat, int row, int col) {\n      \n        // base case: Reached nth column of the last row\n        if (row == 8 && col == 9)\n            return true;\n\n        // If last column of the row go to the next row\n        if (col == 9) {\n            row++;\n            col = 0;\n        }\n\n        // If cell is already occupied then move forward\n        if (mat[row, col] != 0)\n            return solveSudokuRec(mat, row, col + 1);\n\n        for (int num = 1; num <= 9; num++) {\n            // If it is safe to place num at current position\n            if (isSafe(mat, row, col, num)) {\n                mat[row, col] = num;\n                if (solveSudokuRec(mat, row, col + 1))\n                    return true;\n                mat[row, col] = 0;\n            }\n        }\n\n        return false;\n    }\n\n    static void solveSudoku(int[,] mat) {\n        solveSudokuRec(mat, 0, 0);\n    }\n\n    public static void Main() {\n        int[,] mat = {\n            {3, 0, 6, 5, 0, 8, 4, 0, 0},\n            {5, 2, 0, 0, 0, 0, 0, 0, 0},\n            {0, 8, 7, 0, 0, 0, 0, 3, 1},\n            {0, 0, 3, 0, 1, 0, 0, 8, 0},\n            {9, 0, 0, 8, 6, 3, 0, 0, 5},\n            {0, 5, 0, 0, 9, 0, 6, 0, 0},\n            {1, 3, 0, 0, 0, 0, 2, 5, 0},\n            {0, 0, 0, 0, 0, 0, 0, 7, 4},\n            {0, 0, 5, 2, 0, 6, 3, 0, 0}\n        };\n\n        solveSudoku(mat);\n\n        for (int i = 0; i < 9; i++) {\n            for (int j = 0; j < 9; j++)\n                Console.Write(mat[i, j] + \" \");\n            Console.WriteLine();\n        }\n    }\n}\n// JavaScript Program to solve Sudoku problem\n\n// Function to check if it is safe to place num at mat[row][col]\nfunction isSafe(mat, row, col, num) {\n    // Check if num exists in the row\n    for (let x = 0; x < 9; x++)\n        if (mat[row][x] === num)\n            return false;\n\n    // Check if num exists in the col\n    for (let x = 0; x < 9; x++)\n        if (mat[x][col] === num)\n            return false;\n\n    // Check if num exists in the 3x3 sub-matrix\n    const startRow = row - (row % 3),\n          startCol = col - (col % 3);\n\n    for (let i = 0; i < 3; i++)\n        for (let j = 0; j < 3; j++)\n            if (mat[i + startRow][j + startCol] === num)\n                return false;\n\n    return true;\n}\n\n// Function to solve the Sudoku problem\nfunction solveSudokuRec(mat, row, col) {\n\n    // base case: Reached nth column of the last row\n    if (row === 8 && col === 9)\n        return true;\n\n    // If last column of the row go to the next row\n    if (col === 9) {\n        row++;\n        col = 0;\n    }\n\n    // If cell is already occupied then move forward\n    if (mat[row][col] !== 0)\n        return solveSudokuRec(mat, row, col + 1);\n\n    for (let num = 1; num <= 9; num++) {\n        // If it is safe to place num at current position\n        if (isSafe(mat, row, col, num)) {\n            mat[row][col] = num;\n            if (solveSudokuRec(mat, row, col + 1))\n                return true;\n            mat[row][col] = 0;\n        }\n    }\n\n    return false;\n}\n\nfunction solveSudoku(mat) {\n    solveSudokuRec(mat, 0, 0);\n}\n\n// Driver Code\nconst mat = [\n    [3, 0, 6, 5, 0, 8, 4, 0, 0],\n    [5, 2, 0, 0, 0, 0, 0, 0, 0],\n    [0, 8, 7, 0, 0, 0, 0, 3, 1],\n    [0, 0, 3, 0, 1, 0, 0, 8, 0],\n    [9, 0, 0, 8, 6, 3, 0, 0, 5],\n    [0, 5, 0, 0, 9, 0, 6, 0, 0],\n    [1, 3, 0, 0, 0, 0, 2, 5, 0],\n    [0, 0, 0, 0, 0, 0, 0, 7, 4],\n    [0, 0, 5, 2, 0, 6, 3, 0, 0]\n];\n\nsolveSudoku(mat);\n\nmat.forEach(row => console.log(row.join(\" \")));\n3 1 6 5 7 8 4 9 2 \n5 2 9 1 3 4 7 6 8 \n4 8 7 6 2 9 5 3 1 \n2 6 3 4 1 5 9 8 7 \n9 7 4 8 6 3 1 2 5 \n8 5 1 7 9 2 6 4 3 \n1 3 8 9 4 7 2 5 6 \n6 9 2 3 5 1 8 7 4 \n7 4 5 2 8 6 3 1 9\n// C++ Program to solve Sudoku problem\n#include <iostream>\n#include <vector>\nusing namespace std;\n\n// Function to heck if it is safe to place num at mat[row][col]\nbool isSafe(vector<vector<int>> &mat, int i, int j, int num, \n        vector<int> &row, vector<int> &col, vector<int> &box) {\n  \n    if( (row[i] & (1 << num)) || (col[j] & (1 << num)) ||\n       \t\t\t\t\t(box[i / 3 * 3 + j / 3] & (1 << num)) )\n        return false;\n    \n    return true;\n}\n\nbool sudokuSolverRec(vector<vector<int>> &mat, int i, int j, \n    \t\tvector<int> &row, vector<int> &col, vector<int> &box) {\n    int n = mat.size();\n\n\t// base case: Reached nth column of last row\n    if (i == n - 1 && j == n)\n        return true;\n\n    // If reached last column of the row go to next row\n    if (j == n) {\n        i++;\n        j = 0;\n    }\n  \n    // If cell is already occupied then move forward\n    if (mat[i][j] != 0)\n        return sudokuSolverRec(mat, i, j + 1, row, col, box);\n\n    for (int num = 1; num <= n; num++) {\n        \n        // If it is safe to place num at current position\n        if (isSafe(mat, i, j, num, row, col, box)) {\n            mat[i][j] = num;\n          \n          \t// Update masks for the corresponding row, column and box\n            row[i] |= (1 << num);\n            col[j] |= (1 << num);\n            box[i / 3 * 3 + j / 3] |= (1 << num);\n          \n            if (sudokuSolverRec(mat, i, j + 1, row, col, box))\n                return true;\n          \t\n          \t// Unmask the number num in the corresponding row, column and box masks\n            mat[i][j] = 0;\n            row[i] &= ~(1 << num);\n            col[j] &= ~(1 << num);\n            box[i / 3 * 3 + j / 3] &= ~(1 << num);\n        }\n    }\n  \n    return false;\n}\n\nvoid solveSudoku(vector<vector<int>> &mat) {\n  \tint n = mat.size();\n    vector<int> row(n, 0), col(n, 0), box(n, 0);\n\n    // Set the bits in bitmasks for values that are initital present   \n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            if (mat[i][j] != 0) {\n                row[i] |= (1 << mat[i][j]);\n                col[j] |= (1 << mat[i][j]);\n                box[ (i / 3) * 3 + j / 3] |= (1 << mat[i][j]);\n            }\n        }\n    }\n\n    sudokuSolverRec(mat, 0, 0, row, col, box);\n}\n\nint main() {\n    vector<vector<int>> mat = {\n        {3, 0, 6, 5, 0, 8, 4, 0, 0}, \n      \t{5, 2, 0, 0, 0, 0, 0, 0, 0}, \n      \t{0, 8, 7, 0, 0, 0, 0, 3, 1},\n        {0, 0, 3, 0, 1, 0, 0, 8, 0}, \n      \t{9, 0, 0, 8, 6, 3, 0, 0, 5}, \n      \t{0, 5, 0, 0, 9, 0, 6, 0, 0},\n        {1, 3, 0, 0, 0, 0, 2, 5, 0}, \n      \t{0, 0, 0, 0, 0, 0, 0, 7, 4}, \n      \t{0, 0, 5, 2, 0, 6, 3, 0, 0}};\n\n\tsolveSudoku(mat);\n    \n  \tfor (int i = 0; i < mat.size(); i++) {\n        for (int j = 0; j < mat.size(); j++)\n            cout << mat[i][j] << \" \";\n        cout << endl;\n    }\n\n    return 0;\n}\n// Java Program to solve Sudoku problem\nimport java.util.Arrays;\n\nclass GfG {\n\n    // Function to check if it is safe to place num at mat[row][col]\n    static boolean isSafe(int[][] mat, int i, int j, int num, \n                          int[] row, int[] col, int[] box) {\n        if ((row[i] & (1 << num)) != 0 || (col[j] & (1 << num)) != 0 || \n            (box[i / 3 * 3 + j / 3] & (1 << num)) != 0)\n            return false;\n        \n        return true;\n    }\n\n    static boolean sudokuSolverRec(int[][] mat, int i, int j, \n                                   int[] row, int[] col, int[] box) {\n        int n = mat.length;\n\n        // base case: Reached nth column of last row\n        if (i == n - 1 && j == n)\n            return true;\n\n        // If reached last column of the row go to next row\n        if (j == n) {\n            i++;\n            j = 0;\n        }\n\n        // If cell is already occupied then move forward\n        if (mat[i][j] != 0)\n            return sudokuSolverRec(mat, i, j + 1, row, col, box);\n\n        for (int num = 1; num <= n; num++) {\n            // If it is safe to place num at current position\n            if (isSafe(mat, i, j, num, row, col, box)) {\n                mat[i][j] = num;\n\n                // Update masks for the corresponding row, column and box\n                row[i] |= (1 << num);\n                col[j] |= (1 << num);\n                box[i / 3 * 3 + j / 3] |= (1 << num);\n\n                if (sudokuSolverRec(mat, i, j + 1, row, col, box))\n                    return true;\n\n                // Unmask the number num in the corresponding row, column and box masks\n                mat[i][j] = 0;\n                row[i] &= ~(1 << num);\n                col[j] &= ~(1 << num);\n                box[i / 3 * 3 + j / 3] &= ~(1 << num);\n            }\n        }\n\n        return false;\n    }\n\n    static void solveSudoku(int[][] mat) {\n        int n = mat.length;\n        int[] row = new int[n];\n        int[] col = new int[n];\n        int[] box = new int[n];\n\n        // Set the bits in bitmasks for values that are initially present\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                if (mat[i][j] != 0) {\n                    row[i] |= (1 << mat[i][j]);\n                    col[j] |= (1 << mat[i][j]);\n                    box[(i / 3) * 3 + j / 3] |= (1 << mat[i][j]);\n                }\n            }\n        }\n\n        sudokuSolverRec(mat, 0, 0, row, col, box);\n    }\n\n    public static void main(String[] args) {\n        int[][] mat = {\n            {3, 0, 6, 5, 0, 8, 4, 0, 0},\n            {5, 2, 0, 0, 0, 0, 0, 0, 0},\n            {0, 8, 7, 0, 0, 0, 0, 3, 1},\n            {0, 0, 3, 0, 1, 0, 0, 8, 0},\n            {9, 0, 0, 8, 6, 3, 0, 0, 5},\n            {0, 5, 0, 0, 9, 0, 6, 0, 0},\n            {1, 3, 0, 0, 0, 0, 2, 5, 0},\n            {0, 0, 0, 0, 0, 0, 0, 7, 4},\n            {0, 0, 5, 2, 0, 6, 3, 0, 0}\n        };\n\n        solveSudoku(mat);\n\n        for (int i = 0; i < mat.length; i++) {\n            for (int j = 0; j < mat[i].length; j++)\n                System.out.print(mat[i][j] + \" \");\n            System.out.println();\n        }\n    }\n}\n# Python Program to solve Sudoku problem\n\ndef isSafe(mat, i, j, num, row, col, box):\n    if (row[i] & (1 << num)) or (col[j] & (1 << num)) or (box[i // 3 * 3 + j // 3] & (1 << num)):\n        return False\n    return True\n\ndef sudokuSolverRec(mat, i, j, row, col, box):\n    n = len(mat)\n\n    # base case: Reached nth column of last row\n    if i == n - 1 and j == n:\n        return True\n\n    # If reached last column of the row go to next row\n    if j == n:\n        i += 1\n        j = 0\n\n    # If cell is already occupied then move forward\n    if mat[i][j] != 0:\n        return sudokuSolverRec(mat, i, j + 1, row, col, box)\n\n    for num in range(1, n + 1):\n        # If it is safe to place num at current position\n        if isSafe(mat, i, j, num, row, col, box):\n            mat[i][j] = num\n\n            # Update masks for the corresponding row, column and box\n            row[i] |= (1 << num)\n            col[j] |= (1 << num)\n            box[i // 3 * 3 + j // 3] |= (1 << num)\n\n            if sudokuSolverRec(mat, i, j + 1, row, col, box):\n                return True\n\n            # Unmask the number num in the corresponding row, column and box masks\n            mat[i][j] = 0\n            row[i] &= ~(1 << num)\n            col[j] &= ~(1 << num)\n            box[i // 3 * 3 + j // 3] &= ~(1 << num)\n\n    return False\n\ndef solveSudoku(mat):\n    n = len(mat)\n    row = [0] * n\n    col = [0] * n\n    box = [0] * n\n\n    # Set the bits in bitmasks for values that are initially present\n    for i in range(n):\n        for j in range(n):\n            if mat[i][j] != 0:\n                row[i] |= (1 << mat[i][j])\n                col[j] |= (1 << mat[i][j])\n                box[(i // 3) * 3 + j // 3] |= (1 << mat[i][j])\n\n    sudokuSolverRec(mat, 0, 0, row, col, box)\n\nif __name__ == \"__main__\":\n    mat = [\n        [3, 0, 6, 5, 0, 8, 4, 0, 0],\n        [5, 2, 0, 0, 0, 0, 0, 0, 0],\n        [0, 8, 7, 0, 0, 0, 0, 3, 1],\n        [0, 0, 3, 0, 1, 0, 0, 8, 0],\n        [9, 0, 0, 8, 6, 3, 0, 0, 5],\n        [0, 5, 0, 0, 9, 0, 6, 0, 0],\n        [1, 3, 0, 0, 0, 0, 2, 5, 0],\n        [0, 0, 0, 0, 0, 0, 0, 7, 4],\n        [0, 0, 5, 2, 0, 6, 3, 0, 0]\n    ]\n\n    solveSudoku(mat)\n\n    for row in mat:\n        print(\" \".join(map(str, row)))\n// C# Program to solve Sudoku problem using bitmasks\nusing System;\n\nclass GfG {\n\n    // Function to check if it is safe to place num at mat[row, col]\n    static bool isSafe(int[,] mat, int i, int j, int num, \n                       \tint[] row, int[] col, int[] box) {\n      \n        if ((row[i] & (1 << num)) != 0 || (col[j] & (1 << num)) != 0 ||\n            (box[i / 3 * 3 + j / 3] & (1 << num)) != 0)\n            return false;\n\n        return true;\n    }\n\n    static bool sudokuSolverRec(int[,] mat, int i, int j, \n                                int[] row, int[] col, int[] box) {\n        int n = mat.GetLength(0);\n\n        // base case: Reached nth column of last row\n        if (i == n - 1 && j == n)\n            return true;\n\n        // If reached last column of the row, go to next row\n        if (j == n) {\n            i++;\n            j = 0;\n        }\n\n        // If cell is already occupied, then move forward\n        if (mat[i, j] != 0)\n            return sudokuSolverRec(mat, i, j + 1, row, col, box);\n\n        for (int num = 1; num <= n; num++) {\n\n            // If it is safe to place num at current position\n            if (isSafe(mat, i, j, num, row, col, box)) {\n                mat[i, j] = num;\n\n                // Update masks for the corresponding row, column, and box\n                row[i] |= (1 << num);\n                col[j] |= (1 << num);\n                box[i / 3 * 3 + j / 3] |= (1 << num);\n\n                if (sudokuSolverRec(mat, i, j + 1, row, col, box))\n                    return true;\n\n                // Unmask the number num in the corresponding row, column and box masks\n                mat[i, j] = 0;\n                row[i] &= ~(1 << num);\n                col[j] &= ~(1 << num);\n                box[i / 3 * 3 + j / 3] &= ~(1 << num);\n            }\n        }\n\n        return false;\n    }\n\n    static void solveSudoku(int[,] mat) {\n        int n = mat.GetLength(0);\n        int[] row = new int[n];\n        int[] col = new int[n];\n        int[] box = new int[n];\n\n        // Set the bits in bitmasks for values that are initially present\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                if (mat[i, j] != 0) {\n                    row[i] |= (1 << mat[i, j]);\n                    col[j] |= (1 << mat[i, j]);\n                    box[(i / 3) * 3 + j / 3] |= (1 << mat[i, j]);\n                }\n            }\n        }\n\n        sudokuSolverRec(mat, 0, 0, row, col, box);\n    }\n\n    public static void Main(string[] args) {\n        int[,] mat = {\n            {3, 0, 6, 5, 0, 8, 4, 0, 0},\n            {5, 2, 0, 0, 0, 0, 0, 0, 0},\n            {0, 8, 7, 0, 0, 0, 0, 3, 1},\n            {0, 0, 3, 0, 1, 0, 0, 8, 0},\n            {9, 0, 0, 8, 6, 3, 0, 0, 5},\n            {0, 5, 0, 0, 9, 0, 6, 0, 0},\n            {1, 3, 0, 0, 0, 0, 2, 5, 0},\n            {0, 0, 0, 0, 0, 0, 0, 7, 4},\n            {0, 0, 5, 2, 0, 6, 3, 0, 0}\n        };\n\n        solveSudoku(mat);\n\n        for (int i = 0; i < mat.GetLength(0); i++) {\n            for (int j = 0; j < mat.GetLength(1); j++)\n                Console.Write(mat[i, j] + \" \");\n            Console.WriteLine();\n        }\n    }\n}\n// JavaScript Program to solve Sudoku problem using bitmasks\n\n// Function to check if it is safe to place num at mat[row][col]\nfunction isSafe(mat, i, j, num, row, col, box) {\n    if ((row[i] & (1 << num)) !== 0 || (col[j] & (1 << num)) !== 0 ||\n        (box[Math.floor(i / 3) * 3 + Math.floor(j / 3)] & (1 << num)) !== 0)\n        return false;\n\n    return true;\n}\n\nfunction sudokuSolverRec(mat, i, j, row, col, box) {\n    const n = mat.length;\n\n    // base case: Reached nth column of last row\n    if (i === n - 1 && j === n)\n        return true;\n\n    // If reached last column of the row, go to next row\n    if (j === n) {\n        i++;\n        j = 0;\n    }\n\n    // If cell is already occupied, then move forward\n    if (mat[i][j] !== 0)\n        return sudokuSolverRec(mat, i, j + 1, row, col, box);\n\n    for (let num = 1; num <= n; num++) {\n\n        // If it is safe to place num at current position\n        if (isSafe(mat, i, j, num, row, col, box)) {\n            mat[i][j] = num;\n\n            // Update masks for the corresponding row, column, and box\n            row[i] |= (1 << num);\n            col[j] |= (1 << num);\n            box[Math.floor(i / 3) * 3 + Math.floor(j / 3)] |= (1 << num);\n\n            if (sudokuSolverRec(mat, i, j + 1, row, col, box))\n                return true;\n\n            // Unmask the number num in the corresponding row, column and box masks\n            mat[i][j] = 0;\n            row[i] &= ~(1 << num);\n            col[j] &= ~(1 << num);\n            box[Math.floor(i / 3) * 3 + Math.floor(j / 3)] &= ~(1 << num);\n        }\n    }\n\n    return false;\n}\n\nfunction solveSudoku(mat) {\n    const n = mat.length;\n    const row = new Array(n).fill(0);\n    const col = new Array(n).fill(0);\n    const box = new Array(n).fill(0);\n\n    // Set the bits in bitmasks for values that are initially present\n    for (let i = 0; i < n; i++) {\n        for (let j = 0; j < n; j++) {\n            if (mat[i][j] !== 0) {\n                row[i] |= (1 << mat[i][j]);\n                col[j] |= (1 << mat[i][j]);\n                box[Math.floor(i / 3) * 3 + Math.floor(j / 3)] |= (1 << mat[i][j]);\n            }\n        }\n    }\n\n    sudokuSolverRec(mat, 0, 0, row, col, box);\n}\n\n// Driver Code\nconst mat = [\n    [3, 0, 6, 5, 0, 8, 4, 0, 0],\n    [5, 2, 0, 0, 0, 0, 0, 0, 0],\n    [0, 8, 7, 0, 0, 0, 0, 3, 1],\n    [0, 0, 3, 0, 1, 0, 0, 8, 0],\n    [9, 0, 0, 8, 6, 3, 0, 0, 5],\n    [0, 5, 0, 0, 9, 0, 6, 0, 0],\n    [1, 3, 0, 0, 0, 0, 2, 5, 0],\n    [0, 0, 0, 0, 0, 0, 0, 7, 4],\n    [0, 0, 5, 2, 0, 6, 3, 0, 0]\n];\n\nsolveSudoku(mat);\n\nfor (let i = 0; i < mat.length; i++) {\n    console.log(mat[i].join(\" \"));\n}\n3 1 6 5 7 8 4 9 2 \n5 2 9 1 3 4 7 6 8 \n4 8 7 6 2 9 5 3 1 \n2 6 3 4 1 5 9 8 7 \n9 7 4 8 6 3 1 2 5 \n8 5 1 7 9 2 6 4 3 \n1 3 8 9 4 7 2 5 6 \n6 9 2 3 5 1 8 7 4 \n7 4 5 2 8 6 3 1 9\n",
        "complexity": {
            "time": "Time complexity: O(9(n*n))Auxiliary Space: O(n)",
            "space": ""
        },
        "tags": [
            "Backtracking"
        ],
        "url": "https://www.geeksforgeeks.org/sudoku-backtracking-7/"
    },
    {
        "title": "Rat in a Maze",
        "description": "Given an n x n binary matrix representing a maze, where 1 means open and 0 means blocked, a rat starts at (0, 0) and needs to reach (n - 1, n - 1). The rat can move up (U), down (D), left (L), and right (R), but: Return all possible paths from the source to the destination as strings. If no path exists, return -1. Example: Input:  Output: DRDDRRExplanation:  The main idea uses DFS (Depth First Search) to explore all possible paths from the source to the destination in the maze. The algorithm recursively builds paths, stores them when the destination is reached, and backtracks to explore alternative routes. It ensures that no cell is visited more than once in a given path by marking cells as visited during exploration and unvisited during backtracking. Time Complexity: O(4n*n), because on every cell we have to try 4 different directions.Auxiliary Space:  O(n*n), Maximum Depth of the recursion tree.  ",
        "code": "// C++ Program to find all paths for a rat in a maze\n// from source (0,0) to destination (n-1, n-1)\n\n#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Directions: Down, Left, Right, Up\nstring dir = \"DLRU\";\nint dr[4] = {1, 0, 0, -1};\nint dc[4] = {0, -1, 1, 0};\n\n// Check if a cell is valid (inside the maze and open)\nbool isValid(int r, int c, int n, vector<vector<int>>& maze) {\n    return r >= 0 && c >= 0 && r < n && c < n && maze[r][c];\n}\n\n// Function to find all valid paths\nvoid findPath(int r, int c, vector<vector<int>>& maze, string& path,\n                                vector<string>& res) {\n    int n = maze.size(); \n\n    // If destination is reached, store the path\n    if (r == n - 1 && c == n - 1) {\n        res.push_back(path);\n        return;\n    }\n    \n    // Mark current cell as blocked\n    maze[r][c] = 0; \n\n    for (int i = 0; i < 4; i++) {\n        int nr = r + dr[i], nc = c + dc[i];\n        if (isValid(nr, nc, n, maze)) {\n            path.push_back(dir[i]);\n            \n            // Recurse to next cell\n            findPath(nr, nc, maze, path, res); \n            \n            // Backtrack\n            path.pop_back();\n        }\n    }\n    \n    // Unmark current cell\n    maze[r][c] = 1;  \n}\n\n// Function to find all paths and return them\nvector<string> ratInMaze(vector<vector<int>>& maze) {\n    vector<string> result;\n    int n = maze.size();\n    string path = \"\";\n\n    if (maze[0][0] != 0 && maze[n - 1][n - 1] != 0) {\n        \n        // Start DFS from (0,0)\n        findPath(0, 0, maze, path, result);  \n    }\n\n    return result;\n}\n\nint main() {\n    vector<vector<int>> maze = {\n        {1, 0, 0, 0},\n        {1, 1, 0, 1},\n        {1, 1, 0, 0},\n        {0, 1, 1, 1}\n    };\n\n    // Call ratInMaze and get the result\n    vector<string> result = ratInMaze(maze);\n\n    // Print result in the main function\n    if (result.empty()) {\n        cout << -1 << endl;\n    } else {\n        for (const auto& p : result) {\n            cout << p << \" \";\n        }\n        cout << endl;\n    }\n\n    return 0;\n}\n// Java Program to find all paths for a rat in a maze\n// from source (0,0) to destination (n-1, n-1)\n\nimport java.util.*;\n\n class GfG {\n\n    static String dir = \"DLRU\";\n    static int[] dr = {1, 0, 0, -1};\n    static int[] dc = {0, -1, 1, 0};\n\n    // Check if a cell is valid (inside the maze and open)\n    static boolean isValid(int r, int c, int n, int[][] maze) {\n        return r >= 0 && c >= 0 && r < n && c < n && maze[r][c] == 1;\n    }\n\n    // Function to find all valid paths\n    static void findPath(int r, int c, int[][] maze, String path,\n                                    ArrayList<String> res) {\n        int n = maze.length;\n\n        // If destination is reached, store the path\n        if (r == n - 1 && c == n - 1) {\n            res.add(path);\n            return;\n        }\n\n        // Mark current cell as blocked\n        maze[r][c] = 0;\n\n        for (int i = 0; i < 4; i++) {\n            int nr = r + dr[i], nc = c + dc[i];\n            if (isValid(nr, nc, n, maze)) {\n                findPath(nr, nc, maze, path + dir.charAt(i), res);\n            }\n        }\n\n        // Unmark current cell\n        maze[r][c] = 1;  \n    }\n\n    // Function to find all paths and return them\n    static ArrayList<String> ratInMaze(int[][] maze) {\n        ArrayList<String> result = new ArrayList<>();\n        int n = maze.length;\n        String path = \"\";\n\n        if (maze[0][0] != 0 && maze[n - 1][n - 1] != 0) {\n            findPath(0, 0, maze, path, result);\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        int[][] maze = {\n            {1, 0, 0, 0},\n            {1, 1, 0, 1},\n            {1, 1, 0, 0},\n            {0, 1, 1, 1}\n        };\n\n        ArrayList<String> result = ratInMaze(maze);\n\n        if (result.isEmpty()) {\n            System.out.println(-1);\n        } else {\n            for (String p : result) {\n                System.out.print(p + \" \");\n            }\n            System.out.println();\n        }\n    }\n}\n# Python Program to find all paths for a rat in a maze\n# from source (0,0) to destination (n-1, n-1)\n\n# Initialize a string direction which represents all the directions.\ndirection = \"DLRU\"\n\n# Arrays to represent change in rows and columns\ndr = [1, 0, 0, -1]\ndc = [0, -1, 1, 0]\n\n# Function to check if cell(row, col) is inside the maze and unblocked\ndef isValid(row, col, n, maze):\n    return 0 <= row < n and 0 <= col < n and maze[row][col] == 1\n\n# Function to get all valid paths\ndef findPath(row, col, maze, n, ans, currentPath):\n    if row == n - 1 and col == n - 1:\n        ans.append(currentPath)\n        return\n\n    # Mark the current cell as blocked\n    maze[row][col] = 0\n\n    for i in range(4):\n\n        # Find the next row and column based on the current direction\n        nextRow = row + dr[i]\n        nextCol = col + dc[i]\n\n        # Check if the next cell is valid or not\n        if isValid(nextRow, nextCol, n, maze):\n            currentPath += direction[i]\n            \n            # Recursively call the findPath function for the next cell\n            findPath(nextRow, nextCol, maze, n, ans, currentPath)\n            \n            # Remove the last direction when backtracking\n            currentPath = currentPath[:-1]\n\n    # Mark the current cell as unblocked\n    maze[row][col] = 1\n\n# Main function to solve the maze\ndef ratInMaze(maze):\n    result = []\n    n = len(maze)\n    currentPath = \"\"\n\n    if maze[0][0] != 0 and maze[n - 1][n - 1] != 0:\n        \n        # Function call to get all valid paths\n        findPath(0, 0, maze, n, result, currentPath)\n\n    return result\n    \nif __name__ == \"__main__\":\n    maze = [\n        [1, 0, 0, 0],\n        [1, 1, 0, 1],\n        [1, 1, 0, 0],\n        [0, 1, 1, 1]\n    ]\n\n    # Call ratInMaze and get the result\n    result = ratInMaze(maze)\n\n    # Print result in the main function\n    if not result:\n        print(-1)\n    else:\n        print(\" \".join(result))\n// C# Program to find all paths for a rat in a maze\n// from source (0,0) to destination (n-1, n-1)\n\nusing System;\nusing System.Collections.Generic;\n\n class GfG {\n    static string dir = \"DLRU\";\n    static int[] dr = { 1, 0, 0, -1 };\n    static int[] dc = { 0, -1, 1, 0 };\n\n    // Check if a cell is valid (inside the maze and open)\n    static bool IsValid(int r, int c, int n, int[,] maze) {\n        return r >= 0 && c >= 0 && r < n && c < n && maze[r, c] == 1;\n    }\n\n    // Function to find all valid paths\n    static void findPath(int r, int c, int[,] maze, string path,\n                    List<string> res) {\n        int n = maze.GetLength(0);\n\n        // If destination is reached, store the path\n        if (r == n - 1 && c == n - 1) {\n            res.Add(path);\n            return;\n        }\n\n        // Mark current cell as blocked\n        maze[r, c] = 0;\n\n        for (int i = 0; i < 4; i++) {\n            int nr = r + dr[i], nc = c + dc[i];\n            if (IsValid(nr, nc, n, maze)) {\n                findPath(nr, nc, maze, path + dir[i], res);\n            }\n        }\n        \n        // Unmark current cell\n        maze[r, c] = 1; \n    }\n\n    // Function to find all paths and return them\n    static List<string> ratInMaze(int[,] maze) {\n        List<string> result = new List<string>();\n        int n = maze.GetLength(0);\n        string path = \"\";\n\n        if (maze[0, 0] != 0 && maze[n - 1, n - 1] != 0) {\n            findPath(0, 0, maze, path, result);\n        }\n\n        return result;\n    }\n\n    public static void Main() {\n        int[,] maze = {\n            {1, 0, 0, 0},\n            {1, 1, 0, 1},\n            {1, 1, 0, 0},\n            {0, 1, 1, 1}\n        };\n\n        List<string> res = ratInMaze(maze);\n\n        if (res.Count == 0) {\n            Console.WriteLine(-1);\n        } else {\n            foreach (var path in res) {\n                Console.Write(path + \" \");\n            }\n            Console.WriteLine();\n        }\n    }\n}\n// JavaScript Program to find all paths for a rat in a maze\n// from source (0,0) to destination (n-1, n-1)\n\nconst dir = \"DLRU\";\nconst dr = [1, 0, 0, -1];\nconst dc = [0, -1, 1, 0];\n\n// Check if a cell is valid (inside the maze and open)\nfunction isValid(r, c, n, maze) {\n    return r >= 0 && c >= 0 && r < n && c < n && maze[r][c] === 1;\n}\n\n// Function to find all valid paths\nfunction findPath(r, c, maze, path, res) {\n    const n = maze.length;\n\n    // If destination is reached, store the path\n    if (r === n - 1 && c === n - 1) {\n        res.push(path);\n        return;\n    }\n\n    // Mark current cell as blocked\n    maze[r][c] = 0;\n\n    for (let i = 0; i < 4; i++) {\n        const nr = r + dr[i], nc = c + dc[i];\n        if (isValid(nr, nc, n, maze)) {\n            findPath(nr, nc, maze, path + dir[i], res);\n        }\n    }\n    \n    // Unmark current cell\n    maze[r][c] = 1; \n}\n\n// Function to find all paths and return them\nfunction ratInMaze(maze) {\n    const result = [];\n    const n = maze.length;\n    const path = \"\";\n\n    if (maze[0][0] !== 0 && maze[n - 1][n - 1] !== 0) {\n        findPath(0, 0, maze, path, result);\n    }\n\n    return result;\n}\n\n// Driver Code \nconst maze = [\n    [1, 0, 0, 0],\n    [1, 1, 0, 1],\n    [1, 1, 0, 0],\n    [0, 1, 1, 1]\n];\n\nconst result = ratInMaze(maze);\n\nif (result.length === 0) {\n    console.log(-1);\n} else {\n    console.log(result.join(\" \"));\n}\nDDRDRR DRDDRR\n",
        "complexity": {
            "time": "Time Complexity: O(4n*n), because on every cell we have to try 4 different directions.Auxiliary Space:  O(n*n), Maximum Depth of the recursion tree.",
            "space": ""
        },
        "tags": [
            "Backtracking"
        ],
        "url": "https://www.geeksforgeeks.org/rat-in-a-maze/"
    },
    {
        "title": "Hamiltonian Cycle",
        "description": "Hamiltonian Cycle or Circuit in a graph G is a cycle that visits every vertex of G exactly once and returns to the starting vertex. Hamiltonian Path in a graph G is a path that visits every vertex of G exactly once and Hamiltonian Path doesn’t have to return to the starting vertex. It’s an open path. Problems Statement: Given an undirected graph, the task is to determine whether the graph contains a Hamiltonian cycle or not. If it contains, then prints the path. Example: Input: graph[][] = {{0, 1, 0, 1, 0},{1, 0, 1, 1, 1},{0, 1, 0, 0, 1},{1, 1, 0, 0, 1},{0, 1, 1, 1, 0}} Input graph[][] Output: {0, 1, 2, 4, 3, 0}. Input: graph[][] = {{0, 1, 0, 1, 0},{1, 0, 1, 1, 1},{0, 1, 0, 0, 1},{1, 1, 0, 0, 0},{0, 1, 1, 0, 0}} Input graph[][] Naive Algorithm: This problem can be solved using below idea: Generate all possible configurations of vertices and print a configuration that satisfies the given constraints. There will be n! (n factorial) configurations. So the overall Time Complexity of this approach will be O(N!). Create an empty path array and add vertex 0 to it. Add other vertices, starting from the vertex 1. Before adding a vertex, check for whether it is adjacent to the previously added vertex and not already added. If we find such a vertex, we add the vertex as part of the solution. If we do not find a vertex then we return false. Illustrations: Let’s find out the Hamiltonian cycle for the following graph: Starting from start node 0 calling DFS  Hamiltonian Cycle Below is the Backtracking implementation for finding Hamiltonian Cycle: Time Complexity : O(N!), where N is number of vertices.Auxiliary Space : O(1), since no extra space used. Note: The above code always prints a cycle starting from 0. The starting point should not matter as the cycle can be started from any point. If you want to change the starting point, you should make two changes to the above code. Change “path[0] = 0;” to “path[0] = s;” where s is your new starting point. Also change loop “for (int v = 1; v < V; v++)” in hamCycleUtil() to “for (int v = 0; v < V; v++)”.  ",
        "code": "/* C++ program for solution of Hamiltonian \nCycle problem using backtracking */\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Number of vertices in the graph \n#define V 5 \n\nvoid printSolution(int path[]); \n\n/* A utility function to check if \nthe vertex v can be added at index 'pos' \nin the Hamiltonian Cycle constructed \nso far (stored in 'path[]') */\nbool isSafe(int v, bool graph[V][V], \n            int path[], int pos) \n{ \n    /* Check if this vertex is an adjacent \n    vertex of the previously added vertex. */\n    if (graph [path[pos - 1]][ v ] == 0) \n        return false; \n\n    /* Check if the vertex has already been included. \n    This step can be optimized by creating\n    an array of size V */\n    for (int i = 0; i < pos; i++) \n        if (path[i] == v) \n            return false; \n\n    return true; \n} \n\n/* A recursive utility function \nto solve hamiltonian cycle problem */\nbool hamCycleUtil(bool graph[V][V], \n                  int path[], int pos) \n{ \n    /* base case: If all vertices are \n    included in Hamiltonian Cycle */\n    if (pos == V) \n    { \n        // And if there is an edge from the \n        // last included vertex to the first vertex \n        if (graph[path[pos - 1]][path[0]] == 1) \n            return true; \n        else\n            return false; \n    } \n\n    // Try different vertices as a next candidate \n    // in Hamiltonian Cycle. We don't try for 0 as \n    // we included 0 as starting point in hamCycle() \n    for (int v = 1; v < V; v++) \n    { \n        /* Check if this vertex can be added \n        // to Hamiltonian Cycle */\n        if (isSafe(v, graph, path, pos)) \n        { \n            path[pos] = v; \n\n            /* recur to construct rest of the path */\n            if (hamCycleUtil (graph, path, pos + 1) == true) \n                return true; \n\n            /* If adding vertex v doesn't lead to a solution, \n            then remove it */\n            path[pos] = -1; \n        } \n    } \n\n    /* If no vertex can be added to \n    Hamiltonian Cycle constructed so far, \n    then return false */\n    return false; \n} \n\n/* This function solves the Hamiltonian Cycle problem \nusing Backtracking. It mainly uses hamCycleUtil() to \nsolve the problem. It returns false if there is no \nHamiltonian Cycle possible, otherwise return true \nand prints the path. Please note that there may be \nmore than one solutions, this function prints one \nof the feasible solutions. */\nbool hamCycle(bool graph[V][V]) \n{ \n    int *path = new int[V]; \n    for (int i = 0; i < V; i++) \n        path[i] = -1; \n\n    /* Let us put vertex 0 as the first vertex in the path.\n    If there is a Hamiltonian Cycle, then the path can be \n    started from any point of the cycle as the graph is undirected */\n    path[0] = 0; \n    if (hamCycleUtil(graph, path, 1) == false ) \n    { \n        cout << \"\\nSolution does not exist\"; \n        return false; \n    } \n\n    printSolution(path); \n    return true; \n} \n\n/* A utility function to print solution */\nvoid printSolution(int path[]) \n{ \n    cout << \"Solution Exists:\"\n            \" Following is one Hamiltonian Cycle \\n\"; \n    for (int i = 0; i < V; i++) \n        cout << path[i] << \" \"; \n\n    // Let us print the first vertex again\n    // to show the complete cycle \n    cout << path[0] << \" \"; \n    cout << endl;\n} \n\n// Driver Code \nint main() \n{ \n    /* Let us create the following graph \n        (0)--(1)--(2) \n        |     / \\   | \n        |    /      \\  | \n        | /      \\ | \n        (3)-------(4) */\n    bool graph1[V][V] = {{0, 1, 0, 1, 0}, \n                        {1, 0, 1, 1, 1}, \n                        {0, 1, 0, 0, 1}, \n                        {1, 1, 0, 0, 1}, \n                        {0, 1, 1, 1, 0}}; \n    \n    // Print the solution \n    hamCycle(graph1); \n    \n    /* Let us create the following graph \n        (0)--(1)--(2) \n        |     / \\   | \n        |    /      \\  | \n        | /      \\ | \n        (3)       (4) */\n    bool graph2[V][V] = {{0, 1, 0, 1, 0}, \n                         {1, 0, 1, 1, 1}, \n                         {0, 1, 0, 0, 1}, \n                         {1, 1, 0, 0, 0}, \n                         {0, 1, 1, 0, 0}}; \n\n    // Print the solution \n    hamCycle(graph2); \n\n    return 0; \n} \n\n// This is code is contributed by rathbhupendra\n#include <iostream>\nusing namespace std;\n\nint main() {\n\n    cout << \"GFG!\";\n    return 0;\n}\n/* C program for solution of Hamiltonian Cycle problem\n   using backtracking */\n#include<stdio.h>\n\n// Number of vertices in the graph\n#define V 5\n\nvoid printSolution(int path[]);\n\n/* A utility function to check if the vertex v can be added at\n   index 'pos' in the Hamiltonian Cycle constructed so far (stored\n   in 'path[]') */\nint isSafe(int v, int graph[V][V], int path[], int pos)\n{\n    /* Check if this vertex is an adjacent vertex of the previously\n       added vertex. */\n    if (graph [ path[pos-1] ][ v ] == 0)\n        return 0;\n\n    /* Check if the vertex has already been included.\n      This step can be optimized by creating an array of size V */\n    for (int i = 0; i < pos; i++)\n        if (path[i] == v)\n            return 0;\n\n    return 1;\n}\n\n/* A recursive utility function to solve hamiltonian cycle problem */\nint hamCycleUtil(int graph[V][V], int path[], int pos)\n{\n    /* base case: If all vertices are included in Hamiltonian Cycle */\n    if (pos == V)\n    {\n        // And if there is an edge from the last included vertex to the\n        // first vertex\n        if ( graph[ path[pos-1] ][ path[0] ] == 1 )\n           return 1;\n        else\n          return 0;\n    }\n\n    // Try different vertices as a next candidate in Hamiltonian Cycle.\n    // We don't try for 0 as we included 0 as starting point in hamCycle()\n    for (int v = 1; v < V; v++)\n    {\n        /* Check if this vertex can be added to Hamiltonian Cycle */\n        if (isSafe(v, graph, path, pos))\n        {\n            path[pos] = v;\n\n            /* recur to construct rest of the path */\n            if (hamCycleUtil (graph, path, pos+1) == 1)\n                return 1;\n\n            /* If adding vertex v doesn't lead to a solution,\n               then remove it */\n            path[pos] = -1;\n        }\n    }\n\n    /* If no vertex can be added to Hamiltonian Cycle constructed so far,\n       then return false */\n    return 0;\n}\n\n/* This function solves the Hamiltonian Cycle problem using Backtracking.\n  It mainly uses hamCycleUtil() to solve the problem. It returns false\n  if there is no Hamiltonian Cycle possible, otherwise return true and\n  prints the path. Please note that there may be more than one solutions,\n  this function prints one of the feasible solutions. */\nint hamCycle(int graph[V][V])\n{\n    int path[V];\n    for (int i = 0; i < V; i++)\n        path[i] = -1;\n\n    /* Let us put vertex 0 as the first vertex in the path. If there is\n       a Hamiltonian Cycle, then the path can be started from any point\n       of the cycle as the graph is undirected */\n    path[0] = 0;\n    if ( hamCycleUtil(graph, path, 1) == 0 )\n    {\n        printf(\"\\nSolution does not exist\");\n        return 0;\n    }\n\n    printSolution(path);\n    return 1;\n}\n\n/* A utility function to print solution */\nvoid printSolution(int path[])\n{\n    printf (\"Solution Exists:\"\n            \" Following is one Hamiltonian Cycle \\n\");\n    for (int i = 0; i < V; i++)\n        printf(\" %d \", path[i]);\n\n    // Let us print the first vertex again to show the complete cycle\n    printf(\" %d \", path[0]);\n    printf(\"\\n\");\n}\n\n// driver program to test above function\nint main()\n{\n   /* Let us create the following graph\n      (0)--(1)--(2)\n       |   / \\   |\n       |  /   \\  |\n       | /     \\ |\n      (3)-------(4)    */\n   int graph1[V][V] = {{0, 1, 0, 1, 0},\n                      {1, 0, 1, 1, 1},\n                      {0, 1, 0, 0, 1},\n                      {1, 1, 0, 0, 1},\n                      {0, 1, 1, 1, 0},\n                     };\n\n    // Print the solution\n    hamCycle(graph1);\n\n   /* Let us create the following graph\n      (0)--(1)--(2)\n       |   / \\   |\n       |  /   \\  |\n       | /     \\ |\n      (3)       (4)    */\n    int graph2[V][V] = {{0, 1, 0, 1, 0},\n                      {1, 0, 1, 1, 1},\n                      {0, 1, 0, 0, 1},\n                      {1, 1, 0, 0, 0},\n                      {0, 1, 1, 0, 0},\n                     };\n\n    // Print the solution\n    hamCycle(graph2);\n\n    return 0;\n}\n/* Java program for solution of Hamiltonian Cycle problem\n   using backtracking */\nclass HamiltonianCycle\n{\n    final int V = 5;\n    int path[];\n\n    /* A utility function to check if the vertex v can be\n       added at index 'pos'in the Hamiltonian Cycle\n       constructed so far (stored in 'path[]') */\n    boolean isSafe(int v, int graph[][], int path[], int pos)\n    {\n        /* Check if this vertex is an adjacent vertex of\n           the previously added vertex. */\n        if (graph[path[pos - 1]][v] == 0)\n            return false;\n\n        /* Check if the vertex has already been included.\n           This step can be optimized by creating an array\n           of size V */\n        for (int i = 0; i < pos; i++)\n            if (path[i] == v)\n                return false;\n\n        return true;\n    }\n\n    /* A recursive utility function to solve hamiltonian\n       cycle problem */\n    boolean hamCycleUtil(int graph[][], int path[], int pos)\n    {\n        /* base case: If all vertices are included in\n           Hamiltonian Cycle */\n        if (pos == V)\n        {\n            // And if there is an edge from the last included\n            // vertex to the first vertex\n            if (graph[path[pos - 1]][path[0]] == 1)\n                return true;\n            else\n                return false;\n        }\n\n        // Try different vertices as a next candidate in\n        // Hamiltonian Cycle. We don't try for 0 as we\n        // included 0 as starting point in hamCycle()\n        for (int v = 1; v < V; v++)\n        {\n            /* Check if this vertex can be added to Hamiltonian\n               Cycle */\n            if (isSafe(v, graph, path, pos))\n            {\n                path[pos] = v;\n\n                /* recur to construct rest of the path */\n                if (hamCycleUtil(graph, path, pos + 1) == true)\n                    return true;\n\n                /* If adding vertex v doesn't lead to a solution,\n                   then remove it */\n                path[pos] = -1;\n            }\n        }\n\n        /* If no vertex can be added to Hamiltonian Cycle\n           constructed so far, then return false */\n        return false;\n    }\n\n    /* This function solves the Hamiltonian Cycle problem using\n       Backtracking. It mainly uses hamCycleUtil() to solve the\n       problem. It returns false if there is no Hamiltonian Cycle\n       possible, otherwise return true and prints the path.\n       Please note that there may be more than one solutions,\n       this function prints one of the feasible solutions. */\n    int hamCycle(int graph[][])\n    {\n        path = new int[V];\n        for (int i = 0; i < V; i++)\n            path[i] = -1;\n\n        /* Let us put vertex 0 as the first vertex in the path.\n           If there is a Hamiltonian Cycle, then the path can be\n           started from any point of the cycle as the graph is\n           undirected */\n        path[0] = 0;\n        if (hamCycleUtil(graph, path, 1) == false)\n        {\n            System.out.println(\"\\nSolution does not exist\");\n            return 0;\n        }\n\n        printSolution(path);\n        return 1;\n    }\n\n    /* A utility function to print solution */\n    void printSolution(int path[])\n    {\n        System.out.println(\"Solution Exists: Following\" +\n                           \" is one Hamiltonian Cycle\");\n        for (int i = 0; i < V; i++)\n            System.out.print(\" \" + path[i] + \" \");\n\n        // Let us print the first vertex again to show the\n        // complete cycle\n        System.out.println(\" \" + path[0] + \" \");\n    }\n\n    // driver program to test above function\n    public static void main(String args[])\n    {\n        HamiltonianCycle hamiltonian =\n                                new HamiltonianCycle();\n        /* Let us create the following graph\n           (0)--(1)--(2)\n            |   / \\   |\n            |  /   \\  |\n            | /     \\ |\n           (3)-------(4)    */\n        int graph1[][] = {{0, 1, 0, 1, 0},\n            {1, 0, 1, 1, 1},\n            {0, 1, 0, 0, 1},\n            {1, 1, 0, 0, 1},\n            {0, 1, 1, 1, 0},\n        };\n\n        // Print the solution\n        hamiltonian.hamCycle(graph1);\n\n        /* Let us create the following graph\n           (0)--(1)--(2)\n            |   / \\   |\n            |  /   \\  |\n            | /     \\ |\n           (3)       (4)    */\n        int graph2[][] = {{0, 1, 0, 1, 0},\n            {1, 0, 1, 1, 1},\n            {0, 1, 0, 0, 1},\n            {1, 1, 0, 0, 0},\n            {0, 1, 1, 0, 0},\n        };\n\n        // Print the solution\n        hamiltonian.hamCycle(graph2);\n    }\n}\n// This code is contributed by Abhishek Shankhadhar\n# Python program for solution of \n# hamiltonian cycle problem \n\nclass Graph(): \n    def __init__(self, vertices): \n        self.graph = [[0 for column in range(vertices)]\n                            for row in range(vertices)] \n        self.V = vertices \n\n    ''' Check if this vertex is an adjacent vertex \n        of the previously added vertex and is not \n        included in the path earlier '''\n    def isSafe(self, v, pos, path): \n        # Check if current vertex and last vertex \n        # in path are adjacent \n        if self.graph[ path[pos-1] ][v] == 0: \n            return False\n\n        # Check if current vertex not already in path \n        for vertex in path: \n            if vertex == v: \n                return False\n\n        return True\n\n    # A recursive utility function to solve \n    # hamiltonian cycle problem \n    def hamCycleUtil(self, path, pos): \n\n        # base case: if all vertices are \n        # included in the path \n        if pos == self.V: \n            # Last vertex must be adjacent to the \n            # first vertex in path to make a cycle \n            if self.graph[ path[pos-1] ][ path[0] ] == 1: \n                return True\n            else: \n                return False\n\n        # Try different vertices as a next candidate \n        # in Hamiltonian Cycle. We don't try for 0 as \n        # we included 0 as starting point in hamCycle() \n        for v in range(1,self.V): \n\n            if self.isSafe(v, pos, path) == True: \n\n                path[pos] = v \n\n                if self.hamCycleUtil(path, pos+1) == True: \n                    return True\n\n                # Remove current vertex if it doesn't \n                # lead to a solution \n                path[pos] = -1\n\n        return False\n\n    def hamCycle(self): \n        path = [-1] * self.V \n\n        ''' Let us put vertex 0 as the first vertex \n            in the path. If there is a Hamiltonian Cycle, \n            then the path can be started from any point \n            of the cycle as the graph is undirected '''\n        path[0] = 0\n\n        if self.hamCycleUtil(path,1) == False: \n            print (\"Solution does not exist\\n\")\n            return False\n\n        self.printSolution(path) \n        return True\n\n    def printSolution(self, path): \n        print (\"Solution Exists: Following\",\n                 \"is one Hamiltonian Cycle\")\n        for vertex in path: \n           print (vertex )\n        \n\n# Driver Code \n\n''' Let us create the following graph \n    (0)--(1)--(2) \n    | / \\ | \n    | / \\ | \n    | /     \\ | \n    (3)-------(4) '''\ng1 = Graph(5) \ng1.graph = [ [0, 1, 0, 1, 0], [1, 0, 1, 1, 1], \n            [0, 1, 0, 0, 1,],[1, 1, 0, 0, 1], \n            [0, 1, 1, 1, 0], ] \n\n# Print the solution \ng1.hamCycle(); \n\n''' Let us create the following graph \n    (0)--(1)--(2) \n    | / \\ | \n    | / \\ | \n    | /     \\ | \n    (3)     (4) '''\ng2 = Graph(5) \ng2.graph = [ [0, 1, 0, 1, 0], [1, 0, 1, 1, 1], \n        [0, 1, 0, 0, 1,], [1, 1, 0, 0, 0], \n        [0, 1, 1, 0, 0], ] \n\n# Print the solution \ng2.hamCycle(); \n\n# This code is contributed by Divyanshu Mehta\n// C# program for solution of Hamiltonian \n// Cycle problem using backtracking\nusing System;\n\npublic class HamiltonianCycle\n{\n    readonly int V = 5;\n    int []path;\n\n    /* A utility function to check \n    if the vertex v can be added at \n    index 'pos'in the Hamiltonian Cycle\n    constructed so far (stored in 'path[]') */\n    bool isSafe(int v, int [,]graph,\n                int []path, int pos)\n    {\n        /* Check if this vertex is \n        an adjacent vertex of the\n        previously added vertex. */\n        if (graph[path[pos - 1], v] == 0)\n            return false;\n\n        /* Check if the vertex has already \n        been included. This step can be\n        optimized by creating an array\n        of size V */\n        for (int i = 0; i < pos; i++)\n            if (path[i] == v)\n                return false;\n\n        return true;\n    }\n\n    /* A recursive utility function\n    to solve hamiltonian cycle problem */\n    bool hamCycleUtil(int [,]graph, int []path, int pos)\n    {\n        /* base case: If all vertices \n        are included in Hamiltonian Cycle */\n        if (pos == V)\n        {\n            // And if there is an edge from the last included\n            // vertex to the first vertex\n            if (graph[path[pos - 1],path[0]] == 1)\n                return true;\n            else\n                return false;\n        }\n\n        // Try different vertices as a next candidate in\n        // Hamiltonian Cycle. We don't try for 0 as we\n        // included 0 as starting point in hamCycle()\n        for (int v = 1; v < V; v++)\n        {\n            /* Check if this vertex can be \n            added to Hamiltonian Cycle */\n            if (isSafe(v, graph, path, pos))\n            {\n                path[pos] = v;\n\n                /* recur to construct rest of the path */\n                if (hamCycleUtil(graph, path, pos + 1) == true)\n                    return true;\n\n                /* If adding vertex v doesn't \n                lead to a solution, then remove it */\n                path[pos] = -1;\n            }\n        }\n\n        /* If no vertex can be added to Hamiltonian Cycle\n        constructed so far, then return false */\n        return false;\n    }\n\n    /* This function solves the Hamiltonian \n    Cycle problem using Backtracking. It \n    mainly uses hamCycleUtil() to solve the\n    problem. It returns false if there\n    is no Hamiltonian Cycle possible, \n    otherwise return true and prints the path.\n    Please note that there may be more than \n    one solutions, this function prints one \n    of the feasible solutions. */\n    int hamCycle(int [,]graph)\n    {\n        path = new int[V];\n        for (int i = 0; i < V; i++)\n            path[i] = -1;\n\n        /* Let us put vertex 0 as the first\n        vertex in the path. If there is a \n        Hamiltonian Cycle, then the path can be\n        started from any point of the cycle \n        as the graph is undirected */\n        path[0] = 0;\n        if (hamCycleUtil(graph, path, 1) == false)\n        {\n            Console.WriteLine(\"\\nSolution does not exist\");\n            return 0;\n        }\n\n        printSolution(path);\n        return 1;\n    }\n\n    /* A utility function to print solution */\n    void printSolution(int []path)\n    {\n        Console.WriteLine(\"Solution Exists: Following\" +\n                        \" is one Hamiltonian Cycle\");\n        for (int i = 0; i < V; i++)\n            Console.Write(\" \" + path[i] + \" \");\n\n        // Let us print the first vertex again\n        //  to show the complete cycle\n        Console.WriteLine(\" \" + path[0] + \" \");\n    }\n\n    // Driver code\n    public static void Main(String []args)\n    {\n        HamiltonianCycle hamiltonian =\n                                new HamiltonianCycle();\n        /* Let us create the following graph\n        (0)--(1)--(2)\n            | / \\ |\n            | / \\ |\n            | /     \\ |\n        (3)-------(4) */\n        int [,]graph1= {{0, 1, 0, 1, 0},\n            {1, 0, 1, 1, 1},\n            {0, 1, 0, 0, 1},\n            {1, 1, 0, 0, 1},\n            {0, 1, 1, 1, 0},\n        };\n\n        // Print the solution\n        hamiltonian.hamCycle(graph1);\n\n        /* Let us create the following graph\n        (0)--(1)--(2)\n            | / \\ |\n            | / \\ |\n            | /     \\ |\n        (3)     (4) */\n        int [,]graph2 = {{0, 1, 0, 1, 0},\n            {1, 0, 1, 1, 1},\n            {0, 1, 0, 0, 1},\n            {1, 1, 0, 0, 0},\n            {0, 1, 1, 0, 0},\n        };\n\n        // Print the solution\n        hamiltonian.hamCycle(graph2);\n    }\n}\n\n// This code contributed by Rajput-Ji\n<script>\n      // JavaScript program for solution of Hamiltonian\n      // Cycle problem using backtracking\n\n      class HamiltonianCycle {\n        constructor() {\n          this.V = 5;\n          this.path = [];\n        }\n\n        /* A utility function to check\n    if the vertex v can be added at\n    index 'pos'in the Hamiltonian Cycle\n    constructed so far (stored in 'path[]') */\n        isSafe(v, graph, path, pos) {\n          /* Check if this vertex is\n        an adjacent vertex of the\n        previously added vertex. */\n          if (graph[path[pos - 1]][v] == 0) return false;\n\n          /* Check if the vertex has already\n        been included. This step can be\n        optimized by creating an array\n        of size V */\n          for (var i = 0; i < pos; i++) if (path[i] == v) return false;\n\n          return true;\n        }\n\n        /* A recursive utility function\n    to solve hamiltonian cycle problem */\n        hamCycleUtil(graph, path, pos) {\n          /* base case: If all vertices\n        are included in Hamiltonian Cycle */\n          if (pos == this.V) {\n            // And if there is an edge from the last included\n            // vertex to the first vertex\n            if (graph[path[pos - 1]][path[0]] == 1) return true;\n            else return false;\n          }\n\n          // Try different vertices as a next candidate in\n          // Hamiltonian Cycle. We don't try for 0 as we\n          // included 0 as starting point in hamCycle()\n          for (var v = 1; v < this.V; v++) {\n            /* Check if this vertex can be\n            added to Hamiltonian Cycle */\n            if (this.isSafe(v, graph, path, pos)) {\n              path[pos] = v;\n\n              /* recur to construct rest of the path */\n              if (this.hamCycleUtil(graph, path, pos + 1) == true) return true;\n\n              /* If adding vertex v doesn't\n                lead to a solution, then remove it */\n              path[pos] = -1;\n            }\n          }\n\n          /* If no vertex can be added to Hamiltonian Cycle\n        constructed so far, then return false */\n          return false;\n        }\n\n        /* This function solves the Hamiltonian\n    Cycle problem using Backtracking. It\n    mainly uses hamCycleUtil() to solve the\n    problem. It returns false if there\n    is no Hamiltonian Cycle possible,\n    otherwise return true and prints the path.\n    Please note that there may be more than\n    one solutions, this function prints one\n    of the feasible solutions. */\n        hamCycle(graph) {\n          this.path = new Array(this.V).fill(0);\n          for (var i = 0; i < this.V; i++) this.path[i] = -1;\n\n          /* Let us put vertex 0 as the first\n        vertex in the path. If there is a\n        Hamiltonian Cycle, then the path can be\n        started from any point of the cycle\n        as the graph is undirected */\n          this.path[0] = 0;\n          if (this.hamCycleUtil(graph, this.path, 1) == false) {\n            document.write(\"<br>Solution does not exist\");\n            return 0;\n          }\n\n          this.printSolution(this.path);\n          return 1;\n        }\n\n        /* A utility function to print solution */\n        printSolution(path) {\n          document.write(\n            \"Solution Exists: Following\" + \" is one Hamiltonian Cycle <br>\"\n          );\n          for (var i = 0; i < this.V; i++) document.write(\" \" + path[i] + \" \");\n\n          // Let us print the first vertex again\n          // to show the complete cycle\n          document.write(\" \" + path[0] + \" <br>\");\n        }\n      }\n      // Driver code\n      var hamiltonian = new HamiltonianCycle();\n      /* Let us create the following graph\n        (0)--(1)--(2)\n            | / \\ |\n            | / \\ |\n            | /     \\ |\n        (3)-------(4) */\n      var graph1 = [\n        [0, 1, 0, 1, 0],\n        [1, 0, 1, 1, 1],\n        [0, 1, 0, 0, 1],\n        [1, 1, 0, 0, 1],\n        [0, 1, 1, 1, 0],\n      ];\n\n      // Print the solution\n      hamiltonian.hamCycle(graph1);\n\n      /* Let us create the following graph\n        (0)--(1)--(2)\n            | / \\ |\n            | / \\ |\n            | /     \\ |\n        (3)     (4) */\n      var graph2 = [\n        [0, 1, 0, 1, 0],\n        [1, 0, 1, 1, 1],\n        [0, 1, 0, 0, 1],\n        [1, 1, 0, 0, 0],\n        [0, 1, 1, 0, 0],\n      ];\n\n      // Print the solution\n      hamiltonian.hamCycle(graph2);\n      \n      // This code is contributed by rdtank.\n    </script>\n<?php\n// PHP program for solution of \n// Hamiltonian Cycle problem\n// using backtracking \n$V = 5;\n\n/* A utility function to check if \nthe vertex v can be added at index 'pos'\nin the Hamiltonian Cycle constructed so far \n(stored in 'path[]') */\nfunction isSafe($v, $graph, &$path, $pos)\n{\n    /* Check if this vertex is \n    an adjacent vertex of the \n    previously added vertex. */\n    if ($graph[$path[$pos - 1]][$v] == 0)\n        return false;\n\n    /* Check if the vertex has already been included.\n    This step can be optimized by creating an array\n    of size V */\n    for ($i = 0; $i < $pos; $i++)\n        if ($path[$i] == $v)\n            return false;\n\n    return true;\n}\n\n/* A recursive utility function \nto solve hamiltonian cycle problem */\nfunction hamCycleUtil($graph, &$path, $pos)\n{\n    global $V;\n    \n    /* base case: If all vertices are included in\n    Hamiltonian Cycle */\n    if ($pos == $V)\n    {\n        // And if there is an edge from the \n        // last included vertex to the first vertex\n        if ($graph[$path[$pos - 1]][$path[0]] == 1)\n            return true;\n        else\n            return false;\n    }\n\n    // Try different vertices as a next candidate in\n    // Hamiltonian Cycle. We don't try for 0 as we\n    // included 0 as starting point hamCycle()\n    for ($v = 1; $v < $V; $v++)\n    {\n        /* Check if this vertex can be added \n        to Hamiltonian Cycle */\n        if (isSafe($v, $graph, $path, $pos))\n        {\n            $path[$pos] = $v;\n\n            /* recur to construct rest of the path */\n            if (hamCycleUtil($graph, $path, \n                                     $pos + 1) == true)\n                return true;\n\n            /* If adding vertex v doesn't lead to a solution,\n            then remove it */\n            $path[$pos] = -1;\n        }\n    }\n\n    /* If no vertex can be added to Hamiltonian Cycle\n    constructed so far, then return false */\n    return false;\n}\n\n/* This function solves the Hamiltonian Cycle problem using\nBacktracking. It mainly uses hamCycleUtil() to solve the\nproblem. It returns false if there is no Hamiltonian Cycle\npossible, otherwise return true and prints the path.\nPlease note that there may be more than one solutions,\nthis function prints one of the feasible solutions. */\nfunction hamCycle($graph)\n{\n    global $V;\n    $path = array_fill(0, $V, 0);\n    for ($i = 0; $i < $V; $i++)\n        $path[$i] = -1;\n\n    /* Let us put vertex 0 as the first vertex in the path.\n    If there is a Hamiltonian Cycle, then the path can be\n    started from any point of the cycle as the graph is\n    undirected */\n    $path[0] = 0;\n    if (hamCycleUtil($graph, $path, 1) == false)\n    {\n        echo(\"\\nSolution does not exist\");\n        return 0;\n    }\n\n    printSolution($path);\n    return 1;\n}\n\n/* A utility function to print solution */\nfunction printSolution($path)\n{\n    global $V;\n    echo(\"Solution Exists: Following is \".\n         \"one Hamiltonian Cycle\\n\");\n    for ($i = 0; $i < $V; $i++)\n        echo(\" \".$path[$i].\" \");\n\n    // Let us print the first vertex again to show the\n    // complete cycle\n    echo(\" \".$path[0].\" \\n\");\n}\n\n\n// Driver Code\n\n/* Let us create the following graph\n(0)--(1)--(2)\n    | / \\ |\n    | / \\ |\n    | / \\ |\n(3)-------(4) */\n$graph1 = array(array(0, 1, 0, 1, 0),\n    array(1, 0, 1, 1, 1),\n    array(0, 1, 0, 0, 1),\n    array(1, 1, 0, 0, 1),\n    array(0, 1, 1, 1, 0),\n);\n\n// Print the solution\nhamCycle($graph1);\n\n/* Let us create the following graph\n(0)--(1)--(2)\n    | / \\ |\n    | / \\ |\n    | / \\ |\n(3) (4) */\n$graph2 = array(array(0, 1, 0, 1, 0),\n                array(1, 0, 1, 1, 1),\n                array(0, 1, 0, 0, 1),\n                array(1, 1, 0, 0, 0),\n                array(0, 1, 1, 0, 0));\n\n// Print the solution\nhamCycle($graph2);\n\n// This code is contributed by mits\n?>\nSolution Exists: Following is one Hamiltonian Cycle \n0 1 2 4 3 0 \n\nSolution does not exist\n",
        "complexity": {
            "time": "Time Complexity : O(N!), where N is number of vertices.Auxiliary Space : O(1), since no extra space used.",
            "space": ""
        },
        "tags": [
            "Backtracking"
        ],
        "url": "https://www.geeksforgeeks.org/hamiltonian-cycle/"
    },
    {
        "title": "Introduction to Graph Coloring",
        "description": "Graph coloring refers to the problem of coloring vertices of a graph in such a way that no two adjacent vertices have the same color. This is also called the vertex coloring problem. If coloring is done using at most m colors, it is called m-coloring.  The minimum number of colors needed to color a graph is called its chromatic number. For example, the following can be colored a minimum of 2 colors. Example of Chromatic Number The problem of finding a chromatic number of a given graph is NP-complete. Graph coloring problem is both, a decision problem as well as an optimization problem. Assign colors one by one to different vertices, starting from vertex 0. Before assigning a color, check if the adjacent vertices have the same color or not. If there is any color assignment that does not violate the conditions, mark the color assignment as part of the solution. If no assignment of color is possible then backtrack and return false. Follow the given steps to solve the problem: Below is the implementation of the above approach: Related Articles:  ",
        "code": "// C++ program for solution of M\n// Coloring problem using backtracking\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Number of vertices in the graph\n#define V 4\n\nvoid printSolution(int color[]);\n\n/* A utility function to check if\n   the current color assignment\n   is safe for vertex v i.e. checks\n   whether the edge exists or not\n   (i.e, graph[v][i]==1). If exist\n   then checks whether the color to\n   be filled in the new vertex(c is\n   sent in the parameter) is already\n   used by its adjacent\n   vertices(i-->adj vertices) or\n   not (i.e, color[i]==c) */\nbool isSafe(int v, bool graph[V][V], int color[], int c)\n{\n    for (int i = 0; i < V; i++)\n        if (graph[v][i] && c == color[i])\n            return false;\n\n    return true;\n}\n\n/* A recursive utility function\nto solve m coloring problem */\nbool graphColoringUtil(bool graph[V][V], int m, int color[],\n                       int v)\n{\n\n    /* base case: If all vertices are\n       assigned a color then return true */\n    if (v == V)\n        return true;\n\n    /* Consider this vertex v and\n       try different colors */\n    for (int c = 1; c <= m; c++) {\n\n        /* Check if assignment of color\n           c to v is fine*/\n        if (isSafe(v, graph, color, c)) {\n            color[v] = c;\n\n            /* recur to assign colors to\n               rest of the vertices */\n            if (graphColoringUtil(graph, m, color, v + 1)\n                == true)\n                return true;\n\n            /* If assigning color c doesn't\n               lead to a solution then remove it */\n            color[v] = 0;\n        }\n    }\n\n    /* If no color can be assigned to\n       this vertex then return false */\n    return false;\n}\n\n/* This function solves the m Coloring\n   problem using Backtracking. It mainly\n   uses graphColoringUtil() to solve the\n   problem. It returns false if the m\n   colors cannot be assigned, otherwise\n   return true and prints assignments of\n   colors to all vertices. Please note\n   that there may be more than one solutions,\n   this function prints one of the\n   feasible solutions.*/\nbool graphColoring(bool graph[V][V], int m)\n{\n\n    // Initialize all color values as 0.\n    // This initialization is needed\n    // correct functioning of isSafe()\n    int color[V];\n    for (int i = 0; i < V; i++)\n        color[i] = 0;\n\n    // Call graphColoringUtil() for vertex 0\n    if (graphColoringUtil(graph, m, color, 0) == false) {\n        cout << \"Solution does not exist\";\n        return false;\n    }\n\n    // Print the solution\n    printSolution(color);\n    return true;\n}\n\n/* A utility function to print solution */\nvoid printSolution(int color[])\n{\n    cout << \"Solution Exists:\"\n         << \" Following are the assigned colors\"\n         << \"\\n\";\n    for (int i = 0; i < V; i++)\n        cout << \" \" << color[i] << \" \";\n\n    cout << \"\\n\";\n}\n\n// Driver code\nint main()\n{\n\n    /* Create following graph and test\n       whether it is 3 colorable\n      (3)---(2)\n       |   / |\n       |  /  |\n       | /   |\n      (0)---(1)\n    */\n    bool graph[V][V] = {\n        { 0, 1, 1, 1 },\n        { 1, 0, 1, 0 },\n        { 1, 1, 0, 1 },\n        { 1, 0, 1, 0 },\n    };\n\n    // Number of colors\n    int m = 3;\n\n    // Function call\n    graphColoring(graph, m);\n    return 0;\n}\n// Nikunj Sonigara\n\npublic class Main {\n\n    static final int V = 4;\n\n    // A utility function to check if the current color assignment is safe for vertex v\n    static boolean isSafe(int v, boolean[][] graph, int[] color, int c) {\n        for (int i = 0; i < V; i++)\n            if (graph[v][i] && c == color[i])\n                return false;\n        return true;\n    }\n\n    // A recursive utility function to solve m coloring problem\n    static boolean graphColoringUtil(boolean[][] graph, int m, int[] color, int v) {\n        if (v == V)\n            return true;\n\n        for (int c = 1; c <= m; c++) {\n            if (isSafe(v, graph, color, c)) {\n                color[v] = c;\n                if (graphColoringUtil(graph, m, color, v + 1))\n                    return true;\n                color[v] = 0;\n            }\n        }\n\n        return false;\n    }\n\n    // This function solves the m Coloring problem using Backtracking.\n    // It returns false if the m colors cannot be assigned, otherwise, return true\n    // and prints assignments of colors to all vertices.\n    static boolean graphColoring(boolean[][] graph, int m) {\n        int[] color = new int[V];\n        for (int i = 0; i < V; i++)\n            color[i] = 0;\n\n        if (!graphColoringUtil(graph, m, color, 0)) {\n            System.out.println(\"Solution does not exist\");\n            return false;\n        }\n\n        // Print the solution\n        printSolution(color);\n        return true;\n    }\n\n    // A utility function to print the solution\n    static void printSolution(int[] color) {\n        System.out.print(\"Solution Exists: Following are the assigned colors\\n\");\n        for (int i = 0; i < V; i++)\n            System.out.print(\" \" + color[i] + \" \");\n        System.out.println();\n    }\n\n    // Driver code\n    public static void main(String[] args) {\n        // Create following graph and test whether it is 3 colorable\n        // (3)---(2)\n        // |   / |\n        // |  /  |\n        // | /   |\n        // (0)---(1)\n\n        boolean[][] graph = {\n            { false, true, true, true },\n            { true, false, true, false },\n            { true, true, false, true },\n            { true, false, true, false }\n        };\n\n        // Number of colors\n        int m = 3;\n\n        // Function call\n        graphColoring(graph, m);\n    }\n}\nV = 4\n\ndef print_solution(color):\n    print(\"Solution Exists: Following are the assigned colors\")\n    print(\" \".join(map(str, color)))\n\ndef is_safe(v, graph, color, c):\n    # Check if the color 'c' is safe for the vertex 'v'\n    for i in range(V):\n        if graph[v][i] and c == color[i]:\n            return False\n    return True\n\ndef graph_coloring_util(graph, m, color, v):\n    # Base case: If all vertices are assigned a color, return true\n    if v == V:\n        return True\n\n    # Try different colors for the current vertex 'v'\n    for c in range(1, m + 1):\n        # Check if assignment of color 'c' to 'v' is fine\n        if is_safe(v, graph, color, c):\n            color[v] = c\n\n            # Recur to assign colors to the rest of the vertices\n            if graph_coloring_util(graph, m, color, v + 1):\n                return True\n\n            # If assigning color 'c' doesn't lead to a solution, remove it\n            color[v] = 0\n\n    # If no color can be assigned to this vertex, return false\n    return False\n\ndef graph_coloring(graph, m):\n    color = [0] * V\n\n    # Call graph_coloring_util() for vertex 0\n    if not graph_coloring_util(graph, m, color, 0):\n        print(\"Solution does not exist\")\n        return False\n\n    # Print the solution\n    print_solution(color)\n    return True\n\n# Driver code\nif __name__ == \"__main__\":\n    graph = [\n        [0, 1, 1, 1],\n        [1, 0, 1, 0],\n        [1, 1, 0, 1],\n        [1, 0, 1, 0],\n    ]\n\n    m = 3\n\n    # Function call\n    graph_coloring(graph, m)\n    \n    #This code is contrubting by Raja Ramakrishna\nusing System;\n\nclass GraphColoringProblem\n{\n    // Number of vertices in the graph\n    const int V = 4;\n\n    // A utility function to check if the current color assignment is safe for vertex v\n    static bool IsSafe(int v, bool[,] graph, int[] color, int c)\n    {\n        for (int i = 0; i < V; i++)\n        {\n            if (graph[v, i] && c == color[i])\n                return false;\n        }\n        return true;\n    }\n\n    // A recursive utility function to solve m coloring problem\n    static bool GraphColoringUtil(bool[,] graph, int m, int[] color, int v)\n    {\n        if (v == V)\n            return true;\n\n        for (int c = 1; c <= m; c++)\n        {\n            if (IsSafe(v, graph, color, c))\n            {\n                color[v] = c;\n\n                if (GraphColoringUtil(graph, m, color, v + 1))\n                    return true;\n\n                color[v] = 0;\n            }\n        }\n        return false;\n    }\n\n    // This function solves the m Coloring problem using Backtracking\n    static bool SolveGraphColoring(bool[,] graph, int m)\n    {\n        int[] color = new int[V];\n        for (int i = 0; i < V; i++)\n            color[i] = 0;\n\n        if (!GraphColoringUtil(graph, m, color, 0))\n        {\n            Console.WriteLine(\"Solution does not exist\");\n            return false;\n        }\n\n        PrintSolution(color);\n        return true;\n    }\n\n    // A utility function to print solution\n    static void PrintSolution(int[] color)\n    {\n        Console.WriteLine(\"Solution Exists: Following are the assigned colors\");\n        for (int i = 0; i < V; i++)\n            Console.Write(\" \" + color[i] + \" \");\n        Console.WriteLine();\n    }\n\n    // Driver code\n    static void Main(string[] args)\n    {\n        /* Create following graph and test whether it is 3 colorable\n           (3)---(2)\n            |   / |\n            |  /  |\n            | /   |\n           (0)---(1)\n        */\n        bool[,] graph = {\n            { false, true, true, true },\n            { true, false, true, false },\n            { true, true, false, true },\n            { true, false, true, false }\n        };\n\n        // Number of colors\n        int m = 3;\n\n        // Function call\n        SolveGraphColoring(graph, m);\n    }\n}\n\n\n// This code is contributed by shivamgupta310570\n// Equivalent JavaScript program for M Coloring problem using backtracking\n\n// Number of vertices in the graph\nconst V = 4;\n\n// Function to print the solution\nfunction printSolution(color) {\n    console.log(\"Solution Exists: Following are the assigned colors\");\n    for (let i = 0; i < V; i++) {\n        console.log(color[i] + \" \");\n    }\n    console.log(\"\\n\");\n}\n\n// Utility function to check if the current color assignment is safe for the vertex\nfunction isSafe(v, graph, color, c) {\n    for (let i = 0; i < V; i++) {\n        if (graph[v][i] && c == color[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n// Recursive utility function to solve the M coloring problem\nfunction graphColoringUtil(graph, m, color, v) {\n    // Base case: If all vertices are assigned a color, return true\n    if (v === V) {\n        return true;\n    }\n\n    // Consider the vertex v and try different colors\n    for (let c = 1; c <= m; c++) {\n        // Check if assignment of color c to v is fine\n        if (isSafe(v, graph, color, c)) {\n            color[v] = c;\n\n            // Recur to assign colors to the rest of the vertices\n            if (graphColoringUtil(graph, m, color, v + 1)) {\n                return true;\n            }\n\n            // If assigning color c doesn't lead to a solution, remove it\n            color[v] = 0;\n        }\n    }\n\n    // If no color can be assigned to this vertex, return false\n    return false;\n}\n\n// Function to solve the M Coloring problem using backtracking\nfunction graphColoring(graph, m) {\n    // Initialize all color values as 0\n    const color = new Array(V).fill(0);\n\n    // Call graphColoringUtil() for vertex 0\n    if (!graphColoringUtil(graph, m, color, 0)) {\n        console.log(\"Solution does not exist\");\n        return false;\n    }\n\n    // Print the solution\n    printSolution(color);\n    return true;\n}\n\n// Driver code\nconst graph = [\n    [0, 1, 1, 1],\n    [1, 0, 1, 0],\n    [1, 1, 0, 1],\n    [1, 0, 1, 0],\n];\n\nconst m = 3;\n\n// Function call\ngraphColoring(graph, m);\n\n// This code is contributed by shivamgupta310570\nSolution Exists: Following are the assigned colors\n 1  2  3  2\n",
        "complexity": {
            "time": "",
            "space": ""
        },
        "tags": [
            "Backtracking"
        ],
        "url": "https://www.geeksforgeeks.org/graph-coloring-applications/"
    },
    {
        "title": "DSA Tutorial - Learn Data Structures and Algorithms",
        "description": "DSA (Data Structures and Algorithms)  is the study of organizing data efficiently using data structures like arrays, stacks, and trees, paired with step-by-step procedures (or algorithms) to solve problems effectively. Data structures manage how data is stored and accessed, while algorithms focus on processing this data. Hoping you have learned a programming language of your choice, here comes the next stage of the roadmap - Learn about Time and Space Complexities. Once you have learned basics of a programming language, it is recommended that you learn basic logic building To analyze algorithms, we mainly measure order of growth of time or space taken in terms of input size.  We do this in the worst case scenario in most of the cases. Please refer the below links for a clear understanding of these concepts. Array is a linear data structure where elements are allocated contiguous memory, allowing for constant-time access. Searching algorithms are used to locate specific data within a large set of data. It helps find a target value within the data. There are various types of searching algorithms, each with its own approach and efficiency. Sorting algorithms are used to arrange the elements of a list in a specific order, such as numerical or alphabetical. It organizes the items in a systematic way, making it easier to search for and access specific elements. Hashing is a technique that generates a fixed-size output (hash value) from an input of variable size using mathematical formulas called hash functions. Hashing is commonly used in data structures for efficient searching, insertion and deletion. In Two Pointer Technique, we typically use two index variables from two corners of an array. We use the two pointer technique for searching a required point or value in an array. In Window Sliding Technique, we use the result of previous subarray to quickly compute the result of current. In Prefix Sum Technique, we compute prefix sums of an array to quickly find results for a subarray. String is a sequence of characters, typically immutable and have limited set of elements (lower case or all English alphabets). Recursion is a programming technique where a function calls itself within its own definition. It is usually used to solve problems that can be broken down into smaller instances of the same problem. Matrix is a two-dimensional array of elements, arranged in rows and columns. It is represented as a rectangular grid, with each element at the intersection of a row and column. Linked list is a linear data structure that stores data in nodes, which are connected by pointers. Unlike arrays, nodes of linked lists are not stored in contiguous memory locations and can only be accessed sequentially, starting from the head of list. Stack is a linear data structure that follows the Last In, First Out (LIFO) principle. Stacks play an important role in managing function calls, memory, and are widely used in algorithms like stock span problem, next greater element and largest area in a histogram. Queue is a linear data structure that follows the First In, First Out (FIFO) principle. Queues play an important role in managing tasks or data in order, scheduling and message handling systems. A deque (double-ended queue) is a data structure that allows elements to be added or removed from both ends efficiently. Tree is a non-linear, hierarchical data structure consisting of nodes connected by edges, with a top node called the root and nodes having child nodes. It is widely used in file systems, databases, decision-making algorithms, etc. Heap is a complete binary tree data structure that satisfies the heap property. Heaps are usually used to implement priority queues, where the smallest or largest element is always at the root of the tree. Graph is a non-linear data structure consisting of a finite set of vertices(or nodes) and a set of edges(or links)that connect a pair of nodes. Graphs are widely used to represent relationships between entities. Greedy Algorithm builds up the solution one piece at a time and chooses the next piece which gives the most obvious and immediate benefit i.e., which is the most optimal choice at that moment. So the problems where choosing locally optimal also leads to the global solutions are best fit for Greedy. Dynamic Programming is a method used to solve complex problems by breaking them down into simpler subproblems. By solving each subproblem only once and storing the results, it avoids redundant computations, leading to more efficient solutions for a wide range of problems. Bitwise Algorithms: Operate on individual bits of numbers. Backtracking Algorithm : Follow Recursion  with the option to revert and traces back if the solution from current point is not feasible. Divide and conquer:  A strategy to solve problems by dividing them into smaller subproblems, solving those subproblems, and combining the solutions to obtain the final solution. Branch and Bound : Used in combinatorial optimization problems to systematically search for the best solution. It works by dividing the problem into smaller subproblems, or branches, and then eliminating certain branches based on bounds on the optimal solution. This process continues until the best solution is found or all branches have been explored. Geometric algorithms are a set of algorithms that solve problems related to shapes, points, lines and polygons. Randomized algorithms are algorithms that use randomness to solve problems. They make use of random input to achieve their goals, often leading to simpler and more efficient solutions. These algorithms may not product same result but are particularly useful in situations when a probabilistic approach is acceptable. Advanced Data Structures like Trie, Segment Tree, Red-Black Tree and Binary Indexed Tree offer significant performance improvements for specific problem domains. They provide efficient solutions for tasks like fast prefix searches, range queries, dynamic updates, and maintaining balanced data structures, which are crucial for handling large datasets and real-time processing. By optimizing time complexity, they enable better scalability and faster execution in many computational problems. R  ",
        "code": "",
        "complexity": {
            "time": "Advanced Data Structures like Trie, Segment Tree, Red-Black Tree and Binary Indexed Tree offer significant performance improvements for specific problem domains. They provide efficient solutions for tasks like fast prefix searches, range queries, dynamic updates, and maintaining balanced data structures, which are crucial for handling large datasets and real-time processing. By optimizing time complexity, they enable better scalability and faster execution in many computational problems.",
            "space": ""
        },
        "tags": [
            "Dynamic Programming"
        ],
        "url": "https://www.geeksforgeeks.org/learn-data-structures-and-algorithms-dsa-tutorial/"
    },
    {
        "title": "Top 50 Dynamic Programming Coding Problems for Interviews",
        "description": "Here is the collection of the Top 50 list of frequently asked interview questions on Dynamic Programming. Problems in this Article are divided into three Levels so that readers can practice according to the difficulty level step by step.   ",
        "code": "",
        "complexity": {
            "time": "",
            "space": ""
        },
        "tags": [
            "Dynamic Programming"
        ],
        "url": "https://www.geeksforgeeks.org/top-50-dynamic-programming-coding-problems-for-interviews/"
    },
    {
        "title": "No Title",
        "description": "",
        "code": "",
        "complexity": {
            "time": "",
            "space": ""
        },
        "tags": [
            "Dynamic Programming"
        ],
        "url": "https://www.geeksforgeeks.org/explore?page=1&category=Dynamic+Programming&sortBy=submissions"
    },
    {
        "title": "Top MCQs on Dynamic Programming with Answers",
        "description": "Question 1 We use dynamic programming approach when We need an optimal solution The solution has optimal substructure The given problem can be reduced to the 3-SAT problem It\\'s faster than Greedy Question 2 An algorithm to find the length of the longest monotonically increasing sequence of numbers in an array A[0 :n-1] is given below. Let Li denote the length of the longest monotonically increasing sequence starting at index i in the array. Which of the following statements is TRUE? The algorithm uses dynamic programming paradigm The algorithm has a linear complexity and uses branch and bound paradigm The algorithm has a non-linear polynomial complexity and uses branch and bound paradigm The algorithm uses divide and conquer paradigm. Question 3 Which of the following is NOT a characteristic of dynamic programming? Memoization, which involves storing the results of expensive function calls and reusing them. Breaking a problem into smaller overlapping subproblems. Solving problems in a sequential manner. Dynamic programming can be used for problems where the solution has an optimal substructure. Question 4 What is the time complexity of Bellman-Ford single-source shortest path algorithm on a complete graph of n vertices? θ(n2) θ(n2 log n) θ(n3) θ(n3 log n) Question 5 Question 6 Let A1, A2, A3, and A4 be four matrices of dimensions 10 x 5, 5 x 20, 20 x 10, and 10 x 5, respectively. The minimum number of scalar multiplications required to find the product A1A2A3A4 using the basic matrix multiplication method is 1500 2000 500 100 Question 7 Consider a sequence F00 defined as :\r\n F00(0) = 1, F00(1) = 1\r\n F00(n) = 10 ∗ F00(n – 1) + 100\r\nF00(n – 2) for n ≥ 2\r\n Then what shall be the set of values of the sequence F00 ? Question 8 Question 9 Consider the weights and values of items listed below. Note that there is only one unit of each item. The task is to pick a subset of these items such that their total weight is no more than 11 Kgs and their total value is maximized. Moreover, no item may be split. The total value of items picked by an optimal algorithm is denoted by Vopt. A greedy algorithm sorts the items by their value-to-weight ratios in descending order and packs them greedily, starting from the first item in the ordered list. The total value of items picked by the greedy algorithm is denoted by Vgreedy. The value of Vopt − Vgreedy is ______ . 16 8 44 60 Question 10 Consider two strings A = \"qpqrr\" and B = \"pqprqrp\". Let x be the length of the longest common subsequence (not necessarily contiguous) between A and B and let y be the number of such longest common subsequences between A and B. Then x + 10y = ___. 33 23 43 34 There are 30 questions to complete. ",
        "code": "",
        "complexity": {
            "time": "What is the time complexity of Bellman-Ford single-source shortest path algorithm on a complete graph of n vertices?",
            "space": ""
        },
        "tags": [
            "Dynamic Programming"
        ],
        "url": "https://www.geeksforgeeks.org/quizzes/top-mcqs-on-dynamic-programming-with-answers/"
    },
    {
        "title": "Dynamic Programming (DP) Introduction",
        "description": "Dynamic Programming is a commonly used algorithmic technique used to optimize recursive solutions when same subproblems are called again. Dynamic programming is used for solving problems that consists of the following characteristics: The property Optimal substructure means that we use the optimal results of subproblems to achieve the optimal result of the bigger problem. Example: Consider the problem of finding the minimum cost path in a weighted graph from a source node to a destination node. We can break this problem down into smaller subproblems: The solution to the larger problem (finding the minimum cost path from the source node to the destination node) can be constructed from the solutions to these smaller subproblems. The same subproblems are solved repeatedly in different parts of the problem refer to Overlapping Subproblems Property in Dynamic Programming. Example: Consider the problem of computing the Fibonacci series. To compute the Fibonacci number at index n, we need to compute the Fibonacci numbers at indices n-1 and n-2. This means that the subproblem of computing the Fibonacci number at index n-2 is used twice (note that the call for n – 1 will make two calls, one for n-2 and other for n-3) in the solution to the larger problem of computing the Fibonacci number at index n. You may notice overlapping subproblems highlighted in the second recursion tree for Nth Fibonacci diagram shown below. Dynamic programming can be achieved using two approaches: In the top-down approach, also known as memoization, we keep the solution recursive and add a memoization table to avoid repeated calls of same subproblems. In the bottom-up approach, also known as tabulation, we start with the smallest subproblems and gradually build up to the final solution. Please refer Tabulation vs Memoization for the detailed differences. Example 1: Consider the problem of finding the Fibonacci sequence: Fibonacci sequence: 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, … Brute Force Approach:  To find the nth Fibonacci number using a brute force approach, you would simply add the (n-1)th and (n-2)th Fibonacci numbers. Below is the recursion tree of the above recursive solution. The time complexity of the above approach is exponential and upper bounded by O(2n) as we make two recursive calls in every function. Let’s us now see the above recursion tree with overlapping subproblems highlighted with same color. We can clearly see that that recursive solution is doing a lot work again and again which is causing the time complexity to be exponential. Imagine time taken for computing a large Fibonacci number. To achieve this in our example we simply take an memo array initialized to -1. As we make a recursive call, we first check if the value stored in the memo array corresponding to that position is -1. The value -1 indicates that we haven’t calculated it yet and have to recursively compute it. The output must be stored in the memo array so that, next time, if the same value is encountered, it can be directly used from the memo array. In this approach, we use an array of size (n + 1), often called dp[], to store Fibonacci numbers. The array is initialized with base values at the appropriate indices, such as dp[0] = 0 and dp[1] = 1. Then, we iteratively calculate Fibonacci values from dp[2] to dp[n] by using the relation dp[i] = dp[i-1] + dp[i-2]. This allows us to efficiently compute Fibonacci numbers in a loop. Finally, the value at dp[n] gives the Fibonacci number for the input n, as each index holds the answer for its corresponding Fibonacci number. In the above code, we can see that the current state of any fibonacci number depends only on the previous two values. So we do not need to store the whole table of size n+1 but instead of that we can only store the previous two values. Dynamic programming has a wide range of advantages, including: Dynamic programming has a wide range of applications, including:  ",
        "code": "// C++ program to find \n// fibonacci number using recursion.\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Function to find nth fibonacci number\nint fib(int n) {\n    if (n <= 1) {\n        return n;\n    }\n\n    return fib(n - 1) + fib(n - 2);\n}\n\nint main() {\n    int n = 5;\n    cout << fib(n);\n    return 0;\n}\n// C program to find \n// fibonacci number using recursion.\n#include <stdio.h>\n\n// Function to find nth fibonacci number\nint fib(int n) {\n    if (n <= 1) {\n        return n;\n    }\n    return fib(n - 1) + fib(n - 2);\n}\n\nint main() {\n    int n = 5;\n    printf(\"%d\", fib(n));\n    return 0;\n}\n// Java program to find \n// fibonacci number using recursion.\nclass GfG {\n  \n    // Function to find nth fibonacci number\n    static int fib(int n) {\n        if (n <= 1) {\n            return n;\n        }\n        return fib(n - 1) + fib(n - 2);\n    }\n\n    public static void main(String[] args) {\n        int n = 5;\n        System.out.println(fib(n));\n    }\n}\n# Python program to find \n# fibonacci number using recursion.\n\n# Function to find nth fibonacci number\ndef fib(n):\n    if n <= 1:\n        return n\n    return fib(n - 1) + fib(n - 2)\n\nif __name__ == \"__main__\":\n    n = 5\n    print(fib(n))\n// C# program to find \n// fibonacci number using recursion.\nusing System;\n\nclass GfG {\n  \n    // Function to find nth fibonacci number\n    static int fib(int n) {\n        if (n <= 1) {\n            return n;\n        }\n        return fib(n - 1) + fib(n - 2);\n    }\n\n    static void Main(string[] args) {\n        int n = 5;\n        Console.WriteLine(fib(n));\n    }\n}\n// JavaScript program to find \n// fibonacci number using recursion.\n\n// Function to find nth fibonacci number\nfunction fib(n) {\n    if (n <= 1) {\n        return n;\n    }\n    return fib(n - 1) + fib(n - 2);\n}\n\n//driver code\nlet n = 5;\nconsole.log(fib(n));\n5\n// C++ program to find\n// fibonacci number using memoization.\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nint fibRec(int n, vector<int> &memo) {\n  \n    // Base case\n    if (n <= 1) {\n        return n;\n    }\n\n    // To check if output already exists\n    if (memo[n] != -1) {\n        return memo[n];\n    }\n\n    // Calculate and save output for future use\n    memo[n] = fibRec(n - 1, memo) + fibRec(n - 2, memo);\n\n    return memo[n];\n}\n\nint fib(int n) {\n    vector<int> memo(n + 1, -1);\n    return fibRec(n, memo);\n}\n\nint main() {\n    int n = 5;\n    cout << fib(n);\n    return 0;\n}\n// Java program to find\n// fibonacci number using memoization.\nimport java.util.Arrays;\n\nclass GfG {\n\n    static int fibRec(int n, int[] memo) {\n\n        // Base case\n        if (n <= 1) {\n            return n;\n        }\n\n        // To check if output already exists\n        if (memo[n] != -1) {\n            return memo[n];\n        }\n\n        // Calculate and save output for future use\n        memo[n] = fibRec(n - 1, memo) + fibRec(n - 2, memo);\n\n        return memo[n];\n    }\n\n    static int fib(int n) {\n        int[] memo = new int[n + 1];\n        Arrays.fill(memo, -1);\n        return fibRec(n, memo);\n    }\n\n    public static void main(String[] args) {\n        int n = 5;\n        System.out.println(fib(n));\n    }\n}\n# Python program to find\n# fibonacci number using memoization.\ndef fibRec(n, memo):\n  \n    # Base case\n    if n <= 1:\n        return n\n\n    # To check if output already exists\n    if memo[n] != -1:\n        return memo[n]\n\n    # Calculate and save output for future use\n    memo[n] = fibRec(n - 1, memo) + \\\n              fibRec(n - 2, memo)\n    return memo[n]\n\ndef fib(n):\n    memo = [-1] * (n + 1)\n    return fibRec(n, memo)\n\nn = 5\nprint(fib(n))\n// C# program to find\n// fibonacci number using memoization.\nusing System;\nusing System.Collections.Generic;\n\nclass GfG {\n  \n    // Recursive function with memoization\n    static int FibRec(int n, List<int> memo) {\n      \n        // Base case\n        if (n <= 1)\n        {\n            return n;\n        }\n\n        // To check if output already exists\n        if (memo[n] != -1) {\n            return memo[n];\n        }\n\n        // Calculate and save output for future use\n        memo[n] = FibRec(n - 1, memo) + FibRec(n - 2, memo);\n\n        return memo[n];\n    }\n\n    // Wrapper function to initiate the \n  \t// memoization process\n    static int Fib(int n) {\n      \n        // Initialize the memoization array with -1\n        List<int> memo = new List<int>(new int[n + 1]);\n        for (int i = 0; i <= n; i++) {\n            memo[i] = -1;\n        }\n        return FibRec(n, memo);\n    }\n\n    static void Main() {\n        int n = 5;\n        Console.WriteLine(Fib(n)); \n    }\n}\n// Javascript program to find\n// fibonacci number using memoization.\nfunction fibRec(n, memo) {\n\n    // Base case\n    if (n <= 1) {\n        return n;\n    }\n\n    // To check if output already exists\n    if (memo[n] !== -1) {\n        return memo[n];\n    }\n\n    // Calculate and save output for future use\n    memo[n] = fibRec(n - 1, memo) + \n              fibRec(n - 2, memo);\n\n    // Returning the final output\n    return memo[n];\n}\n\nfunction fib(n) {\n\n    // Initialize array with -1\n    const memo = new Array(n + 1).fill(-1);\n\n    // Call helper function\n    return fibRec(n, memo);\n}\n\n// Driver code\nconst n = 5;\nconsole.log(fib(n));\n5\n// C++ program to find\n// fibonacci number using tabulation.\n#include <iostream>\n#include <vector>\nusing namespace std;\n\n// Function for calculating the nth Fibonacci number\nint fibo(int n) {\n    vector<int> dp(n + 1);\n\n    // Storing the independent values in dp\n    dp[0] = 0;\n    dp[1] = 1;\n\n    // Using the bottom-up approach\n    for (int i = 2; i <= n; i++) {\n        dp[i] = dp[i - 1] + dp[i - 2];\n    }\n  \n    return dp[n];\n}\n\nint main() {\n    int n = 5;\n    cout << fibo(n);\n    return 0;\n}\n// C program to find\n// fibonacci number using tabulation.\n#include <stdio.h>\n\n// Function for calculating the nth Fibonacci number\nint fibo(int n) {\n    int dp[n + 1];\n\n    // Storing the independent values in dp\n    dp[0] = 0;\n    dp[1] = 1;\n\n    // Using the bottom-up approach\n    for (int i = 2; i <= n; i++) {\n        dp[i] = dp[i - 1] + dp[i - 2];\n    }\n  \n    return dp[n];\n}\n\nint main() {\n    int n = 5;\n    printf(\"%d\", fibo(n));\n    return 0;\n}\n// Java program to find\n// fibonacci number using tabulation.\nimport java.util.Arrays;\n\n// Function for calculating the nth Fibonacci number\nclass GfG {\n    static int fibo(int n) {\n        int[] dp = new int[n + 1];\n\n        // Storing the independent values in dp\n        dp[0] = 0;\n        dp[1] = 1;\n\n        // Using the bottom-up approach\n        for (int i = 2; i <= n; i++) {\n            dp[i] = dp[i - 1] + dp[i - 2];\n        }\n\n        return dp[n];\n    }\n\n    public static void main(String[] args) {\n        int n = 5;\n        System.out.println(fibo(n));\n    }\n}\n# Python program to find\n# fibonacci number using tabulation.\ndef fibo(n):\n    dp = [0] * (n + 1)\n\n    # Storing the independent values in dp\n    dp[0] = 0\n    dp[1] = 1\n\n    # Using the bottom-up approach\n    for i in range(2, n + 1):\n        dp[i] = dp[i - 1] + dp[i - 2]\n    \n    return dp[n]\n\nn = 5\nprint(fibo(n))\n// C# program to find\n// fibonacci number using tabulation.\nusing System;\n\nclass GfG {\n    static int Fibo(int n) {\n        int[] dp = new int[n + 1];\n\n        // Storing the independent values in dp\n        dp[0] = 0;\n        dp[1] = 1;\n\n        // Using the bottom-up approach\n        for (int i = 2; i <= n; i++) {\n            dp[i] = dp[i - 1] + dp[i - 2];\n        }\n        \n        return dp[n];\n    }\n\n    static void Main() {\n        int n = 5;\n        Console.WriteLine(Fibo(n));\n    }\n}\n// JavaScript program to find\n// fibonacci number using tabulation.\n\nfunction fibo(n) {\n    let dp = new Array(n + 1);\n\n    // Storing the independent values in dp\n    dp[0] = 0;\n    dp[1] = 1;\n\n    // Using the bottom-up approach\n    for (let i = 2; i <= n; i++) {\n        dp[i] = dp[i - 1] + dp[i - 2];\n    }\n    \n    return dp[n];\n}\n\n//driver code\nlet n = 5;\nconsole.log(fibo(n));\n5\n// C++ program to find\n// fibonacci number using space optimised.\n#include <iostream>\nusing namespace std;\n\nint fibo(int n) {\n  \n    int prevPrev, prev, curr;\n\n    // Storing the independent values\n    prevPrev = 0;\n    prev = 1;\n    curr = 1;\n\n    // Using the bottom-up approach\n    for (int i = 2; i <= n; i++) {\n        curr = prev + prevPrev;\n        prevPrev = prev;\n        prev = curr;\n    }\n\n    return curr;\n}\n\nint main() {\n    int n = 5;\n    cout << fibo(n);\n    return 0;\n}\n// C program to find\n// fibonacci number using space optimised.\n#include <stdio.h>\n\nint fibo(int n) {\n    int prevPrev, prev, curr;\n\n    // Storing the independent values\n    prevPrev = 0;\n    prev = 1;\n    curr = 1;\n\n    // Using the bottom-up approach\n    for (int i = 2; i <= n; i++) {\n        curr = prev + prevPrev;\n        prevPrev = prev;\n        prev = curr;\n    }\n\n    return curr;\n}\n\nint main() {\n    int n = 5;\n    printf(\"%d\", fibo(n));\n    return 0;\n}\n// Java program to find\n// fibonacci number using space optimised.\nclass GfG {\n    static int fibo(int n) {\n        int prevPrev, prev, curr;\n\n        // Storing the independent values\n        prevPrev = 0;\n        prev = 1;\n        curr = 1;\n\n        // Using the bottom-up approach\n        for (int i = 2; i <= n; i++) {\n            curr = prev + prevPrev;\n            prevPrev = prev;\n            prev = curr;\n        }\n\n        return curr;\n    }\n\n    public static void main(String[] args) {\n        int n = 5;\n        System.out.println(fibo(n));\n    }\n}\n# Python program to find\n# fibonacci number using space optimised.\ndef fibo(n):\n    prevPrev, prev, curr = 0, 1, 1\n\n    # Using the bottom-up approach\n    for i in range(2, n + 1):\n        curr = prev + prevPrev\n        prevPrev = prev\n        prev = curr\n\n    return curr\n\nn = 5\nprint(fibo(n))\n// C# program to find\n// fibonacci number using space optimised.\nusing System;\n\nclass GfG {\n    static int Fibo(int n) {\n        int prevPrev = 0, prev = 1, curr = 1;\n\n        // Using the bottom-up approach\n        for (int i = 2; i <= n; i++) {\n            curr = prev + prevPrev;\n            prevPrev = prev;\n            prev = curr;\n        }\n\n        return curr;\n    }\n\n    static void Main() {\n        int n = 5;\n        Console.WriteLine(Fibo(n));\n    }\n}\n// Javascript program to find\n// fibonacci number using space optimised.\nfunction fibo(n) {\n    let prevPrev = 0, prev = 1, curr = 1;\n\n    // Using the bottom-up approach\n    for (let i = 2; i <= n; i++) {\n        curr = prev + prevPrev;\n        prevPrev = prev;\n        prev = curr;\n    }\n\n    return curr;\n}\n\nlet n = 5;\nconsole.log(fibo(n));\n5\n",
        "complexity": {
            "time": "Let’s us now see the above recursion tree with overlapping subproblems highlighted with same color. We can clearly see that that recursive solution is doing a lot work again and again which is causing the time complexity to be exponential. Imagine time taken for computing a large Fibonacci number.",
            "space": ""
        },
        "tags": [
            "Dynamic Programming"
        ],
        "url": "https://www.geeksforgeeks.org/introduction-to-dynamic-programming-data-structures-and-algorithm-tutorials/"
    },
    {
        "title": "Optimal Substructure Property in Dynamic Programming | DP-2",
        "description": "The following are the two main properties of a problem that suggest that the given problem can be solved using Dynamic programming: 1) Overlapping Subproblems 2) Optimal Substructure We have already discussed the Overlapping Subproblem property. Let us discuss the Optimal Substructure property here. In Dynamic  programming, the ideal base property alludes to the way that an ideal answer for an issue can be built from ideal answers for subproblems. This property is utilized to plan dynamic programming calculations that tackle streamlining issues by separating them into more modest subproblems and afterward consolidating the answers for those subproblems to get an answer for the first issue.For instance, think about the issue of tracking down the most brief way between two focuses in a diagram. On the off chance that we apply dynamic programming to this issue, we can characterize the subproblems as the briefest ways between halfway focuses on the chart, and afterward utilize the answers for those subproblems to build an answer for the first issue.To show this thought all the more officially, we should assume we disapprove of an ideal arrangement S* and a bunch of subproblems S1, S2, …, Sn. On the off chance that the ideal answer for the issue can be developed from the ideal answers for the subproblems, then the issue displays the ideal base property. Optimal Substructure: A given problem is said to have Optimal Substructure Property if the optimal solution of the given problem can be obtained by using the optimal solution to its subproblems instead of trying every possible way to solve the subproblems. Example: The Shortest Path problem has the following optimal substructure property: If node x lies in the shortest path from a source node U to destination node V then the shortest path from U to V is a combination of the shortest path from U to X and the shortest path from X to V. The standard All Pair Shortest Path algorithm like Floyd–Warshall and Single Source Shortest path algorithm for negative weight edges like Bellman–Ford are typical examples of Dynamic Programming. On the other hand, the Longest Path problem doesn’t have the Optimal Substructure property. Here by Longest Path, we mean the longest simple path (path without cycle) between two nodes. Consider the following unweighted graph given in the CLRS book. There are two longest paths from q to t: q?r?t and q?s?t. Unlike shortest paths, these longest paths do not have the optimal substructure property. For example, The longest path q?r?t is not a combination of the longest path from q to r and the longest path from r to t, because the longest path from q to r is q?s?t?r and the longest path from r to t is r?q?s?t.  S. No. Article Practice Problem 1 Longest Common Subsequence solve 2 Count ways to reach the n’th stair solve 3 Coin Change solve 4 Edit Distance | DP-5 – GeeksforGeeks solve 5 Cutting a Rod solve 6 Program for Fibonacci numbers – GeeksforGeeks solve The above problems can be solved optimally using Dynamic programming as each of these problems have an optimal substructure, On the other hand, there are some problems that need to be solved by trying all possible solutions one such problem is Rat in a Maze problem. In these types of problems, the optimal solution for subproblems may not surely give the solution to the entire problem. In Rat in a Maze problem, all paths need to be explored to find out the final path from the source that leads to the destination. Thus in these problems, Recursion and Backtracking are the way to go.  ",
        "code": "",
        "complexity": {
            "time": "",
            "space": ""
        },
        "tags": [
            "Dynamic Programming"
        ],
        "url": "https://www.geeksforgeeks.org/optimal-substructure-property-in-dynamic-programming-dp-2/"
    },
    {
        "title": "Overlapping Subproblems Property in Dynamic Programming | DP-1",
        "description": "Dynamic Programming is an algorithmic paradigm that solves a given complex problem by breaking it into subproblems using recursion and storing the results of subproblems to avoid computing the same results again. Following are the two main properties of a problem that suggests that the given problem can be solved using Dynamic programming. In this post, we will discuss the first property Overlapping Subproblems in detail. The second property of Dynamic programming is discussed in the next post. Like Divide and Conquer, Dynamic Programming combines solutions to sub-problems. Dynamic Programming is mainly used when solutions to the same subproblems are needed again and again. In dynamic programming, computed solutions to subproblems are stored in a table so that these don’t have to be recomputed. So Dynamic Programming is not useful when there are no common (overlapping) subproblems because there is no point in storing the solutions if they are not needed again. For example, Binary Search doesn’t have common subproblems. If we take the example of following a recursive program for Fibonacci Numbers, there are many subproblems that are solved again and again. Time Complexity: O(2N)  Auxiliary Space: O(1) Recursion tree for the execution of fib(5) We can see that the function fib(3) is being called 2 times. If we would have stored the value of fib(3), then instead of computing it again, we could have reused the old stored value. There are following two different ways to store the values so that these values can be reused: The memoized program for a problem is similar to the recursive version with a small modification that looks into a lookup table before computing solutions. We initialize a lookup array with all initial values as NIL. Whenever we need the solution to a subproblem, we first look into the lookup table. If the precomputed value is there then we return that value, otherwise, we calculate the value and put the result in the lookup table so that it can be reused later. Following is the memoized version for the nth Fibonacci Number. Time Complexity: O(N). This is because the algorithm computes each Fibonacci number only once and stores the result in an array for future use. Subsequent calls to the function with the same input value of n will retrieve the stored value from the lookup table, avoiding the need to recompute it. Therefore, the time complexity is linear, and the algorithm is very efficient for large values of n. Space Complexity: O(N) as lookup table has been created. The tabulated program for a given problem builds a table in a bottom-up fashion and returns the last entry from the table. For example, for the same Fibonacci number, we first calculate fib(0) then fib(1) then fib(2) then fib(3), and so on. So literally, we are building the solutions to subproblems bottom-up. Following is the tabulated version for the nth Fibonacci Number. Time Complexity: O(N)Auxiliary Space: O(N)  ",
        "code": "#include <iostream>\nusing namespace std;\n\n/* a simple recursive program for Fibonacci numbers */\nint fib(int n)\n{\n    if (n <= 1)\n        return n;\n \n    return fib(n - 1) + fib(n - 2);\n}\n\nint main() {\n    \n    cout << fib(7);\n    \n    return 0;\n}\n\n// This code is contributed by sanjoy_62.\n/* a simple recursive program for Fibonacci numbers */\nint fib(int n)\n{\n    if (n <= 1)\n        return n;\n\n    return fib(n - 1) + fib(n - 2);\n}\n/*package whatever //do not write package name here */\n/* a simple recursive program for Fibonacci numbers */\nstatic int fib(int n)\n{\n    if (n <= 1)\n        return n;\n\n    return fib(n - 1) + fib(n - 2);\n}\n\n// This code is contributed by umadevi9616\n#  a simple recursive program for Fibonacci numbers\ndef fib(n):\n    if n <= 1:\n        return n\n\n    return fib(n - 1) + fib(n - 2)\n/* a simple recursive program for Fibonacci numbers */\nstatic int fib(int n)\n{\n    if (n <= 1)\n        return n;\n\n    return fib(n - 1) + fib(n - 2);\n}\n\n\n// This code contributed by umadevi9616\n<script>\n/*package whatever //do not write package name here */\n/* a simple recursive program for Fibonacci numbers */\nfunction fib(n)\n{\n    if (n <= 1)\n        return n;\n\n    return fib(n - 1) + fib(n - 2);\n}\n\n// This code is contributed by gauravrajput1 \n</script>\n13\n/* C++ program for Memoized version\nfor nth Fibonacci number */\n#include <bits/stdc++.h>\nusing namespace std;\n#define NIL -1\n#define MAX 100\n\nint lookup[MAX];\n\n/* Function to initialize NIL\nvalues in lookup table */\nvoid _initialize()\n{\n    int i;\n    for (i = 0; i < MAX; i++)\n        lookup[i] = NIL;\n}\n\n/* function for nth Fibonacci number */\nint fib(int n)\n{\n    if (lookup[n] == NIL) {\n        if (n <= 1)\n            lookup[n] = n;\n        else\n            lookup[n] = fib(n - 1) + fib(n - 2);\n    }\n\n    return lookup[n];\n}\n\n// Driver code\nint main()\n{\n    int n = 40;\n    _initialize();\n    cout << \"Fibonacci number is \" << fib(n);\n    return 0;\n}\n\n// This is code is contributed by rathbhupendra\n/* C program for Memoized version for nth Fibonacci number\n */\n#include <stdio.h>\n#define NIL -1\n#define MAX 100\n\nint lookup[MAX];\n\n/* Function to initialize NIL values in lookup table */\nvoid _initialize()\n{\n    int i;\n    for (i = 0; i < MAX; i++)\n        lookup[i] = NIL;\n}\n\n/* function for nth Fibonacci number */\nint fib(int n)\n{\n    if (lookup[n] == NIL) {\n        if (n <= 1)\n            lookup[n] = n;\n        else\n            lookup[n] = fib(n - 1) + fib(n - 2);\n    }\n\n    return lookup[n];\n}\n\nint main()\n{\n    int n = 40;\n    _initialize();\n    printf(\"Fibonacci number is %d \", fib(n));\n    return 0;\n}\n/* Java program for Memoized version */\npublic class Fibonacci {\n    final int MAX = 100;\n    final int NIL = -1;\n\n    int lookup[] = new int[MAX];\n\n    /* Function to initialize NIL values in lookup table */\n    void _initialize()\n    {\n        for (int i = 0; i < MAX; i++)\n            lookup[i] = NIL;\n    }\n\n    /* function for nth Fibonacci number */\n    int fib(int n)\n    {\n        if (lookup[n] == NIL) {\n            if (n <= 1)\n                lookup[n] = n;\n            else\n                lookup[n] = fib(n - 1) + fib(n - 2);\n        }\n        return lookup[n];\n    }\n\n    public static void main(String[] args)\n    {\n        Fibonacci f = new Fibonacci();\n        int n = 40;\n        f._initialize();\n        System.out.println(\"Fibonacci number is\"\n                           + \" \" + f.fib(n));\n    }\n}\n// This Code is Contributed by Saket Kumar\n# a program for Memoized version of nth Fibonacci number\n\n# function to calculate nth Fibonacci number\n\n\ndef fib(n, lookup):\n\n    # base case\n    if n <= 1:\n        lookup[n] = n\n\n    # if the value is not calculated previously then calculate it\n    if lookup[n] is None:\n        lookup[n] = fib(n-1, lookup) + fib(n-2, lookup)\n\n    # return the value corresponding to that value of n\n    return lookup[n]\n# end of function\n\n# Driver program to test the above function\n\n\ndef main():\n    n = 34\n    # Declaration of lookup table\n    # Handles till n = 100\n    lookup = [None] * 101\n    print \"Fibonacci Number is \", fib(n, lookup)\n\n\nif __name__ == \"__main__\":\n    main()\n\n# This code is contributed by Nikhil Kumar Singh(nickzuck_007)\n// C# program for Memoized versionof nth Fibonacci number\nusing System;\n\nclass GFG {\n\n    static int MAX = 100;\n    static int NIL = -1;\n    static int[] lookup = new int[MAX];\n\n    /* Function to initialize NIL\n    values in lookup table */\n    static void initialize()\n    {\n        for (int i = 0; i < MAX; i++)\n            lookup[i] = NIL;\n    }\n\n    /* function for nth Fibonacci number */\n    static int fib(int n)\n    {\n        if (lookup[n] == NIL) {\n            if (n <= 1)\n                lookup[n] = n;\n            else\n                lookup[n] = fib(n - 1) + fib(n - 2);\n        }\n        return lookup[n];\n    }\n\n    // Driver code\n    public static void Main()\n    {\n\n        int n = 40;\n        initialize();\n        Console.Write(\"Fibonacci number is\"\n                      + \" \" + fib(n));\n    }\n}\n\n// This Code is Contributed by Sam007\n<script>\n\nlet  MAX = 100;\nlet NIL = -1;\n\nlet lookup = new Array(MAX);\n\nfunction  _initialize()\n{\n    for (let i = 0; i < MAX; i++)\n        lookup[i] = NIL;\n}\n\nfunction fib(n)\n{\n    if (lookup[n] == NIL)\n    {\n      if (n <= 1)\n          lookup[n] = n;\n      else\n          lookup[n] = fib(n-1) + fib(n-2);\n    }\n    return lookup[n];\n}\n\n\nlet n = 40;\n_initialize();\ndocument.write(\"Fibonacci number is\" + \" \" + fib(n)+\"<br>\");\n\n// This code is contributed by avanitrachhadiya2155\n</script>\nFibonacci number is 102334155\n/* C++ program for Tabulated version */\n\n#include <iostream>\nusing namespace std;\n\nint fib(int n)\n{\n    int f[n + 1];\n    int i;\n    f[0] = 0;\n    f[1] = 1;\n    for (i = 2; i <= n; i++)\n        f[i] = f[i - 1] + f[i - 2];\n\n    return f[n];\n}\n\nint main()\n{\n    int n = 9;\n    printf(\"Fibonacci number is %d \", fib(n));\n    return 0;\n}\n/* C program for Tabulated version */\n#include <stdio.h>\nint fib(int n)\n{\n    int f[n + 1];\n    int i;\n    f[0] = 0;\n    f[1] = 1;\n    for (i = 2; i <= n; i++)\n        f[i] = f[i - 1] + f[i - 2];\n\n    return f[n];\n}\n\nint main()\n{\n    int n = 9;\n    printf(\"Fibonacci number is %d \", fib(n));\n    return 0;\n}\n/* Java program for Tabulated version */\npublic class Fibonacci {\n    int fib(int n)\n    {\n        int f[] = new int[n + 1];\n        f[0] = 0;\n        f[1] = 1;\n        for (int i = 2; i <= n; i++)\n            f[i] = f[i - 1] + f[i - 2];\n        return f[n];\n    }\n\n    public static void main(String[] args)\n    {\n        Fibonacci f = new Fibonacci();\n        int n = 9;\n        System.out.println(\"Fibonacci number is\"\n                           + \" \" + f.fib(n));\n    }\n}\n// This Code is Contributed by Saket Kumar\n# Python program Tabulated (bottom up) version\ndef fib(n):\n\n    # array declaration\n    f = [0] * (n + 1)\n\n    # base case assignment\n    f[1] = 1\n\n    # calculating the fibonacci and storing the values\n    for i in xrange(2, n + 1):\n        f[i] = f[i - 1] + f[i - 2]\n    return f[n]\n\n# Driver program to test the above function\n\n\ndef main():\n    n = 9\n    print \"Fibonacci number is \", fib(n)\n\n\nif __name__ == \"__main__\":\n    main()\n\n# This code is contributed by Nikhil Kumar Singh (nickzuck_007)\n// C# program for Tabulated version\nusing System;\n\nclass GFG {\n    static int fib(int n)\n    {\n        int[] f = new int[n + 1];\n        f[0] = 0;\n        f[1] = 1;\n        for (int i = 2; i <= n; i++)\n            f[i] = f[i - 1] + f[i - 2];\n        return f[n];\n    }\n\n    public static void Main()\n    {\n\n        int n = 9;\n        Console.Write(\"Fibonacci number is\"\n                      + \" \" + fib(n));\n    }\n}\n\n// This Code is Contributed by Sam007\n<script>\n\n// Javascript program for Tabulated version\nfunction fib(n)\n{\n    var f = new Array(n + 1);\n    var i;\n    \n    f[0] = 0; \n    f[1] = 1;\n    for(i = 2; i <= n; i++)\n        f[i] = f[i - 1] + f[i - 2];\n    \n    return f[n];\n}\n\n// Driver code\nvar n = 9;\ndocument.write(\"Fibonacci number is  \" + fib(n));\n\n// This code is contributed by akshitsaxenaa09\n\n</script>\n<?php\n// PHP program for Tabulated version\n\nfunction fib($n)\n{\n    $f[$n + 1]=0;\n    $i;\n    $f[0] = 0;\n    $f[1] = 1; \n    for ($i = 2; $i <= $n; $i++)\n        $f[$i] = $f[$i - 1] + \n                 $f[$i - 2];\n    \n    return $f[$n];\n}\n\n// Driver Code\n$n = 9;\necho(\"Fibonacci number is \"); \necho(fib($n));\n\n// This code is contributed by nitin mittal.\n?>\nFibonacci number is 34\n",
        "complexity": {
            "time": "Time Complexity: O(N)Auxiliary Space: O(N)",
            "space": "Space Complexity: O(N) as lookup table has been created."
        },
        "tags": [
            "Dynamic Programming"
        ],
        "url": "https://www.geeksforgeeks.org/overlapping-subproblems-property-in-dynamic-programming-dp-1/"
    },
    {
        "title": "What is Memoization? A Complete Tutorial",
        "description": "In this tutorial, we will dive into memoization, a powerful optimization technique that can drastically improve the performance of certain algorithms. Memoization helps by storing the results of expensive function calls and reusing them when the same inputs occur again. This avoids redundant calculations, making your code more efficient. The term “Memoization” comes from the Latin word “memorandum” (to remember), which is commonly shortened to “memo” in American English, and which means “to transform the results of a function into something to remember”. In computing, memoization is used to speed up computer programs by eliminating the repetitive computation of results, and by avoiding repeated calls to functions that process the same input. Table of Content Memoization is an optimization technique primarily used to enhance the performance of algorithms by storing the results of expensive function calls and reusing them when the same inputs occur again. The term comes from “memorandum“, which refers to a note intended to help with memory.Memoization is particularly effective in scenarios involving repeated computations, like recursive algorithms, where the same calculations may be performed multiple times. Memoization is a specific form of caching that is used in dynamic programming. The purpose of caching is to improve the performance of our programs and keep data accessible that can be used later. It basically stores the previously calculated result of the subproblem and reuses the stored result for the same subproblem. This removes the extra effort to calculate again and again for the same problem. Memoization is useful in situations where previously calculated results can be reused. It is particularly effective in recursive problems, especially those involving overlapping subproblems, where the same calculations are repeated multiple times. The Fibonacci sequence is a classic example of how memoization can optimize recursive algorithms by eliminating redundant computations. The Fibonacci sequence is defined as:Base Case: F(0) = 0 and F(1) = 1Recursive Cases: F(n) = F(n-1) + F(n-2) Using recursion, solving F(n) involves repeatedly breaking the problem into smaller subproblems. However, many of these subproblems are recalculated multiple times, leading to inefficiency. For instance, computing F(5) will independently calculate F(3) and F(2) multiple times. By using memoization, we store the results of already computed subproblems in a cache, allowing us to reuse them whenever the same subproblem arises again. This eliminates redundant calculations and significantly improves efficiency. Please refer to Nth Fibonacci Number for implementation. Without memoization, the time complexity of finding the nth Fibonacci number using recursion is O(2^n), as the function repeatedly solves overlapping subproblems, creating an exponential number of recursive calls. For instance, F(3) and F(2) are recalculated multiple times when computing F(5), leading to inefficiency. With memoization, the time complexity reduces to O(n) because each Fibonacci number is computed only once and stored for reuse. This eliminates redundant computations and ensures a linear traversalfrom F(0) and F(n), significantly improving performance. The implementation of memoization depends on the parameters that change and are responsible for solving the problem. Memoization can be applied in various ways, based on the number of arguments in the recursive function. Below are some common types of memoization: 1D Memoization: Used when the recursive function has one argument whose value changes with every function call.2D Memoization: Used when the recursive function has two arguments whose values change with every function call.3D Memoization: Used when the recursive function has three arguments whose values change with every function call. Please refer to Memoization (1D, 2D and 3D) for better understanding. Dynamic programming helps to efficiently solve problems that have overlapping subproblems and optimal substructure properties. The idea behind dynamic programming is to break the problem into smaller sub-problems and save the result for future use, thus eliminating the need to compute the result repeatedly. There are two approaches to formulate a dynamic programming solution: How Memoization technique is used in Dynamic Programming  Memoization Tabulation State State transition relation is easy to think. State transition relation is difficult to think.  Code Code is easy and less complicated. Code gets complicated when a lot of conditions are required. Speed Slow due to many recursive calls and return statements. Fast, as we directly access previous states from the table. Subproblem solving If some subproblems in the subproblem space need not be solved at all, the memoized solution has the advantage of solving only those subproblems that are definitely required. If all subproblems must be solved at least once, a bottom-up dynamic programming algorithm usually outperforms a top-down memoized algorithm by a constant factor. Table Entries Unlike the Tabulated version, all entries of the lookup table are not necessarily filled in Memoized version. The table is filled on demand. In the Tabulated version, starting from the first entry, all entries are filled one by one Please refer to Tabulation vs Memoization for better understanding. Question Article Practice Count ways to reach the n’th stair Word Break Problem | DP-32 Program for Fibonacci numbers nth Catalan Number Gold Mine Problem Subset Sum Problem Cutting a Rod Min Cost Path Minimum number of jumps to reach end Longest Palindromic Substring | Set 1 Longest Repeating Subsequence Count ways to reach the nth stair using step 1, 2 or 3 Count of different ways to express n as the sum of 1, 3 and 4 Count number of ways to cover a distance Count of arrays having consecutive element with different values Largest Sum Contiguous Subarray Smallest sum contiguous subarray Unique paths in a Grid with Obstacles Different ways to sum n using numbers greater than or equal to m Memoization is a programming concept and can be applied to any programming language. Its absolute goal is to optimize the program. Usually, this problem is seen when programs perform heavy computations. This technique cache all the previous result that is computed so that it will not have to recalculate for the same problem.  ",
        "code": "",
        "complexity": {
            "time": "Without memoization, the time complexity of finding the nth Fibonacci number using recursion is O(2^n), as the function repeatedly solves overlapping subproblems, creating an exponential number of recursive calls. For instance, F(3) and F(2) are recalculated multiple times when computing F(5), leading to inefficiency. With memoization, the time complexity reduces to O(n) because each Fibonacci number is computed only once and stored for reuse. This eliminates redundant computations and ensures a linear traversalfrom F(0) and F(n), significantly improving performance.",
            "space": ""
        },
        "tags": [
            "Dynamic Programming"
        ],
        "url": "https://www.geeksforgeeks.org/what-is-memoization-a-complete-tutorial/"
    },
    {
        "title": "Meanings and objectives of Tabulation",
        "description": "Tabulation is a fundamental concept in Dynamic programming (DP), which entails dividing a problem into smaller subproblems and an array to hold the outcomes of these subproblems. One of the two primary methodologies in dynamic programming is tabulation, and memoization serves as the other. Tabulation creates a table (often an array) and fills it up one row at a time. It begins with resolving the smallest subproblems first and builds up towards larger subproblems using those answers until the main problem is resolved. Tabulation follows these steps: Follow the steps to solve the problem using Dynamic Programming(tabulation): Below is the implementation of the above idea:                Tabulation is a powerful technique in dynamic programming for solving complex problems efficiently by storing subproblems results in array. N  ",
        "code": "\n\n\n\n\n\n\n\n\n\n55\n",
        "complexity": {
            "time": "",
            "space": ""
        },
        "tags": [
            "Dynamic Programming"
        ],
        "url": "https://www.geeksforgeeks.org/meanings-and-objectives-of-tabulation/"
    },
    {
        "title": "Tabulation vs Memoization",
        "description": "Tabulation and memoization are two techniques used to implement dynamic programming.  Both techniques are used when there are overlapping subproblems (the same subproblem is executed multiple times). Below is an overview of two approaches.  Given a rod of length n inches and an array price[]. price[i] denotes the value of a piece of length i. The task is to determine the maximum value obtainable by cutting up the rod and selling the pieces. Examples: Input: price[] =  [1, 5, 8, 9, 10, 17, 17, 20]Output: 22Explanation:  The maximum obtainable value is 22 by cutting in two pieces of lengths 2 and 6, i.e., 5 + 17 = 22. Input : price[] =  [3, 5, 8, 9, 10, 17, 17, 20]Output : 24Explanation : The maximum obtainable value is 24 by cutting the rod into 8 pieces of length 1, i.e, 8*price[1]= 8*3 = 24. Input : price[] =  [3]Output : 3Explanation: There is only 1 way to pick a piece of length 1. In the rod cutting problem, the goal is to determine the maximum profit that can be obtained by cutting a rod into smaller pieces and selling them, given a price list for each possible piece length. The approach involves considering all possible cuts for the rod and recursively calculating the maximum profit for each cut. For detailed explanation and approaches, refer to Rod Cutting. In this implementation of the rod cutting problem, memoization is used to optimize the recursive approach by storing the results of subproblems, avoiding redundant calculations. We iteratively calculate the maximum profit for each possible rod length. For each length i, we check all possible smaller cuts, update the profit by comparing the current maximum profit with the profit obtained by combining smaller cuts, and ultimately return the maximum profit for the entire rod. From the above two approaches, we can observe the following key differences:  Memoization Tabulation Memory Initialization Initializes memo array with -1 to mark unfilled states. Initializes dp array with 0 as base values. Solution Building Direction Starts from n and recursively breaks down to smaller subproblems. Also, Only computes states that are actually needed. Systematically builds solution from smallest subproblem (length 1) to largest (length n). Computes all possible states in a predetermined order. Handling Base Cases Uses conditional checking to handle base cases. Base cases are pre-filled during initialization. Space Usage Additional space for recursion stack (O(n) in worst case) Only requires the DP array O(n) N  ",
        "code": "// C++ program to find maximum\n// profit from rod of size n\n#include <bits/stdc++.h>\nusing namespace std;\n\nint cutRodRecur(int i, vector<int> &price, vector<int> &memo) {\n\n    // Base case\n    if (i == 0)\n        return 0;\n\n    // If value is memoized\n    if (memo[i - 1] != -1)\n        return memo[i - 1];\n\n    int ans = 0;\n\n    // Find maximum value for each cut.\n    // Take value of rod of length j, and\n    // recursively find value of rod of\n    // length (i-j).\n    for (int j = 1; j <= i; j++) {\n        ans = max(ans, price[j - 1] + cutRodRecur(i - j, price, memo));\n    }\n\n    return memo[i - 1] = ans;\n}\n\nint cutRod(vector<int> &price) {\n    int n = price.size();\n    vector<int> memo(price.size(), -1);\n    return cutRodRecur(n, price, memo);\n}\n\nint main() {\n  \n    vector<int> price = {1, 5, 8, 9, 10, 17, 17, 20};\n    cout << cutRod(price);\n    return 0;\n}\n// Java program to find maximum\n// profit from rod of size n \n\nimport java.util.*;\n\nclass GfG {\n\n    static int cutRodRecur(int i, int[] price, int[] memo) {\n        \n        // Base case\n        if (i == 0) return 0;\n        \n        // If value is memoized\n        if (memo[i - 1] != -1) return memo[i - 1];\n        \n        int ans = 0;\n\n        // Find maximum value for each cut.\n        // Take value of rod of length j, and \n        // recursively find value of rod of \n        // length (i-j).\n        for (int j = 1; j <= i; j++) {\n            ans = Math.max(ans, price[j - 1] + cutRodRecur(i - j, price, memo));\n        }\n\n        return memo[i - 1] = ans;\n    }\n\n    static int cutRod(int[] price) {\n        int n = price.length;\n        int[] memo = new int[n];\n        Arrays.fill(memo, -1);\n        return cutRodRecur(n, price, memo);\n    }\n\n    public static void main(String[] args) {\n        int[] price = {1, 5, 8, 9, 10, 17, 17, 20};\n        System.out.println(cutRod(price));\n    }\n}\n# Python program to find maximum\n# profit from rod of size n \n\ndef cutRodRecur(i, price, memo):\n    \n    # Base case\n    if i == 0:\n        return 0\n    \n    # If value is memoized\n    if memo[i - 1] != -1:\n        return memo[i - 1]\n    \n    ans = 0\n\n    # Find maximum value for each cut.\n    # Take value of rod of length j, and \n    # recursively find value of rod of \n    # length (i-j).\n    for j in range(1, i + 1):\n        ans = max(ans, price[j - 1] + cutRodRecur(i - j, price, memo))\n\n    memo[i - 1] = ans\n    return ans\n\ndef cutRod(price):\n    n = len(price)\n    memo = [-1] * n\n    return cutRodRecur(n, price, memo)\n\nif __name__ == \"__main__\":\n    price = [1, 5, 8, 9, 10, 17, 17, 20]\n    print(cutRod(price))\n// C# program to find maximum\n// profit from rod of size n \n\nusing System;\n\nclass GfG {\n\n    static int cutRodRecur(int i, int[] price, int[] memo) {\n        \n        // Base case\n        if (i == 0) return 0;\n        \n        // If value is memoized\n        if (memo[i - 1] != -1) return memo[i - 1];\n        \n        int ans = 0;\n\n        // Find maximum value for each cut.\n        // Take value of rod of length j, and \n        // recursively find value of rod of \n        // length (i-j).\n        for (int j = 1; j <= i; j++) {\n            ans = Math.Max(ans, price[j - 1] +\n            cutRodRecur(i - j, price, memo));\n        }\n\n        return memo[i - 1] = ans;\n    }\n\n    static int cutRod(int[] price) {\n        int n = price.Length;\n        int[] memo = new int[n];\n        Array.Fill(memo, -1);\n        return cutRodRecur(n, price, memo);\n    }\n\n    static void Main(string[] args) {\n        int[] price = {1, 5, 8, 9, 10, 17, 17, 20};\n        Console.WriteLine(cutRod(price));\n    }\n}\n// JavaScript program to find maximum\n// profit from rod of size n \n\nfunction cutRodRecur(i, price, memo) {\n    \n    // Base case\n    if (i === 0) return 0;\n    \n    // If value is memoized\n    if (memo[i - 1] !== -1) return memo[i - 1];\n    \n    let ans = 0;\n\n    // Find maximum value for each cut.\n    // Take value of rod of length j, and \n    // recursively find value of rod of \n    // length (i-j).\n    for (let j = 1; j <= i; j++) {\n        ans = Math.max(ans, price[j - 1] + cutRodRecur(i - j, price, memo));\n    }\n\n    memo[i - 1] = ans;\n    return ans;\n}\n\nfunction cutRod(price) {\n    const n = price.length;\n    const memo = Array(n).fill(-1);\n    return cutRodRecur(n, price, memo);\n}\n\nconst price = [1, 5, 8, 9, 10, 17, 17, 20];\nconsole.log(cutRod(price));\n22\n// C++ program to find maximum\n// profit from rod of size n\n#include <bits/stdc++.h>\nusing namespace std;\n\nint cutRod(vector<int> &price) {\n    int n = price.size();\n    vector<int> dp(price.size() + 1, 0);\n\n    // Find maximum value for all\n    // rod of length i.\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= i; j++) {\n            dp[i] = max(dp[i], price[j - 1] + dp[i - j]);\n        }\n    }\n\n    return dp[n];\n}\n\nint main() {\n  \n    vector<int> price = {1, 5, 8, 9, 10, 17, 17, 20};\n    cout << cutRod(price);\n    return 0;\n}\n// Java program to find maximum\n// profit from rod of size n \n\nimport java.util.*;\n\nclass GfG {\n\n    static int cutRod(int[] price) {\n        int n = price.length;\n        int[] dp = new int[n + 1];\n\n        // Find maximum value for all \n        // rod of length i.\n        for (int i = 1; i <= n; i++) {\n            for (int j = 1; j <= i; j++) {\n                dp[i] = Math.max(dp[i], price[j - 1] + dp[i - j]);\n            }\n        }\n\n        return dp[n];\n    }\n\n    public static void main(String[] args) {\n        int[] price = {1, 5, 8, 9, 10, 17, 17, 20};\n        System.out.println(cutRod(price));\n    }\n}\n# Python program to find maximum\n# profit from rod of size n \n\ndef cutRod(price):\n    n = len(price)\n    dp = [0] * (n + 1)\n\n    # Find maximum value for all \n    # rod of length i.\n    for i in range(1, n + 1):\n        for j in range(1, i + 1):\n            dp[i] = max(dp[i], price[j - 1] + dp[i - j])\n\n    return dp[n]\n\nif __name__ == \"__main__\":\n    price = [1, 5, 8, 9, 10, 17, 17, 20]\n    print(cutRod(price))\n// C# program to find maximum\n// profit from rod of size n \n\nusing System;\n\nclass GfG {\n\n    static int cutRod(int[] price) {\n        int n = price.Length;\n        int[] dp = new int[n + 1];\n\n        // Find maximum value for all \n        // rod of length i.\n        for (int i = 1; i <= n; i++) {\n            for (int j = 1; j <= i; j++) {\n                dp[i] = Math.Max(dp[i], price[j - 1] + dp[i - j]);\n            }\n        }\n\n        return dp[n];\n    }\n\n    static void Main(string[] args) {\n        int[] price = {1, 5, 8, 9, 10, 17, 17, 20};\n        Console.WriteLine(cutRod(price));\n    }\n}\n// JavaScript program to find maximum\n// profit from rod of size n \n\nfunction cutRod(price) {\n    const n = price.length;\n    const dp = Array(n + 1).fill(0);\n\n    // Find maximum value for all \n    // rod of length i.\n    for (let i = 1; i <= n; i++) {\n        for (let j = 1; j <= i; j++) {\n            dp[i] = Math.max(dp[i], price[j - 1] + dp[i - j]);\n        }\n    }\n\n    return dp[n];\n}\n\nconst price = [1, 5, 8, 9, 10, 17, 17, 20];\nconsole.log(cutRod(price));\n22\n",
        "complexity": {
            "time": "",
            "space": ""
        },
        "tags": [
            "Dynamic Programming"
        ],
        "url": "https://www.geeksforgeeks.org/tabulation-vs-memoization/"
    },
    {
        "title": "0/1 Knapsack Problem",
        "description": "Given n items where each item has some weight and profit associated with it and also given a bag with capacity W, [i.e., the bag can hold at most W weight in it]. The task is to put the items into the bag such that the sum of profits associated with them is the maximum possible. Note: The constraint here is we can either put an item completely into the bag or cannot put it at all [It is not possible to put a part of an item into the bag]. Input:  W = 4, profit[] = [1, 2, 3], weight[] = [4, 5, 1]Output: 3Explanation: There are two items which have weight less than or equal to 4. If we select the item with weight 4, the possible profit is 1. And if we select the item with weight 1, the possible profit is 3. So the maximum possible profit is 3. Note that we cannot put both the items with weight 4 and 1 together as the capacity of the bag is 4. Input: W = 3, profit[] = [1, 2, 3], weight[] = [4, 5, 6]Output: 0 Table of Content A simple solution is to consider all subsets of items and calculate the total weight and value of all subsets. Consider the only subsets whose total weight is smaller than W. From all such subsets, pick the subset with maximum value. Optimal Substructure: To consider all subsets of items, there can be two cases for every item. Follow the below steps to solve the problem: The maximum value obtained from ‘n’ items is the max of the following two values. Below is an example run of the above implementation.  Note: The above function using recursion computes the same subproblems again and again. See the following recursion tree, K(1, 1) is being evaluated twice.  As there are repetitions of the same subproblem again and again we can implement the following idea to solve the problem. If we get a subproblem the first time, we can solve this problem by creating a 2-D array that can store a particular state (n, w). Now if we come across the same state (n, w) again instead of calculating it i again we can directly return its result stored in the table in constant time. There are two parameters that change in the recursive solution and these parameters go from 0 to n and 0 to W. So we create a 2D dp[][] array of size (n+1) x (W+1), such that dp[i][j] stores the maximum value we can get using i items such that the knapsack capacity is j. For each item i and knapsack capacity j, we decide whether to pick the item or not. For calculating the current row of the dp[] array we require only previous row, but if we start traversing the rows from right to left then it can be done with a single row only  ",
        "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n// Returns the maximum value that\n// can be put in a knapsack of capacity W\nint knapsackRec(int W, vector<int> &val, vector<int> &wt, int n) {\n\n    // Base Case\n    if (n == 0 || W == 0)\n        return 0;\n\n    int pick = 0;\n\n    // Pick nth item if it does not exceed the capacity of knapsack\n    if (wt[n - 1] <= W)\n        pick = val[n - 1] + knapsackRec(W - wt[n - 1], val, wt, n - 1);\n    \n    // Don't pick the nth item\n    int notPick = knapsackRec(W, val, wt, n - 1);\n     \n    return max(pick, notPick);\n}\n\nint knapsack(int W, vector<int> &val, vector<int> &wt) {\n    int n = val.size();\n    return knapsackRec(W, val, wt, n);\n}\n\nint main() {\n    vector<int> val = {1, 2, 3};\n    vector<int> wt = {4, 5, 1};\n    int W = 4;\n\n    cout << knapsack(W, val, wt) << endl;\n    return 0;\n}\nimport java.util.*;\n\nclass GfG {\n\n    // Returns the maximum value that\n    // can be put in a knapsack of capacity W\n    static int knapsackRec(int W, int[] val, int[] wt, int n) {\n\n        // Base Case\n        if (n == 0 || W == 0)\n            return 0;\n\n        int pick = 0;\n\n        // Pick nth item if it does not exceed the capacity of knapsack\n        if (wt[n - 1] <= W)\n            pick = val[n - 1] + knapsackRec(W - wt[n - 1], val, wt, n - 1);\n        \n        // Don't pick the nth item\n        int notPick = knapsackRec(W, val, wt, n - 1);\n         \n        return Math.max(pick, notPick);\n    }\n\n    static int knapsack(int W, int[] val, int[] wt) {\n        int n = val.length;\n        return knapsackRec(W, val, wt, n);\n    }\n\n    public static void main(String[] args) {\n        int[] val = {1, 2, 3};\n        int[] wt = {4, 5, 1};\n        int W = 4;\n\n        System.out.println(knapsack(W, val, wt));\n    }\n}\n# Returns the maximum value that\n# can be put in a knapsack of capacity W\ndef knapsackRec(W, val, wt, n):\n\n    # Base Case\n    if n == 0 or W == 0:\n        return 0\n\n    pick = 0\n\n    # Pick nth item if it does not exceed the capacity of knapsack\n    if wt[n - 1] <= W:\n        pick = val[n - 1] + knapsackRec(W - wt[n - 1], val, wt, n - 1)\n    \n    # Don't pick the nth item\n    notPick = knapsackRec(W, val, wt, n - 1)\n     \n    return max(pick, notPick)\n\ndef knapsack(W, val, wt):\n    n = len(val)\n    return knapsackRec(W, val, wt, n)\n\nif __name__ == \"__main__\":\n    val = [1, 2, 3]\n    wt = [4, 5, 1]\n    W = 4\n\n    print(knapsack(W, val, wt))\nusing System;\n\nclass GfG {\n\n    // Returns the maximum value that\n    // can be put in a knapsack of capacity W\n    static int knapsackRec(int W, int[] val, int[] wt, int n) {\n\n        // Base Case\n        if (n == 0 || W == 0)\n            return 0;\n\n        int pick = 0;\n\n        // Pick nth item if it does not exceed the capacity of knapsack\n        if (wt[n - 1] <= W)\n            pick = val[n - 1] + knapsackRec(W - wt[n - 1], val, wt, n - 1);\n        \n        // Don't pick the nth item\n        int notPick = knapsackRec(W, val, wt, n - 1);\n         \n        return Math.Max(pick, notPick);\n    }\n\n    static int knapsack(int W, int[] val, int[] wt) {\n        int n = val.Length;\n        return knapsackRec(W, val, wt, n);\n    }\n\n    static void Main() {\n        int[] val = { 1, 2, 3 };\n        int[] wt = { 4, 5, 1 };\n        int W = 4;\n\n        Console.WriteLine(knapsack(W, val, wt));\n    }\n}\n// Returns the maximum value that\n// can be put in a knapsack of capacity W\nfunction knapsackRec(W, val, wt, n) {\n\n    // Base Case\n    if (n === 0 || W === 0)\n        return 0;\n\n    let pick = 0;\n\n    // Pick nth item if it does not exceed the capacity of knapsack\n    if (wt[n - 1] <= W)\n        pick = val[n - 1] + knapsackRec(W - wt[n - 1], val, wt, n - 1);\n    \n    // Don't pick the nth item\n    let notPick = knapsackRec(W, val, wt, n - 1);\n     \n    return Math.max(pick, notPick);\n}\n\nfunction knapsack(W, val, wt) {\n    let n = val.length;\n    return knapsackRec(W, val, wt, n);\n}\n\n\n// Driver Code\nlet val = [1, 2, 3];\nlet wt = [4, 5, 1];\nlet W = 4;\n\nconsole.log(knapsack(W, val, wt));\n3\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Returns the maximum value that\n// can be put in a knapsack of capacity W\nint knapsackRec(int W, vector<int> &val, vector<int> &wt, int n, \n                                        vector<vector<int>> &memo) {\n\n    // Base Case\n    if (n == 0 || W == 0)\n        return 0;\n\n    // Check if we have previously calculated the same subproblem\n    if(memo[n][W] != -1)\n        return memo[n][W];\n\n    int pick = 0;\n\n    // Pick nth item if it does not exceed the capacity of knapsack\n    if (wt[n - 1] <= W)\n        pick = val[n - 1] + knapsackRec(W - wt[n - 1], val, wt, n - 1, memo);\n    \n    // Don't pick the nth item\n    int notPick = knapsackRec(W, val, wt, n - 1, memo);\n    \n    // Store the result in memo[n][W] and return it\n    return memo[n][W] = max(pick, notPick);\n}\n\nint knapsack(int W, vector<int> &val, vector<int> &wt) {\n    int n = val.size();\n    \n    // Memoization table to store the results\n    vector<vector<int>> memo(n + 1, vector<int>(W + 1, -1));\n    \n    return knapsackRec(W, val, wt, n, memo);\n}\n\nint main() {\n    vector<int> val = {1, 2, 3};\n    vector<int> wt = {4, 5, 1};\n    int W = 4;\n\n    cout << knapsack(W, val, wt) << endl;\n    return 0;\n}\nimport java.util.*;\n\nclass GfG {\n\n    // Returns the maximum value that\n    // can be put in a knapsack of capacity W\n    static int knapsackRec(int W, int[] val, int[] wt, int n, int[][] memo) {\n\n        // Base Case\n        if (n == 0 || W == 0)\n            return 0;\n\n        // Check if we have previously calculated the same subproblem\n        if (memo[n][W] != -1)\n            return memo[n][W];\n\n        int pick = 0;\n\n        // Pick nth item if it does not exceed the capacity of knapsack\n        if (wt[n - 1] <= W)\n            pick = val[n - 1] + knapsackRec(W - wt[n - 1], val, wt, n - 1, memo);\n\n        // Don't pick the nth item\n        int notPick = knapsackRec(W, val, wt, n - 1, memo);\n\n        // Store the result in memo[n][W] and return it\n        return memo[n][W] = Math.max(pick, notPick);\n    }\n\n    static int knapsack(int W, int[] val, int[] wt) {\n        int n = val.length;\n\n        // Memoization table to store the results\n        int[][] memo = new int[n + 1][W + 1];\n\n        // Initialize memoization table with -1\n        for (int i = 0; i <= n; i++) {\n            for (int j = 0; j <= W; j++)\n                memo[i][j] = -1;\n        }\n\n        return knapsackRec(W, val, wt, n, memo);\n    }\n\n    public static void main(String[] args) {\n        int[] val = { 1, 2, 3 };\n        int[] wt = { 4, 5, 1 };\n        int W = 4;\n\n        System.out.println(knapsack(W, val, wt));\n    }\n}\n# Returns the maximum value that\n# can be put in a knapsack of capacity W\ndef knapsackRec(W, val, wt, n, memo):\n\n    # Base Case\n    if n == 0 or W == 0:\n        return 0\n\n    # Check if we have previously calculated the same subproblem\n    if memo[n][W] != -1:\n        return memo[n][W]\n\n    pick = 0\n\n    # Pick nth item if it does not exceed the capacity of knapsack\n    if wt[n - 1] <= W:\n        pick = val[n - 1] + knapsackRec(W - wt[n - 1], val, wt, n - 1, memo)\n\n    # Don't pick the nth item\n    notPick = knapsackRec(W, val, wt, n - 1, memo)\n\n    # Store the result in memo[n][W] and return it\n    memo[n][W] = max(pick, notPick)\n    return memo[n][W]\n\ndef knapsack(W, val, wt):\n    n = len(val)\n\n    # Memoization table to store the results\n    memo = [[-1] * (W + 1) for _ in range(n + 1)]\n\n    return knapsackRec(W, val, wt, n, memo)\n\nif __name__ == \"__main__\":\n    val = [1, 2, 3]\n    wt = [4, 5, 1]\n    W = 4\n\n    print(knapsack(W, val, wt))\nusing System;\n\nclass GfG {\n    // Returns the maximum value that\n    // can be put in a knapsack of capacity W\n    static int KnapsackRec(int W, int[] val, int[] wt, int n, ref int[,] memo) {\n        \n        // Base Case\n        if (n == 0 || W == 0)\n            return 0;\n\n        // Check if we have previously calculated the same subproblem\n        if (memo[n, W] != -1)\n            return memo[n, W];\n\n        int pick = 0;\n\n        // Pick nth item if it does not exceed the capacity of knapsack\n        if (wt[n - 1] <= W)\n            pick = val[n - 1] + KnapsackRec(W - wt[n - 1], val, wt, n - 1, ref memo);\n\n        // Don't pick the nth item\n        int notPick = KnapsackRec(W, val, wt, n - 1, ref memo);\n\n        // Store the result in memo[n, W] and return it\n        return memo[n, W] = Math.Max(pick, notPick);\n    }\n\n    static int Knapsack(int W, int[] val, int[] wt) {\n        int n = val.Length;\n\n        // Memoization table to store the results\n        int[,] memo = new int[n + 1, W + 1];\n\n        // Initialize memo table with -1\n        for (int i = 0; i <= n; i++)\n        {\n            for (int j = 0; j <= W; j++)\n            {\n                memo[i, j] = -1;\n            }\n        }\n\n        return KnapsackRec(W, val, wt, n, ref memo);\n    }\n\n    static void Main() {\n        int[] val = { 1, 2, 3 };\n        int[] wt = { 4, 5, 1 };\n        int W = 4;\n\n        Console.WriteLine(Knapsack(W, val, wt));\n    }\n}\n// Returns the maximum value that\n// can be put in a knapsack of capacity W\nfunction knapsackRec(W, val, wt, n, memo) {\n\n    // Base Case\n    if (n === 0 || W === 0)\n        return 0;\n\n    // Check if we have previously calculated the same subproblem\n    if (memo[n][W] !== -1)\n        return memo[n][W];\n\n    let pick = 0;\n\n    // Pick nth item if it does not exceed the capacity of knapsack\n    if (wt[n - 1] <= W)\n        pick = val[n - 1] + knapsackRec(W - wt[n - 1], val, wt, n - 1, memo);\n\n    // Don't pick the nth item\n    let notPick = knapsackRec(W, val, wt, n - 1, memo);\n\n    // Store the result in memo[n][W] and return it\n    memo[n][W] = Math.max(pick, notPick);\n    return memo[n][W];\n}\n\nfunction knapsack(W, val, wt) {\n    const n = val.length;\n\n    // Memoization table to store the results\n    const memo = Array.from({ length: n + 1 }, () => Array(W + 1).fill(-1));\n\n    return knapsackRec(W, val, wt, n, memo);\n}\n\n// Driver Code\nconst val = [1, 2, 3];\nconst wt = [4, 5, 1];\nconst W = 4;\n\nconsole.log(knapsack(W, val, wt));\n3\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Returns the maximum value that\n// can be put in a knapsack of capacity W\nint knapsack(int W, vector<int> &val, vector<int> &wt) {\n    int n = wt.size();\n    vector<vector<int>> dp(n + 1, vector<int>(W + 1));\n\n    // Build table dp[][] in bottom-up manner\n    for (int i = 0; i <= n; i++) {\n        for (int j = 0; j <= W; j++) {\n            \n            // If there is no item or the knapsack's capacity is 0\n            if (i == 0 || j == 0)\n                dp[i][j] = 0;\n            else {\n                int pick = 0;\n                \n                // Pick ith item if it does not exceed the capacity of knapsack\n                if(wt[i - 1] <= j)\n                    pick = val[i - 1] + dp[i - 1][j - wt[i - 1]];\n                    \n                // Don't pick the ith item\n                int notPick = dp[i - 1][j];\n                \n                dp[i][j] = max(pick, notPick);\n            }\n        }\n    }\n    return dp[n][W];\n}\n\nint main() {\n    vector<int> val = {1, 2, 3};\n    vector<int> wt = {4, 5, 1};\n    int W = 4;\n\n    cout << knapsack(W, val, wt) << endl;\n    return 0;\n}\nimport java.util.*;\n\nclass GfG {\n\n    // Returns the maximum value that\n    // can be put in a knapsack of capacity W\n    static int knapsack(int W, int[] val, int[] wt) {\n        int n = wt.length;\n        int[][] dp = new int[n + 1][W + 1];\n\n        // Build table dp[][] in bottom-up manner\n        for (int i = 0; i <= n; i++) {\n            for (int j = 0; j <= W; j++) {\n\n                // If there is no item or the knapsack's capacity is 0\n                if (i == 0 || j == 0)\n                    dp[i][j] = 0;\n                else {\n                    int pick = 0;\n\n                    // Pick ith item if it does not exceed the capacity of knapsack\n                    if (wt[i - 1] <= j)\n                        pick = val[i - 1] + dp[i - 1][j - wt[i - 1]];\n\n                    // Don't pick the ith item\n                    int notPick = dp[i - 1][j];\n\n                    dp[i][j] = Math.max(pick, notPick);\n                }\n            }\n        }\n        return dp[n][W];\n    }\n\n    public static void main(String[] args) {\n        int[] val = {1, 2, 3};\n        int[] wt = {4, 5, 1};\n        int W = 4;\n\n        System.out.println(knapsack(W, val, wt));\n    }\n}\ndef knapsack(W, val, wt):\n    n = len(wt)\n    dp = [[0 for _ in range(W + 1)] for _ in range(n + 1)]\n\n    # Build table dp[][] in bottom-up manner\n    for i in range(n + 1):\n        for j in range(W + 1):\n\n            # If there is no item or the knapsack's capacity is 0\n            if i == 0 or j == 0:\n                dp[i][j] = 0\n            else:\n                pick = 0\n\n                # Pick ith item if it does not exceed the capacity of knapsack\n                if wt[i - 1] <= j:\n                    pick = val[i - 1] + dp[i - 1][j - wt[i - 1]]\n\n                # Don't pick the ith item\n                notPick = dp[i - 1][j]\n\n                dp[i][j] = max(pick, notPick)\n\n    return dp[n][W]\n\nif __name__ == \"__main__\":\n    val = [1, 2, 3]\n    wt = [4, 5, 1]\n    W = 4\n    \n    print(knapsack(W, val, wt))\nusing System;\nusing System.Linq;\n\nclass GfG {\n    // Returns the maximum value that\n    // can be put in a knapsack of capacity W\n    static int Knapsack(int W, int[] val, int[] wt) {\n        int n = wt.Length;\n        int[,] dp = new int[n + 1, W + 1];\n\n        // Build table dp[][] in bottom-up manner\n        for (int i = 0; i <= n; i++) {\n            for (int j = 0; j <= W; j++) {\n                \n                // If there is no item or the knapsack's capacity is 0\n                if (i == 0 || j == 0)\n                    dp[i, j] = 0;\n                else {\n                    int pick = 0;\n\n                    // Pick ith item if it does not exceed the capacity of knapsack\n                    if (wt[i - 1] <= j)\n                        pick = val[i - 1] + dp[i - 1, j - wt[i - 1]];\n\n                    // Don't pick the ith item\n                    int notPick = dp[i - 1, j];\n\n                    dp[i, j] = Math.Max(pick, notPick);\n                }\n            }\n        }\n        return dp[n, W];\n    }\n\n    static void Main() {\n        int[] val = { 1, 2, 3 };\n        int[] wt = { 4, 5, 1 };\n        int W = 4;\n\n        Console.WriteLine(Knapsack(W, val, wt));\n    }\n}\n// Returns the maximum value that\n// can be put in a knapsack of capacity W\n\nfunction knapsack(W, val, wt) {\n    let n = wt.length;\n    let dp = Array.from({ length: n + 1 }, () => Array(W + 1).fill(0));\n\n    // Build table dp[][] in bottom-up manner\n    for (let i = 0; i <= n; i++) {\n        for (let j = 0; j <= W; j++) {\n\n            // If there is no item or the knapsack's capacity is 0\n            if (i === 0 || j === 0)\n                dp[i][j] = 0;\n            else {\n                let pick = 0;\n\n                // Pick ith item if it does not exceed the capacity of knapsack\n                if (wt[i - 1] <= j)\n                    pick = val[i - 1] + dp[i - 1][j - wt[i - 1]];\n\n                // Don't pick the ith item\n                let notPick = dp[i - 1][j];\n\n                dp[i][j] = Math.max(pick, notPick);\n            }\n        }\n    }\n    return dp[n][W];\n}\n\n// Driver code\nlet val = [1, 2, 3];\nlet wt = [4, 5, 1];\nlet W = 4;\n\nconsole.log(knapsack(W, val, wt));\n3\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Function to find the maximum profit\nint knapsack(int W, vector<int> &val, vector<int> &wt) {\n\n    // Initializing dp vector\n    vector<int> dp(W + 1, 0);\n\n    // Taking first i elements\n    for (int i = 1; i <= wt.size(); i++) {\n        \n        // Starting from back, so that we also have data of\n        // previous computation of i-1 items\n        for (int j = W; j >= wt[i - 1]; j--) {\n            dp[j] = max(dp[j], dp[j - wt[i - 1]] + val[i - 1]);\n        }\n    }\n    return dp[W];\n}\n\nint main() {\n    vector<int> val = {1, 2, 3};\n    vector<int> wt = {4, 5, 1};\n    int W = 4;\n\n    cout << knapsack(W, val, wt) << endl;\n    return 0;\n}\nimport java.util.*;\n\nclass GfG {\n\n    // Function to find the maximum profit\n    static int knapsack(int W, int[] val, int[] wt) {\n        \n        // Initializing dp array\n        int[] dp = new int[W + 1];\n        \n        // Taking first i elements\n        for (int i = 1; i <= wt.length; i++) {\n            \n            // Starting from back, so that we also have data of\n            // previous computation of i-1 items\n            for (int j = W; j >= wt[i - 1]; j--) {\n                dp[j] = Math.max(dp[j], dp[j - wt[i - 1]] + val[i - 1]);\n            }\n        }\n        return dp[W];\n    }\n\n    public static void main(String[] args) {\n        int[] val = {1, 2, 3};\n        int[] wt = {4, 5, 1};\n        int W = 4;\n\n        System.out.println(knapsack(W, val, wt));\n    }\n}\n# Function to find the maximum profit\ndef knapsack(W, val, wt):\n    \n    # Initializing dp list\n    dp = [0] * (W + 1)\n\n    # Taking first i elements\n    for i in range(1, len(wt) + 1):\n        \n        # Starting from back, so that we also have data of\n        # previous computation of i-1 items\n        for j in range(W, wt[i - 1] - 1, -1):\n            dp[j] = max(dp[j], dp[j - wt[i - 1]] + val[i - 1])\n    \n    return dp[W]\n\nif __name__ == \"__main__\":\n    val = [1, 2, 3]\n    wt = [4, 5, 1]\n    W = 4\n\n    print(knapsack(W, val, wt))\nusing System;\n\nclass GfG {\n    \n    // Function to find the maximum profit\n    static int Knapsack(int W, int[] val, int[] wt) {\n        \n        // Initializing dp array\n        int[] dp = new int[W + 1];\n\n        // Taking first i elements\n        for (int i = 1; i <= wt.Length; i++) {\n            \n            // Starting from back, so that we also have data of\n            // previous computation of i-1 items\n            for (int j = W; j >= wt[i - 1]; j--) {\n                dp[j] = Math.Max(dp[j], dp[j - wt[i - 1]] + val[i - 1]);\n            }\n        }\n        return dp[W];\n    }\n\n    static void Main() {\n        int[] val = { 1, 2, 3 };\n        int[] wt = { 4, 5, 1 };\n        int W = 4;\n\n        Console.WriteLine(Knapsack(W, val, wt));\n    }\n}\n// Function to find the maximum profit\nfunction knapsack(W, val, wt) {\n\n    // Initializing dp array\n    let dp = new Array(W + 1).fill(0);\n\n    // Taking first i elements\n    for (let i = 1; i <= wt.length; i++) {\n        \n        // Starting from back, so that we also have data of\n        // previous computation of i-1 items\n        for (let j = W; j >= wt[i - 1]; j--) {\n            dp[j] = Math.max(dp[j], dp[j - wt[i - 1]] + val[i - 1]);\n        }\n    }\n    return dp[W];\n}\n\n// Driver Code\nlet val = [1, 2, 3];\nlet wt = [4, 5, 1];\nlet W = 4;\n\nconsole.log(knapsack(W, val, wt));\n3\n",
        "complexity": {
            "time": "",
            "space": ""
        },
        "tags": [
            "Dynamic Programming"
        ],
        "url": "https://www.geeksforgeeks.org/0-1-knapsack-problem-dp-10/"
    },
    {
        "title": "Unbounded Knapsack (Repetition of items allowed)",
        "description": "Given a knapsack weight, say capacity and a set of n items with certain value vali and weight wti, The task is to fill the knapsack in such a way that we can get the maximum profit. This is different from the classical Knapsack problem, here we are allowed to use an unlimited number of instances of an item. Examples: Input: capacity = 100, val[]  = [1, 30], wt[] = [1, 50]Output: 100 Explanation: There are many ways to fill knapsack. 1) 2 instances of 50 unit weight item. 2) 100 instances of 1 unit weight item. 3) 1 instance of 50 unit weight item and 50 instances of 1 unit weight items. We get maximum value with option 2.  Input: capacity = 8, val[] = [10, 40, 50, 70], wt[]  = [1, 3, 4, 5]        Output : 110Explanation: We get maximum value with one unit of weight 5 and one unit of weight 3. Table of Content The idea is to explore the two possibilities for each item in the list. We start by considering the first item and check if it can be included in the knapsack, meaning its weight is less than or equal to the current remaining weight capacity. The solution is found by returning the maximum of the two choices-whether to include or exclude the item at each stage.The recurrence relation can be expressed as: If we notice carefully, we can observe that the above recursive solution holds the following two properties of Dynamic Programming. 1. Optimal Substructure: The Unbounded Knapsack Problem has an optimal substructure property, meaning the solution to the problem can be derived from the solutions to smaller subproblems. Specifically, for any given item i and remaining capacity w, we can express the recursive relation as follows: 2. Overlapping Subproblems: When implementing the recursive solution, we notice that many subproblems are computed multiple times. For example, in the recursive call knapSack(i, capacity), we might need to compute knapSack(i, capacity – wt[i]) and knapSack(i + 1, capacity) multiple times, especially when the weight w is large. The idea is to fill the dp table based on previous values. For each item, we either include it or exclude it to compute the maximum value for each given knapsack weight. The table is filled in an iterative manner from i = n-1 to i = 0 and for each weight from 1 to capacity. The idea is store only the next row values. We can observe that for a given index i, its value depends only on current (i) and next (i+1) row. So only store these values and update them after each step.  ",
        "code": "// C++ program to implement\n// unbounded knapsack problem using recursion.\n#include <bits/stdc++.h>\nusing namespace std;\n\nint knapSackRecur(int i, int capacity, vector<int> &val, vector<int> &wt) {\n    if (i==val.size()) return 0;\n    \n    // Consider current item only if \n    // its weight is less than equal \n    // to maximum weight.\n    int take = 0;\n    if (wt[i]<=capacity) {\n        take = val[i] + knapSackRecur(i, capacity-wt[i], val, wt);\n    }\n    \n    // Skip the current item\n    int noTake = knapSackRecur(i+1, capacity, val, wt);\n    \n    // Return maximum of the two.\n    return max(take, noTake);\n}\n\nint knapSack(int capacity, vector<int> &val, vector<int> &wt) {\n    \n    return knapSackRecur(0, capacity, val ,wt);\n}\n\nint main() {\n    vector<int> val = {1, 1}, wt = {2, 1};\n    int capacity = 3;\n    cout << knapSack(capacity, val, wt);    \n}\n// Java program to implement\n// unbounded knapsack problem using recursion.\n\nclass GfG {\n\n    static int knapSackRecur(int i, int capacity, int[] val, int[] wt) {\n        if (i == val.length) return 0;\n\n        // Consider current item only if \n        // its weight is less than equal \n        // to maximum weight.\n        int take = 0;\n        if (wt[i] <= capacity) {\n            take = val[i] + knapSackRecur(i, capacity - wt[i], val, wt);\n        }\n\n        // Skip the current item\n        int noTake = knapSackRecur(i + 1, capacity, val, wt);\n\n        // Return maximum of the two.\n        return Math.max(take, noTake);\n    }\n\n    static int knapSack(int capacity, int[] val, int[] wt) {\n        return knapSackRecur(0, capacity, val, wt);\n    }\n\n    public static void main(String[] args) {\n        int[] val = {1, 1};\n        int[] wt = {2, 1};\n        int capacity = 3;\n        System.out.println(knapSack(capacity, val, wt));    \n    }\n}\n# Python program to implement\n# unbounded knapsack problem using recursion.\n\ndef knapSackRecur(i, capacity, val, wt):\n    if i == len(val):\n        return 0\n\n    # Consider current item only if \n    # its weight is less than equal \n    # to maximum weight.\n    take = 0\n    if wt[i] <= capacity:\n        take = val[i] + knapSackRecur(i, capacity - wt[i], val, wt)\n\n    # Skip the current item\n    noTake = knapSackRecur(i + 1, capacity, val, wt)\n\n    # Return maximum of the two.\n    return max(take, noTake)\n\ndef knapSack(capacity, val, wt):\n    return knapSackRecur(0, capacity, val, wt)\n\nif __name__ == \"__main__\":\n    val = [1, 1]\n    wt = [2, 1]\n    capacity = 3\n    print(knapSack(capacity, val, wt))\n// C# program to implement\n// unbounded knapsack problem using recursion.\n\nusing System;\n\nclass GfG {\n\n    static int knapSackRecur(int i, int capacity, int[] val, int[] wt) {\n        if (i == val.Length) return 0;\n\n        // Consider current item only if \n        // its weight is less than equal \n        // to maximum weight.\n        int take = 0;\n        if (wt[i] <= capacity) {\n            take = val[i] + knapSackRecur(i, capacity - wt[i], val, wt);\n        }\n\n        // Skip the current item\n        int noTake = knapSackRecur(i + 1, capacity, val, wt);\n\n        // Return maximum of the two.\n        return Math.Max(take, noTake);\n    }\n\n    static int knapSack(int capacity, int[] val, int[] wt) {\n        return knapSackRecur(0, capacity, val, wt);\n    }\n\n    static void Main() {\n        int[] val = {1, 1};\n        int[] wt = {2, 1};\n        int capacity = 3;\n        Console.WriteLine(knapSack(capacity, val, wt));    \n    }\n}\n// JavaScript program to implement\n// unbounded knapsack problem using recursion.\n\nfunction knapSackRecur(i, capacity, val, wt) {\n    if (i === val.length) return 0;\n\n    // Consider current item only if \n    // its weight is less than equal \n    // to maximum weight.\n    let take = 0;\n    if (wt[i] <= capacity) {\n        take = val[i] + knapSackRecur(i, capacity - wt[i], val, wt);\n    }\n\n    // Skip the current item\n    let noTake = knapSackRecur(i + 1, capacity, val, wt);\n\n    // Return maximum of the two.\n    return Math.max(take, noTake);\n}\n\nfunction knapSack(capacity, val, wt) {\n    return knapSackRecur(0, capacity, val, wt);\n}\n\nconst val = [1, 1];\nconst wt = [2, 1];\nconst capacity = 3;\nconsole.log(knapSack(capacity, val, wt));\n3\n// C++ program to implement\n// unbounded knapsack problem using memoization.\n#include <bits/stdc++.h>\nusing namespace std;\n\nint knapSackRecur(int i, int capacity, vector<int> &val, \n                  vector<int> &wt, vector<vector<int>> &memo) {\n    if (i == val.size())\n        return 0;\n\n    // If value is memoized.\n    if (memo[i][capacity] != -1)\n        return memo[i][capacity];\n\n    // Consider current item only if\n    // its weight is less than equal\n    // to maximum weight.\n    int take = 0;\n    if (wt[i] <= capacity) {\n        take = val[i] + knapSackRecur(i, capacity - wt[i],\n                                      val, wt, memo);\n    }\n\n    // Skip the current item\n    int noTake = knapSackRecur(i + 1, capacity, val, wt, memo);\n\n    // store maximum of the two and return it.\n    return memo[i][capacity] = max(take, noTake);\n}\n\nint knapSack(int capacity, vector<int> &val, vector<int> &wt) {\n\n    // 2D matrix for memoization.\n    vector<vector<int>> memo(val.size(), vector<int>(capacity + 1, -1));\n\n    return knapSackRecur(0, capacity, val, wt, memo);\n}\n\nint main() {\n  \n    vector<int> val = {1, 1}, wt = {2, 1};\n    int capacity = 3;\n    cout << knapSack(capacity, val, wt);\n}\n// Java program to implement\n// unbounded knapsack problem using memoization.\n\nimport java.util.Arrays;\n\nclass GfG {\n\n    static int knapSackRecur(int i, int capacity, int[] val,\n                             int[] wt, int[][] memo) {\n        if (i == val.length)\n            return 0;\n\n        // If value is memoized.\n        if (memo[i][capacity] != -1)\n            return memo[i][capacity];\n\n        // Consider current item only if\n        // its weight is less than equal\n        // to maximum weight.\n        int take = 0;\n        if (wt[i] <= capacity) {\n            take = val[i]\n                   + knapSackRecur(i, capacity - wt[i], val, wt,\n                                   memo);\n        }\n\n        // Skip the current item\n        int noTake = knapSackRecur(i + 1, capacity, val, wt, memo);\n\n        // store maximum of the two and return it.\n        return memo[i][capacity] = Math.max(take, noTake);\n    }\n\n    static int knapSack(int capacity, int[] val, int[] wt) {\n\n        // 2D matrix for memoization.\n        int[][] memo = new int[val.length][capacity + 1];\n        for (int i = 0; i < val.length; i++) {\n            Arrays.fill(memo[i], -1);\n        }\n\n        return knapSackRecur(0, capacity, val, wt, memo);\n    }\n\n    public static void main(String[] args) {\n      \n        int[] val = { 1, 1 };\n        int[] wt = { 2, 1 };\n        int capacity = 3;\n        System.out.println(knapSack(capacity, val, wt));\n    }\n}\n# Python program to implement\n# unbounded knapsack problem using memoization.\n\ndef knapSackRecur(i, capacity, val, wt, memo):\n    if i == len(val):\n        return 0\n\n    # If value is memoized.\n    if memo[i][capacity] != -1:\n        return memo[i][capacity]\n\n    # Consider current item only if \n    # its weight is less than equal \n    # to maximum weight.\n    take = 0\n    if wt[i] <= capacity:\n        take = val[i] + knapSackRecur(i, capacity - wt[i], val, wt, memo)\n\n    # Skip the current item\n    noTake = knapSackRecur(i + 1, capacity, val, wt, memo)\n\n    # store maximum of the two and return it.\n    memo[i][capacity] = max(take, noTake)\n    return memo[i][capacity]\n\ndef knapSack(capacity, val, wt):\n    \n    # 2D matrix for memoization.\n    memo = [[-1 for _ in range(capacity + 1)] for _ in range(len(val))]\n    return knapSackRecur(0, capacity, val, wt, memo)\n\nif __name__ == \"__main__\":\n    val = [1, 1]\n    wt = [2, 1]\n    capacity = 3\n    print(knapSack(capacity, val, wt))\n// C# program to implement\n// unbounded knapsack problem using memoization.\n\nusing System;\n\nclass GfG {\n\n    static int knapSackRecur(int i, int capacity, int[] val,\n                             int[] wt, int[, ] memo) {\n        if (i == val.Length)\n            return 0;\n\n        // If value is memoized.\n        if (memo[i, capacity] != -1)\n            return memo[i, capacity];\n\n        // Consider current item only if\n        // its weight is less than equal\n        // to maximum weight.\n        int take = 0;\n        if (wt[i] <= capacity) {\n            take = val[i]\n                   + knapSackRecur(i, capacity - wt[i], val, wt,\n                                   memo);\n        }\n\n        // Skip the current item\n        int noTake = knapSackRecur(i + 1, capacity, val, wt, memo);\n\n        // store maximum of the two and return it.\n        return memo[i, capacity] = Math.Max(take, noTake);\n    }\n\n    static int knapSack(int capacity, int[] val, int[] wt) {\n\n        // 2D matrix for memoization.\n        int[, ] memo = new int[val.Length, capacity + 1];\n        for (int i = 0; i < val.Length; i++) {\n            for (int j = 0; j <= capacity; j++) {\n                memo[i, j] = -1;\n            }\n        }\n\n        return knapSackRecur(0, capacity, val, wt, memo);\n    }\n\n    static void Main() {\n        int[] val = { 1, 1 };\n        int[] wt = { 2, 1 };\n        int capacity = 3;\n        Console.WriteLine(knapSack(capacity, val, wt));\n    }\n}\n// JavaScript program to implement\n// unbounded knapsack problem using memoization.\n\nfunction knapSackRecur(i, capacity, val, wt, memo) {\n    if (i === val.length) return 0;\n\n    // If value is memoized.\n    if (memo[i][capacity] !== -1) return memo[i][capacity];\n\n    // Consider current item only if \n    // its weight is less than equal \n    // to maximum weight.\n    let take = 0;\n    if (wt[i] <= capacity) {\n        take = val[i] + knapSackRecur(i, capacity - wt[i], val, wt, memo);\n    }\n\n    // Skip the current item\n    let noTake = knapSackRecur(i + 1, capacity, val, wt, memo);\n\n    // store maximum of the two and return it.\n    memo[i][capacity] = Math.max(take, noTake);\n    return memo[i][capacity];\n}\n\nfunction knapSack(capacity, val, wt) {\n    \n    // 2D matrix for memoization.\n    let memo = Array.from({ length: val.length }, () => Array(capacity + 1).fill(-1));\n    return knapSackRecur(0, capacity, val, wt, memo);\n}\n\nconst val = [1, 1];\nconst wt = [2, 1];\nconst capacity = 3;\nconsole.log(knapSack(capacity, val, wt));\n3\n// C++ program to implement\n// unbounded knapsack problem using tabulation\n#include <bits/stdc++.h>\nusing namespace std;\n\nint knapSack(int capacity, vector<int> &val, vector<int> &wt) {\n\n    // 2D matrix for tabulation.\n    vector<vector<int>> dp(val.size() + 1, vector<int>(capacity + 1, 0));\n\n    // Calculate maximum profit for each\n    // item index and knapsack weight.\n    for (int i = val.size() - 1; i >= 0; i--) {\n        for (int j = 1; j <= capacity; j++) {\n\n            int take = 0;\n            if (j - wt[i] >= 0) {\n                take = val[i] + dp[i][j - wt[i]];\n            }\n            int noTake = dp[i + 1][j];\n\n            dp[i][j] = max(take, noTake);\n        }\n    }\n\n    return dp[0][capacity];\n}\n\nint main() {\n  \n    vector<int> val = {1, 1}, wt = {2, 1};\n    int capacity = 3;\n    cout << knapSack(capacity, val, wt);\n}\n// Java program to implement\n// unbounded knapsack problem using tabulation\n\nclass GfG {\n\n    static int knapSack(int capacity, int[] val, int[] wt) {\n\n        // 2D matrix for tabulation.\n        int[][] dp = new int[val.length + 1][capacity + 1];\n\n        // Calculate maximum profit for each\n        // item index and knapsack weight.\n        for (int i = val.length - 1; i >= 0; i--) {\n            for (int j = 1; j <= capacity; j++) {\n\n                int take = 0;\n                if (j - wt[i] >= 0) {\n                    take = val[i] + dp[i][j - wt[i]];\n                }\n                int noTake = dp[i + 1][j];\n\n                dp[i][j] = Math.max(take, noTake);\n            }\n        }\n\n        return dp[0][capacity];\n    }\n\n    public static void main(String[] args) {\n      \n        int[] val = { 1, 1 };\n        int[] wt = { 2, 1 };\n        int capacity = 3;\n        System.out.println(knapSack(capacity, val, wt));\n    }\n}\n# Python program to implement\n# unbounded knapsack problem using tabulation\n\ndef knapSack(capacity, val, wt):\n    \n    # 2D matrix for tabulation.\n    dp = [[0 for _ in range(capacity + 1)] for _ in range(len(val) + 1)]\n\n    # Calculate maximum profit for each \n    # item index and knapsack weight.\n    for i in range(len(val) - 1, -1, -1):\n        for j in range(1, capacity + 1):\n\n            take = 0\n            if j - wt[i] >= 0:\n                take = val[i] + dp[i][j - wt[i]]\n            noTake = dp[i + 1][j]\n\n            dp[i][j] = max(take, noTake)\n\n    return dp[0][capacity]\n\nif __name__ == \"__main__\":\n    val = [1, 1]\n    wt = [2, 1]\n    capacity = 3\n    print(knapSack(capacity, val, wt))\n// C# program to implement\n// unbounded knapsack problem using tabulation\n\nusing System;\n\nclass GfG {\n\n    static int knapSack(int capacity, int[] val, int[] wt) {\n        \n        // 2D matrix for tabulation.\n        int[,] dp = new int[val.Length + 1, capacity + 1];\n\n        // Calculate maximum profit for each \n        // item index and knapsack weight.\n        for (int i = val.Length - 1; i >= 0; i--) {\n            for (int j = 1; j <= capacity; j++) {\n\n                int take = 0;\n                if (j - wt[i] >= 0) {\n                    take = val[i] + dp[i, j - wt[i]];\n                }\n                int noTake = dp[i + 1, j];\n\n                dp[i, j] = Math.Max(take, noTake);\n            }\n        }\n\n        return dp[0, capacity];\n    }\n\n    static void Main() {\n        int[] val = {1, 1};\n        int[] wt = {2, 1};\n        int capacity = 3;\n        Console.WriteLine(knapSack(capacity, val, wt));    \n    }\n}\n// JavaScript program to implement\n// unbounded knapsack problem using tabulation\n\nfunction knapSack(capacity, val, wt) {\n    \n    // 2D matrix for tabulation.\n    let dp = Array.from({ length: val.length + 1 }, () => Array(capacity + 1).fill(0));\n\n    // Calculate maximum profit for each \n    // item index and knapsack weight.\n    for (let i = val.length - 1; i >= 0; i--) {\n        for (let j = 1; j <= capacity; j++) {\n\n            let take = 0;\n            if (j - wt[i] >= 0) {\n                take = val[i] + dp[i][j - wt[i]];\n            }\n            let noTake = dp[i + 1][j];\n\n            dp[i][j] = Math.max(take, noTake);\n        }\n    }\n\n    return dp[0][capacity];\n}\n\nconst val = [1, 1];\nconst wt = [2, 1];\nconst capacity = 3;\nconsole.log(knapSack(capacity, val, wt));\n3\n// C++ program to implement\n// unbounded knapsack problem using space optimised\n#include <bits/stdc++.h>\nusing namespace std;\n\nint knapSack(int capacity, vector<int> &val, vector<int> &wt) {\n\n    // 1D matrix for tabulation.\n    vector<int> dp(capacity + 1, 0);\n\n    // Calculate maximum profit for each\n    // item index and knapsack weight.\n    for (int i = val.size() - 1; i >= 0; i--) {\n        for (int j = 1; j <= capacity; j++) {\n\n            int take = 0;\n            if (j - wt[i] >= 0) {\n                take = val[i] + dp[j - wt[i]];\n            }\n            int noTake = dp[j];\n\n            dp[j] = max(take, noTake);\n        }\n    }\n\n    return dp[capacity];\n}\n\nint main() {\n  \n    vector<int> val = {1, 1}, wt = {2, 1};\n    int capacity = 3;\n    cout << knapSack(capacity, val, wt);\n}\n// Java program to implement\n// unbounded knapsack problem using space optimised\n\nclass GfG {\n\n    static int knapSack(int capacity, int[] val, int[] wt) {\n\n        // 1D matrix for tabulation.\n        int[] dp = new int[capacity + 1];\n\n        // Calculate maximum profit for each\n        // item index and knapsack weight.\n        for (int i = val.length - 1; i >= 0; i--) {\n            for (int j = 1; j <= capacity; j++) {\n\n                int take = 0;\n                if (j - wt[i] >= 0) {\n                    take = val[i] + dp[j - wt[i]];\n                }\n                int noTake = dp[j];\n\n                dp[j] = Math.max(take, noTake);\n            }\n        }\n\n        return dp[capacity];\n    }\n\n    public static void main(String[] args) {\n      \n        int[] val = { 1, 1 };\n        int[] wt = { 2, 1 };\n        int capacity = 3;\n        System.out.println(knapSack(capacity, val, wt));\n    }\n}\n# Python program to implement\n# unbounded knapsack problem using space optimised\n\ndef knapSack(capacity, val, wt):\n\n    # 1D matrix for tabulation.\n    dp = [0] * (capacity + 1)\n\n    # Calculate maximum profit for each\n    # item index and knapsack weight.\n    for i in range(len(val) - 1, -1, -1):\n        for j in range(1, capacity + 1):\n\n            take = 0\n            if j - wt[i] >= 0:\n                take = val[i] + dp[j - wt[i]]\n            noTake = dp[j]\n\n            dp[j] = max(take, noTake)\n\n    return dp[capacity]\n\n\nif __name__ == \"__main__\":\n    val = [1, 1]\n    wt = [2, 1]\n    capacity = 3\n    print(knapSack(capacity, val, wt))\n// C# program to implement\n// unbounded knapsack problem using space optimised\n\nusing System;\n\nclass GfG {\n\n    static int knapSack(int capacity, int[] val, int[] wt) {\n\n        // 1D matrix for tabulation.\n        int[] dp = new int[capacity + 1];\n\n        // Calculate maximum profit for each\n        // item index and knapsack weight.\n        for (int i = val.Length - 1; i >= 0; i--) {\n            for (int j = 1; j <= capacity; j++) {\n\n                int take = 0;\n                if (j - wt[i] >= 0) {\n                    take = val[i] + dp[j - wt[i]];\n                }\n                int noTake = dp[j];\n\n                dp[j] = Math.Max(take, noTake);\n            }\n        }\n\n        return dp[capacity];\n    }\n\n    static void Main() {\n        int[] val = { 1, 1 };\n        int[] wt = { 2, 1 };\n        int capacity = 3;\n        Console.WriteLine(knapSack(capacity, val, wt));\n    }\n}\n// JavaScript program to implement\n// unbounded knapsack problem using space optimised\n\nfunction knapSack(capacity, val, wt) {\n    \n    // 1D matrix for tabulation.\n    let dp = Array(capacity + 1).fill(0);\n\n    // Calculate maximum profit for each \n    // item index and knapsack weight.\n    for (let i = val.length - 1; i >= 0; i--) {\n        for (let j = 1; j <= capacity; j++) {\n\n            let take = 0;\n            if (j - wt[i] >= 0) {\n                take = val[i] + dp[j - wt[i]];\n            }\n            let noTake = dp[j];\n\n            dp[j] = Math.max(take, noTake);\n        }\n    }\n\n    return dp[capacity];\n}\n\nconst val = [1, 1];\nconst wt = [2, 1];\nconst capacity = 3;\nconsole.log(knapSack(capacity, val, wt));\n3\n",
        "complexity": {
            "time": "",
            "space": ""
        },
        "tags": [
            "Dynamic Programming"
        ],
        "url": "https://www.geeksforgeeks.org/unbounded-knapsack-repetition-items-allowed/"
    },
    {
        "title": "Subset Sum Problem",
        "description": "Given an array arr[] of non-negative integers and a value sum, the task is to check if there is a subset of the given array whose sum is equal to the given sum. Examples: Input: arr[] = [3, 34, 4, 12, 5, 2], sum = 9Output: TrueExplanation: There is a subset (4, 5) with sum 9. Input: arr[] = [3, 34, 4, 12, 5, 2], sum = 30Output: FalseExplanation: There is no subset that add up to 30. Table of Content For the recursive approach, there will be two cases (In both cases, the number of available elements decreases by 1) Mathematically the recurrence relation will look like the following: isSubsetSum(arr, n, sum) = isSubsetSum(arr, n-1, sum) OR isSubsetSum(arr, n-1, sum – arr[n-1]) Base Cases: Follow the below steps to implement the recursion: If we notice carefully, we can observe that the above recursive solution holds the following two properties of Dynamic Programming. 1. Optimal Substructure: The solution to the subset sum problem can be derived from the optimal solutions of smaller subproblems. Specifically, for any given n (the number of elements considered) and a target sum, we can express the recursive relation as follows: If the last element is less than or equal to sum, we have two choices: 2. Overlapping Subproblems: When implementing a recursive approach to solve the subset sum problem, we observe that many subproblems are computed multiple times. For instance, when computing isSubsetSum(arr, sum), where arr[] = {2,3,1,1} and sum = 4 we might need to compute isSubsetSum(1,3) multiple times. Overlapping subproblems The approach is similar to the previous one. just instead of breaking down the problem recursively, we iteratively build up the solution by calculating in bottom-up manner. So we will create a 2D array of size (n + 1) * (sum + 1) of type boolean. The state dp[i][j] will be true if there exists a subset of elements from arr[0 . . . i] with sum = ‘j’. The dynamic programming relation is as follows: if (arr[i-1] > j)    dp[i][j] = dp[i-1][j]else     dp[i][j] = dp[i-1][j] OR dp[i-1][j-arr[i-1]] This means that if the current element has a value greater than the ‘current sum value’ we will copy the answer for previous cases and if the current sum value is greater than the ‘ith’ element we will see if any of the previous states have already computed the sum= j OR any previous states computed a value ‘j – arr[i]’ which will solve our purpose. In previous approach of dynamic programming we have derive the relation between states as given below: if (arr[i-1] > j)    dp[i][j] = dp[i-1][j]else     dp[i][j] = dp[i-1][j] OR dp[i-1][j-arr[i-1]] If we observe that for calculating current dp[i][j] state we only need previous row dp[i-1][j] or dp[i-1][j-arr[i-1]]. There is no need to store all the previous states just one previous state is used to compute result. Approach: Related articles:  ",
        "code": "//C++ implementation for subset sum\n// problem using recursion\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Function to check if there is a subset\n// with the given sum using recursion\nbool isSubsetSumRec(vector<int>& arr, int n, int sum) {\n  \n    // Base Cases\n    if (sum == 0)\n        return true;\n    if (n == 0)\n        return false;\n\n    // If last element is greater than sum,\n    // then ignore it\n    if (arr[n - 1] > sum)\n        return isSubsetSumRec(arr, n - 1, sum);\n\n    // Check if sum can be obtained by including \n  \t// or excluding the last element\n    return isSubsetSumRec(arr, n - 1, sum) \n      \t\t|| isSubsetSumRec(arr, n - 1, sum - arr[n - 1]);\n}\n\nbool isSubsetSum(vector<int>& arr, int sum) {\n    return isSubsetSumRec(arr, arr.size(), sum);\n}\n\nint main() {\n  \n    vector<int> arr = {3, 34, 4, 12, 5, 2};\n    int sum = 9;\n\n    if (isSubsetSum(arr, sum))\n        cout << \"True\" << endl;\n    else\n        cout << \"False\" << endl;\n\n    return 0;\n}\n//C implementation for subset sum\n// problem using recursion\n#include <stdio.h>\n\n// Function to check if there is a subset\n// with the given sum using recursion\nint isSubsetSumRec(int arr[], int n, int sum) {\n  \n    // Base Cases\n    if (sum == 0) {\n        return 1;\n    }\n    if (n == 0) {\n        return 0;\n    }\n\n    // If last element is greater than sum, ignore it\n    if (arr[n - 1] > sum) {\n        return isSubsetSumRec(arr, n - 1, sum);\n    }\n\n    // Check if sum can be obtained by including\n    // or excluding the last element\n    return isSubsetSumRec(arr, n - 1, sum) || \n           isSubsetSumRec(arr, n - 1, sum - arr[n - 1]);\n}\n\nint isSubsetSum(int arr[], int n, int sum) {\n    return isSubsetSumRec(arr, n, sum);\n}\n\nint main() {\n    int arr[] = {3, 34, 4, 12, 5, 2};\n    int sum = 9;\n    int n = sizeof(arr) / sizeof(arr[0]);\n\n    if (isSubsetSum(arr, n, sum)) {\n        printf(\"True\\n\");\n    } else {\n        printf(\"False\\n\");\n    }\n\n    return 0;\n}\n//Java implementation for subset sum\n// problem using recursion\nimport java.util.*;\n\nclass GfG {\n\n    // Function to check if there is a subset\n    // with the given sum using recursion\n   \tstatic boolean isSubsetSumRec(int[] arr, int n, int sum) {\n      \n        // Base Cases\n        if (sum == 0) {\n            return true;\n        }\n        if (n == 0) {\n            return false;\n        }\n\n        // If last element is greater than \n      \t// sum, ignore it\n        if (arr[n - 1] > sum) {\n            return isSubsetSumRec(arr, n - 1, sum);\n        }\n\n        // Check if sum can be obtained by including \n      \t// or excluding the last element\n        return isSubsetSumRec(arr, n - 1, sum) || \n               isSubsetSumRec(arr, n - 1, sum - arr[n - 1]);\n    }\n\n    static boolean isSubsetSum(int[] arr, int sum) {\n        return isSubsetSumRec(arr, arr.length, sum);\n    }\n\n    public static void main(String[] args) {\n      \n        int[] arr = {3, 34, 4, 12, 5, 2};\n        int sum = 9;\n\n        if (isSubsetSum(arr, sum)) {\n            System.out.println(\"True\");\n        } else {\n            System.out.println(\"False\");\n        }\n    }\n}\n# Python implementation for subset sum\n# problem using recursion\ndef isSubsetSumRec(arr, n, sum):\n  \n    # Base Cases\n    if sum == 0:\n        return True \n    if n == 0:\n        return False\n\n    # If the last element is greater\n    # than the sum, ignore it\n    if arr[n - 1] > sum:\n        return isSubsetSumRec(arr, n - 1, sum)\n\n    # Check if sum can be obtained by including\n    # or excluding the last element\n    return (isSubsetSumRec(arr, n - 1, sum) or \n            isSubsetSumRec(arr, n - 1, sum - arr[n - 1]))\n\ndef isSubsetSum(arr, sum):\n    return isSubsetSumRec(arr, len(arr), sum)\n\nif __name__ == \"__main__\":\n  \n    arr = [3, 34, 4, 12, 5, 2]\n    sum = 9\n\n    if isSubsetSum(arr, sum):\n        print(\"True\")\n    else:\n        print(\"False\")\n// C# implementation for subset sum\n// problem using recursion\nusing System;\n\nclass GfG {\n  \n    // Function to check if there is a subset\n    // with the given sum using recursion\n    static bool isSubsetSumRec(int[] arr, int n, int sum) {\n      \n        // Base Cases\n        if (sum == 0)\n            return true; \n        if (n == 0)\n            return false;\n\n        // If the last element is greater than the sum,\n        // ignore it\n        if (arr[n - 1] > sum)\n            return isSubsetSumRec(arr, n - 1, sum);\n\n        // Check if sum can be obtained by including\n        // or excluding the last element\n        return isSubsetSumRec(arr, n - 1, sum)\n            || isSubsetSumRec(arr, n - 1, sum - arr[n - 1]);\n    }\n\n    static bool isSubsetSum(int[] arr, int sum) {\n      \n        return isSubsetSumRec(arr, arr.Length, sum);\n    }\n\n    static void Main(string[] args) {\n      \n        int[] arr = { 3, 34, 4, 12, 5, 2 };\n        int sum = 9;\n\n        if (isSubsetSum(arr, sum))\n            Console.WriteLine(\"True\");\n        else\n            Console.WriteLine(\"False\");\n    }\n}\n// Javascript implementation for subset sum\n// problem using recursion\nfunction isSubsetSumRec(arr, n, sum) {\n\n    // Base Cases\n    if (sum === 0) return true;\n    if (n === 0) return false;    \n\n    // If the last element is greater than\n    // the sum, ignore it\n    if (arr[n - 1] > sum) {\n        return isSubsetSumRec(arr, n - 1, sum);\n    }\n\n    // Check if sum can be obtained by including\n    // or excluding the last element\n    return isSubsetSumRec(arr, n - 1, sum) || \n           isSubsetSumRec(arr, n - 1, sum - arr[n - 1]);\n}\n\nfunction isSubsetSum(arr, sum) {\n    return isSubsetSumRec(arr, arr.length, sum);\n}\n\n// Driver code \nconst arr = [3, 34, 4, 12, 5, 2];\nconst sum = 9;\n\nif (isSubsetSum(arr, sum)) {\n    console.log(\"True\");\n} else {\n    console.log(\"False\");\n}\nTrue\n//C++ implementation for subset sum\n// problem using memoization\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Recursive function to check if a subset \n// with the given sum exists\nbool isSubsetSumRec(vector<int>& arr, int n, int sum,\n                   vector<vector<int>> &memo) {\n  \n    // If the sum is zero, we found a subset\n    if (sum == 0)\n        return 1;\n\n    // If no elements are left\n    if (n <= 0)\n        return 0;\n\n    // If the value is already\n  \t// computed, return it\n    if (memo[n][sum] != -1)\n        return memo[n][sum];\n\n    // If the last element is greater than\n  \t// the sum, ignore it\n    if (arr[n - 1] > sum)\n        return memo[n][sum] = isSubsetSumRec(arr, n - 1, sum, memo);\n    else {\n      \n        // Include or exclude the last element\n        return memo[n][sum] = isSubsetSumRec(arr, n - 1, sum, memo) ||\n                              isSubsetSumRec(arr, n - 1, sum - arr[n - 1], memo);\n    }\n}\n\n// Function to initiate the subset sum check\nbool isSubsetSum(vector<int>&arr, int sum) {\n   int n = arr.size();\n\n    vector<vector<int>> memo(n + 1, vector<int>(sum + 1, -1));\n    return isSubsetSumRec(arr, n, sum, memo);\n}\n\nint main() {\n  \n    vector<int>arr = {1, 5, 3, 7, 4};\n    int sum = 12;\n\n    if (isSubsetSum(arr, sum)) {\n        cout << \"True\" << endl;\n    }\n    else {\n        cout << \"False\" << endl;\n    }\n\n    return 0;\n}\n//Java implementation for subset sum\n// problem using memoization\nimport java.util.Arrays;\n\nclass GfG {\n\n    // Recursive function to check if a subset\n    // with the given sum exists\n    static boolean isSubsetSumRec(int[] arr, int n, int sum,\n                                  int[][] memo) {\n\n        // If the sum is zero, we found a subset\n        if (sum == 0) {\n            return true;\n        }\n\n        // If no elements are left\n        if (n <= 0) {\n            return false;\n        }\n\n        // If the value is already computed, return it\n        if (memo[n][sum] != -1) {\n            return memo[n][sum] == 1;\n        }\n\n        // If the last element is greater than the sum,\n        // ignore it\n        if (arr[n - 1] > sum) {\n            memo[n][sum] = isSubsetSumRec(arr, n - 1, sum, memo) \n              \t\t \t? 1 : 0;\n        }\n        else {\n\n            // Include or exclude the last element directly\n            memo[n][sum] = (isSubsetSumRec(arr, n - 1, sum, memo)\n\t\t\t\t\t|| isSubsetSumRec(arr, n - 1, sum - arr[n - 1], memo))\n                      ? 1 : 0;\n        }\n\n        return memo[n][sum] == 1;\n    }\n\n    // Function to initiate the subset sum check\n    static boolean isSubsetSum(int[] arr, int sum) {\n        int n = arr.length;\n        int[][] memo = new int[n + 1][sum + 1];\n        for (int[] row : memo) {\n            Arrays.fill(row, -1);\n        }\n        return isSubsetSumRec(arr, n, sum, memo);\n    }\n\n    public static void main(String[] args) {\n      \n        int[] arr = { 1, 5, 3, 7, 4 };\n        int sum = 12;\n\n        if (isSubsetSum(arr, sum)) {\n            System.out.println(\"True\");\n        }\n        else {\n            System.out.println(\"False\");\n        }\n    }\n}\n# Python implementation for subset sum\n# problem using memoization\ndef isSubsetSumRec(arr, n, sum, memo):\n\n    # If the sum is zero, we found \n    # a subset\n    if sum == 0:\n        return True\n\n    # If no elements are left\n    if n <= 0:\n        return False\n\n    # If the value is already \n    # computed, return it\n    if memo[n][sum] != -1:\n        return memo[n][sum]\n\n    # If the last element is greater \n    # than the sum, ignore it\n    if arr[n - 1] > sum:\n        memo[n][sum] = isSubsetSumRec(arr, n - 1, sum, memo)\n    else:\n      \n        # Include or exclude the last element\n        # directly\n        memo[n][sum] = (isSubsetSumRec(arr, n - 1, sum, memo)\n                        or isSubsetSumRec(arr, n - 1, sum - arr[n - 1], memo))\n\n    return memo[n][sum]\n\n\ndef isSubsetSum(arr, sum):\n    n = len(arr)\n    memo = [[-1 for _ in range(sum + 1)] for _ in range(n + 1)]\n    return isSubsetSumRec(arr, n, sum, memo)\n\n\nif __name__ == \"__main__\":\n    arr = [1, 5, 3, 7, 4]\n    sum = 12\n\n    if isSubsetSum(arr, sum):\n        print(\"True\")\n    else:\n        print(\"False\")\n//C# implementation for subset sum\n// problem using memoization\nusing System;\n\nclass GfG {\n\n    // Recursive function to check if a subset with\n    // the given sum exists\n    static bool isSubsetSumRec(int[] arr, int n, int sum,\n                               int[, ] memo) {\n\n        // If the sum is zero, we found a subset\n        if (sum == 0)\n            return true;\n\n        // If no elements are left\n        if (n <= 0)\n            return false;\n\n        // If the value is already computed,\n        // return it\n        if (memo[n, sum] != -1)\n            return memo[n, sum] == 1;\n\n        // If the last element is greater\n        // than the sum, ignore it\n        if (arr[n - 1] > sum)\n            memo[n, sum]\n                = isSubsetSumRec(arr, n - 1, sum, memo) ? 1\n                                                        : 0;\n        else {\n\n            // Include or exclude the last element directly\n            memo[n, sum]\n                = (isSubsetSumRec(arr, n - 1, sum, memo)\n                   || isSubsetSumRec(arr, n - 1, sum - arr[n - 1], memo))\n                      ? 1 : 0;\n        }\n\n        return memo[n, sum] == 1;\n    }\n\n    // Function to initiate the subset sum check\n    static bool isSubsetSum(int[] arr, int sum) {\n      \n        int n = arr.Length;\n        int[, ] memo = new int[n + 1, sum + 1];\n        for (int i = 0; i <= n; i++)\n            for (int j = 0; j <= sum; j++)\n                memo[i, j] = -1;\n\n        return isSubsetSumRec(arr, n, sum, memo);\n    }\n\n    static void Main() {\n\n        int[] arr = { 1, 5, 3, 7, 4 };\n        int sum = 12;\n\n        if (isSubsetSum(arr, sum))\n            Console.WriteLine(\"True\");\n        else\n            Console.WriteLine(\"False\");\n    }\n}\n//Javascript implementation for subset sum\n// problem using memoization\nfunction isSubsetSumRec(arr, n, sum, memo) {\n\n    // If the sum is zero, we found a subset\n    if (sum === 0) return true;\n\n    // If no elements are left\n    if (n <= 0) return false;\n\n    // If the value is already computed,\n    // return it\n    if (memo[n][sum] !== -1) return memo[n][sum] === 1;\n\n    // If the last element is greater than\n    // the sum, ignore it\n    if (arr[n - 1] > sum) {\n        memo[n][sum] = isSubsetSumRec(arr, n - 1, sum, memo) ? 1 : 0;\n    } else {\n    \n        // Include or exclude the last element directly\n        memo[n][sum] = (isSubsetSumRec(arr, n - 1, sum, memo) || \n                        isSubsetSumRec(arr, n - 1, sum - arr[n - 1], memo))\n                        ? 1 : 0;\n    }\n\n    return memo[n][sum] === 1;\n}\n\n// Function to initiate the subset sum check\nfunction isSubsetSum(arr, sum) {\n    const n = arr.length;\n    const memo = Array.from(Array(n + 1), () => Array(sum + 1).fill(-1));\n    return isSubsetSumRec(arr, n, sum, memo);\n}\n\nconst arr = [1, 5, 3, 7, 4];\nconst sum = 12;\n\nif (isSubsetSum(arr, sum)) {\n    console.log(\"True\");\n} else {\n    console.log(\"False\");\n}\nTrue\n//C++ implementation for subset sum\n// problem using tabulation\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Function to check if there is a subset of arr[]\n// with sum equal to the given sum using tabulation with vectors\nbool isSubsetSum(vector<int> &arr, int sum) {\n    int n = arr.size();\n\n    // Create a 2D vector for storing results\n  \t// of subproblems\n    vector<vector<bool>> dp(n + 1, vector<bool>(sum + 1, false));\n\n    // If sum is 0, then answer is true (empty subset)\n    for (int i = 0; i <= n; i++)\n        dp[i][0] = true;\n\n    // Fill the dp table in bottom-up manner\n    for (int i = 1; i <= n; i++) {\n      \n        for (int j = 1; j <= sum; j++) {\n            if (j < arr[i - 1]) {\n              \n               // Exclude the current element\n                dp[i][j] = dp[i - 1][j]; \n            }\n            else {\n              \n               // Include or exclude\n                dp[i][j] = dp[i - 1][j] \n                || dp[i - 1][j - arr[i - 1]];\n            }\n        }\n    }\n\n    return dp[n][sum];\n}\n\nint main() {\n\n    vector<int> arr = {3, 34, 4, 12, 5, 2};\n    int sum = 9;\n\n    if (isSubsetSum(arr, sum))\n        cout << \"True\" << endl;\n    else\n        cout << \"False\" << endl;\n\n    return 0;\n}\n//Java implementation for subset sum\n// problem using tabulation\nimport java.util.*;\n\nclass GfG {\n\n    // Function to check if there is a subset of arr[]\n    // with sum equal to the given sum using tabulation\n   \tstatic boolean isSubsetSum(int[] arr, int sum) {\n        int n = arr.length;\n\n        // Create a 2D array for storing results of\n        // subproblems\n        boolean[][] dp = new boolean[n + 1][sum + 1];\n\n        // If sum is 0, then answer is true\n      \t// (empty subset)\n        for (int i = 0; i <= n; i++) {\n            dp[i][0] = true;\n        }\n\n        // Fill the dp table in bottom-up manner\n        for (int i = 1; i <= n; i++) {\n            for (int j = 1; j <= sum; j++) {\n                if (j < arr[i - 1]) {\n                  \n                    // Exclude the current element\n                    dp[i][j] = dp[i - 1][j];\n                }\n                else {\n                  \n                    // Include or exclude\n                    dp[i][j] = dp[i - 1][j]\n                               || dp[i - 1][j - arr[i - 1]];\n                }\n            }\n        }\n\n        return dp[n][sum];\n    }\n\n    public static void main(String[] args) {\n      \n        int[] arr = { 3, 34, 4, 12, 5, 2 };\n        int sum = 9;\n\n        if (isSubsetSum(arr, sum)) {\n            System.out.println(\"True\");\n        }\n        else {\n            System.out.println(\"False\");\n        }\n    }\n}\n# Python implementation for subset sum\n# problem using tabulation\ndef isSubsetSum(arr, sum):\n    n = len(arr)\n\n    # Create a 2D list for storing \n    # results of subproblems\n    dp = [[False] * (sum + 1) for _ in range(n + 1)]\n\n    # If sum is 0, then answer is \n    # true (empty subset)\n    for i in range(n + 1):\n        dp[i][0] = True\n\n    # Fill the dp table in bottom-up manner\n    for i in range(1, n + 1):\n        for j in range(1, sum + 1):\n            if j < arr[i - 1]:\n                \n                # Exclude the current element\n                dp[i][j] = dp[i - 1][j]\n            else:\n                \n                # Include or exclude\n                dp[i][j] = dp[i - 1][j] or dp[i - 1][j - arr[i - 1]]\n\n    return dp[n][sum]\n\n\nif __name__ == \"__main__\":\n    arr = [3, 34, 4, 12, 5, 2]\n    sum_value = 9\n\n    if isSubsetSum(arr, sum_value):\n        print(\"True\")\n    else:\n        print(\"False\")\n//C# implementation for subset sum\n// problem using tabulation\nusing System;\n\nclass GfG {\n  \n    // Function to check if there is a subset of arr[]\n    // with sum equal to the given sum using tabulation\n    static bool isSubsetSum(int[] arr, int sum) {\n        int n = arr.Length;\n\n        // Create a 2D array for storing results of\n        // subproblems\n        bool[, ] dp = new bool[n + 1, sum + 1];\n\n        // If sum is 0, then answer is true\n      \t// (empty subset)\n        for (int i = 0; i <= n; i++)\n            dp[i, 0] = true;\n\n        // Fill the dp table in bottom-up manner\n        for (int i = 1; i <= n; i++) {\n            for (int j = 1; j <= sum; j++) {\n                if (j < arr[i - 1]) {\n                  \n                    // Exclude the current element\n                    dp[i, j] = dp[i - 1, j];\n                }\n                else {\n                  \n                    // Include or exclude\n                    dp[i, j] = dp[i - 1, j]\n                               || dp[i - 1, j - arr[i - 1]];\n                }\n            }\n        }\n\n        return dp[n, sum];\n    }\n\n    static void Main(string[] args) {\n      \n        int[] arr = { 3, 34, 4, 12, 5, 2 };\n        int sum = 9;\n\n        if (isSubsetSum(arr, sum))\n            Console.WriteLine(\"True\");\n        else\n            Console.WriteLine(\"False\");\n    }\n}\n//Javascript implementation for subset sum\n// problem using tabulation\nfunction isSubsetSum(arr, sum) {\n    const n = arr.length;\n\n    // Create a 2D array for storing results\n    // of subproblems\n    const dp = Array.from(Array(n + 1), () => Array(sum + 1).fill(false));\n\n    // If sum is 0, then answer is\n    // true (empty subset)\n    for (let i = 0; i <= n; i++) {\n        dp[i][0] = true;\n    }\n\n    // Fill the dp table in bottom-up manner\n    for (let i = 1; i <= n; i++) {\n        for (let j = 1; j <= sum; j++) {\n            if (j < arr[i - 1]) {\n            \n                // Exclude the current element\n                dp[i][j] = dp[i - 1][j];\n            } else {\n            \n                // Include or exclude\n                dp[i][j] = dp[i - 1][j] \n                || dp[i - 1][j - arr[i - 1]];\n            }\n        }\n    }\n\n    return dp[n][sum];\n}\n\n// Driver code\nconst arr = [3, 34, 4, 12, 5, 2];\nconst sum = 9;\n\nif (isSubsetSum(arr, sum)) {\n    console.log(\"True\");\n} else {\n    console.log(\"False\");\n}\nTrue\n// C++ Program for Space Optimized Dynamic Programming\n// Solution to Subset Sum Problem\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Returns true if there is a subset of arr[]\n// with sum equal to given sum\nbool isSubsetSum(vector<int> arr, int sum) {\n    int n = arr.size();\n    vector<bool> prev(sum + 1, false), curr(sum + 1);\n\n    // Mark prev[0] = true as it is true\n  \t// to make sum = 0 using 0 elements\n    prev[0] = true;\n\n    // Fill the subset table in\n  \t// bottom up manner\n    for (int i = 1; i <= n; i++) {\n        for (int j = 0; j <= sum; j++) {\n            if (j < arr[i - 1])\n                curr[j] = prev[j];\n            else\n                curr[j] = (prev[j] || prev[j - arr[i - 1]]);\n        }\n        prev = curr;\n    }\n    return prev[sum];\n}\n\nint main() {\n    vector<int> arr = {3, 34, 4, 12, 5, 2};\n    int sum = 9;\n    if (isSubsetSum(arr, sum) == true)\n        cout << \"True\";\n    else\n        cout << \"False\";\n    return 0;\n}\n// Java Program for Space Optimized Dynamic Programming\n// Solution to Subset Sum Problem\nimport java.util.Arrays;\n\nclass GfG {\n\n    // Returns true if there is a subset of arr[]\n    // with sum equal to given sum\n    static boolean isSubsetSum(int[] arr, int sum) {\n        int n = arr.length;\n        boolean[] prev = new boolean[sum + 1];\n        boolean[] curr = new boolean[sum + 1];\n\n        // Mark prev[0] = true as it is true to\n        // make sum = 0 using 0 elements\n        prev[0] = true;\n\n        // Fill the subset table in bottom-up\n        // manner\n        for (int i = 1; i <= n; i++) {\n            for (int j = 0; j <= sum; j++) {\n                if (j < arr[i - 1]) {\n                    curr[j] = prev[j];\n                }\n                else {\n                    curr[j]\n                        = prev[j] || prev[j - arr[i - 1]];\n                }\n            }\n\n            // Update prev to be the current row\n            System.arraycopy(curr, 0, prev, 0, sum + 1);\n        }\n        return prev[sum];\n    }\n\n    public static void main(String[] args) {\n        int[] arr = { 3, 34, 4, 12, 5, 2 };\n        int sum = 9;\n        if (isSubsetSum(arr, sum)) {\n            System.out.println(\"True\");\n        }\n        else {\n            System.out.println(\"False\");\n        }\n    }\n}\n# Python Program for Space Optimized Dynamic Programming\n# Solution to Subset Sum Problem\ndef isSubsetSum(arr, sum):\n    n = len(arr)\n    prev = [False] * (sum + 1)\n    curr = [False] * (sum + 1)\n\n    # Base case: sum 0 can always \n    # be achieved\n    prev[0] = True\n\n    # Fill the dp table in a\n    # bottom-up manner\n    for i in range(1, n + 1):\n        for j in range(sum + 1):\n            if j < arr[i - 1]:\n                curr[j] = prev[j]\n            else:\n                curr[j] = prev[j] or prev[j - arr[i - 1]]\n        prev = curr.copy() \n\n    return prev[sum]\n\nif __name__ == \"__main__\":\n    arr = [3, 34, 4, 12, 5, 2]\n    sum_value = 9\n    if isSubsetSum(arr, sum_value):\n        print(\"True\")\n    else:\n        print(\"False\")\n// C# Program for Space Optimized Dynamic Programming\n// Solution to Subset Sum Problem\nusing System;\n\nclass GfG {\n    static bool isSubsetSum(int[] arr, int sum) {\n        int n = arr.Length;\n        bool[] prev = new bool[sum + 1];\n        bool[] curr = new bool[sum + 1];\n\n        // Base case: sum 0 can \n      \t// always be achieved\n        prev[0] = true;\n\n        // Fill the dp table in a \n      \t// bottom-up manner\n        for (int i = 1; i <= n; i++) {\n            for (int j = 0; j <= sum; j++) {\n                if (j < arr[i - 1])\n                    curr[j] = prev[j];\n                else\n                    curr[j]\n                        = prev[j] || prev[j - arr[i - 1]];\n            }\n            Array.Copy(curr, prev,\n                       sum + 1);\n        }\n        return prev[sum];\n    }\n\n    static void Main() {\n        int[] arr = { 3, 34, 4, 12, 5, 2 };\n        int sum = 9;\n        if (isSubsetSum(arr, sum))\n            Console.WriteLine(\"True\");\n        else\n            Console.WriteLine(\"False\");\n    }\n}\n// Javascript Program for Space Optimized Dynamic Programming\n// Solution to Subset Sum Problem\nfunction isSubsetSum(arr, sum) {\n    const n = arr.length;\n    const prev = new Array(sum + 1).fill(false);\n    const curr = new Array(sum + 1).fill(false);\n\n    // Base case: sum 0 can always\n    // be achieved\n    prev[0] = true;\n\n    // Fill the dp table in a \n    // bottom-up manner\n    for (let i = 1; i <= n; i++) {\n        for (let j = 0; j <= sum; j++) {\n            if (j < arr[i - 1]) {\n                curr[j] = prev[j];\n            } else {\n                curr[j] = prev[j] || prev[j - arr[i - 1]];\n            }\n        }\n        \n        // Update prev to be the current row\n        for (let j = 0; j <= sum; j++) {\n            prev[j] = curr[j];\n        }\n    }\n    return prev[sum];\n}\n\n// Driver code \nconst arr = [3, 34, 4, 12, 5, 2];\nconst sum = 9;\nif (isSubsetSum(arr, sum)) {\n    console.log(\"True\");\n} else {\n    console.log(\"False\");\n}\nTrue\n",
        "complexity": {
            "time": "",
            "space": ""
        },
        "tags": [
            "Dynamic Programming"
        ],
        "url": "https://www.geeksforgeeks.org/subset-sum-problem-dp-25/"
    },
    {
        "title": "Longest Common Subsequence (LCS)",
        "description": "Given two strings, s1 and s2, the task is to find the length of the Longest Common Subsequence. If there is no common subsequence, return 0. A subsequence is a string generated from the original string by deleting 0 or more characters, without changing the relative order of the remaining characters. For example, subsequences of “ABC” are “”, “A”, “B”, “C”, “AB”, “AC”, “BC” and “ABC”.  In general, a string of length n has 2n subsequences. Examples: Input: s1 = “ABC”, s2 = “ACD”Output: 2Explanation: The longest subsequence which is present in both strings is “AC”. Input: s1 = “AGGTAB”, s2 = “GXTXAYB”Output: 4Explanation: The longest common subsequence is “GTAB”. Input: s1 = “ABC”, s2 = “CBA”Output: 1Explanation: There are three longest common subsequences of length 1, “A”, “B” and “C”. Table of Content The idea is to compare the last characters of s1 and s2. While comparing the strings s1 and s2 two cases arise: Base case : If any of the strings become empty, we return 0. For example, consider the input strings s1 = “ABX” and  s2 = “ACX”. LCS(“ABX”, “ACX”) = 1 + LCS(“AB”, “AC”) [Last Characters Match] LCS(“AB”, “AC”) = max( LCS(“A”, “AC”) , LCS(“AB”, “A”) ) [Last Characters Do Not Match] LCS(“A”, “AC”) = max( LCS(“”, “AC”) , LCS(“A”, “A”) ) = max(0, 1 + LCS(“”, “”)) = 1 LCS(“AB”, “A”) = max( LCS(“A”, “A”) , LCS(“AB”, “”) ) = max( 1 + LCS(“”, “”, 0)) = 1 So overall result is 1 + 1 = 2 To optimize the recursive solution, we use a 2D memoization table of size (m+1)×(n+1)(m+1) \\times (n+1)(m+1)×(n+1), initialized to −1-1−1 to track computed values. Before making recursive calls, we check this table to avoid redundant computations of overlapping subproblems. This prevents repeated calculations, improving efficiency through memoization or tabulation. Overlapping Subproblems in Longest Common Subsequence There are two parameters that change in the recursive solution and these parameters go from 0 to m and 0 to n. So we create a 2D dp array of size (m+1) x (n+1). Say the strings are S1 = “AXTY” and S2 = “AYZX”, Follow below : One important observation in the above simple implementation is, in each iteration of the outer loop we only need values from all columns of the previous row. So there is no need to store all rows in our DP matrix, we can just store two rows at a time and use them. We can further optimize to use only one array. Please refer this post: A Space Optimized Solution of LCS LCS is used to implement diff utility (find the difference between two data sources).  It is also widely used by revision control systems such as Git for multiple changes made to a revision-controlled collection of files.   ",
        "code": "// A Naive recursive implementation of LCS problem\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Returns length of LCS for s1[0..m-1], s2[0..n-1]\nint lcsRec(string &s1, string &s2,int m,int n) {\n    \n    // Base case: If either string is empty, the length of LCS is 0\n    if (m == 0 || n == 0)\n        return 0;\n\n    // If the last characters of both substrings match\n    if (s1[m - 1] == s2[n - 1])\n      \n        // Include this character in LCS and recur for remaining substrings\n        return 1 + lcsRec(s1, s2, m - 1, n - 1);\n\n    else\n        // If the last characters do not match\n        // Recur for two cases:\n        // 1. Exclude the last character of s1 \n        // 2. Exclude the last character of s2 \n        // Take the maximum of these two recursive calls\n        return max(lcsRec(s1, s2, m, n - 1), lcsRec(s1, s2, m - 1, n));\n}\nint lcs(string &s1,string &s2){\n    \n    int m = s1.size(), n = s2.size();\n    return lcsRec(s1,s2,m,n);\n}\n\nint main() {\n    string s1 = \"AGGTAB\";\n    string s2 = \"GXTXAYB\";\n    int m = s1.size();\n    int n = s2.size();\n\n    cout << lcs(s1, s2) << endl;\n\n    return 0;\n}\n// A Naive recursive implementation of LCS problem\n#include <stdio.h>\n#include <string.h>\n\nint max(int x, int y) {\n  \treturn x > y ? x : y; \n}\n\n// Returns length of LCS for s1[0..m-1], s2[0..n-1]\nint lcsRec(char s1[], char s2[], int m, int n) {\n\n    // Base case: If either string is empty, the length of LCS is 0\n    if (m == 0 || n == 0)\n        return 0;\n\n    // If the last characters of both substrings match\n    if (s1[m - 1] == s2[n - 1])\n\n        // Include this character in LCS and recur for remaining substrings\n        return 1 + lcsRec(s1, s2, m - 1, n - 1);\n\n    else\n        // If the last characters do not match\n        // Recur for two cases:\n        // 1. Exclude the last character of S1 \n        // 2. Exclude the last character of S2 \n        // Take the maximum of these two recursive calls\n        return max(lcsRec(s1, s2, m, n - 1), lcsRec(s1, s2, m - 1, n));\n}\nint lcs(char s1[],char s2[]){\n    int m = strlen(s1);\n    int n = strlen(s2);\n    \n    return lcsRec(s1,s2,m,n);\n}\n\nint main() {\n    char s1[] = \"AGGTAB\";\n    char s2[] = \"GXTXAYB\";\n    printf(\"%d\\n\", lcs(s1, s2));\n    return 0;\n}\n// A Naive recursive implementation of LCS problem\nclass GfG {\n\n    // Returns length of LCS for s1[0..m-1], s2[0..n-1]\n    static int lcsRec(String s1, String s2, int m, int n) {\n\n        // Base case: If either string is empty, the length of LCS is 0\n        if (m == 0 || n == 0)\n            return 0;\n\n        // If the last characters of both substrings match\n        if (s1.charAt(m - 1) == s2.charAt(n - 1))\n\n            // Include this character in LCS and recur for remaining substrings\n            return 1 + lcsRec(s1, s2, m - 1, n - 1);\n\n        else\n            // If the last characters do not match\n            // Recur for two cases:\n            // 1. Exclude the last character of S1 \n            // 2. Exclude the last character of S2 \n            // Take the maximum of these two recursive calls\n            return Math.max(lcsRec(s1, s2, m, n - 1), lcsRec(s1, s2, m - 1, n));\n    }\n    static int lcs(String s1,String s2){\n        int m = s1.length(), n = s2.length();\n        return lcsRec(s1,s2,m,n);\n    }\n    public static void main(String[] args) {\n        String s1 = \"AGGTAB\";\n        String s2 = \"GXTXAYB\";\n        System.out.println(lcs(s1, s2));\n    }\n}\n# A Naive recursive implementation of LCS problem\n\n# Returns length of LCS for s1[0..m-1], s2[0..n-1]\ndef lcsRec(s1, s2, m, n):\n  \n    # Base case: If either string is empty, the length of LCS is 0\n    if m == 0 or n == 0:\n        return 0\n\n    # If the last characters of both substrings match\n    if s1[m - 1] == s2[n - 1]:\n\n        # Include this character in LCS and recur for remaining substrings\n        return 1 + lcsRec(s1, s2, m - 1, n - 1)\n\n    else:\n        # If the last characters do not match\n        # Recur for two cases:\n        # 1. Exclude the last character of S1 \n        # 2. Exclude the last character of S2 \n        # Take the maximum of these two recursive calls\n        return max(lcsRec(s1, s2, m, n - 1), lcsRec(s1, s2, m - 1, n))\n\ndef lcs(s1,s2):\n    m = len(s1)\n    n = len(s2)\n    return lcsRec(s1,s2,m,n)\n\nif __name__ == \"__main__\":\n    s1 = \"AGGTAB\"\n    s2 = \"GXTXAYB\"\n    print(lcs(s1, s2))\n// A Naive recursive implementation of LCS problem\nusing System;\n\nclass GfG {\n\n    // Returns length of LCS for s1[0..m-1], s2[0..n-1]\n    static int lcsRec(string s1, string s2, int m, int n) {\n\n        // Base case: If either string is empty, the length of LCS is 0\n        if (m == 0 || n == 0)\n            return 0;\n\n        // If the last characters of both substrings match\n        if (s1[m - 1] == s2[n - 1])\n\n            // Include this character in LCS and recur for remaining substrings\n            return 1 + lcsRec(s1, s2, m - 1, n - 1);\n\n        else\n            // If the last characters do not match\n            // Recur for two cases:\n            // 1. Exclude the last character of S1 \n            // 2. Exclude the last character of S2 \n            // Take the maximum of these two recursive calls\n            return Math.Max(lcsRec(s1, s2, m, n - 1), lcsRec(s1, s2, m - 1, n));\n    }\n    static int lcs(string s1,string s2){\n        int m = s1.Length , n = s2.Length; \n        return lcsRec(s1,s2,m,n);\n    }\n    static void Main() {\n        string s1 = \"AGGTAB\";\n        string s2 = \"GXTXAYB\";\n        Console.WriteLine(lcs(s1, s2));\n    }\n}\n// A Naive recursive implementation of LCS problem\n\n// Returns length of LCS for s1[0..m-1], s2[0..n-1]\nfunction lcsRec(s1, s2, m, n) {\n  \n    // Base case: If either string is empty, the length of LCS is 0\n    if (m === 0 || n === 0)\n        return 0;\n\n    // If the last characters of both substrings match\n    if (s1[m - 1] === s2[n - 1])\n\n        // Include this character in LCS and recur for remaining substrings\n        return 1 + lcsRec(s1, s2, m - 1, n - 1);\n\n    else\n        return Math.max(lcsRec(s1, s2, m, n - 1), lcsRec(s1, s2, m - 1, n));\n}\nfunction lcs(s1,s2){\n    \n    let m = s1.length;\n    let n = s2.length;\n    return lcsRec(s1,s2,m,n);\n}\n\n// driver code\nlet s1 = \"AGGTAB\";\nlet s2 = \"GXTXAYB\";\nlet m = s1.length;\nlet n = s2.length;\n\nconsole.log(lcs(s1, s2, m, n));\n4\n// C++ implementation of Top-Down DP\n// of LCS problem\n#include <bits/stdc++.h>\nusing namespace std;\n// Returns length of LCS for s1[0..m-1], s2[0..n-1]\nint lcsRec(string &s1, string &s2, int m, int n, vector<vector<int>> &memo) {\n\n    // Base Case\n    if (m == 0 || n == 0)\n        return 0;\n\n    // Already exists in the memo table\n    if (memo[m][n] != -1)\n        return memo[m][n];\n\n    // Match\n    if (s1[m - 1] == s2[n - 1])\n        return memo[m][n] = 1 + lcsRec(s1, s2, m - 1, n - 1, memo);\n\n    // Do not match\n    return memo[m][n] = max(lcsRec(s1, s2, m, n - 1, memo), lcsRec(s1, s2, m - 1, n, memo));\n}\nint lcs(string &s1,string &s2){\n    int m = s1.length();\n    int n = s2.length();\n    vector<vector<int>> memo(m + 1, vector<int>(n + 1, -1));\n    return lcsRec(s1, s2, m, n, memo);\n}\n\nint main() {\n    string s1 = \"AGGTAB\";\n    string s2 = \"GXTXAYB\";\n    cout << lcs(s1, s2) << endl;\n    return 0;\n}\n// C implementation of Top-Down DP\n// of LCS problem\n#include <stdio.h>\n#include <string.h>\n\n// Define a maximum size for the strings\n#define MAX 1000\n\n// Function to find the maximum of two integers\nint max(int a, int b) {\n    return (a > b) ? a : b;\n}\n\n// Returns length of LCS for s1[0..m-1], s2[0..n-1]\nint lcsRec(const char *s1, const char *s2, int m, int n, int memo[MAX][MAX]) {\n  \n    // Base Case\n    if (m == 0 || n == 0) {\n        return 0;\n    }\n\n    // Already exists in the memo table\n    if (memo[m][n] != -1) {\n        return memo[m][n];\n    }\n\n    // Match\n    if (s1[m - 1] == s2[n - 1]) {\n        return memo[m][n] = 1 + lcsRec(s1, s2, m - 1, n - 1, memo);\n    }\n\n    // Do not match\n    return memo[m][n] = max(lcsRec(s1, s2, m, n - 1, memo), lcsRec(s1, s2, m - 1, n, memo));\n}\n\nint lcs(char s1[],char s2[]){\n      int m = strlen(s1);\n    int n = strlen(s2);\n\n    // Create memo table with fixed size\n    int memo[MAX][MAX];\n    for (int i = 0; i <= m; i++) {\n        for (int j = 0; j <= n; j++) {\n            // Initialize memo table with -1\n            memo[i][j] = -1;\n        }\n    }\n\n    return lcsRec(s1, s2, m, n, memo);\n}\n\nint main() {\n    const char *s1 = \"AGGTAB\";\n    const char *s2 = \"GXTXAYB\";\n\n  \n    printf(\"%d\\n\", lcs(s1, s2));\n\n    return 0;\n}\n// Java implementation of Top-Down DP of LCS problem\nimport java.util.Arrays;\n\nclass GfG {\n  \n    // Returns length of LCS for s1[0..m-1], s2[0..n-1]\n    static int lcsRec(String s1, String s2, int m, int n,\n                   int[][] memo) {\n        // Base Case\n        if (m == 0 || n == 0)\n            return 0;\n\n        // Already exists in the memo table\n        if (memo[m][n] != -1)\n            return memo[m][n];\n\n        // Match\n        if (s1.charAt(m - 1) == s2.charAt(n - 1)) {\n            return memo[m][n]\n                = 1 + lcsRec(s1, s2, m - 1, n - 1, memo);\n        }\n\n        // Do not match\n        return memo[m][n]\n            = Math.max(lcsRec(s1, s2, m, n - 1, memo),\n                       lcsRec(s1, s2, m - 1, n, memo));\n    }\n    static int lcs(String s1, String s2){\n        int m = s1.length();\n        int n = s2.length();\n        int[][] memo = new int[m + 1][n + 1];\n\n        // Initialize the memo table with -1\n        for (int i = 0; i <= m; i++) {\n            Arrays.fill(memo[i], -1);\n        }\n\n        return lcsRec(s1, s2, m, n, memo);\n    } \n    public static void main(String[] args) {\n        String s1 = \"AGGTAB\";\n        String s2 = \"GXTXAYB\";\n\n        System.out.println(lcs(s1, s2));\n    }\n}\ndef lcsRec(s1, s2, m, n, memo):\n    # Base Case\n    if m == 0 or n == 0:\n        return 0\n\n    # Already exists in the memo table\n    if memo[m][n] != -1:\n        return memo[m][n]\n\n    # Match\n    if s1[m - 1] == s2[n - 1]:\n        memo[m][n] = 1 + lcsRec(s1, s2, m - 1, n - 1, memo)\n        return memo[m][n]\n\n    # Do not match\n    memo[m][n] = max(lcsRec(s1, s2, m, n - 1, memo),\n                     lcsRec(s1, s2, m - 1, n, memo))\n    return memo[m][n]\n\n\ndef lcs(s1, s2):\n    m = len(s1)\n    n = len(s2)\n    memo = [[-1 for _ in range(n + 1)] for _ in range(m + 1)]\n    return lcsRec(s1,s2,m,n,memo)\n    \nif __name__ == \"__main__\":\n    s1 = \"AGGTAB\"\n    s2 = \"GXTXAYB\"\n    print(lcs(s1, s2))\n// C# implementation of Top-Down DP of LCS problem\nusing System;\nclass GfG {\n\n    // Returns length of LCS for s1[0..m-1], s2[0..n-1]\n    static int lcsRec(string s1, string s2, int m,\n                          int n, int[, ] memo) {\n        // Base Case\n        if (m == 0 || n == 0)\n            return 0;\n\n        // Already exists in the memo table\n        if (memo[m, n] != -1)\n            return memo[m, n];\n\n        // Match\n        if (s1[m - 1] == s2[n - 1]) {\n            return memo[m, n]\n                = 1 + lcsRec(s1, s2, m - 1, n - 1, memo);\n        }\n\n        // Do not match\n        return memo[m, n]\n            = Math.Max(lcsRec(s1, s2, m, n - 1, memo),\n                       lcsRec(s1, s2, m - 1, n, memo));\n    }\n    \n    static int lcs(string s1,string s2){\n        int m = s1.Length;\n        int n = s2.Length;\n        \n        int[, ] memo = new int[m + 1, n + 1];\n\n        // Initialize memo array with -1\n        for (int i = 0; i <= m; i++) {\n            for (int j = 0; j <= n; j++) {\n                memo[i, j] = -1;\n            }\n        }\n        \n        return lcsRec(s1,s2,m,n,memo);\n    }\n\n    public static void Main() {\n        string s1 = \"AGGTAB\";\n        string s2 = \"GXTXAYB\";\n        \n        Console.WriteLine(lcs(s1, s2));\n    }\n}\n// A Top-Down DP implementation of LCS problem\n\n// Returns length of LCS for s1[0..m-1], s2[0..n-1]\nfunction lcsRec(s1, s2, m, n, memo)\n{\n    // Base Case\n    if (m === 0 || n === 0)\n        return 0;\n\n    // Already exists in the memo table\n    if (memo[m][n] !== -1)\n        return memo[m][n];\n\n    // Match\n    if (s1[m - 1] === s2[n - 1]) {\n        memo[m][n] = 1 + lcsRec(s1, s2, m - 1, n - 1, memo);\n        return memo[m][n];\n    }\n\n    // Do not match\n    memo[m][n] = Math.max(lcsRec(s1, s2, m, n - 1, memo),\n                          lcsRec(s1, s2, m - 1, n, memo));\n    return memo[m][n];\n}\n\nfunction lcs(s1, s2)\n{\n\n    const m = s1.length;\n    const n = s2.length;\n    const memo = Array.from({length : m + 1},\n                            () => Array(n + 1).fill(-1));\n\n    return lcsRec(s1, s2, m, n, memo);\n}\n// driver code\nconst s1 = \"AGGTAB\";\nconst s2 = \"GS1TS1AS2B\";\n\nconsole.log(lcs(s1, s2));\n4\n#include <iostream>\n#include <vector>\nusing namespace std;\n\n// Returns length of LCS for s1[0..m-1], s2[0..n-1]\nint lcs(string &s1, string &s2) {\n    int m = s1.size();\n    int n = s2.size();\n\n    // Initializing a matrix of size (m+1)*(n+1)\n    vector<vector<int>> dp(m + 1, vector<int>(n + 1, 0));\n\n    // Building dp[m+1][n+1] in bottom-up fashion\n    for (int i = 1; i <= m; ++i) {\n        for (int j = 1; j <= n; ++j) {\n            if (s1[i - 1] == s2[j - 1])\n                dp[i][j] = dp[i - 1][j - 1] + 1;\n            else\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);\n        }\n    }\n\n    // dp[m][n] contains length of LCS for s1[0..m-1]\n    // and s2[0..n-1]\n    return dp[m][n];\n}\n\nint main() {\n    string s1 = \"AGGTAB\";\n    string s2 = \"GXTXAYB\";\n    cout << lcs(s1, s2) << endl;\n\n    return 0;\n}\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint max(int x, int y);\n\n// Function to find length of LCS for s1[0..m-1], s2[0..n-1]\nint lcs(const char *S1, const char *S2) {\n    int m = strlen(S1);\n    int n = strlen(S2);\n\n    // Initializing a matrix of size (m+1)*(n+1)\n    int dp[m + 1][n + 1];\n\n    // Building dp[m+1][n+1] in bottom-up fashion\n    for (int i = 0; i <= m; i++) {\n        for (int j = 0; j <= n; j++) {\n          \n            if (i == 0 || j == 0)\n                dp[i][j] = 0;\n            \n            else if (S1[i - 1] == S2[j - 1])\n                dp[i][j] = dp[i - 1][j - 1] + 1;\n\n            else\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);\n        }\n    }\n   \n    return dp[m][n];\n}\n\nint max(int x, int y) {\n    return (x > y) ? x : y;\n}\n\nint main() {\n    const char *S1 = \"AGGTAB\";\n    const char *S2 = \"GXTXAYB\";\n    printf(\"%d\\n\", lcs(S1, S2));\n\n    return 0;\n}\nimport java.util.Arrays;\n\nclass GfG {\n  \n    // Returns length of LCS for s1[0..m-1], s2[0..n-1]\n    static int lcs(String S1, String S2) {\n        int m = S1.length();\n        int n = S2.length();\n\n        // Initializing a matrix of size (m+1)*(n+1)\n        int[][] dp = new int[m + 1][n + 1];\n\n        // Building dp[m+1][n+1] in bottom-up fashion\n        for (int i = 1; i <= m; i++) {\n            for (int j = 1; j <= n; j++) {\n                if (S1.charAt(i - 1) == S2.charAt(j - 1)) {\n                    dp[i][j] = dp[i - 1][j - 1] + 1;\n                }\n                else {\n                    dp[i][j] = Math.max(dp[i - 1][j],\n                                        dp[i][j - 1]);\n                }\n            }\n        }\n\n        // dp[m][n] contains length of LCS for S1[0..m-1]\n        // and S2[0..n-1]\n        return dp[m][n];\n    }\n\n  \n    public static void main(String[] args)\n    {\n        String S1 = \"AGGTAB\";\n        String S2 = \"GXTXAYB\";\n        System.out.println( lcs(S1, S2));\n    }\n}\ndef lcs(S1, S2):\n    m = len(S1)\n    n = len(S2)\n\n    # Initializing a matrix of size (m+1)*(n+1)\n    dp = [[0] * (n + 1) for x in range(m + 1)]\n\n    # Building dp[m+1][n+1] in bottom-up fashion\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if S1[i - 1] == S2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j],\n                               dp[i][j - 1])\n\n    # dp[m][n] contains length of LCS for S1[0..m-1]\n    # and S2[0..n-1]\n    return dp[m][n]\n\n\nif __name__ == \"__main__\":\n    S1 = \"AGGTAB\"\n    S2 = \"GXTXAYB\"\n    print(lcs(S1, S2))\nusing System;\n\nclass GfG {\n    // Returns length of LCS for S1[0..m-1], S2[0..n-1]\n    static int lcs(string S1, string S2) {\n        int m = S1.Length;\n        int n = S2.Length;\n\n        // Initializing a matrix of size (m+1)*(n+1)\n        int[, ] dp = new int[m + 1, n + 1];\n\n        // Building dp[m+1][n+1] in bottom-up fashion\n        for (int i = 1; i <= m; i++) {\n            for (int j = 1; j <= n; j++) {\n                if (S1[i - 1] == S2[j - 1]) {\n                    dp[i, j] = dp[i - 1, j - 1] + 1;\n                }\n                else {\n                    dp[i, j] = Math.Max(dp[i - 1, j],\n                                        dp[i, j - 1]);\n                }\n            }\n        }\n\n        // dp[m, n] contains length of LCS for S1[0..m-1]\n        // and S2[0..n-1]\n        return dp[m, n];\n    }\n\n    static void Main() {\n        string S1 = \"AGGTAB\";\n        string S2 = \"GXTXAYB\";\n        Console.WriteLine(lcs(S1, S2));\n    }\n}\nfunction lcs(S1, S2) {\n    const m = S1.length;\n    const n = S2.length;\n\n    // Initializing a matrix of size (m+1)*(n+1)\n    const dp = Array.from({length : m + 1},\n                          () => Array(n + 1).fill(0));\n\n    // Building dp[m+1][n+1] in bottom-up fashion\n    for (let i = 1; i <= m; i++) {\n        for (let j = 1; j <= n; j++) {\n            if (S1[i - 1] === S2[j - 1]) {\n                dp[i][j] = dp[i - 1][j - 1] + 1;\n            }\n            else {\n                dp[i][j]\n                    = Math.max(dp[i - 1][j], dp[i][j - 1]);\n            }\n        }\n    }\n\n    // dp[m][n] contains length of LCS for\n    // S1[0..m-1] and S2[0..n-1]\n    return dp[m][n];\n}\n\nconst S1 = \"AGGTAB\";\nconst S2 = \"GXTXAYB\";\nconsole.log(lcs(S1, S2));\n4\n",
        "complexity": {
            "time": "",
            "space": ""
        },
        "tags": [
            "Dynamic Programming"
        ],
        "url": "https://www.geeksforgeeks.org/longest-common-subsequence-dp-4/"
    },
    {
        "title": "Longest Increasing Subsequence (LIS)",
        "description": "Given an array arr[] of size n, the task is to find the length of the Longest Increasing Subsequence (LIS) i.e., the longest possible subsequence in which the elements of the subsequence are sorted in increasing order. Examples: Input: arr[] = [3, 10, 2, 1, 20]Output: 3Explanation: The longest increasing subsequence is 3, 10, 20Input: arr[] = [30, 20, 10]Output:1Explanation: The longest increasing subsequences are [30], [20] and [10] Input: arr[] = [2, 2, 2]Output: 1Explanation:  We consider only strictly increasing. Input: arr[] = [10, 20, 35, 80]Output: 4Explanation: The whole array is sorted Table of Content The idea to do traverse the input array from left to right and find length of the Longest Increasing Subsequence (LIS) ending with every element arr[i].  Let the length found for arr[i] be L[i]. At the end we return maximum of all L[i] values. Now to compute L[i], we use recursion, we consider all smaller elements on left of arr[i], recursively compute LIS value for all the smaller elements on left, take the maximum of all and add 1 to it.  If there is no smaller element on left of an element, we return 1. Let L(i) be the length of the LIS ending at index i such that arr[i] is the last element of the LIS. Then, L(i) can be recursively written as: Formally, the length of LIS ending at index i, is 1 greater than the maximum of lengths of all LIS ending at some index prev such that arr[prev] < arr[i] where prev < i. After we fill the L array, we find LIS as maximum of all in L[] Overall LIS =  max(L[i])  where 0 <= i < n We can see that the above recurrence relation follows the optimal substructure property. Follow the below illustration to see overlapping subproblems. Consider arr[] = [3, 10, 2, 11] L(i): Denotes LIS of subarray ending at position ‘i’ Recursion Tree If notice carefully, we can see that the above recursive function lisEndingAtIdx() also follows the overlapping subproblems property i.e., same substructure solved again and again in different recursion call paths. We can avoid this using the memoization approach. Since there is only one parameter that changes in recursive calls and the range of the parameter goes from 0 to n-1,  so we us a 1D array of size n and initialize it as -1 to indicate that the values are not computed yet. The tabulation approach for finding the Longest Increasing Subsequence (LIS) solves the problem iteratively in a bottom-up manner. The idea is to maintain a 1D array lis[], where lis[i] stores the length of the longest increasing subsequence that ends at index i. Initially, each element in lis[] is set to 1, as the smallest possible subsequence for any element is the element itself. The algorithm then iterates over each element of the array. For each element arr[i], it checks all previous elements arr[0] to arr[i-1]. If arr[i] is greater than arr[prev] (ensuring the subsequence is increasing), it updates lis[i] to the maximum of its current value or lis[prev] + 1, indicating that we can extend the subsequence ending at arr[prev] by including arr[i]. Finally, the length of the longest increasing subsequence is the maximum value in the lis[] array.  We can solve this in O(n Log n) time using Binary Search. The idea is to traverse the given sequence and maintain a separate list of sorted subsequence so far. For every new element, find its position in the sorted subsequence using Binary Search. Refer Longest Increasing Subsequence Size (N * logN) for details.   ",
        "code": "// Cpp program to find lis using recursion\n// in Exponential Time and Linear Space\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Returns LIS of subarray ending with index i.\nint lisEndingAtIdx(vector<int>& arr, int idx) {\n  \n    // Base case\n    if (idx == 0)\n        return 1;\n\n    // Consider all elements on the left of i,\n    // recursively compute LISs ending with \n    // them and consider the largest\n    int mx = 1;\n    for (int prev = 0; prev < idx; prev++)\n        if (arr[prev] < arr[idx])\n            mx = max(mx, lisEndingAtIdx(arr, prev) + 1);\n    return mx;\n}\n\nint lis(vector<int>& arr) {\n    int n = arr.size();\n    int res = 1;\n    for (int i = 1; i < n; i++)\n        res = max(res, lisEndingAtIdx(arr, i));\n    return res;\n}\n\nint main() {\n    vector<int> arr = { 10, 22, 9, 33, 21, 50, 41, 60 };\n    cout << lis(arr);\n    return 0;\n}\n// Java program to find lis using recursion\n// in Exponential Time and Linear Space\nimport java.util.*;\n\nclass GfG {\n    static int lisEndingAtIdx(int[] arr, int idx) {\n      \n        // Base case\n        if (idx == 0)\n            return 1;\n\n        // Consider all elements on the left of i,\n        // recursively compute LISs ending with \n        // them and consider the largest\n        int mx = 1;\n        for (int prev = 0; prev < idx; prev++)\n            if (arr[prev] < arr[idx])\n                mx = Math.max(mx, lisEndingAtIdx(arr, prev) + 1);\n        return mx;\n    }\n\n    static int lis(int[] arr) {\n        int n = arr.length;\n        int res = 1;\n        for (int idx = 1; idx < n; idx++)\n            res = Math.max(res, lisEndingAtIdx(arr, idx));\n        return res;\n    }\n\n    public static void main(String[] args) {\n        int[] arr = { 10, 22, 9, 33, 21, 50, 41, 60 };\n        System.out.println(lis(arr));\n    }\n}\n# Python program to find lis using recursion\n# in Exponential Time and Linear Space\ndef lisEndingAtIdx(arr, idx):\n  \n    # Base case\n    if idx == 0:\n        return 1\n\n    # Consider all elements on the left of i,\n    # recursively compute LISs ending with \n    # them and consider the largest\n    mx = 1\n    for prev in range(idx):\n        if arr[prev] < arr[idx]:\n            mx = max(mx, lisEndingAtIdx(arr, prev) + 1)\n    return mx\n\ndef lis(arr):\n    n = len(arr)\n    res = 1\n    for idx in range(1, n):\n        res = max(res, lisEndingAtIdx(arr, idx))\n    return res\n\nif __name__ == \"__main__\":\n    arr = [10, 22, 9, 33, 21, 50, 41, 60]\n    print(lis(arr))\n// C# program to find lis using recursion\n// in Exponential Time and Linear Space\nusing System;\nusing System.Collections.Generic;\n\nclass GfG {\n    static int lisEndingAtIdx(List<int> arr, int idx) {\n        // Base case\n        if (idx == 0)\n            return 1;\n\n        // Consider all elements on the left of i,\n        // recursively compute LISs ending with \n        // them and consider the largest\n        int mx = 1;\n        for (int prev = 0; prev < idx; prev++)\n            if (arr[prev] < arr[idx])\n                mx = Math.Max(mx, lisEndingAtIdx(arr, prev) + 1);\n        return mx;\n    }\n\n    static int lis(List<int> arr) {\n        int n = arr.Count;\n        int res = 1;\n        for (int idx = 1; idx < n; idx++)\n            res = Math.Max(res, lisEndingAtIdx(arr, idx));\n        return res;\n    }\n\n    static void Main(string[] args) {\n        List<int> arr = new List<int> { 10, 22, 9, 33, 21, 50, 41, 60 };\n        Console.WriteLine(lis(arr));\n    }\n}\n// JavaScript program to find lis using recursion\n// in Exponential Time and Linear Space\nfunction lisEndingAtIdx(arr, idx) {\n\n    // Base case\n    if (idx === 0)\n        return 1;\n\n    // Consider all elements on the left of i,\n    // recursively compute LISs ending with\n    // them and consider the largest\n    let mx = 1;\n    for (let prev = 0; prev < idx; prev++) {\n        if (arr[prev] < arr[idx]) {\n            mx = Math.max(mx,\n                          lisEndingAtIdx(arr, prev) + 1);\n        }\n    }\n    return mx;\n}\n\nfunction lis(arr) {\n    let n = arr.length;\n    let res = 1;\n    for (let idx = 1; idx < n; idx++) {\n        res = Math.max(res, lisEndingAtIdx(arr, idx));\n    }\n    return res;\n}\n\nlet arr = [ 10, 22, 9, 33, 21, 50, 41, 60 ];\nconsole.log(lis(arr));\n5\n#include <bits/stdc++.h>\nusing namespace std;\n\nint lisEndingAtIdx(vector<int>& arr, int idx, vector<int>& memo) {\n  \n    // Base case\n    if (idx == 0)\n        return 1;\n\n    // Check if the result is already computed\n    if (memo[idx] != -1)\n        return memo[idx];\n\n    // Consider all elements on left of i,\n    // recursively compute LISs ending with \n    // them and consider the largest\n    int mx = 1;\n    for (int prev = 0; prev < idx; prev++)\n        if (arr[prev] < arr[idx])\n            mx = max(mx, lisEndingAtIdx(arr, prev, memo) + 1);\n\n    // Store the result in the memo array\n    memo[idx] = mx;\n    return memo[idx];\n}\n\nint lis(vector<int>& arr) {\n    \n    int n = arr.size();\n  \n    vector<int> memo(n, -1);\n  \n    int res = 1;\n    for (int i = 1; i < n; i++)\n        res = max(res, lisEndingAtIdx(arr, i, memo));\n    return res;\n}\n\nint main() {\n    vector<int> arr = { 10, 22, 9, 33, 21, 50, 41, 60 };\n    cout << lis(arr);\n    return 0;\n}\nimport java.util.*;\n\nclass GfG {\n    static int lisEndingAtIdx(int[] arr, int idx, int[] memo) {\n      \n        // Base case\n        if (idx == 0)\n            return 1;\n\n        // Check if the result is already computed\n        if (memo[idx] != -1)\n            return memo[idx];\n\n        // Consider all elements on left of i,\n        // recursively compute LISs ending with \n        // them and consider the largest\n        int mx = 1;\n        for (int prev = 0; prev < idx; prev++)\n            if (arr[prev] < arr[idx])\n                mx = Math.max(mx, lisEndingAtIdx(arr, prev, memo) + 1);\n\n        // Store the result in the memo array\n        memo[idx] = mx;\n        return memo[idx];\n    }\n\n    static int lis(int[] arr) {\n        int n = arr.length;\n      \n        int[] memo = new int[n];\n        Arrays.fill(memo, -1);\n      \n        int res = 1;\n        for (int idx = 1; idx < n; idx++)\n            res = Math.max(res, lisEndingAtIdx(arr, idx, memo));\n        return res;\n    }\n\n    public static void main(String[] args) {\n        int[] arr = {10, 22, 9, 33, 21, 50, 41, 60};\n        System.out.println(lis(arr));\n    }\n}\ndef lisEndingAtIdx(arr, idx, memo):\n  \n    # Base case\n    if idx == 0:\n        return 1\n\n    # Check if the result is already computed\n    if memo[idx] != -1:\n        return memo[idx]\n\n    # Consider all elements on left of i,\n    # recursively compute LISs ending with \n    # them and consider the largest\n    mx = 1\n    for prev in range(idx):\n        if arr[prev] < arr[idx]:\n            mx = max(mx, lisEndingAtIdx(arr, prev, memo) + 1)\n\n    # Store the result in the memo array\n    memo[idx] = mx\n    return memo[idx]\n\ndef lis(arr):\n    n = len(arr)\n\n    memo = [-1] * n\n  \n    res = 1\n    for idx in range(1, n):\n        res = max(res, lisEndingAtIdx(arr, idx, memo))\n    return res\n\nif __name__ == \"__main__\":\n    arr = [10, 22, 9, 33, 21, 50, 41, 60]\n    print(lis(arr))\nusing System;\nusing System.Collections.Generic;\n\nclass GfG {\n    static int lisEndingAtIdx(List<int> arr, int idx, int[] memo) {\n      \n        // Base case\n        if (idx == 0)\n            return 1;\n\n        // Check if the result is already computed\n        if (memo[idx] != -1)\n            return memo[idx];\n\n        // Consider all elements on left of i,\n        // recursively compute LISs ending with \n        // them and consider the largest\n        int mx = 1;\n        for (int prev = 0; prev < idx; prev++)\n            if (arr[prev] < arr[idx])\n                mx = Math.Max(mx, lisEndingAtIdx(arr, prev, memo) + 1);\n\n        // Store the result in the memo array\n        memo[idx] = mx;\n        return memo[idx];\n    }\n\n    static int lis(List<int> arr) {\n        int n = arr.Count;\n      \n        int[] memo = new int[n];\n        for(int i = 0; i < n; i++) {\n            memo[i] = -1;\n        }\n      \n        int res = 1;\n        for (int idx = 1; idx < n; idx++)\n            res = Math.Max(res, lisEndingAtIdx(arr, idx, memo));\n        return res;\n    }\n\n    static void Main(string[] args) {\n        List<int> arr = new List<int> {10, 22, 9, 33, 21, 50, 41, 60};\n        Console.WriteLine(lis(arr));\n    }\n}\nfunction lisEndingAtIdx(arr, idx, memo) {\n\n    // Base case\n    if (idx === 0)\n        return 1;\n\n    // Check if the result is already computed\n    if (memo[idx] !== -1)\n        return memo[idx];\n\n    // Consider all elements on left of i,\n    // recursively compute LISs ending with\n    // them and consider the largest\n    let mx = 1;\n    for (let prev = 0; prev < idx; prev++) {\n        if (arr[prev] < arr[idx]) {\n            mx = Math.max(\n                mx, lisEndingAtIdx(arr, prev, memo) + 1);\n        }\n    }\n\n    // Store the result in the memo array\n    memo[idx] = mx;\n    return memo[idx];\n}\n\nfunction lis(arr) {\n    const n = arr.length;\n\n    const memo = Array(n).fill(-1);\n\n    let res = 1;\n    for (let idx = 1; idx < n; idx++) {\n        res = Math.max(res, lisEndingAtIdx(arr, idx, memo));\n    }\n    return res;\n}\n\nconst arr = [ 10, 22, 9, 33, 21, 50, 41, 60 ];\nconsole.log(lis(arr));\n5\n#include <bits/stdc++.h>\nusing namespace std;\n\n// lis() returns the length of the longest\n// increasing subsequence in arr of size n\nint lis(vector<int>& arr) {\n    int n = arr.size();\n    vector<int> lis(n, 1);\n\n    // Compute optimized LIS values in\n    // bottom-up manner\n    for (int i = 1; i < n; i++) {\n        for (int prev = 0; prev < i; prev++) {\n            if (arr[i] > arr[prev] && lis[i] < lis[prev] + 1) {\n                lis[i] = lis[prev] + 1;\n            }\n        }\n    }\n\n    // Return maximum value in lis\n    return *max_element(lis.begin(), lis.end());\n}\n\nint main() {\n    vector<int> arr = { 10, 22, 9, 33, 21, 50, 41, 60 };\n    cout << lis(arr) << endl;\n    return 0;\n}\nimport java.lang.*;\n\nclass GfG {\n\n    // lis() returns the length of the longest\n    // increasing subsequence in arr[] of size n\n    static int lis(int arr[]) {\n        int n = arr.length;\n        \n        int lis[] = new int[n];\n      \n        // Initialize LIS values for all indexes\n        for (int i = 0; i < n; i++)\n            lis[i] = 1;\n\n        // Compute optimized LIS values in\n        // bottom up manner\n        for (int i = 1; i < n; i++)\n            for (int prev = 0; prev < i; prev++)\n                if (arr[i] > arr[prev] && lis[i] < lis[prev] + 1)\n                    lis[i] = lis[prev] + 1;\n\n        // Pick maximum of all LIS values\n        int max = 1;\n        for (int i = 0; i < n; i++)\n            max = Math.max(max, lis[i]);\n\n        return max;\n    }\n\n    public static void main(String args[]) {\n        int arr[] = { 10, 22, 9, 33, 21, 50, 41, 60 };\n        System.out.println(lis(arr));\n    }\n}\n# lis returns length of the longest\n# increasing subsequence in arr of size n\ndef lis(arr):\n    n = len(arr)\n\n    # Declare the list (array) for LIS and\n    # initialize LIS values for all indexes\n    lis = [1] * n\n\n    # Compute optimized LIS values in bottom\n    # -up manner\n    for i in range(1, n):\n        for prev in range(0, i):\n            if arr[i] > arr[prev]:\n                lis[i] = max(lis[i], lis[prev] + 1)\n\n    # Return the maximum of all LIS values\n    return max(lis)\n\nif __name__ == '__main__':\n    arr = [10, 22, 9, 33, 21, 50, 41, 60]\n    print(lis(arr))\nusing System;\n\nclass GfG {\n\n    // lis() returns the length of the longest \n    // increasing subsequence in arr[] of size n\n    static int lis(int[] arr) {\n        int n = arr.Length;\n        \n        int[] lis = new int[n];\n\n        // Initialize LIS values for all indexes\n        for (int i = 0; i < n; i++)\n            lis[i] = 1;\n\n        // Compute optimized LIS values in bottom up manner\n        for (int i = 1; i < n; i++) {\n            for (int prev = 0; prev < i; prev++) {\n                if (arr[i] > arr[prev] && lis[i] < lis[prev] + 1)\n                    lis[i] = lis[prev] + 1;\n            }\n        }\n\n        // Pick maximum of all LIS values        \n        int max = 0;\n        for (int i = 0; i < n; i++) {\n            if (max < lis[i])\n                max = lis[i];\n        }\n\n        return max;\n    }\n\n    static void Main() {\n        int[] arr = { 10, 22, 9, 33, 21, 50, 41, 60 };\n        Console.WriteLine(lis(arr));\n    }\n}\n// lis() returns the length of the longest\n// increasing subsequence in arr[] of size n\nfunction lis(arr) {\n    let n = arr.length;\n    \n    let lis = Array(n).fill(0);\n    let max = 0;\n\n    // Initialize LIS values for all indexes\n    for (let i = 0; i < n; i++)\n        lis[i] = 1;\n\n    // Compute optimized LIS values in\n    // bottom up manner \n    for (let i = 1; i < n; i++) {\n        for (let prev = 0; prev < i; prev++) {\n            if (arr[i] > arr[prev] && lis[i] < lis[prev] + 1)\n                lis[i] = lis[prev] + 1;\n        }\n    }\n\n    // Pick maximum of all LIS values \n    for (let i = 0; i < n; i++)\n        if (max < lis[i])\n            max = lis[i];\n\n    return max;\n}\n\nlet arr = [10, 22, 9, 33, 21, 50, 41, 60];\nconsole.log(lis(arr));\n5\n",
        "complexity": {
            "time": "",
            "space": ""
        },
        "tags": [
            "Dynamic Programming"
        ],
        "url": "https://www.geeksforgeeks.org/longest-increasing-subsequence-dp-3/"
    },
    {
        "title": "Coin Change – Count Ways to Make Sum",
        "description": "Given an integer array of coins[] of size n representing different types of denominations and an integer sum, the task is to count all combinations of coins to make a given value sum. Note: Assume that you have an infinite supply of each type of coin. Examples: Input: sum = 4, coins[] = [1, 2, 3]Output: 4Explanation: There are four solutions: [1, 1, 1, 1], [1, 1, 2], [2, 2] and [1, 3] Input: sum = 10, coins[] = [2, 5, 3, 6]Output: 5Explanation: There are five solutions: [2, 2, 2, 2, 2], [2, 2, 3, 3], [2, 2, 6], [2, 3, 5] and [5, 5] Input: sum = 10, coins[] = [10]Output: 1Explanation: The only is to pick 1 coin of value 10. Input: sum = 5, coins[] = [4]Output: 0Explanation:  We cannot make sum 5 with the given coins Table of Content For each coin, there are 2 options: Base cases: 1. Optimal Substructure: Number of ways to make sum at index i, i.e., count(i, sum, coins), depends on the optimal solutions of the subproblems count(i, sum-coins[i-1], coins) , and count(i+1, sum, coins). By adding these optimal substructures, we can efficiently calculate the number of ways to make target sum at index i. 2. Overlapping Subproblems: While applying a recursive approach in this problem, we notice that certain subproblems are computed multiple times. Follow the below steps to Implement the idea: The idea is to fill the DP table based on previous values. For each coin, we either include it or exclude it to compute the minimum number of coins needed for each sum. The table is filled in an iterative manner from i = 1 to i = n and for each sum from 0 to sum. The dynamic programming relation is as follows:  In previous approach of dynamic programming we have derive the relation between states as given below: If we observe that for calculating current dp[i][sum] state we only need previous row dp[i-1][sum] or current row dp[i][sum-coins[i]]. There is no need to store all the previous states just one previous state is used to compute result. Related articles:  ",
        "code": "// C++ program for coin change problem\n// using recursion\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Returns the count of ways we can\n// sum coins[0...n-1] coins to get sum \"sum\"\nint countRecur(vector<int>& coins, int n, int sum) {\n  \n    // If sum is 0 then there is 1 solution\n    // (do not include any coin)\n    if (sum == 0) return 1;\n\n    // 0 ways in the following two cases\n    if (sum < 0 || n == 0) return 0;\n\n    // count is sum of solutions (i)\n    // including coins[n-1] (ii) excluding coins[n-1]\n    return countRecur(coins, n, sum - coins[n - 1]) + \n            countRecur(coins, n - 1, sum);\n}\n\nint count(vector<int> &coins, int sum) {\n    return countRecur(coins, coins.size(), sum);\n}\n\nint main() {\n    vector<int> coins = {1, 2, 3};\n    int sum = 5;\n    cout << count(coins, sum);\n    return 0;\n}\n// Java program for coin change problem.\n// using recursion\n\nclass GfG {\n\n    static int countRecur(int[] coins, int n, int sum) {\n\n        // If sum is 0 then there is 1 solution\n        // (do not include any coin)\n        if (sum == 0) return 1;\n\n        // 0 ways in the following two cases\n        if (sum < 0 || n == 0) return 0;\n\n        // count is sum of solutions (i)\n        // including coins[n-1] (ii) excluding coins[n-1]\n        return countRecur(coins, n, sum - coins[n - 1]) +\n                countRecur(coins, n - 1, sum);\n    }\n\n    static int count(int[] coins, int sum) {\n        return countRecur(coins, coins.length, sum);\n    }\n\n    public static void main(String[] args) {\n        int[] coins = {1, 2, 3};\n        int sum = 5;\n        System.out.println(count(coins, sum));\n    }\n}\n# Python program for coin change problem.\n# using recursion\n\ndef countRecur(coins, n, sum):\n  \n    # If sum is 0 then there is 1 solution\n    # (do not include any coin)\n    if sum == 0:\n        return 1\n\n    # 0 ways in the following two cases\n    if sum < 0 or n == 0:\n        return 0\n\n    # count is sum of solutions (i)\n    # including coins[n-1] (ii) excluding coins[n-1]\n    return countRecur(coins, n, sum - coins[n - 1]) + \\\n  \t\t\tcountRecur(coins, n - 1, sum)\n\ndef count(coins, sum):\n    return countRecur(coins, len(coins), sum)\n\nif __name__ == \"__main__\":\n    coins = [1, 2, 3]\n    sum = 5\n    print(count(coins, sum))\n// C# program for coin change problem.\n// using recursion\n\nusing System;\n\nclass GfG {\n\n    static int countRecur(int[] coins, int n, int sum) {\n\n        // If sum is 0 then there is 1 solution\n        // (do not include any coin)\n        if (sum == 0) return 1;\n\n        // 0 ways in the following two cases\n        if (sum < 0 || n == 0) return 0;\n\n        // count is sum of solutions (i)\n        // including coins[n-1] (ii) excluding coins[n-1]\n        return countRecur(coins, n, sum - coins[n - 1]) +\n               countRecur(coins, n - 1, sum);\n    }\n\n    static int count(int[] coins, int sum) {\n        return countRecur(coins, coins.Length, sum);\n    }\n\n    static void Main() {\n        int[] coins = {1, 2, 3};\n        int sum = 5;\n        Console.WriteLine(count(coins, sum));\n    }\n}\n// JavaScript program for coin change problem.\n// using recursion\n\nfunction countRecur(coins, n, sum) {\n\n    // If sum is 0 then there is 1 solution\n    // (do not include any coin)\n    if (sum === 0) return 1;\n\n    // 0 ways in the following two cases\n    if (sum < 0 || n === 0) return 0;\n\n    // count is sum of solutions (i)\n    // including coins[n-1] (ii) excluding coins[n-1]\n    return countRecur(coins, n, sum - coins[n - 1]) +\n           countRecur(coins, n - 1, sum);\n}\n\nfunction count(coins, sum) {\n    return countRecur(coins, coins.length, sum);\n}\n\nconst coins = [1, 2, 3];\nconst sum = 5;\nconsole.log(count(coins, sum));\n5\n// C++ program for coin change problem\n// using memoization\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Returns the count of ways we can\n// sum coins[0...n-1] coins to get sum \"sum\"\nint countRecur(vector<int>& coins, int n, int sum, \n               vector<vector<int>> &memo) {\n  \n    // If sum is 0 then there is 1 solution\n    // (do not include any coin)\n    if (sum == 0) return 1;\n\n    // 0 ways in the following two cases\n    if (sum < 0 || n == 0) return 0;\n    \n    // If the subproblem is previously calculated then\n    // simply return the result\n    if (memo[n-1][sum]!=-1) return memo[n-1][sum];\n\n    // count is sum of solutions (i)\n    // including coins[n-1] (ii) excluding coins[n-1]\n    return memo[n-1][sum] = \n        countRecur(coins, n, sum - coins[n-1], memo) + \n        countRecur(coins, n - 1, sum, memo);\n}\n\nint count(vector<int> &coins, int sum) {\n    \n    vector<vector<int>> memo(coins.size(), vector<int>(sum+1, -1));\n    return countRecur(coins, coins.size(), sum, memo);\n}\n\nint main() {\n    vector<int> coins = {1, 2, 3};\n    int sum = 5;\n    cout << count(coins, sum);\n    return 0;\n}\n// Java program for coin change problem.\n// using memoization\nimport java.util.Arrays;\n\nclass GfG {\n\n    static int countRecur(int[] coins, int n, int sum, int[][] memo) {\n\n        // If sum is 0 then there is 1 solution\n        // (do not include any coin)\n        if (sum == 0) return 1;\n\n        // 0 ways in the following two cases\n        if (sum < 0 || n == 0) return 0;\n\n        // If the subproblem is previously calculated then\n        // simply return the result\n        if (memo[n - 1][sum] != -1) return memo[n - 1][sum];\n\n        // count is sum of solutions (i)\n        // including coins[n-1] (ii) excluding coins[n-1]\n        return memo[n - 1][sum] = \n                countRecur(coins, n, sum - coins[n - 1], memo) + \n                countRecur(coins, n - 1, sum, memo);\n    }\n\n    static int count(int[] coins, int sum) {\n        int[][] memo = new int[coins.length][sum + 1];\n        for (int[] row : memo) {\n            Arrays.fill(row, -1);\n        }\n        return countRecur(coins, coins.length, sum, memo);\n    }\n\n    public static void main(String[] args) {\n        int[] coins = {1, 2, 3};\n        int sum = 5;\n        System.out.println(count(coins, sum));\n    }\n}\n# Python program for coin change problem.\n# using memoization\ndef countRecur(coins, n, sum, memo):\n  \n    # If sum is 0 then there is 1 solution\n    # (do not include any coin)\n    if sum == 0:\n        return 1\n\n    # 0 ways in the following two cases\n    if sum < 0 or n == 0:\n        return 0\n\n    # If the subproblem is previously calculated then\n    # simply return the result\n    if memo[n - 1][sum] != -1:\n        return memo[n - 1][sum]\n\n    # count is sum of solutions (i)\n    # including coins[n-1] (ii) excluding coins[n-1]\n    memo[n - 1][sum] = (countRecur(coins, n, sum - coins[n - 1], memo) + \n                        countRecur(coins, n - 1, sum, memo))\n    return memo[n - 1][sum]\n\ndef count(coins, sum):\n    memo = [[-1 for _ in range(sum + 1)] for _ in range(len(coins))]\n    return countRecur(coins, len(coins), sum, memo)\n\nif __name__ == \"__main__\":\n    coins = [1, 2, 3]\n    sum = 5\n    print(count(coins, sum))\n// C# program for coin change problem.\n// using memoization\n\nusing System;\n\nclass GfG {\n\n    static int countRecur(int[] coins, int n, int sum, int[,] memo) {\n\n        // If sum is 0 then there is 1 solution\n        // (do not include any coin)\n        if (sum == 0) return 1;\n\n        // 0 ways in the following two cases\n        if (sum < 0 || n == 0) return 0;\n\n        // If the subproblem is previously calculated then\n        // simply return the result\n        if (memo[n - 1, sum] != -1) return memo[n - 1, sum];\n\n        // count is sum of solutions (i)\n        // including coins[n-1] (ii) excluding coins[n-1]\n        memo[n - 1, sum] = \n            countRecur(coins, n, sum - coins[n - 1], memo) + \n            countRecur(coins, n - 1, sum, memo);\n        return memo[n - 1, sum];\n    }\n\n    static int count(int[] coins, int sum) {\n        int[,] memo = new int[coins.Length, sum + 1];\n        for (int i = 0; i < coins.Length; i++) {\n            for (int j = 0; j <= sum; j++) {\n                memo[i, j] = -1;\n            }\n        }\n        return countRecur(coins, coins.Length, sum, memo);\n    }\n\n    static void Main() {\n        int[] coins = {1, 2, 3};\n        int sum = 5;\n        Console.WriteLine(count(coins, sum));\n    }\n}\n// JavaScript program for coin change problem.\n// using memoization\n\nfunction countRecur(coins, n, sum, memo) {\n\n    // If sum is 0 then there is 1 solution\n    // (do not include any coin)\n    if (sum === 0) return 1;\n\n    // 0 ways in the following two cases\n    if (sum < 0 || n === 0) return 0;\n\n    // If the subproblem is previously calculated then\n    // simply return the result\n    if (memo[n - 1][sum] !== -1) return memo[n - 1][sum];\n\n    // count is sum of solutions (i)\n    // including coins[n-1] (ii) excluding coins[n-1]\n    memo[n - 1][sum] = countRecur(coins, n, sum - coins[n - 1], memo) + \n                       countRecur(coins, n - 1, sum, memo);\n    return memo[n - 1][sum];\n}\n\nfunction count(coins, sum) {\n    const memo = Array.from({ length: coins.length }, () => Array(sum + 1).fill(-1));\n    return countRecur(coins, coins.length, sum, memo);\n}\n\nconst coins = [1, 2, 3];\nconst sum = 5;\nconsole.log(count(coins, sum));\n5\n// C++ program for coin change problem using tabulation\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Returns total distinct ways to make sum using n coins of\n// different denominations\nint count(vector<int>& coins, int sum) {\n    int n = coins.size();\n    \n    // 2d dp array where n is the number of coin\n    // denominations and sum is the target sum\n    vector<vector<int> > dp(n + 1, vector<int>(sum + 1, 0));\n\n    // Represents the base case where the target sum is 0,\n    // and there is only one way to make change: by not\n    // selecting any coin\n    dp[0][0] = 1;\n    for (int i = 1; i <= n; i++) {\n        for (int j = 0; j <= sum; j++) {\n\n            // Add the number of ways to make change without\n            // using the current coin,\n            dp[i][j] += dp[i - 1][j];\n\n            if ((j - coins[i - 1]) >= 0) {\n\n                // Add the number of ways to make change\n                // using the current coin\n                dp[i][j] += dp[i][j - coins[i - 1]];\n            }\n        }\n    }\n    return dp[n][sum];\n}\n\nint main() {\n    vector<int> coins = {1, 2, 3};\n    int sum = 5;\n    cout << count(coins, sum);\n    return 0;\n}\n// Java program for coin change problem using tabulation\n\nclass GfG {\n\n    static int count(int[] coins, int sum) {\n        int n = coins.length;\n        \n        // 2d dp array where n is the number of coin\n        // denominations and sum is the target sum\n        int[][] dp = new int[n + 1][sum + 1];\n\n        // Represents the base case where the target sum is 0,\n        // and there is only one way to make change: by not\n        // selecting any coin\n        dp[0][0] = 1;\n        for (int i = 1; i <= n; i++) {\n            for (int j = 0; j <= sum; j++) {\n\n                // Add the number of ways to make change without\n                // using the current coin\n                dp[i][j] += dp[i - 1][j];\n\n                if ((j - coins[i - 1]) >= 0) {\n\n                    // Add the number of ways to make change\n                    // using the current coin\n                    dp[i][j] += dp[i][j - coins[i - 1]];\n                }\n            }\n        }\n        return dp[n][sum];\n    }\n\n    public static void main(String[] args) {\n        int[] coins = {1, 2, 3};\n        int sum = 5;\n        System.out.println(count(coins, sum));\n    }\n}\n# Python program for coin change problem using tabulation\n\ndef count(coins, sum):\n    n = len(coins)\n    \n    # 2d dp array where n is the number of coin\n    # denominations and sum is the target sum\n    dp = [[0] * (sum + 1) for _ in range(n + 1)]\n\n    # Represents the base case where the target sum is 0,\n    # and there is only one way to make change: by not\n    # selecting any coin\n    dp[0][0] = 1\n    for i in range(1, n + 1):\n        for j in range(sum + 1):\n\n            # Add the number of ways to make change without\n            # using the current coin\n            dp[i][j] += dp[i - 1][j]\n\n            if (j - coins[i - 1]) >= 0:\n\n                # Add the number of ways to make change\n                # using the current coin\n                dp[i][j] += dp[i][j - coins[i - 1]]\n                \n    return dp[n][sum]\n\nif __name__ == \"__main__\":\n    coins = [1, 2, 3]\n    sum = 5\n    print(count(coins, sum))\n// C# program for coin change problem using tabulation\n\nusing System;\n\nclass GfG {\n\n    static int count(int[] coins, int sum) {\n        int n = coins.Length;\n        \n        // 2d dp array where n is the number of coin\n        // denominations and sum is the target sum\n        int[,] dp = new int[n + 1, sum + 1];\n\n        // Represents the base case where the target sum is 0,\n        // and there is only one way to make change: by not\n        // selecting any coin\n        dp[0, 0] = 1;\n        for (int i = 1; i <= n; i++) {\n            for (int j = 0; j <= sum; j++) {\n\n                // Add the number of ways to make change without\n                // using the current coin\n                dp[i, j] += dp[i - 1, j];\n\n                if ((j - coins[i - 1]) >= 0) {\n\n                    // Add the number of ways to make change\n                    // using the current coin\n                    dp[i, j] += dp[i, j - coins[i - 1]];\n                }\n            }\n        }\n        return dp[n, sum];\n    }\n\n    static void Main() {\n        int[] coins = {1, 2, 3};\n        int sum = 5;\n        Console.WriteLine(count(coins, sum));\n    }\n}\n// JavaScript program for coin change problem using tabulation\n\nfunction count(coins, sum) {\n    const n = coins.length;\n    \n    // 2d dp array where n is the number of coin\n    // denominations and sum is the target sum\n    const dp = Array.from({ length: n + 1 }, () => Array(sum + 1).fill(0));\n\n    // Represents the base case where the target sum is 0,\n    // and there is only one way to make change: by not\n    // selecting any coin\n    dp[0][0] = 1;\n    for (let i = 1; i <= n; i++) {\n        for (let j = 0; j <= sum; j++) {\n\n            // Add the number of ways to make change without\n            // using the current coin\n            dp[i][j] += dp[i - 1][j];\n\n            if ((j - coins[i - 1]) >= 0) {\n\n                // Add the number of ways to make change\n                // using the current coin\n                dp[i][j] += dp[i][j - coins[i - 1]];\n            }\n        }\n    }\n    return dp[n][sum];\n}\n\nconst coins = [1, 2, 3];\nconst sum = 5;\nconsole.log(count(coins, sum));\n5\n// C++ program for coin change problem\n// using space optimised dp\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Returns total distinct ways to make sum using n coins of\n// different denominations\nint count(vector<int> &coins, int sum) {\n    int n = coins.size();\n    \n    // dp[i] will be storing the number of solutions for\n    // value i. We need sum+1 rows as the dp is\n    // constructed in bottom up manner using the base case\n    // (sum = 0)\n    vector<int> dp(sum + 1);\n\n    // Base case (If given value is 0)\n    dp[0] = 1;\n\n    // Pick all coins one by one and update the table[]\n    // values after the index greater than or equal to the\n    // value of the picked coin\n    for (int i = 0; i < n; i++)\n        for (int j = coins[i]; j <= sum; j++)\n            dp[j] += dp[j - coins[i]];\n    return dp[sum];\n}\n\nint main() {\n    vector<int> coins = {1, 2, 3};\n    int sum = 5;\n    cout << count(coins, sum);\n    return 0;\n}\n// Java program for coin change problem.\n// using space optimised dp\n\nclass GfG {\n\n    static int count(int[] coins, int sum) {\n        int n = coins.length;\n        \n        // dp[i] will be storing the number of solutions for\n        // value i. We need sum+1 rows as the dp is\n        // constructed in bottom up manner using the base case\n        // (sum = 0)\n        int[] dp = new int[sum + 1];\n\n        // Base case (If given value is 0)\n        dp[0] = 1;\n\n        // Pick all coins one by one and update the table[]\n        // values after the index greater than or equal to the\n        // value of the picked coin\n        for (int i = 0; i < n; i++)\n            for (int j = coins[i]; j <= sum; j++)\n                dp[j] += dp[j - coins[i]];\n                \n        return dp[sum];\n    }\n\n    public static void main(String[] args) {\n        int[] coins = {1, 2, 3};\n        int sum = 5;\n        System.out.println(count(coins, sum));\n    }\n}\n# Python program for coin change problem.\n# using space optimised dp\n\ndef count(coins, sum):\n    n = len(coins)\n    \n    # dp[i] will be storing the number of solutions for\n    # value i. We need sum+1 rows as the dp is\n    # constructed in bottom up manner using the base case\n    # (sum = 0)\n    dp = [0] * (sum + 1)\n\n    # Base case (If given value is 0)\n    dp[0] = 1\n\n    # Pick all coins one by one and update the table[]\n    # values after the index greater than or equal to the\n    # value of the picked coin\n    for i in range(n):\n        for j in range(coins[i], sum + 1):\n            dp[j] += dp[j - coins[i]]\n            \n    return dp[sum]\n\nif __name__ == \"__main__\":\n    coins = [1, 2, 3]\n    sum = 5\n    print(count(coins, sum))\n// C# program for coin change problem.\n// using space optimised dp\n\nusing System;\n\nclass GfG {\n\n    static int count(int[] coins, int sum) {\n        int n = coins.Length;\n        \n        // dp[i] will be storing the number of solutions for\n        // value i. We need sum+1 rows as the dp is\n        // constructed in bottom up manner using the base case\n        // (sum = 0)\n        int[] dp = new int[sum + 1];\n\n        // Base case (If given value is 0)\n        dp[0] = 1;\n\n        // Pick all coins one by one and update the table[]\n        // values after the index greater than or equal to the\n        // value of the picked coin\n        for (int i = 0; i < n; i++)\n            for (int j = coins[i]; j <= sum; j++)\n                dp[j] += dp[j - coins[i]];\n                \n        return dp[sum];\n    }\n\n    static void Main() {\n        int[] coins = {1, 2, 3};\n        int sum = 5;\n        Console.WriteLine(count(coins, sum));\n    }\n}\n// JavaScript program for coin change problem\n// using space optimised dp\n\nfunction count(coins, sum) {\n    const n = coins.length;\n    \n    // dp[i] will be storing the number of solutions for\n    // value i. We need sum+1 rows as the dp is\n    // constructed in bottom up manner using the base case\n    // (sum = 0)\n    const dp = Array(sum + 1).fill(0);\n\n    // Base case (If given value is 0)\n    dp[0] = 1;\n\n    // Pick all coins one by one and update the table[]\n    // values after the index greater than or equal to the\n    // value of the picked coin\n    for (let i = 0; i < n; i++)\n        for (let j = coins[i]; j <= sum; j++)\n            dp[j] += dp[j - coins[i]];\n            \n    return dp[sum];\n}\n\nconst coins = [1, 2, 3];\nconst sum = 5;\nconsole.log(count(coins, sum));\n5\n",
        "complexity": {
            "time": "",
            "space": ""
        },
        "tags": [
            "Dynamic Programming"
        ],
        "url": "https://www.geeksforgeeks.org/coin-change-dp-7/"
    },
    {
        "title": "Word Break",
        "description": "Given a string s and y a dictionary of n words dictionary, check if s can be segmented into a sequence of valid words from the dictionary, separated by spaces. Examples: Input:  s = “ilike”, dictionary[] = [“i”, “like”, “gfg”]Output: trueExplanation: The string can be segmented as “i like”. Input:  s = “ilikegfg”, dictionary[] = [“i”, “like”, “man”, “india”, “gfg”]Output: trueExplanation: The string can be segmented as “i like gfg”. Input: “ilikemangoes”, dictionary = [“i”, “like”, “gfg”]Output: falseExplanation: The string cannot be segmented. Table of Content The idea is to consider each prefix and search for it in dictionary. If the prefix is present in dictionary, we recur for rest of the string (or suffix). If the recursive call for suffix returns true, we return true, otherwise we try next prefix. If we have tried all prefixes and none of them resulted in a solution, we return false. The idea is to use dynamic programming in the recursive solution to avoid recomputing same subproblems. To further improve the time complexity, store the words of the dictionary in a set to improve the time complexity of looking for a word in dictionary from O(m) to O(1). If we notice carefully, we can observe that the above recursive solution holds the following two properties of Dynamic Programming: 1. Optimal Substructure: To check if the string can be segmented starting from index i, i.e., wordBreakRec(i), depends on the solutions of the subproblems wordBreakRec(j) where j lies between i and n. Return true if s[i:j] is present in dictionary and wordBreakRec(j) returns true. 2. Overlapping Subproblems: While applying a recursive approach in this problem, we notice that certain subproblems are computed multiple times. For example, for wordBreakRec(0), wordBreakRec(1) and wordBreakRec(2) is called. wordBreakRec(1) will again call wordBreakRec(2).  The idea is to use bottom-up dynamic programming to determine if a string can be segmented into dictionary words. Create a boolean array d[] where each position dp[i] represents whether the substring from 0 to that position can be broken into dictionary words. Step by step approach:  Time Complexity: O(n * m * k), where n is the length of string and m is the number of dictionary words and k is the length of maximum sized string in dictionary.Space Complexity: O(n) Related Articles: Word Break Problem | (Trie solution)Word Break Problem using Backtracking  ",
        "code": "// C++ program to implement word break.\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Function to check if the given string can be broken\n// down into words from the word list\nbool wordBreakRec(int i, string &s, vector<string> &dictionary)\n{\n\n    // If end of string is reached,\n    // return true.\n    if (i == s.length())\n        return true;\n\n    int n = s.length();\n    string prefix = \"\";\n\n    // Try every prefix\n    for (int j = i; j < n; j++)\n    {\n        prefix += s[j];\n\n        // if the prefix s[i..j] is a dictionary word\n        // and rest of the string can also be broken into\n        // valid words, return true\n        if (find(dictionary.begin(), dictionary.end(), prefix) != dictionary.end() &&\n            wordBreakRec(j + 1, s, dictionary))\n        {\n            return true;\n        }\n    }\n\n    return false;\n}\n\nbool wordBreak(string &s, vector<string> &dictionary)\n{\n    return wordBreakRec(0, s, dictionary);\n}\n\nint main()\n{\n    string s = \"ilike\";\n\n    vector<string> dictionary = {\"i\", \"like\", \"gfg\"};\n\n    cout << (wordBreak(s, dictionary) ? \"true\" : \"false\") << endl;\n\n    return 0;\n}\nimport java.util.*;\n\nclass GfG {\n    static boolean wordBreakRec(int i, String s,\n                                String[] dictionary)\n    {\n        if (i == s.length())\n            return true;\n\n        String prefix = \"\";\n\n        for (int j = i; j < s.length(); j++) {\n            prefix += s.charAt(j);\n\n            // Check if the prefix exists in the dictionary\n            if (Arrays.asList(dictionary).contains(prefix)\n                && wordBreakRec(j + 1, s, dictionary)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    static boolean wordBreak(String s, String[] dictionary)\n    {\n        return wordBreakRec(0, s, dictionary);\n    }\n\n    public static void main(String[] args)\n    {\n        String s = \"ilike\";\n        String[] dictionary = { \"i\", \"like\", \"gfg\" };\n\n        System.out.println(\n            wordBreak(s, dictionary) ? \"true\" : \"false\");\n    }\n}\ndef wordBreakRec(i, s, dictionary):\n\n    # If end of string is reached,\n    # return true.\n    if i == len(s):\n        return 1\n\n    n = len(s)\n    prefix = \"\"\n\n    # Try every prefix\n    for j in range(i, n):\n        prefix += s[j]\n\n        # if the prefix s[i..j] is a dictionary word\n        # and rest of the string can also be broken into\n        # valid words, return true\n        if prefix in dictionary and wordBreakRec(j + 1, s, dictionary) == 1:\n            return 1\n\n    return 0\n\n\ndef wordBreak(s, dictionary):\n    return wordBreakRec(0, s, dictionary)\n\n\nif __name__ == \"__main__\":\n    s = \"ilike\"\n\n    dictionary = {\"i\", \"like\", \"gfg\"}\n\n    print(\"true\" if wordBreak(s, dictionary) else \"false\")\nusing System;\n\nclass Program\n{\n    static bool WordBreakRec(int index, string s, string[] dictionary)\n    {\n        // If end of the string is reached, return true.\n        if (index == s.Length)\n            return true;\n\n        string prefix = \"\";\n\n        // Try every prefix from the current index\n        for (int j = index; j < s.Length; j++)\n        {\n            prefix += s[j];\n\n            // Check if the current prefix exists in the dictionary\n            if (Array.Exists(dictionary, word => word == prefix))\n            {\n                // If prefix is valid, recursively check for the remaining substring\n                if (WordBreakRec(j + 1, s, dictionary))\n                    return true;\n            }\n        }\n\n        return false;\n    }\n\n    static bool WordBreak(string s, string[] dictionary)\n    {\n        return WordBreakRec(0, s, dictionary);\n    }\n\n    static void Main()\n    {\n        string[] dictionary = {\"i\", \"like\", \"gfg\"}; \n        string s = \"ilike\";\n\n        Console.WriteLine(WordBreak(s, dictionary) ? \"true\" : \"false\");\n    }\n}\n// JavaScript program to implement word break.\n\n// Function to check if the given string can be broken\n// down into words from the word list.\n// Returns 1 if string can be segmented\nfunction wordBreakRec(i, s, dictionary)\n{\n\n    // If end of string is reached,\n    // return true.\n    if (i === s.length)\n        return 1;\n\n    let n = s.length;\n    let prefix = \"\";\n\n    // Try every prefix\n    for (let j = i; j < n; j++) {\n        prefix += s[j];\n\n        // if the prefix s[i..j] is a dictionary word\n        // and rest of the string can also be broken into\n        // valid words, return true\n        if (dictionary.find((pre) => pre == prefix)\n                !== undefined\n            && wordBreakRec(j + 1, s, dictionary) === 1) {\n            return 1;\n        }\n    }\n\n    return 0;\n}\n\nfunction wordBreak(s, dictionary)\n{\n    return wordBreakRec(0, s, dictionary);\n}\n\nlet s = \"ilike\";\n\nlet dictionary = [ \"i\", \"like\", \"gfg\" ];\nconsole.log(wordBreak(s, dictionary) ? \"true\" : \"false\");\ntrue\n#include <bits/stdc++.h>\nusing namespace std;\n\nbool wordBreakRec(int ind, string &s, vector<string> &dictionary, vector<int> &dp)\n{\n    if (ind >= s.size())\n    {\n        return true;\n    }\n    if (dp[ind] != -1)\n        return dp[ind];\n    bool possible = false;\n    for (int i = 0; i < dictionary.size(); i++)\n    {\n        string temp = dictionary[i];\n        if (temp.size() > s.size() - ind)\n            continue;\n        bool ok = true;\n        int k = ind;\n        for (int j = 0; j < temp.size(); j++)\n        {\n            if (temp[j] != s[k])\n            {\n                ok = false;\n                break;\n            }\n            else\n                k++;\n        }\n        if (ok)\n        {\n            possible |= wordBreakRec(ind + temp.size(), s, dictionary, dp);\n        }\n    }\n    return dp[ind] = possible;\n}\n\nbool wordBreak(string s, vector<string> &dictionary)\n{\n    int n = s.size();\n    vector<int> dp(n + 1, -1);\n    string temp = \"\";\n    return wordBreakRec(0, s, dictionary, dp);\n}\nint main()\n{\n    string s = \"ilike\";\n    vector<string> dictionary = {\"i\", \"like\", \"gfg\"};\n\n    cout << (wordBreak(s, dictionary) ? \"true\" : \"false\") << endl;\n    return 0;\n}\nimport java.util.*;\n\nclass GfG {\n    static boolean wordBreakRec(int ind, String s, String[] dict, int[] dp) {\n        if (ind >= s.length()) {\n            return true;\n        }\n        if (dp[ind] != -1) {\n            return dp[ind] == 1;\n        }\n        boolean possible = false;\n        for (String temp : dict) {\n            if (temp.length() > s.length() - ind) {\n                continue;\n            }\n            boolean ok = true;\n            int k = ind;\n            for (int j = 0; j < temp.length(); j++) {\n                if (temp.charAt(j) != s.charAt(k)) {\n                    ok = false;\n                    break;\n                }\n                k++;\n            }\n            if (ok) {\n                possible |= wordBreakRec(ind + temp.length(), s, dict, dp);\n            }\n        }\n        dp[ind] = possible ? 1 : 0;\n        return possible;\n    }\n\n    public static boolean wordBreak(String s, String[] dict) {\n        int n = s.length();\n        int[] dp = new int[n + 1];\n        Arrays.fill(dp, -1);\n        return wordBreakRec(0, s, dict, dp);\n    }\n\n    public static void main(String[] args) {\n        String s = \"ilike\";\n        String[] dict = {\"i\", \"like\", \"gfg\"};\n        System.out.println(wordBreak(s, dict) ? \"true\" : \"false\");\n    }\n}\ndef wordBreakRec(ind, s, dict, dp):\n    if ind >= len(s):\n        return True\n    if dp[ind] != -1:\n        return dp[ind] == 1\n    possible = False\n    for temp in dict:\n        if len(temp) > len(s) - ind:\n            continue\n        if s[ind:ind+len(temp)] == temp:\n            possible |= wordBreakRec(ind + len(temp), s, dict, dp)\n    dp[ind] = 1 if possible else 0\n    return possible\n\ndef word_break(s, dict):\n    n = len(s)\n    dp = [-1] * (n + 1)\n    return wordBreakRec(0, s, dict, dp)\n\ns = \"ilike\"\ndict = [\"i\", \"like\", \"gfg\"]\nprint(\"true\" if word_break(s, dict) else \"false\")\nfunction wordBreakRec(ind, s, dict, dp) {\n    if (ind >= s.length) {\n        return true;\n    }\n    if (dp[ind] !== -1) {\n        return dp[ind] === 1;\n    }\n    let possible = false;\n    for (let temp of dict) {\n        if (temp.length > s.length - ind) {\n            continue;\n        }\n        if (s.substring(ind, ind + temp.length) === temp) {\n            possible ||= wordBreakRec(ind + temp.length, s, dict, dp);\n        }\n    }\n    dp[ind] = possible ? 1 : 0;\n    return possible;\n}\n\nfunction wordBreak(s, dict) {\n    let n = s.length;\n    let dp = new Array(n + 1).fill(-1);\n    return wordBreakRec(0, s, dict, dp);\n}\n\nlet s = \"ilike\";\nlet dict = [\"i\", \"like\", \"gfg\"];\nconsole.log(wordBreak(s, dict) ? \"true\" : \"false\");\ntrue\n// C++ program to implement word break.\n#include <bits/stdc++.h>\nusing namespace std;\n\nbool wordBreak(string &s, vector<string> &dictionary)\n{\n    int n = s.size();\n    vector<bool> dp(n + 1, 0);\n    dp[0] = 1;\n\n    // Traverse through the given string\n    for (int i = 1; i <= n; i++)\n    {\n\n        // Traverse through the dictionary words\n        for (string &w : dictionary)\n        {\n\n            // Check if current word is present\n            // the prefix before the word is also\n            // breakable\n            int start = i - w.size();\n            if (start >= 0 && dp[start] && s.substr(start, w.size()) == w)\n            {\n                dp[i] = 1;\n                break;\n            }\n        }\n    }\n    return dp[n];\n}\n\nint main()\n{\n    string s = \"ilike\";\n\n    vector<string> dictionary = {\"i\", \"like\", \"gfg\"};\n\n    cout << (wordBreak(s, dictionary) ? \"true\" : \"false\") << endl;\n\n    return 0;\n}\nimport java.util.*;\n\nclass GfG {\n    static boolean wordBreak(String s, String[] dictionary)\n    {\n        int n = s.length();\n        boolean[] dp = new boolean[n + 1];\n        dp[0] = true;\n\n        // Traverse through the given string\n        for (int i = 1; i <= n; i++) {\n            // Traverse through the dictionary words\n            for (String w : dictionary) {\n                // Check if the current word is present and\n                // the prefix before the word is also\n                // breakable\n                int start = i - w.length();\n                if (start >= 0 && dp[start]\n                    && s.substring(start,\n                                   start + w.length())\n                           .equals(w)) {\n                    dp[i] = true;\n                    break;\n                }\n            }\n        }\n        return dp[n]; // Returning true or false\n    }\n\n    public static void main(String[] args)\n    {\n        String s = \"ilike\";\n        String[] dictionary\n            = { \"i\", \"like\", \"gfg\" }; // Using String array\n\n        System.out.println(\n            wordBreak(s, dictionary) ? \"true\" : \"false\");\n    }\n}\n# Python program to implement word break\ndef wordBreak(s, dictionary):\n    n = len(s)\n    dp = [False] * (n + 1)\n    dp[0] = True\n\n    # Traverse through the given string\n    for i in range(1, n + 1):\n\n        # Traverse through the dictionary words\n        for w in dictionary:\n\n            # Check if current word is present\n            # the prefix before the word is also\n            # breakable\n            start = i - len(w)\n            if start >= 0 and dp[start] and s[start:start + len(w)] == w:\n                dp[i] = True\n                break\n    return 1 if dp[n] else 0\n\n\nif __name__ == '__main__':\n    s = \"ilike\"\n\n    dictionary = [\"i\", \"like\", \"gfg\"]\n\n    print(\"true\" if wordBreak(s, dictionary) else \"false\")\nusing System;\nusing System.Collections.Generic;\n\nclass GfG {\n    static bool wordBreak(string s, string[] dictionary)\n    {\n        int n = s.Length;\n        bool[] dp = new bool[n + 1];\n        dp[0] = true;\n\n        // Traverse through the given string\n        for (int i = 1; i <= n; i++) {\n\n            // Traverse through the dictionary words\n            foreach(string w in dictionary)\n            {\n                // Check if current word is present and the\n                // prefix before the word is also breakable\n                int start = i - w.Length;\n                if (start >= 0 && dp[start]\n                    && s.Substring(start, w.Length) == w) {\n                    dp[i] = true;\n                    break;\n                }\n            }\n        }\n        return dp[n]; // Return true if word break is\n                      // possible, else false\n    }\n\n    public static void Main()\n    {\n        string s = \"ilike\";\n        string[] dictionary\n            = { \"i\", \"like\", \"gfg\" }; // Using string array\n\n        Console.WriteLine(\n            wordBreak(s, dictionary) ? \"true\" : \"false\");\n    }\n}\n// JavaScript program to implement word break\nfunction wordBreak(s, dictionary)\n{\n    const n = s.length;\n    const dp = new Array(n + 1).fill(false);\n    dp[0] = true;\n\n    // Traverse through the given string\n    for (let i = 1; i <= n; i++) {\n\n        // Traverse through the dictionary words\n        for (const w of dictionary) {\n\n            // Check if current word is present\n            // the prefix before the word is also\n            // breakable\n            const start = i - w.length;\n            if (start >= 0 && dp[start]\n                && s.substring(start, start + w.length)\n                       === w) {\n                dp[i] = true;\n                break;\n            }\n        }\n    }\n    return (dp[n]) ? 1 : 0;\n}\n\nconst s = \"ilike\";\nconst dictionary = [ \"i\", \"like\", \"gfg\" ];\n\nconsole.log(wordBreak(s, dictionary) ? \"true\" : \"false\");\ntrue\n",
        "complexity": {
            "time": "Time Complexity: O(n * m * k), where n is the length of string and m is the number of dictionary words and k is the length of maximum sized string in dictionary.Space Complexity: O(n)",
            "space": ""
        },
        "tags": [
            "Dynamic Programming"
        ],
        "url": "https://www.geeksforgeeks.org/word-break-problem-dp-32/"
    },
    {
        "title": "Egg Dropping Puzzle | DP-11",
        "description": "You are given n identical eggs and you have access to a k-floored building from 1 to k. There exists a floor f where 0 <= f <= k such that any egg dropped from a floor higher than f will break, and any egg dropped from or below floor f will not break. There are a few rules given below: Your task is to find the minimum number of moves you need to determine the value of f with certainty. Example: Input: n = 2, k = 36Output: 8Explanation: In all the situations, 8 maximum moves are required to find the maximum floor. Following is the strategy to do so: Input: n = 1, k = 36Output: 36Explanation: Drop the egg from the first-floor window; if it survives, drop it from the second-floor window. Continue upward until it breaks. In the worst case, this method may require 36 droppings. Input: n = 2, k = 10Output: 4Explanation: In all the situations, 4 maximum moves are required to find the maximum floor. Following is the strategy to do so: Table of Content The idea is to try dropping an egg from every floor (from 1 to K) and recursively calculate the minimum number of droppings needed in the worst case. To do so, run a loop from x equal to 1 to K, where i denotes the current floor. When we drop an egg from floor i, there are two possibilities: The maximum of  these two move + 1(current move) will be considered, and the minimum of this is our answer. For each recursive call, follow the below given steps: In the recursive solution, many subproblems are computed more than once. Consider calculating the number of attempts for 2 eggs and 10 floors.When dropping an egg from a certain floor i, the problem divides into two subproblems: Different choices of i can lead to the same subproblem being solved multiple times (for example, eggDrop(2, 3) might be computed in several different branches). This repeated computation of the same subproblems demonstrates overlapping subproblems, which makes memoization a highly effective optimisation technique. The above approach can be optimized using memoization, as we are computing the same sub-problem multiple times. A direct tabulation based solution for the above memoization and recursive approach would require O(n * k^2) Time and O(n * k) Space. We can further optimize the above approach. In the above approach, each state memo[i][j] stores the number of moves required to solve the sub-problem of i eggs and j floors. Instead of doing so, the idea is to make dp[i][j] store the maximum number of floors that can be processed using i moves and j eggs. By doing so, we will only be required to find the maximum reachable floor in the previous move, and will avoid checking each k floor for all the states. Step-by-step approach: In the above approach, to calculate the current row of the dp[][] table, we require only the previous row results. The idea is to create a 1D array dp[] of size n to store the result for each move. To do so, proceed similar to above approach, and for each iteration, set dp[i] = 1 + dp[i] + dp[i-1]. At last return the value stored in dp[n]. Illustration for 2 Eggs and 10 Floors (n = 2, k = 10) Related Articles:  ",
        "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n// Function to find minimum number of attempts \n// needed in order to find the critical floor\nint eggDrop(int n, int k) {\n\n    // if there is less than or equal to one floor\n    if (k == 1 || k == 0)\n        return k;\n\n    // if there is only one egg\n    if (n == 1)\n        return k;\n\n    // to store the minimum number of attempts\n    int res = INT_MAX;\n\n    // Consider all droppings from\n    // 1st floor to kth floor\n    for (int i = 1; i <= k; i++) {\n        int cur = 1 + max(eggDrop(n - 1, i - 1), \n                            eggDrop(n, k - i));\n        if (cur < res)\n            res = cur;\n    }\n\n    return res;\n}\n\nint main() {\n    int n = 2, k = 10;\n    cout << eggDrop(n, k);\n    return 0;\n}\n// Function to find minimum number of attempts \n// needed in order to find the critical floor\nimport java.util.*;\n\nclass GfG {\n\n    // Function to find minimum number of attempts \n    // needed in order to find the critical floor\n    static int eggDrop(int n, int k) {\n\n        // if there is less than or equal to one floor\n        if (k == 1 || k == 0)\n            return k;\n\n        // if there is only one egg\n        if (n == 1)\n            return k;\n\n        // to store the minimum number of attempts\n        int res = Integer.MAX_VALUE;\n\n        // Consider all droppings from\n        // 1st floor to kth floor\n        for (int i = 1; i <= k; i++) {\n            int cur = 1 + Math.max(eggDrop(n - 1, i - 1), eggDrop(n, k - i));\n            if (cur < res)\n                res = cur;\n        }\n\n        return res;\n    }\n\n    public static void main(String[] args) {\n        int n = 2, k = 10;\n        System.out.println(eggDrop(n, k));\n    }\n}\n# Function to find minimum number of attempts \n# needed in order to find the critical floor\ndef eggDrop(n, k):\n    \n    # if there is less than or equal to one floor\n    if k == 1 or k == 0:\n        return k\n    \n    # if there is only one egg\n    if n == 1:\n        return k\n    \n    # to store the minimum number of attempts\n    res = float('inf')\n    \n    # Consider all droppings from\n    # 1st floor to kth floor\n    for i in range(1, k + 1):\n        cur = 1 + max(eggDrop(n - 1, i - 1), eggDrop(n, k - i))\n        if cur < res:\n            res = cur\n    \n    return res\n\nif __name__ == \"__main__\":\n    n = 2\n    k = 10\n    print(eggDrop(n, k))\n// Function to find minimum number of attempts \n// needed in order to find the critical floor\nusing System;\n\nclass GfG {\n\n    // Function to find minimum number of attempts \n    // needed in order to find the critical floor\n    static int eggDrop(int n, int k) {\n    \n        // if there is less than or equal to one floor\n        if (k == 1 || k == 0)\n            return k;\n    \n        // if there is only one egg\n        if (n == 1)\n            return k;\n    \n        // to store the minimum number of attempts\n        int res = int.MaxValue;\n    \n        // Consider all droppings from\n        // 1st floor to kth floor\n        for (int i = 1; i <= k; i++) {\n            int cur = 1 + Math.Max(eggDrop(n - 1, i - 1), eggDrop(n, k - i));\n            if (cur < res)\n                res = cur;\n        }\n    \n        return res;\n    }\n    \n    static void Main() {\n        int n = 2, k = 10;\n        Console.WriteLine(eggDrop(n, k));\n    }\n}\n// Function to find minimum number of attempts \n// needed in order to find the critical floor\nfunction eggDrop(n, k) {\n    \n    // if there is less than or equal to one floor\n    if (k === 1 || k === 0)\n        return k;\n    \n    // if there is only one egg\n    if (n === 1)\n        return k;\n    \n    // to store the minimum number of attempts\n    let res = Number.MAX_SAFE_INTEGER;\n    \n    // Consider all droppings from\n    // 1st floor to kth floor\n    for (let i = 1; i <= k; i++) {\n        let cur = 1 + Math.max(eggDrop(n - 1, i - 1), eggDrop(n, k - i));\n        if (cur < res)\n            res = cur;\n    }\n    \n    return res;\n}\n \nlet n = 2, k = 10;\nconsole.log(eggDrop(n, k));\n4\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Function to find minimum number of attempts\n// needed in order to find the critical floor\nint solveEggDrop(int n, int k, vector<vector<int>> &memo) {\n\n    // if value is already calculated\n    if (memo[n][k] != -1) {\n        return memo[n][k];\n    }\n\n    // if there is less than or equal to one floor\n    if (k == 1 || k == 0)\n        return k;\n\n    // if there is only one egg\n    if (n == 1)\n        return k;\n\n    // to store the minimum number of attempts\n    int res = INT_MAX;\n\n    // Consider all droppings from\n    // 1st floor to kth floor\n    for (int i = 1; i <= k; i++) {\n        int cur = max(solveEggDrop(n - 1, i - 1, memo), \n                        solveEggDrop(n, k - i, memo));\n        if (cur < res)\n            res = cur;\n    }\n\n    // update the memo, and return\n    return memo[n][k] = res + 1;\n}\n\n// Function to find minimum number of attempts \n// needed in order to find the critical floor\nint eggDrop(int n, int k) {\n\n    // create memo table\n    vector<vector<int>> memo(n + 1, vector<int>(k + 1, -1));\n\n    return solveEggDrop(n, k, memo);\n}\n\nint main() {\n    int n = 2, k = 10;\n    cout << eggDrop(n, k);\n    return 0;\n}\n// Function to find minimum number of attempts \n// needed in order to find the critical floor\nimport java.util.*;\n\nclass GfG {\n\n    // Function to find minimum number of attempts \n    // needed in order to find the critical floor\n    static int solveEggDrop(int n, int k, int[][] memo) {\n\n        // if value is already calculated\n        if (memo[n][k] != -1) {\n            return memo[n][k];\n        }\n\n        // if there is less than or equal to one floor\n        if (k == 1 || k == 0)\n            return k;\n\n        // if there is only one egg\n        if (n == 1)\n            return k;\n\n        // to store the minimum number of attempts\n        int res = Integer.MAX_VALUE;\n\n        // Consider all droppings from\n        // 1st floor to kth floor\n        for (int i = 1; i <= k; i++) {\n            int cur = Math.max(solveEggDrop(n - 1, i - 1, memo),\n                               solveEggDrop(n, k - i, memo));\n            if (cur < res)\n                res = cur;\n        }\n\n        // update the memo, and return\n        memo[n][k] = res + 1;\n        return memo[n][k];\n    }\n\n    // Function to find minimum number of attempts \n    // needed in order to find the critical floor\n    static int eggDrop(int n, int k) {\n\n        // create memo table\n        int[][] memo = new int[n + 1][k + 1];\n        for (int i = 0; i <= n; i++) {\n            Arrays.fill(memo[i], -1);\n        }\n\n        return solveEggDrop(n, k, memo);\n    }\n\n    public static void main(String[] args) {\n        int n = 2, k = 10;\n        System.out.println(eggDrop(n, k));\n    }\n}\n# Function to find minimum number of attempts \n# needed in order to find the critical floor\ndef solveEggDrop(n, k, memo):\n    \n    # if value is already calculated\n    if memo[n][k] != -1:\n        return memo[n][k]\n    \n    # if there is less than or equal to one floor\n    if k == 1 or k == 0:\n        return k\n    \n    # if there is only one egg\n    if n == 1:\n        return k\n    \n    # to store the minimum number of attempts\n    res = float('inf')\n    \n    # Consider all droppings from\n    # 1st floor to kth floor\n    for i in range(1, k + 1):\n        cur = max(solveEggDrop(n - 1, i - 1, memo), \\\n                    solveEggDrop(n, k - i, memo))\n        if cur < res:\n            res = cur\n    \n    # update the memo, and return\n    memo[n][k] = res + 1\n    return memo[n][k]\n\n# Function to find minimum number of attempts \n# needed in order to find the critical floor\ndef eggDrop(n, k):\n    \n    # create memo table\n    memo = [[-1 for _ in range(k + 1)] for _ in range(n + 1)]\n    \n    return solveEggDrop(n, k, memo)\n\nif __name__ == \"__main__\":\n    n = 2\n    k = 10\n    print(eggDrop(n, k))\n// Function to find minimum number of attempts \n// needed in order to find the critical floor\nusing System;\n \nclass GfG {\n \n    // Function to find minimum number of attempts \n    // needed in order to find the critical floor\n    static int solveEggDrop(int n, int k, int[][] memo) {\n \n        // if value is already calculated\n        if (memo[n][k] != -1)\n            return memo[n][k];\n \n        // if there is less than or equal to one floor\n        if (k == 1 || k == 0)\n            return k;\n \n        // if there is only one egg\n        if (n == 1)\n            return k;\n \n        // to store the minimum number of attempts\n        int res = int.MaxValue;\n \n        // Consider all droppings from\n        // 1st floor to kth floor\n        for (int i = 1; i <= k; i++) {\n            int cur = Math.Max(solveEggDrop(n - 1, i - 1, memo), \n                        solveEggDrop(n, k - i, memo));\n            if (cur < res)\n                res = cur;\n        }\n \n        // update the memo, and return\n        memo[n][k] = res + 1;\n        return memo[n][k];\n    }\n \n    // Function to find minimum number of attempts \n    // needed in order to find the critical floor\n    static int eggDrop(int n, int k) {\n \n        // create memo table\n        int[][] memo = new int[n + 1][];\n        for (int i = 0; i <= n; i++) {\n            memo[i] = new int[k + 1];\n            for (int j = 0; j <= k; j++) {\n                memo[i][j] = -1;\n            }\n        }\n \n        return solveEggDrop(n, k, memo);\n    }\n \n    static void Main() {\n        int n = 2, k = 10;\n        Console.WriteLine(eggDrop(n, k));\n    }\n}\n// Function to find minimum number of attempts \n// needed in order to find the critical floor\nfunction solveEggDrop(n, k, memo) {\n    \n    // if value is already calculated\n    if (memo[n][k] !== -1)\n        return memo[n][k];\n    \n    // if there is less than or equal to one floor\n    if (k === 1 || k === 0)\n        return k;\n    \n    // if there is only one egg\n    if (n === 1)\n        return k;\n    \n    // to store the minimum number of attempts\n    let res = Number.MAX_SAFE_INTEGER;\n    \n    // Consider all droppings from\n    // 1st floor to kth floor\n    for (let i = 1; i <= k; i++) {\n        let cur = Math.max(solveEggDrop(n - 1, i - 1, memo), \n                    solveEggDrop(n, k - i, memo));\n        if (cur < res)\n            res = cur;\n    }\n    \n    // update the memo, and return\n    memo[n][k] = res + 1;\n    return memo[n][k];\n}\n \n// Function to find minimum number of attempts \n// needed in order to find the critical floor\nfunction eggDrop(n, k) {\n    \n    // create memo table\n    let memo = new Array(n + 1);\n    for (let i = 0; i <= n; i++) {\n        memo[i] = new Array(k + 1).fill(-1);\n    }\n    \n    return solveEggDrop(n, k, memo);\n}\n\n// Driver code \nlet n = 2, k = 10;\nconsole.log(eggDrop(n, k));\n4\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Function to find minimum number of attempts \n// needed in order to find the critical floor\nint eggDrop(int n, int k) {\n\n    // create a 2D table to store the results\n    vector<vector<int>> dp(k + 1, \n                vector<int>(n + 1, 0));\n\n    // to count the number of moves\n    int cnt = 0;\n\n    // while the number of floors is less than k\n    while (dp[cnt][n] < k) {\n        cnt++;\n\n        // for each egg\n        for (int i = 1; i <= n; i++) {\n            dp[cnt][i] = 1 + dp[cnt - 1][i - 1] + \n                        dp[cnt - 1][i];\n        }\n    }\n    return cnt;\n}\n\nint main() {\n    int n = 2, k = 10;\n    cout << eggDrop(n, k);\n    return 0;\n}\n// Function to find minimum number of attempts \n// needed in order to find the critical floor\nimport java.util.*;\n\nclass GfG {\n\n    // Function to find minimum number of attempts \n    // needed in order to find the critical floor\n    static int eggDrop(int n, int k) {\n\n        // create a 2D table to store the results\n        int[][] dp = new int[k + 1][n + 1];\n\n        // to count the number of moves\n        int cnt = 0;\n\n        // while the number of floors is less than k\n        while (dp[cnt][n] < k) {\n            cnt++;\n\n            // for each egg\n            for (int i = 1; i <= n; i++) {\n                dp[cnt][i] = 1 + dp[cnt - 1][i - 1] + dp[cnt - 1][i];\n            }\n        }\n        return cnt;\n    }\n\n    public static void main(String[] args) {\n        int n = 2, k = 10;\n        System.out.println(eggDrop(n, k));\n    }\n}\n# Function to find minimum number of attempts \n# needed in order to find the critical floor\ndef eggDrop(n, k):\n    \n    # create a 2D table to store the results\n    dp = [[0 for _ in range(n + 1)] for _ in range(k + 1)]\n    \n    # to count the number of moves\n    cnt = 0\n    \n    # while the number of floors is less than k\n    while dp[cnt][n] < k:\n        cnt += 1\n        \n        # for each egg\n        for i in range(1, n + 1):\n            dp[cnt][i] = 1 + dp[cnt - 1][i - 1] + dp[cnt - 1][i]\n    return cnt\n\nif __name__ == \"__main__\":\n    n = 2\n    k = 10\n    print(eggDrop(n, k))\n// Function to find minimum number of attempts \n// needed in order to find the critical floor\nusing System;\n\nclass GfG {\n\n    // Function to find minimum number of attempts \n    // needed in order to find the critical floor\n    static int eggDrop(int n, int k) {\n    \n        // create a 2D table to store the results\n        int[][] dp = new int[k + 1][];\n        for (int i = 0; i <= k; i++) {\n            dp[i] = new int[n + 1];\n        }\n    \n        // to count the number of moves\n        int cnt = 0;\n    \n        // while the number of floors is less than k\n        while (dp[cnt][n] < k) {\n            cnt++;\n    \n            // for each egg\n            for (int i = 1; i <= n; i++) {\n                dp[cnt][i] = 1 + dp[cnt - 1][i - 1] + dp[cnt - 1][i];\n            }\n        }\n        return cnt;\n    }\n    \n    static void Main() {\n        int n = 2, k = 10;\n        Console.WriteLine(eggDrop(n, k));\n    }\n}\n// Function to find minimum number of attempts \n// needed in order to find the critical floor\nfunction eggDrop(n, k) {\n    \n    // create a 2D table to store the results\n    let dp = new Array(k + 1);\n    for (let i = 0; i <= k; i++) {\n        dp[i] = new Array(n + 1).fill(0);\n    }\n    \n    // to count the number of moves\n    let cnt = 0;\n    \n    // while the number of floors is less than k\n    while (dp[cnt][n] < k) {\n        cnt++;\n        \n        // for each egg\n        for (let i = 1; i <= n; i++) {\n            dp[cnt][i] = 1 + dp[cnt - 1][i - 1] + dp[cnt - 1][i];\n        }\n    }\n    return dp[cnt][n] >= k ? cnt : cnt;\n}\n \nlet n = 2, k = 10;\nconsole.log(eggDrop(n, k));\n4\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Function to find minimum number of attempts \n// needed in order to find the critical floor\nint eggDrop(int n, int k) {\n\n    // create an array to store the results\n    vector<int> dp(n + 1, 0);\n\n    // to count the number of moves\n    int cnt = 0;\n\n    // while the number of floors is less than k\n    while (dp[n] < k) {\n        cnt++;\n\n        // for each egg\n        for (int i = n; i > 0; i--) {\n            dp[i] += 1 + dp[i - 1];\n        }\n    }\n    return cnt;\n}\n\nint main() {\n    int n = 2, k = 10;\n    cout << eggDrop(n, k);\n    return 0;\n}\n// Function to find minimum number of attempts \n// needed in order to find the critical floor\nimport java.util.*;\n\nclass GfG {\n\n    // Function to find minimum number of attempts \n    // needed in order to find the critical floor\n    static int eggDrop(int n, int k) {\n\n        // create an array to store the results\n        int[] dp = new int[n + 1];\n\n        // to count the number of moves\n        int cnt = 0;\n\n        // while the number of floors is less than k\n        while (dp[n] < k) {\n            cnt++;\n\n            // for each egg\n            for (int i = n; i > 0; i--) {\n                dp[i] += 1 + dp[i - 1];\n            }\n        }\n        return cnt;\n    }\n\n    public static void main(String[] args) {\n        int n = 2, k = 10;\n        System.out.println(eggDrop(n, k));\n    }\n}\n# Function to find minimum number of attempts \n# needed in order to find the critical floor\ndef eggDrop(n, k):\n    \n    # create an array to store the results\n    dp = [0] * (n + 1)\n    \n    # to count the number of moves\n    cnt = 0\n    \n    # while the number of floors is less than k\n    while dp[n] < k:\n        cnt += 1\n        \n        # for each egg\n        for i in range(n, 0, -1):\n            dp[i] += 1 + dp[i - 1]\n    return cnt\n\nif __name__ == \"__main__\":\n    n = 2\n    k = 10\n    print(eggDrop(n, k))\n// Function to find minimum number of attempts \n// needed in order to find the critical floor\nusing System;\n\nclass GfG {\n\n    // Function to find minimum number of attempts \n    // needed in order to find the critical floor\n    static int eggDrop(int n, int k) {\n    \n        // create an array to store the results\n        int[] dp = new int[n + 1];\n        \n        // to count the number of moves\n        int cnt = 0;\n        \n        // while the number of floors is less than k\n        while (dp[n] < k) {\n            cnt++;\n            \n            // for each egg\n            for (int i = n; i > 0; i--) {\n                dp[i] += 1 + dp[i - 1];\n            }\n        }\n        return cnt;\n    }\n    \n    static void Main() {\n        int n = 2, k = 10;\n        Console.WriteLine(eggDrop(n, k));\n    }\n}\n// Function to find minimum number of attempts \n// needed in order to find the critical floor\nfunction eggDrop(n, k) {\n    \n    // create an array to store the results\n    let dp = new Array(n + 1).fill(0);\n    \n    // to count the number of moves\n    let cnt = 0;\n    \n    // while the number of floors is less than k\n    while (dp[n] < k) {\n        cnt++;\n        \n        // for each egg\n        for (let i = n; i > 0; i--) {\n            dp[i] += 1 + dp[i - 1];\n        }\n    }\n    return cnt;\n}\n\nlet n = 2, k = 10;\nconsole.log(eggDrop(n, k));\n4\n",
        "complexity": {
            "time": "",
            "space": ""
        },
        "tags": [
            "Dynamic Programming"
        ],
        "url": "https://www.geeksforgeeks.org/egg-dropping-puzzle-dp-11/"
    },
    {
        "title": "Matrix Chain Multiplication",
        "description": "Given the dimension of a sequence of matrices in an array arr[], where the dimension of the ith matrix is (arr[i-1] * arr[i]), the task is to find the most efficient way to multiply these matrices together such that the total number of element multiplications is minimum. When two matrices of size m*n and n*p when multiplied, they generate a matrix of size m*p and the number of multiplications performed is m*n*p. Examples: Input: arr[] = [2, 1, 3, 4]Output: 20Explanation: There are 3 matrices of dimensions 2×1, 1×3, and 3×4, Let the input 3 matrices be M1, M2, and M3. There are two ways to multiply ((M1 x M2) x M3) and (M1 x (M2 x M3)), Please note that the result of M1 x M2 is a 2 x 3 matrix and result of (M2 x M3) is a 1 x 4 matrix.((M1 x M2) x M3)  requires (2 x 1 x 3)  +  (2 x 3 x 4) = 30 (M1 x (M2 x M3))  requires (1 x 3 x 4) +  (2 x 1 x 4) = 20 The minimum of these two is 20. Input: arr[] = [1, 2, 3, 4, 3]Output: 30Explanation: There are 4 matrices of dimensions 1×2, 2×3, 3×4, 4×3. Let the input 4 matrices be M1, M2, M3 and M4. The minimum number of multiplications are obtained by ((M1M2)M3)M4. The minimum number is 1*2*3 + 1*3*4 + 1*4*3 = 30 Input: arr[] = [3, 4]Output: 0Explanation: As there is only one matrix so, there is no cost of multiplication. Table of Content We can solve the problem using recursion based on the following facts and observations: Now, for a given chain of n matrices, the first partition can be done in n-1 ways. For example, sequence of matrices M1, M2, M3 and M4 can be grouped as (M1)(M2 x M3 x M4), (M1x M2) x (M3 x M4) or ((M1 x M2 x M3) x M4) in these 3 ways. For n matrices M1, M2, ….. Mn. we can put the first bracket n-1 ways (M1) x (M2 x M3 x M4 ……… Mn-1 x Mn)(M1 x M2) x (M3 x M4………. Mn-1 x Mn)(M1 x M2 x M3) x (M4 ………. Mn-1 x Mn)…………………………………………………………………………………………………………………………………………(M1 x M2 x M3 x M4 ……….Mn-1) x (Mn)We put the first bracket at different n-1 places and then recursively call for the two parts. At the end, we return the minimum of all partitions. To write a recursive function we use a range of indexes [i, j].  And run a loop for k = i + 1 to j.  For k = i + 1, we put the first bracket after the first matrix which has dimensions arr[i] x arr[i+1] and before the remaining matrices which have dimensions arr[i+1] x arr[i+2],  arr[i+2] x arr[i+3], ……….. arr[j-1] x arr[j] Let’s suppose we have four matrices (M1, M2, M3, M4). Based on the recursive approach described above, we can construct a recursion tree. However, we can observe that some problems are computed multiple times. To avoid this redundant computation, we can implement memoization to store the results of previously computed inputs. Recursion Tree for Matrix Chain Multiplication If observed carefully you can find the following two properties: 1) Optimal Substructure: In the above case, we are breaking the bigger groups into smaller subgroups and solving them to finally find the minimum number of multiplications. Therefore, it can be said that the problem has optimal substructure property. 2) Overlapping Subproblems: We can see in the recursion tree that the same subproblems are called again and again and this problem has the Overlapping Subproblems property. So Matrix Chain Multiplication problem has both properties of a dynamic programming problem. So recomputations of same subproblems can be avoided by constructing a temporary array memo[][] in a bottom up manner. Follow the below steps to solve the problem: In iterative approach, we initially need to find the number of multiplications required to multiply two adjacent matrices. We can use these values to find the minimum multiplication required for matrices in a range of length 3 and further use those values for ranges with higher length. The iterative implementation is going to be tricky here we initially know diagonal values (which are 0), our result is going to be at the top right corner (or dp[0][n-1]) and we never access lower diagonal values. So we cannot fill the matrix with a normal traversal, we rather need to fill in diagonal manner. We fill the matrix using a variable len that stores differences between row and column indexes. We keep increasing len until it becomes n-1 (for the top right element) Related articles: Applications:  ",
        "code": "// C++ code to implement the\n// matrix chain multiplication using recursion\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Matrix Ai has dimension arr[i-1] x arr[i]\nint minMultRec(vector<int> &arr, int i, int j)\n{\n\n    // If there is only one matrix\n    if (i + 1 == j)\n        return 0;\n\n    int res = INT_MAX;\n\n    // Place the first bracket at different\n    // positions or k and for every placed\n    // first bracket, recursively compute\n    // minimum cost for remaining brackets\n    // (or subproblems)\n    for (int k = i + 1; k < j; k++)\n    {\n        int curr = minMultRec(arr, i, k) + minMultRec(arr, k, j) + arr[i] * arr[k] * arr[j];\n\n        res = min(curr, res);\n    }\n\n    // Return minimum count\n    return res;\n}\n\nint matrixMultiplication(vector<int> &arr)\n{\n\n    int n = arr.size();\n    return minMultRec(arr, 0, n - 1);\n}\n\nint main()\n{\n\n    vector<int> arr = {2, 1, 3, 4};\n    cout << matrixMultiplication(arr);\n    return 0;\n}\n// Java code to implement the\n// matrix chain multiplication using recursion\nimport java.util.*;\n\nclass GfG {\n\n    // Matrix Ai has dimension arr[i-1] x arr[i]\n    static int minMultRec(int arr[], int i, int j)\n    {\n\n        // If there is only one matrix\n        if (i + 1 == j)\n            return 0;\n\n        int res = Integer.MAX_VALUE;\n\n        // Place the first bracket at different\n        // positions or k and for every placed\n        // first bracket, recursively compute\n        // minimum cost for remaining brackets\n        // (or subproblems)\n        for (int k = i + 1; k < j; k++) {\n            int curr = minMultRec(arr, i, k)\n                       + minMultRec(arr, k, j)\n                       + arr[i] * arr[k] * arr[j];\n\n            res = Math.min(curr, res);\n        }\n\n        // Return minimum count\n        return res;\n    }\n\n    static int matrixMultiplication(int arr[])\n    {\n\n        int n = arr.length;\n        return minMultRec(arr, 0, n - 1);\n    }\n\n    public static void main(String[] args)\n    {\n\n        int arr[] = { 2, 1, 3, 4 };\n        int res = matrixMultiplication(arr);\n        System.out.println(res);\n    }\n}\n# Python code to implement the\n# matrix chain multiplication using recursion\nimport sys\n\n# Matrix Ai has dimension arr[i-1] x arr[i]\n\n\ndef minMultRec(arr, i, j):\n\n    # If there is only one matrix\n    if i + 1 == j:\n        return 0\n\n    res = sys.maxsize\n\n    # Place the first bracket at different\n    # positions or k and for every placed\n    # first bracket, recursively compute\n    # minimum cost for remaining brackets\n    # (or subproblems)\n    for k in range(i + 1, j):\n        curr = minMultRec(arr, i, k) \\\n            + minMultRec(arr, k, j) \\\n            + arr[i] * arr[k] * arr[j]\n\n        res = min(curr, res)\n\n    # Return minimum count\n    return res\n\n\ndef matrixMultiplication(arr):\n    n = len(arr)\n    return minMultRec(arr, 0, n - 1)\n\n\nif __name__ == \"__main__\":\n    arr = [2, 1, 3, 4]\n    res = matrixMultiplication(arr)\n    print(res)\n// C# code to implement the\n// matrix chain multiplication using recursion\nusing System;\n\nclass GfG {\n\n    // Matrix Ai has dimension arr[i-1] x arr[i]\n    static int minMultRec(int[] arr, int i, int j)\n    {\n\n        // If there is only one matrix\n        if (i + 1 == j)\n            return 0;\n\n        int res = int.MaxValue;\n\n        // Place the first bracket at different\n        // positions or k and for every placed\n        // first bracket, recursively compute\n        // minimum cost for remaining brackets\n        // (or subproblems)\n        for (int k = i + 1; k < j; k++) {\n            int curr = minMultRec(arr, i, k)\n                       + minMultRec(arr, k, j)\n                       + arr[i] * arr[k] * arr[j];\n\n            res = Math.Min(curr, res);\n        }\n\n        // Return minimum count\n        return res;\n    }\n\n    static int matrixMultiplication(int[] arr)\n    {\n\n        int n = arr.Length;\n        return minMultRec(arr, 0, n - 1);\n    }\n\n    static void Main(string[] args)\n    {\n\n        int[] arr = { 2, 1, 3, 4 };\n        int res = matrixMultiplication(arr);\n        Console.WriteLine(res);\n    }\n}\n// JavaScript code to implement the\n// matrix chain multiplication using recursion\nfunction minMultRec(arr, i, j)\n{\n\n    // If there is only one matrix\n    if (i + 1 === j)\n        return 0;\n\n    let res = Number.MAX_SAFE_INTEGER;\n\n    // Place the first bracket at different\n    // positions or k and for every placed\n    // first bracket, recursively compute\n    // minimum cost for remaining brackets\n    // (or subproblems)\n    for (let k = i + 1; k < j; k++) {\n        let curr = minMultRec(arr, i, k)\n                   + minMultRec(arr, k, j)\n                   + arr[i] * arr[k] * arr[j];\n\n        res = Math.min(curr, res);\n    }\n\n    // Return minimum count\n    return res;\n}\n\nfunction matrixMultiplication(arr)\n{\n\n    const n = arr.length;\n    return minMultRec(arr, 0, n - 1);\n}\n\nlet arr = [ 2, 1, 3, 4 ];\nlet res = matrixMultiplication(arr);\nconsole.log(res);\n20\n// C++ code to implement the\n// matrix chain multiplication using memoization\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minMultRec(vector<int> &arr, int i, int j, vector<vector<int>> &memo)\n{\n\n    // If there is only one matrix\n    if (i + 1 == j)\n        return 0;\n\n    // Check if the result is already\n    // computed\n    if (memo[i][j] != -1)\n        return memo[i][j];\n\n    int res = INT_MAX;\n\n    // Place the first bracket at different positions or k and\n    // for every placed first bracket, recursively compute\n    // minimum cost for remaining brackets (or subproblems)\n    for (int k = i + 1; k < j; k++)\n    {\n        int curr = minMultRec(arr, i, k, memo) + minMultRec(arr, k, j, memo) + arr[i] * arr[k] * arr[j];\n\n        res = min(curr, res);\n    }\n\n    // Store the result in memo table\n    memo[i][j] = res;\n    return res;\n}\n\nint matrixMultiplication(vector<int> &arr)\n{\n\n    int n = arr.size();\n    vector<vector<int>> memo(n, vector<int>(n, -1));\n    return minMultRec(arr, 0, n - 1, memo);\n}\n\nint main()\n{\n    vector<int> arr = {2, 1, 3, 4};\n    int res = matrixMultiplication(arr);\n    cout << res << endl;\n    return 0;\n}\n// Java code to implement the\n// matrix chain multiplication using memoization\nimport java.util.Arrays;\n\nclass GfG {\n\n    // Function to compute minimum multiplication\n    // recursively\n    static int minMultRec(int[] arr, int i, int j,\n                          int[][] memo)\n    {\n\n        // If there is only one matrix\n        if (i + 1 == j)\n            return 0;\n\n        // Check if the result is already computed\n        if (memo[i][j] != -1)\n            return memo[i][j];\n\n        int res = Integer.MAX_VALUE;\n\n        // Place the first bracket at different positions or\n        // k and for every placed first bracket, recursively\n        // compute minimum cost for remaining brackets (or\n        // subproblems)\n        for (int k = i + 1; k < j; k++) {\n            int curr = minMultRec(arr, i, k, memo)\n                       + minMultRec(arr, k, j, memo)\n                       + arr[i] * arr[k] * arr[j];\n\n            res = Math.min(curr, res);\n        }\n\n        // Store the result in memo table\n        memo[i][j] = res;\n        return res;\n    }\n\n    static int matrixMultiplication(int[] arr)\n    {\n\n        int n = arr.length;\n        int[][] memo = new int[n][n];\n        for (int[] row : memo)\n            Arrays.fill(row, -1);\n\n        return minMultRec(arr, 0, n - 1, memo);\n    }\n\n    public static void main(String[] args)\n    {\n\n        int[] arr = { 2, 1, 3, 4 };\n        System.out.println(matrixMultiplication(arr));\n    }\n}\n# Python code to implement the\n# matrix chain multiplication using memoization\nimport sys\n\n# Function to compute minimum multiplication\n# recursively\n\n\ndef minMultRec(arr, i, j, memo):\n\n    # If there is only one matrix\n    if i + 1 == j:\n        return 0\n\n    # Check if the result is already computed\n    if memo[i][j] != -1:\n        return memo[i][j]\n\n    res = sys.maxsize\n\n    # Place the first bracket at different positions or k\n    # and for every placed first bracket, recursively compute\n    # minimum cost for remaining brackets (or subproblems)\n    for k in range(i + 1, j):\n        curr = (minMultRec(arr, i, k, memo) +\n                minMultRec(arr, k, j, memo) +\n                arr[i] * arr[k] * arr[j])\n        res = min(res, curr)\n\n    # Store the result in memo table\n    memo[i][j] = res\n    return res\n\n\ndef matrixMultiplication(arr):\n    n = len(arr)\n    memo = [[-1 for _ in range(n)] for _ in range(n)]\n    return minMultRec(arr, 0, n - 1, memo)\n\n\nif __name__ == \"__main__\":\n    arr = [2, 1, 3, 4]\n    res = matrixMultiplication(arr)\n    print(res)\n// C# code to implement the\n// matrix chain multiplication using memoization\nusing System;\n\nclass GfG {\n\n    // Function to compute minimum multiplication\n    // recursively\n    static int MinMultRec(int[] arr, int i, int j,\n                          int[, ] memo)\n    {\n\n        // If there is only one matrix\n        if (i + 1 == j)\n            return 0;\n\n        // Check if the result is already computed\n        if (memo[i, j] != -1)\n            return memo[i, j];\n\n        int res = int.MaxValue;\n\n        // Place the first bracket at different positions or\n        // k and for every placed first bracket, recursively\n        // compute minimum cost for remaining brackets (or\n        // subproblems)\n        for (int k = i + 1; k < j; k++) {\n            int curr = MinMultRec(arr, i, k, memo)\n                       + MinMultRec(arr, k, j, memo)\n                       + arr[i] * arr[k] * arr[j];\n\n            res = Math.Min(curr, res);\n        }\n\n        // Store the result in memo table\n        memo[i, j] = res;\n        return res;\n    }\n\n    static int matrixMultiplication(int[] arr)\n    {\n\n        int n = arr.Length;\n        int[, ] memo = new int[n, n];\n        for (int i = 0; i < n; i++)\n            for (int j = 0; j < n; j++)\n                memo[i, j] = -1;\n\n        return MinMultRec(arr, 0, n - 1, memo);\n    }\n\n    static void Main()\n    {\n\n        int[] arr = { 2, 1, 3, 4 };\n        int res = matrixMultiplication(arr);\n        Console.WriteLine(res);\n    }\n}\n// JavaScript code to implement the\n// matrix chain multiplication using memoization\n\nfunction minMultRec(arr, i, j, memo)\n{\n\n    // If there is only one matrix\n    if (i + 1 === j)\n        return 0;\n\n    // Check if the result is already computed\n    if (memo[i][j] !== -1)\n        return memo[i][j];\n\n    let res = Number.MAX_SAFE_INTEGER;\n\n    // Place the first bracket at different positions or k\n    // and for every placed first bracket, recursively\n    // compute minimum cost for remaining brackets (or\n    // subproblems)\n    for (let k = i + 1; k < j; k++) {\n        let curr = minMultRec(arr, i, k, memo)\n                   + minMultRec(arr, k, j, memo)\n                   + arr[i] * arr[k] * arr[j];\n\n        res = Math.min(res, curr);\n    }\n\n    // Store the result in memo table\n    memo[i][j] = res;\n    return res;\n}\n\nfunction matrixMultiplication(arr)\n{\n\n    let n = arr.length;\n    let memo\n        = Array.from({length : n}, () => Array(n).fill(-1));\n    return minMultRec(arr, 0, n - 1, memo);\n}\n\nlet arr = [ 2, 1, 3, 4 ];\nlet res = matrixMultiplication(arr);\nconsole.log(res);\n20\n// C++ code to implement the\n// matrix chain multiplication using tabulation\n#include <bits/stdc++.h>\nusing namespace std;\n\nint matrixMultiplication(vector<int> &arr)\n{\n\n    int n = arr.size();\n\n    // Create a 2D DP array to store the minimum\n    // multiplication costs\n    vector<vector<int>> dp(n, vector<int>(n, 0));\n\n    // Fill the DP array.\n    // Here, len is the chain length\n    for (int len = 2; len < n; len++)\n    {\n        for (int i = 0; i < n - len; i++)\n        {\n            int j = i + len;\n            dp[i][j] = INT_MAX;\n\n            for (int k = i + 1; k < j; k++)\n            {\n                int cost = dp[i][k] + dp[k][j] + arr[i] * arr[k] * arr[j];\n                dp[i][j] = min(dp[i][j], cost);\n            }\n        }\n    }\n\n    // The minimum cost is stored in dp[0][n-1]\n    return dp[0][n - 1];\n}\n\nint main()\n{\n\n    vector<int> arr = {2, 1, 3, 4};\n    cout << matrixMultiplication(arr);\n    return 0;\n}\n// Java code to implement the\n// matrix chain multiplication using tabulation\nclass GfG {\n\n    // Function to calculate min multiplication cost\n    static int matrixMultiplication(int[] arr)\n    {\n\n        int n = arr.length;\n\n        // Create a 2D DP array to store minimum\n        // multiplication costs\n        int[][] dp = new int[n][n];\n\n        // Fill the DP array\n        // len is the chain length\n        for (int len = 2; len < n; len++) {\n            for (int i = 0; i < n - len; i++) {\n                int j = i + len;\n                dp[i][j] = Integer.MAX_VALUE;\n\n                for (int k = i + 1; k < j; k++) {\n                    int cost = dp[i][k] + dp[k][j]\n                               + arr[i] * arr[k] * arr[j];\n                    if (cost < dp[i][j]) {\n                        dp[i][j] = cost;\n                    }\n                }\n            }\n        }\n\n        // Minimum cost is in dp[0][n-1]\n        return dp[0][n - 1];\n    }\n\n    public static void main(String[] args)\n    {\n\n        int[] arr = { 2, 1, 3, 4 };\n        System.out.println(matrixMultiplication(arr));\n    }\n}\n# Python code to implement the\n# matrix chain multiplication using tabulation\n\ndef matrixMultiplication(arr):\n    n = len(arr)\n\n    # Create a 2D DP array to store min\n    # multiplication costs\n    dp = [[0] * n for _ in range(n)]\n\n    # Fill the DP array\n    # length is the chain length\n    for length in range(2, n):\n        for i in range(n - length):\n            j = i + length\n            dp[i][j] = float('inf')\n\n            for k in range(i + 1, j):\n                cost = dp[i][k] + dp[k][j] + arr[i] * arr[k] * arr[j]\n                dp[i][j] = min(dp[i][j], cost)\n\n    # Minimum cost is in dp[0][n-1]\n    return dp[0][n - 1]\n\n\narr = [2, 1, 3, 4]\nprint(matrixMultiplication(arr))\n// C# code to implement the\n// matrix chain multiplication using tabulation\nusing System;\n\nclass GfG {\n\n    // Function to calculate min multiplication cost\n    static int matrixMultiplication(int[] arr)\n    {\n        int n = arr.Length;\n\n        // Create a 2D DP array to store minimum\n        // multiplication costs\n        int[, ] dp = new int[n, n];\n\n        // Fill the DP array\n        // len is the chain length\n        for (int len = 2; len < n; len++) {\n            for (int i = 0; i < n - len; i++) {\n                int j = i + len;\n                dp[i, j] = int.MaxValue;\n\n                for (int k = i + 1; k < j; k++) {\n                    int cost = dp[i, k] + dp[k, j]\n                               + arr[i] * arr[k] * arr[j];\n                    if (cost < dp[i, j]) {\n                        dp[i, j] = cost;\n                    }\n                }\n            }\n        }\n\n        // Minimum cost is in dp[0][n-1]\n        return dp[0, n - 1];\n    }\n\n    static void Main()\n    {\n\n        int[] arr = { 2, 1, 3, 4 };\n        Console.WriteLine(matrixMultiplication(arr));\n    }\n}\n// JavaScript code to implement the\n// matrix chain multiplication using tabulation\nfunction matrixMultiplication(arr)\n{\n\n    const n = arr.length;\n\n    // Create a 2D DP array to store min\n    // multiplication costs\n    const dp\n        = Array.from({length : n}, () => Array(n).fill(0));\n\n    // Fill the DP array\n    // len is the chain length\n    for (let len = 2; len < n; len++) {\n        for (let i = 0; i < n - len; i++) {\n            let j = i + len;\n            dp[i][j] = Infinity;\n\n            for (let k = i + 1; k < j; k++) {\n                let cost = dp[i][k] + dp[k][j]\n                           + arr[i] * arr[k] * arr[j];\n                dp[i][j] = Math.min(dp[i][j], cost);\n            }\n        }\n    }\n\n    // Minimum cost is in dp[0][n-1]\n    return dp[0][n - 1];\n}\n\nconst arr = [ 2, 1, 3, 4 ];\nconsole.log(matrixMultiplication(arr));\n20\n",
        "complexity": {
            "time": "",
            "space": ""
        },
        "tags": [
            "Dynamic Programming"
        ],
        "url": "https://www.geeksforgeeks.org/matrix-chain-multiplication-dp-8/"
    },
    {
        "title": "Palindrome Partitioning",
        "description": "Given a string s, the task is to find the minimum number of cuts needed for palindrome partitioning of the given string. A partitioning of the string is a palindrome partitioning if every sub-string of the partition is a palindrome. Examples: Input: s = “geek” Output: 2 Explanation: We need to make minimum 2 cuts, i.e., “g | ee | k”. Input: s= “aaaa” Output: 0 Explanation: The string is already a palindrome. Input: s = “ababbbabbababa” Output: 3Explanation: We need to make minimum 3 cuts, i.e., “aba | bb | babbab | aba”. Table of Content In this approach, we will try to apply all possible partitions and at the end return the correct combination of partitions. This approach is similar to that of Matrix Chain Multiplication problem. In this approach, we recursively evaluate the following conditions: The above recursive approach has overlapping subproblems, leading to redundant computations thereby resulting in exponential time complexity. This redundant computation can be solved by using Memoization. To avoid redundant computations, we can memoize results of each subproblem and reuse them as needed. A 2D array can serve as a memoization table to store solutions for overlapping subproblems. The size of this memo table will be n*n, as there are n possible starting indices and n possible ending indices for any subarray. The approach is similar to the previous one; just instead of breaking down the problem recursively, we iteratively build up the solution by calculating in bottom-up manner. Here, we can use two 2D array dp[][] and isPalin[][], for storing the computed result. We starts with smaller substrings and gradually builds up to the result for entire string. Here we precompute a palindrome table isPalin[][], where isPalin[i][j] = true if s[i..j] is a palindrome. This helps efficiently check palindrome partitions. Then we fill dp[], where dp[i] stores the minimum cuts needed to partition s[0..i] into palindromic substrings. If s[0..i] is a palindrome, no cut is needed (dp[i] = 0). Otherwise, we check all valid partitions and update dp[i] accordingly. To fill dp[i], we find the suffix starting from j and ending at index i, (1 <= j <= i <= n – 1), which are palindromes. Hence, we can make a cut here that requires 1 + min cut from rest substring [0, j – 1]. For all such palindromic suffixes starting at j and ending at i, keep minimizing in dp[i]. Similarly, we need to compute results for all such i. (1 <= i <= n – 1) and finally, dp[n – 1] will be the minimum number of cuts needed for palindrome partitioning of the given string.  ",
        "code": "// C++ Program for Palindrome Partitioning Problem\n// using Recursion\n#include <iostream>\n#include <vector>\n#include <limits.h>\nusing namespace std;\n\n// Function to Check if a substring is a palindrome\nbool isPalindrome(string& s, int i, int j) {\n    while (i < j) {\n        if (s[i] != s[j])\n            return false;\n        i++;\n        j--;\n    }\n    return true;\n}\n\n// Recursive Function to find the minimum number of \n// cuts needed for palindrome partitioning\nint palPartitionRec(string& s, int i, int j) {\n  \n    // Base case: If the substring is empty or \n  \t// a palindrome, no cuts needed\n    if (i >= j || isPalindrome(s, i, j))\n        return 0;\n\n    int res = INT_MAX, cuts;\n\n    // Iterate through all possible partitions and \n  \t// find the minimum cuts needed\n    for (int k = i; k < j; k++) {\n        cuts = 1 + palPartitionRec(s, i, k)\n                \t+ palPartitionRec(s, k + 1, j);\n        res = min(res, cuts);\n    }\n\n    return res;\n}\n\nint palPartition(string &s) {\n  \treturn palPartitionRec(s, 0, s.size()-1);\n}\n\nint main() {\n    string s = \"geek\";\n\n    cout << palPartition(s) << endl;\n    return 0;\n}\n// C Program for Palindrome Partitioning Problem\n// using Recursion\n#include <stdio.h>\n#include <string.h>\n#include <limits.h>\n\n// Function to check if a substring is a palindrome\nint isPalindrome(char* s, int i, int j) {\n    while (i < j) {\n        if (s[i] != s[j])\n            return 0;\n        i++;\n        j--;\n    }\n    return 1;\n}\n\n// Recursive function to find the minimum number \n// of cuts needed for palindrome partitioning\nint palPartitionRec(char* s, int i, int j) {\n  \n    // Base case: If the substring is empty \n  \t// or a palindrome, no cuts needed\n    if (i >= j || isPalindrome(s, i, j))\n        return 0;\n\n    int res = INT_MAX, cuts;\n\n    // Iterate through all possible partitions \n  \t// and find the minimum cuts needed\n    for (int k = i; k < j; k++) {\n        cuts = 1 + palPartitionRec(s, i, k) + palPartitionRec(s, k + 1, j);\n        if (cuts < res) res = cuts;\n    }\n\n    return res;\n}\n\nint palPartition(char* s) {\n    return palPartitionRec(s, 0, strlen(s) - 1);\n}\n\nint main() {\n    char s[] = \"geek\";\n    printf(\"%d\\n\", palPartition(s));\n    return 0;\n}\n// Java Program for Palindrome Partitioning Problem\n// using Recursion\nimport java.util.*;\n\nclass GfG {\n\n    // Function to check if a substring is a palindrome\n    static boolean isPalindrome(String s, int i, int j) {\n        while (i < j) {\n            if (s.charAt(i) != s.charAt(j))\n                return false;\n            i++;\n            j--;\n        }\n        return true;\n    }\n\n    // Recursive function to find the minimum number of \n  \t// cuts needed for palindrome partitioning\n    static int palPartitionRec(String s, int i, int j) {\n      \n        // Base case: If the substring is empty\n      \t// or a palindrome, no cuts needed\n        if (i >= j || isPalindrome(s, i, j))\n            return 0;\n\n        int res = Integer.MAX_VALUE, cuts;\n\n        // Iterate through all possible partitions \n      \t// and find the minimum cuts needed\n        for (int k = i; k < j; k++) {\n            cuts = 1 + palPartitionRec(s, i, k) + \n              \t\t\tpalPartitionRec(s, k + 1, j);\n            res = Math.min(res, cuts);\n        }\n\n        return res;\n    }\n\n    static int palPartition(String s) {\n        return palPartitionRec(s, 0, s.length() - 1);\n    }\n\n    public static void main(String[] args) {\n        String s = \"geek\";\n        System.out.println(palPartition(s));\n    }\n}\n# Python Program for Palindrome Partitioning Problem\n# using Recursion\nimport sys\n\n# Function to check if a substring is a palindrome\ndef isPalindrome(s, i, j):\n    while i < j:\n        if s[i] != s[j]:\n            return False\n        i += 1\n        j -= 1\n    return True\n\n# Recursive function to find the minimum number \n# of cuts needed for palindrome partitioning\ndef palPartitionRec(s, i, j):\n  \n    # Base case: If the substring is empty \n    # or a palindrome, no cuts needed\n    if i >= j or isPalindrome(s, i, j):\n        return 0\n\n    res = sys.maxsize\n\n    # Iterate through all possible partitions \n    # and find the minimum cuts needed\n    for k in range(i, j):\n        cuts = 1 + palPartitionRec(s, i, k) \\\n        \t\t + palPartitionRec(s, k + 1, j)\n        res = min(res, cuts)\n\n    return res\n\ndef palPartition(s):\n    return palPartitionRec(s, 0, len(s) - 1)\n\nif __name__ == \"__main__\":\n    s = \"geek\"\n    print(palPartition(s))\n// C# Program for Palindrome Partitioning Problem\n// using Recursion\nusing System;\n\nclass GfG {\n\n    // Function to check if a substring is a palindrome\n    static bool isPalindrome(string s, int i, int j) {\n        while (i < j) {\n            if (s[i] != s[j])\n                return false;\n            i++;\n            j--;\n        }\n        return true;\n    }\n\n    // Recursive function to find the minimum number of \n  \t// cuts needed for palindrome partitioning\n    static int palPartitionRec(string s, int i, int j) {\n      \n        // Base case: If the substring is empty \n      \t// or a palindrome, no cuts needed\n        if (i >= j || isPalindrome(s, i, j))\n            return 0;\n\n        int res = int.MaxValue, cuts;\n\n        // Iterate through all possible partitions \n      \t// and find the minimum cuts needed\n        for (int k = i; k < j; k++) {\n            cuts = 1 + palPartitionRec(s, i, k) \n              \t\t\t+ palPartitionRec(s, k + 1, j);\n            res = Math.Min(res, cuts);\n        }\n\n        return res;\n    }\n\n    static int palPartition(string s) {\n        return palPartitionRec(s, 0, s.Length - 1);\n    }\n\n    static void Main() {\n        string s = \"geek\";\n        Console.WriteLine(palPartition(s));\n    }\n}\n// JavaScript Program for Palindrome Partitioning Problem\n// using Recursion\n\n// Function to check if a substring is a palindrome\nfunction isPalindrome(s, i, j) {\n    while (i < j) {\n        if (s[i] !== s[j])\n            return false;\n        i++;\n        j--;\n    }\n    return true;\n}\n\n// Recursive function to find the minimum number \n// of cuts needed for palindrome partitioning\nfunction palPartitionRec(s, i, j) {\n\n    // Base case: If the substring is empty \n    // or a palindrome, no cuts needed\n    if (i >= j || isPalindrome(s, i, j))\n        return 0;\n\n    let res = Number.MAX_SAFE_INTEGER, cuts;\n\n    // Iterate through all possible partitions \n    // and find the minimum cuts needed\n    for (let k = i; k < j; k++) {\n        cuts = 1 + palPartitionRec(s, i, k) \n        \t\t\t+ palPartitionRec(s, k + 1, j);\n        res = Math.min(res, cuts);\n    }\n\n    return res;\n}\n\nfunction palPartition(s) {\n    return palPartitionRec(s, 0, s.length - 1);\n}\n\n// Driver Code \nconst s = \"geek\";\nconsole.log(palPartition(s));\n2\n// C++ Program for Palindrome Partitioning Problem\n// Using Top-Down DP\n#include <iostream>\n#include <vector>\n#include <limits.h>\nusing namespace std;\n\n// Function to Check if a substring is a palindrome\nbool isPalindrome(string& s, int i, int j) {\n    while (i < j) {\n        if (s[i] != s[j])\n            return false;\n        i++;\n        j--;\n    }\n    return true;\n}\n\n// Recursive Function to find the minimum number of \n// cuts needed for palindrome partitioning\nint palPartitionRec(string& s, int i, int j, \n                    \tvector<vector<int>>& memo) {\n  \t\n  \t// check in memo for \n  \tif (memo[i][j] != -1) \n      \treturn memo[i][j];\n  \n    // Base case: If the substring is empty or \n  \t// a palindrome, no cuts needed\n    if (i >= j || isPalindrome(s, i, j))\n        return memo[i][j] = 0;\n\n    int res = INT_MAX, cuts;\n\n    // Iterate through all possible partitions and \n  \t// find the minimum cuts needed\n    for (int k = i; k < j; k++) {\n        cuts = 1 + palPartitionRec(s, i, k, memo)\n                + palPartitionRec(s, k + 1, j, memo);\n        res = min(res, cuts);\n    }\n\n    return memo[i][j] = res;\n}\n\nint palPartition(string &s) {\n  \tint n = s.size();\n  \n  \t// declare a memo array to store the result\n  \t// and initialise it with -1\n  \tvector<vector<int>> memo(n, vector<int> (n, -1));\n  \n  \treturn palPartitionRec(s, 0, n - 1, memo);\n}\n\nint main() {\n    string s = \"geek\";\n\n    cout << palPartition(s) << endl;\n    return 0;\n}\n// Java Program for Palindrome Partitioning Problem\n// Using Top-Down DP\nimport java.util.Arrays;\n\nclass GfG {\n\n    // Function to check if a substring is a palindrome\n    static boolean isPalindrome(String s, int i, int j) {\n        while (i < j) {\n            if (s.charAt(i) != s.charAt(j)) \n                return false;\n            i++;\n            j--;\n        }\n        return true;\n    }\n\n    // Recursive function to find the minimum number of \n  \t// cuts needed for palindrome partitioning\n    static int palPartitionRec(String s, int i, int j, int[][] memo) {\n      \n        // check in memo for previously computed results\n        if (memo[i][j] != -1) \n            return memo[i][j];\n\n        // Base case: If the substring is empty or \n      \t// a palindrome, no cuts needed\n        if (i >= j || isPalindrome(s, i, j)) \n            return memo[i][j] = 0;\n\n        int res = Integer.MAX_VALUE, cuts;\n\n        // Iterate through all possible partitions and\n      \t// find the minimum cuts needed\n        for (int k = i; k < j; k++) {\n            cuts = 1 + palPartitionRec(s, i, k, memo) \n              \t\t + palPartitionRec(s, k + 1, j, memo);\n            res = Math.min(res, cuts);\n        }\n\n        return memo[i][j] = res;\n    }\n\n    static int palPartition(String s) {\n        int n = s.length();\n        int[][] memo = new int[n][n];\n        \n        // Initialize memo array with -1\n        for (int[] row : memo)\n            Arrays.fill(row, -1);\n        \n        return palPartitionRec(s, 0, n - 1, memo);\n    }\n\n    public static void main(String[] args) {\n        String s = \"geek\";\n        System.out.println(palPartition(s));\n    }\n}\n# Python Program for Palindrome Partitioning Problem\n# Using Top-Down DP\nimport sys\n\n# Function to check if a substring is a palindrome\ndef isPalindrome(s, i, j):\n    while i < j:\n        if s[i] != s[j]:\n            return False\n        i += 1\n        j -= 1\n    return True\n\n# Recursive function to find the minimum number of\n# cuts needed for palindrome partitioning\ndef palPartitionRec(s, i, j, memo):\n  \n    # Check memo for previously computed results\n    if memo[i][j] != -1:\n        return memo[i][j]\n\n    # Base case: If the substring is empty or \n    # a palindrome, no cuts needed\n    if i >= j or isPalindrome(s, i, j):\n        memo[i][j] = 0\n        return 0\n\n    res = sys.maxsize\n\n    # Iterate through all possible partitions and\n    # find the minimum cuts needed\n    for k in range(i, j):\n        cuts = 1 + palPartitionRec(s, i, k, memo) \\\n        + palPartitionRec(s, k + 1, j, memo)\n        res = min(res, cuts)\n\n    memo[i][j] = res\n    return res\n\ndef palPartition(s):\n    n = len(s)\n    memo = [[-1 for _ in range(n)] for _ in range(n)]\n    return palPartitionRec(s, 0, n - 1, memo)\n\nif __name__ == \"__main__\":\n    s = \"geek\"\n    print(palPartition(s))\n// C# Program for Palindrome Partitioning Problem\n// Usin Top-Down DP\nusing System;\n\nclass GfG {\n\n    // Function to check if a substring is a palindrome\n    static bool isPalindrome(string s, int i, int j) {\n        while (i < j) {\n            if (s[i] != s[j]) \n                return false;\n            i++;\n            j--;\n        }\n        return true;\n    }\n\n    // Recursive function to find the minimum number of \n  \t// cuts needed for palindrome partitioning\n  \n    static int palPartitionRec(string s, int i, \n                               \tint j, int[,] memo) {\n      \n        // Check memo for previously computed results\n        if (memo[i, j] != -1) \n            return memo[i, j];\n\n        // Base case: If the substring is empty \n      \t// or a palindrome, no cuts needed\n        if (i >= j || isPalindrome(s, i, j)) \n            return memo[i, j] = 0;\n\n        int res = int.MaxValue, cuts;\n\n        // Iterate through all possible partitions \n      \t// and find the minimum cuts needed\n        for (int k = i; k < j; k++) {\n            cuts = 1 + palPartitionRec(s, i, k, memo) \n              \t+ palPartitionRec(s, k + 1, j, memo);\n            res = Math.Min(res, cuts);\n        }\n\n        return memo[i, j] = res;\n    }\n\n    static int palPartition(string s) {\n        int n = s.Length;\n        int[,] memo = new int[n, n];\n\n        // Initialize memo array with -1\n        for (int i = 0; i < n; i++)\n            for (int j = 0; j < n; j++)\n                memo[i, j] = -1;\n\n        return palPartitionRec(s, 0, n - 1, memo);\n    }\n\n    static void Main() {\n        string s = \"geek\";\n        Console.WriteLine(palPartition(s));\n    }\n}\n// JavaScript Program for Palindrome Partitioning Problem\n// Using Top-Down DP\n\n// Function to check if a substring is a palindrome\nfunction isPalindrome(s, i, j) {\n    while (i < j) {\n        if (s[i] !== s[j])\n            return false;\n        i++;\n        j--;\n    }\n    return true;\n}\n\n// Recursive function to find the minimum number of \n// cuts needed for palindrome partitioning\nfunction palPartitionRec(s, i, j, memo) {\n\n    // Check memo for previously computed results\n    if (memo[i][j] !== -1) \n        return memo[i][j];\n\n    // Base case: If the substring is empty or \n    // a palindrome, no cuts needed\n    if (i >= j || isPalindrome(s, i, j))\n        return memo[i][j] = 0;\n\n    let res = Infinity, cuts;\n\n    // Iterate through all possible partitions \n    // and find the minimum cuts needed\n    for (let k = i; k < j; k++) {\n        cuts = 1 + palPartitionRec(s, i, k, memo) \n        \t\t+ palPartitionRec(s, k + 1, j, memo);\n        res = Math.min(res, cuts);\n    }\n\n    return memo[i][j] = res;\n}\n\nfunction palPartition(s) {\n    const n = s.length;\n    const memo = Array.from({ length: n }, \n    \t\t\t\t() => Array(n).fill(-1));\n    return palPartitionRec(s, 0, n - 1, memo);\n}\n\n// Driver Code\nconst s = \"geek\";\nconsole.log(palPartition(s));\n2\n// C++ Solution for Palindrome Partitioning Problem\n// using Bottom Up Dynamic Programming\n#include <iostream>\n#include <vector>\n#include <climits>\nusing namespace std;\n\n// Function to find the minimum number of cuts \n// needed to partition a string such that \n// every part is a palindrome\nint palPartition(string& s) {\n    int n = s.length();\n\n    // dp[i][j] = Minimum number of cuts needed for\n    // palindrome partitioning of substring s[i..j]\n    int dp[n][n];\n\n    // isPalin[i][j] = true if substring s[i..j] \n  \t// is palindrome,else false\n    bool isPalin[n][n];\n\n    // Every substring of length 1 is a palindrome\n    for (int i = 0; i < n; i++) {\n        isPalin[i][i] = true;\n        dp[i][i] = 0;\n    }\n\n    for (int len = 2; len <= n; len++) {\n\n        // Build solution for all substrings s[i ... j] \n      \t// of length len\n        for (int i = 0, j = i + len - 1; j < n ; i++, j++) {\n          \n            // If len is 2, then we just need to\n            // compare two characters. \n            if (len == 2)\n                isPalin[i][j] = (s[i] == s[j]);\n          \n          \t// Else need to check two corner characters\n            // and value of isPalin[i+1][j-1]\n            else\n                isPalin[i][j] = (s[i] == s[j]) && \n              \t\t\t\t\t\tisPalin[i + 1][j - 1];\n\n            // IF s[i..j] is palindrome, then dp[i][j] is 0\n            if (isPalin[i][j] == true)\n                dp[i][j] = 0;\n            else {\n\n            // Make a cut at every possible location starting \n          \t// from i to j, and get the minimum cost cut.\n                dp[i][j] = INT_MAX;\n                for (int k = i; k <= j - 1; k++)\n                    dp[i][j] = min(dp[i][j], 1 + \n                                   dp[i][k] + dp[k + 1][j]);\n            }\n        }\n    }\n\n    // Return the min cut value for\n    // complete string. i.e., s[0..n-1]\n    return dp[0][n - 1];\n}\n\nint main() {\n    string s = \"geek\";\n\n    cout << palPartition(s) << endl;\n    return 0;\n}\n// Java Solution for Palindrome Partitioning Problem\n// using Bottom Up Dynamic Programming\nimport java.util.Arrays;\n\nclass GfG {\n\n    // Function to find the minimum number of cuts \n    // needed to partition a string such that \n    // every part is a palindrome\n    static int palPartition(String s) {\n        int n = s.length();\n\n        // dp[i][j] = Minimum number of cuts needed for\n        // palindrome partitioning of substring s[i..j]\n        int[][] dp = new int[n][n];\n\n        // isPalin[i][j] = true if substring s[i..j] \n        // is palindrome, else false\n        boolean[][] isPalin = new boolean[n][n];\n\n        // Every substring of length 1 is a palindrome\n        for (int i = 0; i < n; i++) {\n            isPalin[i][i] = true;\n            dp[i][i] = 0;\n        }\n\n        for (int len = 2; len <= n; len++) {\n\n            // Build solution for all  substrings s[i ... j] \n            // of length len\n            for (int i = 0, j = i + len - 1; j < n; i++, j++) {\n\n                // If len is 2, then we just need to\n                // compare two characters.\n                if (len == 2)\n                    isPalin[i][j] = (s.charAt(i) == s.charAt(j));\n\n                // Else need to check two corner characters\n                // and value of isPalin[i+1][j-1]\n                else\n                    isPalin[i][j] = (s.charAt(i) == s.charAt(j)) \n                  \t\t\t\t\t\t&& isPalin[i + 1][j - 1];\n\n                // IF s[i..j] is palindrome, then dp[i][j] is 0\n                if (isPalin[i][j])\n                    dp[i][j] = 0;\n                else {\n\n                    // Make a cut at every possible location starting \n                    // from i to j, and get the minimum cost cut.\n                    dp[i][j] = Integer.MAX_VALUE;\n                    for (int k = i; k <= j - 1; k++)\n                        dp[i][j] = Math.min(dp[i][j], 1 + \n                                          dp[i][k] + dp[k + 1][j]);\n                }\n            }\n        }\n\n        // Return the min cut value for\n        // complete string. i.e., s[0..n-1]\n        return dp[0][n - 1];\n    }\n\n    public static void main(String[] args) {\n        String s = \"geek\";\n        System.out.println(palPartition(s));\n    }\n}\n# Python Solution for Palindrome Partitioning Problem\n# using Bottom Up Dynamic Programming\n\n# Function to find the minimum number of cuts \n# needed to partition a string such that \n# every part is a palindrome\ndef palPartition(s):\n    n = len(s)\n\n    # dp[i][j] = Minimum number of cuts needed for\n    # palindrome partitioning of substring s[i..j]\n    dp = [[0] * n for _ in range(n)]\n\n    # isPalin[i][j] = true if substring s[i..j] \n    # is palindrome, else false\n    isPalin = [[False] * n for _ in range(n)]\n\n    # Every substring of length 1 is a palindrome\n    for i in range(n):\n        isPalin[i][i] = True\n        dp[i][i] = 0\n\n    for length in range(2, n + 1):\n\n        # Build solution for all  substrings s[i ... j] \n        # of length len\n        for i in range(n - length + 1):\n            j = i + length - 1\n\n            # If len is 2, then we just need to\n            # compare two characters.\n            if length == 2:\n                isPalin[i][j] = (s[i] == s[j])\n                \n            # Else need to check two corner characters\n            # and value of isPalin[i+1][j-1]\n            else:\n                isPalin[i][j] = (s[i] == s[j]) and isPalin[i + 1][j - 1]\n\n            # IF s[i..j] is palindrome, then dp[i][j] is 0\n            if isPalin[i][j]:\n                dp[i][j] = 0\n            else:\n                # Make a cut at every possible location starting \n                # from i to j, and get the minimum cost cut.\n                dp[i][j] = min(1 + dp[i][k] + dp[k + 1][j] for k in range(i, j))\n\n    # Return the min cut value for\n    # complete string. i.e., s[0..n-1]\n    return dp[0][n - 1]\n\nif __name__ == \"__main__\":\n    s = \"geek\"\n    print(palPartition(s))\n// C# Solution for Palindrome Partitioning Problem\n// using Bottom Up Dynamic Programming\nusing System;\n\nclass GfG {\n\n    // Function to find the minimum number of cuts \n    // needed to partition a string such that \n    // every part is a palindrome\n    static int palPartition(string s) {\n        int n = s.Length;\n\n        // dp[i][j] = Minimum number of cuts needed for\n        // palindrome partitioning of substring s[i..j]\n        int[,] dp = new int[n, n];\n\n        // isPalin[i][j] = true if substring s[i..j] \n        // is palindrome, else false\n        bool[,] isPalin = new bool[n, n];\n\n        // Every substring of length 1 is a palindrome\n        for (int i = 0; i < n; i++) {\n            isPalin[i, i] = true;\n            dp[i, i] = 0;\n        }\n\n        for (int len = 2; len <= n; len++) {\n\n            // Build solution for all substrings s[i ... j] \n            // of length len\n            for (int i = 0, j = i + len - 1; j < n; i++, j++) {\n\n                // If len is 2, then we just need to\n                // compare two characters.\n                if (len == 2)\n                    isPalin[i, j] = (s[i] == s[j]);\n\n                // Else need to check two corner characters\n                // and value of isPalin[i+1][j-1]\n                else\n                    isPalin[i, j] = (s[i] == s[j]) && \n                  \t\t\t\t\t\tisPalin[i + 1, j - 1];\n\n                // IF s[i..j] is palindrome, then dp[i][j] is 0\n                if (isPalin[i, j])\n                    dp[i, j] = 0;\n                else {\n\n                    // Make a cut at every possible location starting \n                    // from i to j, and get the minimum cost cut.\n                    dp[i, j] = int.MaxValue;\n                    for (int k = i; k <= j - 1; k++)\n                        dp[i, j] = Math.Min(dp[i, j], 1 + \n                                            dp[i, k] + dp[k + 1, j]);\n                }\n            }\n        }\n\n        // Return the min cut value for\n        // complete string. i.e., s[0..n-1]\n        return dp[0, n - 1];\n    }\n\n    static void Main() {\n        string s = \"geek\";\n        Console.WriteLine(palPartition(s));\n    }\n}\n// JavaScript Solution for Palindrome Partitioning Problem\n// using Bottom Up Dynamic Programming\n\n// Function to find the minimum number of cuts \n// needed to partition a string such that \n// every part is a palindrome\nfunction palPartition(s) {\n    let n = s.length;\n\n    // dp[i][j] = Minimum number of cuts needed for\n    // palindrome partitioning of substring s[i..j]\n    let dp = Array.from({ length: n }, \n    \t\t\t\t\t\t\t() => Array(n).fill(0));\n\n    // isPalin[i][j] = true if substring s[i..j] \n    // is palindrome, else false\n    let isPalin = Array.from({ length: n }, \n    \t\t\t\t\t\t() => Array(n).fill(false));\n\n    // Every substring of length 1 is a palindrome\n    for (let i = 0; i < n; i++) {\n        isPalin[i][i] = true;\n        dp[i][i] = 0;\n    }\n\n    for (let len = 2; len <= n; len++) {\n\n        // Build solution for all substrings s[i ... j] \n        // of length len\n        for (let i = 0; i <= n - len; i++) {\n            let j = i + len - 1;\n\n            // If len is 2, then we just need to\n            // compare two characters.\n            if (len === 2)\n                isPalin[i][j] = (s[i] === s[j]);\n\n            // Else need to check two corner characters\n            // and value of isPalin[i+1][j-1]\n            else\n                isPalin[i][j] = (s[i] === s[j]) && \n\t\t\t\t\t\t\t\t\tisPalin[i + 1][j - 1];\n\n            // IF s[i..j] is palindrome, then dp[i][j] is 0\n            if (isPalin[i][j])\n                dp[i][j] = 0;\n            else {\n\n                // Make a cut at every possible location starting \n                // from i to j, and get the minimum cost cut.\n                dp[i][j] = Infinity;\n                for (let k = i; k <= j - 1; k++)\n                    dp[i][j] = Math.min(dp[i][j], 1 + \n                    \t\tdp[i][k] + dp[k + 1][j]);\n            }\n        }\n    }\n\n    // Return the min cut value for\n    // complete string. i.e., s[0..n-1]\n    return dp[0][n - 1];\n}\n\n// Driver Code \nlet s = \"geek\";\nconsole.log(palPartition(s));\n2\n// C++ Solution for Palindrome Partitioning Problem\n// using Optimised Bottom Up Dynamic Programming\n#include <iostream>\n#include <vector>\n#include <climits>\nusing namespace std;\n\n// Function to fill isPalin array such that isPalin[i][j] \n// stores whether substring s[i, j] is a palindrome or not\nvoid generatePal(string& s, vector<vector<bool>>& isPalin) {\n    int n = s.size();\n\n    // Substring s[i .. i] of len 1 \n  \t// is always palindromic\n    for (int i = 0; i < n; i++) {\n        isPalin[i][i] = true;\n    }\n\n    // Iterate over different lengths of substrings\n    for (int len = 2; len <= n; len++) {\n      \n        for (int i = 0, j = i + len - 1; j < n ; i++, j++) {\n          \n            // Check whether s[i] == s[j] and the\n            // substring between them is a palindrome\n            if (s[i] == s[j] && (len == 2 \n                                 || isPalin[i + 1][j - 1])) {\n\n                // Mark the substring from i to j as a\n                // palindrome\n                isPalin[i][j] = true;\n            }\n        }\n    }\n}\n\n// Function to calculate the minimum number of cuts required\n// to make all substrings of 's' palindromic\nint palPartition(string& s) {\n    int n = s.size();\n\n    // 2D array to store whether substring \n  \t// s[i, j] is a palindrome or not\n    vector<vector<bool>> isPalin(n, vector<bool>(n, false));\n\n    generatePal(s, isPalin);\n\n    // dp[i] stores minimum cuts for Palindrome \n  \t// Partitioning of substring s[0...i] \n    vector<int> dp(n, n);\n\n    // There is no cut required for single character\n    // as it is always palindrome\n    dp[0] = 0;\n\n    // Iterate over the given string\n    for (int i = 1; i < n; i++) {\n\n        // Check if string 0 to i is palindrome.\n        if (isPalin[0][i]) {\n          \n          \t// if palindrome then cuts required is 0\n            dp[i] = 0;\n        }\n        else {\n            for (int j = i; j >= 1; j--) {\n              \n              \t// if substring s[j...i] is palindromic\n              \t// then we can make a cut over here\n                if (isPalin[j][i]) {\n\n                  \t// update dp[i] with minimum cuts\n                  \tdp[i] = min(dp[i], 1 + dp[j-1]);\n                }\n            }\n        }\n    }\n\n    // Return the minimum cuts required \n  \t// for the entire string 's'\n  \t\n    return dp[n - 1];\n    \n}\n\nint main() {\n    string s = \"geek\";\n\n    cout << palPartition(s) << endl;\n    return 0;\n}\n// Java Solution for Palindrome Partitioning Problem\n// using Optimised Bottom Up Dynamic Programming\nimport java.util.Arrays;\n\nclass GfG {\n\n    // Function to fill isPalin array such that isPalin[i][j] \n    // stores whether substring s[i, j] is a palindrome or not\n    static void generatePal(String s, boolean[][] isPalin) {\n        int n = s.length();\n\n        // Substring s[i .. i] of len 1 \n        // is always palindromic\n        for (int i = 0; i < n; i++) {\n            isPalin[i][i] = true;\n        }\n\n        // Iterate over different lengths of substrings\n        for (int len = 2; len <= n; len++) {\n            for (int i = 0, j = i + len - 1; j < n; i++, j++) {\n\n                // Check whether s[i] == s[j] and the\n                // substring between them is a palindrome\n                if (s.charAt(i) == s.charAt(j) && \n                    (len == 2 || isPalin[i + 1][j - 1])) {\n\n                    // Mark the substring from i to j as a\n                    // palindrome\n                    isPalin[i][j] = true;\n                }\n            }\n        }\n    }\n\n    // Function to calculate the minimum number of cuts required\n    // to make all substrings of 's' palindromic\n    static int palPartition(String s) {\n        int n = s.length();\n\n        // 2D array to store whether substring \n        // s[i, j] is a palindrome or not\n        boolean[][] isPalin = new boolean[n][n];\n\n        generatePal(s, isPalin);\n\n        // dp[i] stores minimum cuts for Palindrome \n        // Partitioning of substring s[0...i] \n        int[] dp = new int[n];\n        Arrays.fill(dp, n);\n\n        // There is no cut required for single character\n        // as it is always palindrome\n        dp[0] = 0;\n\n        // Iterate over the given string\n        for (int i = 1; i < n; i++) {\n\n            // Check if string 0 to i is palindrome.\n            if (isPalin[0][i]) {\n\n                // if palindrome then cuts required is 0\n                dp[i] = 0;\n            } else {\n                for (int j = i; j >= 1; j--) {\n\n                    // if substring s[j...i] is palindromic\n                    // then we can make a cut over here\n                    if (isPalin[j][i]) {\n\n                        // update dp[i] with minimum cuts\n                        dp[i] = Math.min(dp[i], 1 + dp[j - 1]);\n                    }\n                }\n            }\n        }\n\n        // Return the minimum cuts required \n        // for the entire string 's'\n        return dp[n - 1];\n    }\n\n    public static void main(String[] args) {\n        String s = \"geek\";\n        System.out.println(palPartition(s));\n    }\n}\n# Python Solution for Palindrome Partitioning Problem\n# using Optimised Bottom Up Dynamic Programming\n\n# Function to fill isPalin array such that isPalin[i][j] \n# stores whether substring s[i, j] is a palindrome or not\ndef generatePal(s, isPalin):\n    n = len(s)\n\n    # Substring s[i .. i] of len 1 \n    # is always palindromic\n    for i in range(n):\n        isPalin[i][i] = True\n\n    # Iterate over different lengths of substrings\n    for length in range(2, n + 1):\n        for i in range(n - length + 1):\n            j = i + length - 1\n\n            # Check whether s[i] == s[j] and the\n            # substring between them is a palindrome\n            if s[i] == s[j] and (length == 2 or isPalin[i + 1][j - 1]):\n              \n                # Mark the substring from i to j as a\n                # palindrome\n                isPalin[i][j] = True\n\n# Function to calculate the minimum number of cuts required\n# to make all substrings of 's' palindromic\ndef palPartition(s):\n    n = len(s)\n\n    # 2D array to store whether substring \n    # s[i, j] is a palindrome or not\n    isPalin = [[False] * n for _ in range(n)]\n\n    generatePal(s, isPalin)\n\n    # dp[i] stores minimum cuts for Palindrome \n    # Partitioning of substring s[0...i] \n    dp = [n] * n\n\n    # There is no cut required for single character\n    # as it is always palindrome\n    dp[0] = 0\n\n    # Iterate over the given string\n    for i in range(1, n):\n\n        # Check if string 0 to i is palindrome.\n        if isPalin[0][i]:\n          \n            # if palindrome then cuts required is 0\n            dp[i] = 0\n        else:\n            for j in range(i, 0, -1):\n\n                # if substring s[j...i] is palindromic\n                # then we can make a cut over here\n                if isPalin[j][i]:\n                  \n                    # update dp[i] with minimum cuts\n                    dp[i] = min(dp[i], 1 + dp[j - 1])\n\n    # Return the minimum cuts required \n    # for the entire string 's'\n    return dp[n - 1]\n\nif __name__ == \"__main__\":\n    s = \"geek\"\n    print(palPartition(s))\n// C# Solution for Palindrome Partitioning Problem\n// using Optimised Bottom Up Dynamic Programming\nusing System;\n\nclass GfG {\n\n    // Function to fill isPalin array such that isPalin[i][j] \n    // stores whether substring s[i, j] is a palindrome or not\n    static void GeneratePal(string s, bool[,] isPalin) {\n        int n = s.Length;\n\n        // Substring s[i .. i] of len 1 \n        // is always palindromic\n        for (int i = 0; i < n; i++) {\n            isPalin[i, i] = true;\n        }\n\n        // Iterate over different lengths of substrings\n        for (int len = 2; len <= n; len++) {\n            for (int i = 0, j = i + len - 1; j < n; i++, j++) {\n\n                // Check whether s[i] == s[j] and the\n                // substring between them is a palindrome\n                if (s[i] == s[j] && (len == 2 || isPalin[i + 1, j - 1])) {\n\n                    // Mark the substring from i to j as a\n                    // palindrome\n                    isPalin[i, j] = true;\n                }\n            }\n        }\n    }\n\n    // Function to calculate the minimum number of cuts required\n    // to make all substrings of 's' palindromic\n    static int palPartition(string s) {\n        int n = s.Length;\n\n        // 2D array to store whether substring \n        // s[i, j] is a palindrome or not\n        bool[,] isPalin = new bool[n, n];\n\n        GeneratePal(s, isPalin);\n\n        // dp[i] stores minimum cuts for Palindrome \n        // Partitioning of substring s[0...i] \n        int[] dp = new int[n];\n        Array.Fill(dp, n);\n\n        // There is no cut required for single character\n        // as it is always palindrome\n        dp[0] = 0;\n\n        // Iterate over the given string\n        for (int i = 1; i < n; i++) {\n\n            // Check if string 0 to i is palindrome.\n            if (isPalin[0, i]) {\n              \n                // if palindrome then cuts required is 0\n                dp[i] = 0;\n            } else {\n                for (int j = i; j >= 1; j--) {\n\n                    // if substring s[j...i] is palindromic\n                    // then we can make a cut over here\n                    if (isPalin[j, i]) {\n\n                        // update dp[i] with minimum cuts\n                        dp[i] = Math.Min(dp[i], 1 + dp[j - 1]);\n                    }\n                }\n            }\n        }\n\n        // Return the minimum cuts required \n        // for the entire string 's'\n        return dp[n - 1];\n    }\n\n    static void Main() {\n        string s = \"geek\";\n        Console.WriteLine(palPartition(s));\n    }\n}\n// JavaScript Solution for Palindrome Partitioning Problem\n// using Optimised Bottom Up Dynamic Programming\n\n// Function to fill isPalin array such that isPalin[i][j] \n// stores whether substring s[i, j] is a palindrome or not\nfunction generatePal(s, isPalin) {\n    let n = s.length;\n\n    // Substring s[i .. i] of len 1 \n    // is always palindromic\n    for (let i = 0; i < n; i++) {\n        isPalin[i][i] = true;\n    }\n\n    // Iterate over different lengths of substrings\n    for (let len = 2; len <= n; len++) {\n        for (let i = 0, j = i + len - 1; j < n; i++, j++) {\n\n            // Check whether s[i] == s[j] and the\n            // substring between them is a palindrome\n            if (s[i] === s[j] && (len === 2 || isPalin[i + 1][j - 1])) {\n\n                // Mark the substring from i to j as a\n                // palindrome\n                isPalin[i][j] = true;\n            }\n        }\n    }\n}\n\n// Function to calculate the minimum number of cuts required\n// to make all substrings of 's' palindromic\nfunction palPartition(s) {\n    let n = s.length;\n\n    // 2D array to store whether substring \n    // s[i, j] is a palindrome or not\n    let isPalin = Array.from({ length: n }, \n    \t\t\t\t\t() => Array(n).fill(false));\n\n    generatePal(s, isPalin);\n\n    // dp[i] stores minimum cuts for Palindrome \n    // Partitioning of substring s[0...i] \n    let dp = new Array(n).fill(n);\n\n    // There is no cut required for single character\n    // as it is always palindrome\n    dp[0] = 0;\n\n    // Iterate over the given string\n    for (let i = 1; i < n; i++) {\n\n        // Check if string 0 to i is palindrome.\n        if (isPalin[0][i]) {\n\n            // if palindrome then cuts required is 0\n            dp[i] = 0;\n        } else {\n            for (let j = i; j >= 1; j--) {\n\n                // if substring s[j...i] is palindromic\n                // then we can make a cut over here\n                if (isPalin[j][i]) {\n\n                    // update dp[i] with minimum cuts\n                    dp[i] = Math.min(dp[i], 1 + dp[j - 1]);\n                }\n            }\n        }\n    }\n\n    // Return the minimum cuts required \n    // for the entire string 's'\n    return dp[n - 1];\n}\n\n// Driver Code \nlet s = \"geek\";\nconsole.log(palPartition(s));\n2\n",
        "complexity": {
            "time": "The above recursive approach has overlapping subproblems, leading to redundant computations thereby resulting in exponential time complexity. This redundant computation can be solved by using Memoization.",
            "space": ""
        },
        "tags": [
            "Dynamic Programming"
        ],
        "url": "https://www.geeksforgeeks.org/palindrome-partitioning-dp-17/"
    },
    {
        "title": "Dynamic Programming (DP) on Arrays Tutorial",
        "description": "We know that Dynamic Programming is a way to reduce the time complexity of a problem using memoization or tabulation of the overlapping states. While applying DP on arrays the array indices act as DP states and transitions occurs between indices. Table of Content Before coding the solution, we need to verify whether the time complexity of our solution fits the given constraints or not, we can approximate the time complexity using the below formula: Time Complexity = Total Number of States * ( 1 + Average number of Transitions per State) Space Complexity = Average number of States. The problems that we see on Competitive Programming platforms are mainly made up of two parts: The Adhoc part of the problem is the one that makes each problem unique and also the one that decides the difficulty of the problem. One needs to make several observations to deduce the Adhoc part into the standard solution. Good dp problems will often require you to make adhoc observations to figure out some properties that allow you to apply dp on them. Let's us see how an Adhoc problem changes a standard DP problem: Problem: You are given N tiles 1 to N, and initially you are standing at 1. In one move you can make a jump of either 1 or 2 in forward direction. Determine the total number of ways you can reach from tile 1 to tile N. Example: N=4 Output:  total 3 ways are possible Explaination: 1->2->3->4 1->2->4 1->3->4 Adhoc Part: The Adhoc part of the problem diverts the question towards thinking of moving on tiles from 1 to N in different ways, the programmer will dry run several test cases and make several observations in order to reach to the solution, he might even try to make some mathematical formula to calculate the solution. Standard Part: If observed carefully this question is nothing but print the N'th fibonacci number the simplest DP problem that might exist. each tile T can be reached only via previous two tiles that is T is dependent upon T-1 and T-2. Using This we can write the DP states as: The recurrence relation for the factorial of a number n is given by: The recurrence relation for the inverse factorial of a number n is given by: When tackling DP problems during a contest the most difficult task is to define the states and transitions for the problem. The states and transitions for problems are mostly the variations of existing standard DP problems, let us see how we can try to think towards a particular standard DP problem: Transition: The transitions in Edit distance are very commonly seen in many questions where a particular dp value depends upon previously calculated adjacent dp cells. Transition: Similar to Edit distance, LCS transitions can also be very frequently observed in various problems. Problem Practice Link Minimum number of jumps to reach end (Jump Game) Solve Count number of coins required to make a given value (Coin Change II) Solve 0/1 Knapsack Problem Solve Sieve of Eratosthenes Solve Matrix Chain Multiplication Solve Longest Common Subsequence (LCS) Solve Longest Increasing Subsequence (LIS) Solve Longest Palindromic Substring Solve Save Your Life Solve Travelling Salesman Problem using Dynamic Programming Solve Floyd Warshall Algorithm Solve Count Unique Paths in matrix Solve Edit Distance Solve Cutting a Rod Solve  V  ",
        "code": "",
        "complexity": {
            "time": "Time Complexity = Total Number of States * ( 1 + Average number of Transitions per State)",
            "space": "Space Complexity = Average number of States."
        },
        "tags": [
            "Dynamic Programming"
        ],
        "url": "https://www.geeksforgeeks.org/dynamic-programming-dp-on-arrays-tutorial/"
    },
    {
        "title": "Count Ways To Assign Unique Cap To Every Person",
        "description": "Given n people and 100 types of caps labelled from 1 to 100, along with a 2D integer array caps where caps[i] represents the list of caps preferred by the i-th person,  the task is to determine the number of ways the n people can wear different caps. Example: Input: caps = [[3, 4], [4, 5], [5]] Output: 1Explanation: First person choose cap 3, Second person choose cap 4 and last one cap 5. Input: caps = [[3, 5, 1], [3, 5]]Output: 4Explanation: There are 4 ways to choose hats: (3, 5), (5, 3), (1, 3) and (1, 5) Table of Content In the recursive approach, there are two cases for each cap: The recurrence relation is as follows: Base Cases: The above solution will have a exponential time complexity. If we notice carefully, we can observe that the above recursive solution holds the following two properties of Dynamic Programming. 1. Optimal Substructure: The problem exhibits optimal substructure, meaning that the solution to the problem can be derived from the solutions of smaller subproblems. The recursive relation is: 2. Overlapping Subproblems: Many subproblems are computed multiple times with the same parameters (cap, assignedPeople). To avoid recomputing the same subproblems, we store the result in a memoization table memo[cap][assignedPeople], which stores the number of ways to assign caps for a given cap and assignedPeople combination. We use a 2D DP table of size (number of caps + 1) * (2^n). The state dp[cap][assignedPeople] represents the number of ways to assign caps to people considering the first cap caps and assigning caps to the people represented by the bitmask assignedPeople. Dynamic Programming Relation: Base Case: dp[0][0] = 1, If no caps are assigned and no people are assigned any caps, there is 1 way to do nothing. Skip the current cap: Assign the current cap to a person who hasn’t been assigned a cap: After filling the DP table, the final result will be stored in dp[100][allMask], which represents the number of ways to assign all caps to all people. G  ",
        "code": "// C++ Code to Assign Unique Cap To Every Person\n// using Recursion\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Recursive function to calculate the number of ways\n// to assign caps to people such that each person has\n// a unique cap\nint dfs(int assignedCount, vector<bool>& assignedPeople,\n        int cap, vector<vector<int>>& capToPeople, int totalPeople) {\n    \n    // Base case: if all people have a cap assigned, return 1\n    if (assignedCount == totalPeople) {\n        return 1;\n    }\n    \n    // If we've considered all caps and not everyone\n    // has a cap, return 0\n    if (cap > 100) {\n        return 0;\n    }\n\n    // Case: skip the current cap\n    int ways = dfs(assignedCount, assignedPeople, \n                   cap + 1, capToPeople, totalPeople);\n\n    // Assign the current cap to each person who likes it\n    for (int person : capToPeople[cap]) {\n\n        // Check if the person already has a cap assigned\n        if (!assignedPeople[person]) {\n            \n            // Assign current cap to the person\n            assignedPeople[person] = true;\n            \n            // Recurse with increased assigned count\n            ways = ways + dfs(assignedCount + 1, assignedPeople, \n                               cap + 1, capToPeople, totalPeople);\n            \n            // Backtrack: unassign the cap for other possibilities\n            assignedPeople[person] = false;\n        }\n    }\n\n    return ways;\n}\n\n// Main function to calculate the number of ways to assign caps\nint numberWays(vector<vector<int>>& caps) {\n    int n = caps.size();\n\n    // Map each cap to the list of people who prefer it\n    vector<vector<int>> capToPeople(101);\n    for (int i = 0; i < n; ++i) {\n        for (int cap : caps[i]) {\n            capToPeople[cap].push_back(i);\n        }\n    }\n\n    // Initialize assignedPeople vector to track\n  \t// assigned caps\n    vector<bool> assignedPeople(n, false);\n    \n    // Call the recursive function starting from the first cap\n    return dfs(0, assignedPeople, 1, capToPeople, n);\n}\n\nint main() {\n  \n    vector<vector<int>> caps\n        = {{1, 2, 3}, {1, 2}, {3, 4}, {4, 5}};\n    \n    cout << numberWays(caps) << endl;\n\n    return 0;\n}\n// Java Code to Assign Unique Cap To Every Person\n// using Recursion\nimport java.util.ArrayList;\nimport java.util.List;\n\nclass GfG {\n\n    // Recursive function to calculate the number of ways\n    // to assign caps to people such that each person has\n    // a unique cap\n    static int dfs(int assignedCount, ArrayList<Boolean> assignedPeople,\n              int cap, ArrayList<ArrayList<Integer>> capToPeople, int totalPeople) {\n        \n        // Base case: if all people have a cap assigned, return 1\n        if (assignedCount == totalPeople) {\n            return 1;\n        }\n        \n        // If we've considered all caps and not everyone\n        // has a cap, return 0\n        if (cap > 100) {\n            return 0;\n        }\n\n        // Case: skip the current cap\n        int ways = dfs(assignedCount, assignedPeople, \n                       cap + 1, capToPeople, totalPeople);\n\n        // Assign the current cap to each person who likes it\n        for (int person : capToPeople.get(cap)) {\n\n            // Check if the person already has a cap assigned\n            if (!assignedPeople.get(person)) {\n                \n                // Assign current cap to the person\n                assignedPeople.set(person, true);\n                \n                // Recurse with increased assigned count\n                ways = ways + dfs(assignedCount + 1, assignedPeople, \n                                   cap + 1, capToPeople, totalPeople);\n                \n                // Backtrack: unassign the cap for other possibilities\n                assignedPeople.set(person, false);\n            }\n        }\n\n        return ways;\n    }\n\n    // Main function to calculate the number of ways to assign caps\n   \tstatic int numberWays(ArrayList<ArrayList<Integer>> caps) {\n        int n = caps.size();\n\n        // Map each cap to the list of people who prefer it\n        ArrayList<ArrayList<Integer>> capToPeople = new ArrayList<>(101);\n        for (int i = 0; i <= 100; i++) {\n            capToPeople.add(new ArrayList<>());\n        }\n        \n        for (int i = 0; i < n; ++i) {\n            for (int cap : caps.get(i)) {\n                capToPeople.get(cap).add(i);\n            }\n        }\n\n        // Initialize assignedPeople list to track assigned caps\n        ArrayList<Boolean> assignedPeople = new ArrayList<>(n);\n        for (int i = 0; i < n; i++) {\n            assignedPeople.add(false);\n        }\n        \n        // Call the recursive function starting from the first cap\n        return dfs(0, assignedPeople, 1, capToPeople, n);\n    }\n\n    public static void main(String[] args) {\n      \n        ArrayList<ArrayList<Integer>> caps = new ArrayList<>();\n        caps.add(new ArrayList<>(List.of(1, 2, 3)));\n        caps.add(new ArrayList<>(List.of(1, 2)));\n        caps.add(new ArrayList<>(List.of(3, 4)));\n        caps.add(new ArrayList<>(List.of(4, 5)));\n        \n        System.out.println(numberWays(caps));\n    }\n}\n# Python Code to Assign Unique Cap To Every Person\n# using Recursion\ndef dfs(assigned_count, assigned_people, cap, cap_to_people, total_people):\n    \n    # Base case: if all people have a cap assigned, return 1\n    if assigned_count == total_people:\n        return 1\n    \n    # If we've considered all caps and not everyone\n    # has a cap, return 0\n    if cap > 100:\n        return 0\n\n    # Case: skip the current cap\n    ways = dfs(assigned_count, assigned_people, \n               cap + 1, cap_to_people, total_people)\n\n    # Assign the current cap to each person who likes it\n    for person in cap_to_people[cap]:\n\n        # Check if the person already has a cap assigned\n        if not assigned_people[person]:\n            \n            # Assign current cap to the person\n            assigned_people[person] = True\n            \n            # Recurse with increased assigned count\n            ways += dfs(assigned_count + 1, assigned_people, \n                        cap + 1, cap_to_people, total_people)\n            \n            # Backtrack: unassign the cap for other possibilities\n            assigned_people[person] = False\n\n    return ways\n\n# Main function to calculate the number\n# of ways to assign caps\ndef number_ways(caps):\n    n = len(caps)\n\n    # Map each cap to the list of people who prefer it\n    cap_to_people = [[] for _ in range(101)]\n    for i in range(n):\n        for cap in caps[i]:\n            cap_to_people[cap].append(i)\n\n    # Initialize assigned_people list to track assigned caps\n    assigned_people = [False] * n\n    \n    # Call the recursive function starting from the first cap\n    return dfs(0, assigned_people, 1, cap_to_people, n)\n\nif __name__ == \"__main__\":\n  \n    caps = [[1, 2, 3], [1, 2], [3, 4], [4, 5]]\n    print(number_ways(caps))\n// C# Code to Assign Unique Cap To Every Person\n// using Recursion\nusing System;\nusing System.Collections.Generic;\n\nclass GfG {\n\n    // Recursive function to calculate the number of ways\n    // to assign caps to people such that each person has\n    // a unique cap\n    static int Dfs(int assignedCount, \n                   bool[] assignedPeople, int cap, \n                    List<List<int>> capToPeople, int totalPeople) {\n      \n        // Base case: if all people have a cap assigned, return 1\n        if (assignedCount == totalPeople) {\n            return 1;\n        }\n\n        // If we've considered all caps and not everyone\n        // has a cap, return 0\n        if (cap > 100) {\n            return 0;\n        }\n\n        // Case: skip the current cap\n        int ways = Dfs(assignedCount, assignedPeople,\n                       cap + 1, capToPeople, totalPeople);\n\n        // Assign the current cap to each person who likes it\n        foreach (int person in capToPeople[cap]) {\n          \n            // Check if the person already has a cap assigned\n            if (!assignedPeople[person]) {\n              \n                // Assign current cap to the person\n                assignedPeople[person] = true;\n\n                // Recurse with increased assigned count\n                ways += Dfs(assignedCount + 1, assignedPeople, \n                            cap + 1, capToPeople, totalPeople);\n\n                // Backtrack: unassign the cap for other\n              \t// possibilities\n                assignedPeople[person] = false;\n            }\n        }\n\n        return ways;\n    }\n\n    // Main function to calculate the number of ways\n  \t// to assign caps\n    static int NumberWays(List<List<int>> caps) {\n        int n = caps.Count;\n\n        // Map each cap to the list of people who prefer it\n        List<List<int>> capToPeople = new List<List<int>>();\n        for (int i = 0; i <= 100; i++) {\n            capToPeople.Add(new List<int>());\n        }\n\n        for (int i = 0; i < n; i++) {\n            foreach (int cap in caps[i]) {\n                capToPeople[cap].Add(i);\n            }\n        }\n\n        // Initialize assignedPeople array to\n      \t// track assigned caps\n        bool[] assignedPeople = new bool[n];\n\n        // Call the recursive function starting\n      \t// from the first cap\n        return Dfs(0, assignedPeople, 1, capToPeople, n);\n    }\n\n    static void Main() {\n        List<List<int>> caps = new List<List<int>> {\n            new List<int> {1, 2, 3},\n            new List<int> {1, 2},\n            new List<int> {3, 4},\n            new List<int> {4, 5}\n        };\n\n        Console.WriteLine(NumberWays(caps));\n    }\n}\n// Javascript Code to Assign Unique Cap To Every Person\n// using Recursion\nfunction dfs(assignedCount, assignedPeople, cap,\n                           capToPeople, totalPeople) {\n                           \n    // Base case: if all people have a cap assigned, return 1\n    if (assignedCount === totalPeople) {\n        return 1;\n    }\n\n    // If we've considered all caps and not everyone\n    // has a cap, return 0\n    if (cap > 100) {\n        return 0;\n    }\n\n    // Case: skip the current cap\n    let ways = dfs(assignedCount, assignedPeople,\n                        cap + 1, capToPeople, totalPeople);\n\n    // Assign the current cap to each person who likes it\n    for (let person of capToPeople[cap]) {\n    \n        // Check if the person already has a cap assigned\n        if (!assignedPeople[person]) {\n        \n            // Assign current cap to the person\n            assignedPeople[person] = true;\n\n            // Recurse with increased assigned count\n            ways += dfs(assignedCount + 1, \n               assignedPeople, cap + 1, capToPeople, totalPeople);\n\n            // Backtrack: unassign the cap for other possibilities\n            assignedPeople[person] = false;\n        }\n    }\n\n    return ways;\n}\n\n// Main function to calculate the number of\n// ways to assign caps\nfunction numberWays(caps) {\n    const n = caps.length;\n\n    // Map each cap to the list of people who prefer it\n    const capToPeople = Array.from({ length: 101 }, () => []);\n\n    for (let i = 0; i < n; i++) {\n        for (let cap of caps[i]) {\n            capToPeople[cap].push(i);\n        }\n    }\n\n    // Initialize assignedPeople array to track assigned caps\n    const assignedPeople = new Array(n).fill(false);\n\n    // Call the recursive function starting from the first cap\n    return dfs(0, assignedPeople, 1, capToPeople, n);\n}\n\nconst caps = [[1, 2, 3], [1, 2], [3, 4], [4, 5]];\nconsole.log(numberWays(caps));\n8\n// C++ Code to Assign Unique Cap To Every Person\n// using Memoization and Bitmasking\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Recursive function to count ways to assign \n// caps with memoization\nint dfs(int allMask, int assignedPeople, int cap, \n               vector<vector<int>>& capToPeople, \n                     vector<vector<int>>& memo) {\n\n    // Base case: if all people have hats assigned\n    if (assignedPeople == allMask) {\n        return 1;\n    }\n    \n    // If we've considered all caps and not everyone\n    // has a cap, return 0\n    if (cap > 100) {\n        return 0;\n    }\n\n    // Return memoized result if already computed\n    if (memo[cap][assignedPeople] != -1) {\n        return memo[cap][assignedPeople];\n    }\n\n    // Case: skip the current cap\n    int ways = dfs(allMask, assignedPeople,\n                       cap + 1, capToPeople, memo);\n\n    // Try assigning the current cap to each person\n    // who can wear it\n    for (int person : capToPeople[cap]) {\n\n        // Check if the person hasn't been assigned a cap yet\n        if ((assignedPeople & (1 << person)) == 0) {\n            \n            // Assign current cap to the person\n            ways = ways + dfs(allMask, \n                        assignedPeople | (1 << person),\n                               cap + 1, capToPeople, memo);\n        }\n    }\n\n    // Memoize and return the result\n    return memo[cap][assignedPeople] = ways;\n}\n\n// Main function to calculate the number of \n// ways to assign caps\nint numberWays(vector<vector<int>>& caps) {\n    int n = caps.size();\n    int allMask = (1 << n) - 1; \n\n    // Create adjacency matrix for \n    // cap-to-people distribution\n    vector<vector<int>> capToPeople(101);\n    for (int i = 0; i < n; ++i) {\n        for (int cap : caps[i]) {\n            capToPeople[cap].push_back(i);\n        }\n    }\n\n    // Memo array to store computed results\n    vector<vector<int>> memo(101, vector<int>(1 << n, -1));\n\n    // Call the recursive function starting \n    // from the first cap\n    return dfs(allMask, 0, 1, capToPeople, memo);\n}\n\nint main() {\n    \n    vector<vector<int>> caps \n         = {{1, 2, 3}, {1, 2}, {3, 4}, {4, 5}};\n    cout << numberWays(caps) << endl;\n    return 0;\n}\n// Java Code to Assign Unique Cap To Every Person\n// using Memoization and Bitmasking\nimport java.util.ArrayList;\nimport java.util.List;\n\nclass GfG {\n\n    // Recursive function to calculate the number of ways\n    // to assign caps to people such that each person has\n    // a unique cap\n    static int dfs(int assignedCount, ArrayList<Boolean> assignedPeople,\n                          int cap, ArrayList<ArrayList<Integer>> capToPeople,\n                                                          int totalPeople) {\n        \n        // Base case: if all people have a cap assigned, return 1\n        if (assignedCount == totalPeople) {\n            return 1;\n        }\n        \n        // If we've considered all caps and not everyone\n        // has a cap, return 0\n        if (cap > 100) {\n            return 0;\n        }\n\n        // Case: skip the current cap\n        int ways = dfs(assignedCount, assignedPeople, \n                       cap + 1, capToPeople, totalPeople);\n\n        // Assign the current cap to each person who likes it\n        for (int person : capToPeople.get(cap)) {\n\n            // Check if the person already has a cap assigned\n            if (!assignedPeople.get(person)) {\n                \n                // Assign current cap to the person\n                assignedPeople.set(person, true);\n                \n                // Recurse with increased assigned count\n                ways = ways + dfs(assignedCount + 1, assignedPeople, \n                                   cap + 1, capToPeople, totalPeople);\n                \n                // Backtrack: unassign the cap for other possibilities\n                assignedPeople.set(person, false);\n            }\n        }\n\n        return ways;\n    }\n\n    // Main function to calculate the number of ways to assign caps\n    static int numberWays(ArrayList<ArrayList<Integer>> caps) {\n        int n = caps.size();\n\n        // Map each cap to the list of people who prefer it\n        ArrayList<ArrayList<Integer>> capToPeople = new ArrayList<>(101);\n        for (int i = 0; i <= 100; i++) {\n            capToPeople.add(new ArrayList<>());\n        }\n        \n        for (int i = 0; i < n; ++i) {\n            for (int cap : caps.get(i)) {\n                capToPeople.get(cap).add(i);\n            }\n        }\n\n        // Initialize assignedPeople list to track assigned caps\n        ArrayList<Boolean> assignedPeople = new ArrayList<>(n);\n        for (int i = 0; i < n; i++) {\n            assignedPeople.add(false);\n        }\n        \n        // Call the recursive function starting from the first cap\n        return dfs(0, assignedPeople, 1, capToPeople, n);\n    }\n\n    public static void main(String[] args) {\n      \n        ArrayList<ArrayList<Integer>> caps2 = new ArrayList<>();\n        caps2.add(new ArrayList<>(List.of(1, 2, 3)));\n        caps2.add(new ArrayList<>(List.of(1, 2)));\n        caps2.add(new ArrayList<>(List.of(3, 4)));\n        caps2.add(new ArrayList<>(List.of(4, 5)));\n        \n        System.out.println(numberWays(caps2));\n    }\n}\n# Python Code to Assign Unique Cap To Every Person\n# using Memoization and Bitmasking\n\n# Recursive function to count ways to assign \n# caps with memoization\ndef dfs(all_mask, assigned_people, cap, cap_to_people, memo):\n  \n    # Base case: if all people have hats assigned\n    if assigned_people == all_mask:\n        return 1\n\n    # If we've considered all caps and not everyone\n    # has a cap, return 0\n    if cap > 100:\n        return 0\n\n    # Return memoized result if already computed\n    if memo[cap][assigned_people] != -1:\n        return memo[cap][assigned_people]\n\n    # Case: skip the current cap\n    ways = dfs(all_mask, assigned_people, cap + 1, cap_to_people, memo)\n\n    # Try assigning the current cap to each person\n    # who can wear it\n    for person in cap_to_people[cap]:\n        # Check if the person hasn't been assigned a cap yet\n        if (assigned_people & (1 << person)) == 0:\n          \n            # Assign current cap to the person\n            ways += dfs(all_mask, assigned_people | (1 << person),\\\n                        cap + 1, cap_to_people, memo)\n\n    # Memoize and return the result\n    memo[cap][assigned_people] = ways\n    return ways\n\n# Main function to calculate the number of \n# ways to assign caps\ndef number_ways(caps):\n    n = len(caps)\n    all_mask = (1 << n) - 1\n\n    # Create adjacency matrix for \n    # cap-to-people distribution\n    cap_to_people = [[] for _ in range(101)]\n    for i in range(n):\n        for cap in caps[i]:\n            cap_to_people[cap].append(i)\n\n    # Memo array to store computed results\n    memo = [[-1] * (1 << n) for _ in range(101)]\n\n    # Call the recursive function starting \n    # from the first cap\n    return dfs(all_mask, 0, 1, cap_to_people, memo)\n\nif __name__ == \"__main__\":\n\n  caps = [[1, 2, 3], [1, 2], [3, 4], [4, 5]]\n  print(number_ways(caps))\n// C# Code to Assign Unique Cap To Every Person\n// using Memoization and Bitmasking\nusing System;\nusing System.Collections.Generic;\n\nclass GfG {\n  \n    // Recursive function to count ways to assign \n    // caps with memoization\n    static int dfs(int allMask, int assignedPeople, int cap, \n                   List<List<int>> capToPeople, \n                   List<List<int>> memo) {\n      \n        // Base case: if all people have hats assigned\n        if (assignedPeople == allMask) {\n            return 1;\n        }\n\n        // If we've considered all caps and not everyone\n        // has a cap, return 0\n        if (cap > 100) {\n            return 0;\n        }\n\n        // Return memoized result if already computed\n        if (memo[cap][assignedPeople] != -1) {\n            return memo[cap][assignedPeople];\n        }\n\n        // Case: skip the current cap\n        int ways = dfs(allMask, assignedPeople, \n                       cap + 1, capToPeople, memo);\n\n        // Try assigning the current cap to each person\n        // who can wear it\n        foreach (int person in capToPeople[cap]) {\n          \n            // Check if the person hasn't been assigned a cap yet\n            if ((assignedPeople & (1 << person)) == 0) {\n              \n                // Assign current cap to the person\n                ways += dfs(allMask, \n                            assignedPeople | (1 << person),\n                                cap + 1, capToPeople, memo);\n            }\n        }\n\n        // Memoize and return the result\n        memo[cap][assignedPeople] = ways;\n        return ways;\n    }\n\n    // Main function to calculate the number of \n    // ways to assign caps\n    static int NumberWays(List<List<int>> caps) {\n        int n = caps.Count;\n        int allMask = (1 << n) - 1;\n\n        // Create adjacency matrix for \n        // cap-to-people distribution\n        List<List<int>> capToPeople \n          = new List<List<int>>(new List<int>[101]);\n      \n        for (int i = 0; i < 101; i++) {\n            capToPeople[i] = new List<int>();\n        }\n\n        for (int i = 0; i < n; i++) {\n            foreach (int cap in caps[i]) {\n                capToPeople[cap].Add(i);\n            }\n        }\n\n        // Memo array to store computed results\n        List<List<int>> memo \n           = new List<List<int>>(new List<int>[101]);\n      \n        for (int i = 0; i < 101; i++) {\n            memo[i] = new List<int>(new int[1 << n]);\n            for (int j = 0; j < (1 << n); j++) {\n                memo[i][j] = -1;\n            }\n        }\n\n        // Call the recursive function starting \n        // from the first cap\n        return dfs(allMask, 0, 1, capToPeople, memo);\n    }\n\n    static void Main(string[] args) {\n        List<List<int>> caps = new List<List<int>>() {\n            new List<int>{1, 2, 3},\n            new List<int>{1, 2},\n            new List<int>{3, 4},\n            new List<int>{4, 5}\n        };\n        Console.WriteLine(NumberWays(caps));\n    }\n}\n// Javascript Code to Assign Unique Cap To Every Person\n// using Memoization and Bitmasking\n\n// Recursive function to count ways to assign \n// caps with memoization\nfunction dfs(allMask, assignedPeople, cap, capToPeople, memo) {\n\n    // Base case: if all people have hats assigned\n    if (assignedPeople === allMask) {\n        return 1;\n    }\n\n    // If we've considered all caps and not everyone\n    // has a cap, return 0\n    if (cap > 100) {\n        return 0;\n    }\n\n    // Return memoized result if already computed\n    if (memo[cap][assignedPeople] !== -1) {\n        return memo[cap][assignedPeople];\n    }\n\n    // Case: skip the current cap\n    let ways = dfs(allMask, assignedPeople, \n                        cap + 1, capToPeople, memo);\n\n    // Try assigning the current cap to each person\n    // who can wear it\n    for (let person of capToPeople[cap]) {\n    \n        // Check if the person hasn't been assigned a cap yet\n        if ((assignedPeople & (1 << person)) === 0) {\n        \n            // Assign current cap to the person\n            ways += dfs(allMask, \n                    assignedPeople | (1 << person),\n                    cap + 1, capToPeople, memo);\n        }\n    }\n\n    // Memoize and return the result\n    memo[cap][assignedPeople] = ways;\n    return ways;\n}\n\n// Main function to calculate the number of \n// ways to assign caps\nfunction numberWays(caps) {\n    let n = caps.length;\n    let allMask = (1 << n) - 1;\n\n    // Create adjacency matrix for \n    // cap-to-people distribution\n    let capToPeople = Array.from({ length: 101 }, () => []);\n    for (let i = 0; i < n; i++) {\n        for (let cap of caps[i]) {\n            capToPeople[cap].push(i);\n        }\n    }\n\n    // Memo array to store computed results\n    let memo = Array.from({ length: 101 }, () => Array(1 << n).fill(-1));\n\n    // Call the recursive function starting \n    // from the first cap\n    return dfs(allMask, 0, 1, capToPeople, memo);\n}\n\nlet caps = [\n    [1, 2, 3],\n    [1, 2],\n    [3, 4],\n    [4, 5]\n];\nconsole.log(numberWays(caps));\n8\n// C++ code to calculate the number of ways \n// to assign caps to people using Tabulation\n#include <bits/stdc++.h>\nusing namespace std;\n\nint numberWays(vector<vector<int>>& caps) {\n    int n = caps.size();\n    int allMask = (1 << n) - 1; \n\n    // Create adjacency matrix for cap-to-people distribution\n    vector<vector<int>> capToPeople(101);\n    for (int i = 0; i < n; ++i) {\n        for (int cap : caps[i]) {\n            capToPeople[cap].push_back(i);\n        }\n    }\n\n    // DP table: dp[cap][assignedPeople] \n    // stores the number of ways\n    // to assign caps for the first 'cap' \n    // caps with 'assignedPeople' bitmask\n    vector<vector<int>> dp(102, vector<int>(1 << n, 0));\n\n    // Base case: With 0 caps, no people assigned, \n    // there's 1 way (do nothing)\n    dp[0][0] = 1;\n\n    // Fill the DP table\n    for (int cap = 1; cap <= 100; ++cap) {\n        \n        for (int assignedPeople = 0; \n               assignedPeople <= allMask; ++assignedPeople) {\n            \n            // If there are no ways to assign caps for\n            // this state, continue\n            if (dp[cap - 1][assignedPeople] == 0) {\n                continue;\n            }\n\n            // Case 1: Skip the current cap\n            dp[cap][assignedPeople] += dp[cap - 1][assignedPeople];\n\n            // Case 2: Assign current cap to each person who can wear it\n            for (int person : capToPeople[cap]) {\n                \n                // If the person hasn't been assigned a cap yet\n                if ((assignedPeople & (1 << person)) == 0) {\n                    dp[cap][assignedPeople | (1 << person)] \n                                   += dp[cap - 1][assignedPeople];\n                }\n            }\n        }\n    }\n\n    // The result will be in dp[100][allMask], \n    // as we have considered all caps and assigned all people\n    return dp[100][allMask];\n}\n\nint main() {\n    \n    vector<vector<int>> caps \n         = {{1, 2, 3}, {1, 2}, {3, 4}, {4, 5}};\n    cout << numberWays(caps) << endl;\n    return 0;\n}\n// Java code to calculate the number of ways \n// to assign caps to people using Tabulation\nimport java.util.*;\n\nclass GfG {\n    \n    // Method to calculate the number of ways \n    // to assign caps using Tabulation\n    static int numberWays(List<List<Integer>> caps) {\n        int n = caps.size();\n        int allMask = (1 << n) - 1;\n\n        // Create adjacency matrix for cap-to-people distribution\n        List<Integer>[] capToPeople = new ArrayList[101];\n        for (int i = 0; i < 101; i++) {\n            capToPeople[i] = new ArrayList<>();\n        }\n        \n        // Fill the cap-to-people adjacency list\n        for (int i = 0; i < n; ++i) {\n            for (int cap : caps.get(i)) {\n                capToPeople[cap].add(i);\n            }\n        }\n\n        // DP table: dp[cap][assignedPeople] \n        // stores the number of ways to \n        // assign caps for the first 'cap' caps \n        // with 'assignedPeople' bitmask\n        int[][] dp = new int[102][1 << n];\n        \n        // Base case: With 0 caps, no people assigned, \n        // there's 1 way (do nothing)\n        dp[0][0] = 1;\n\n        // Fill the DP table\n        for (int cap = 1; cap <= 100; ++cap) {\n            for (int assignedPeople = 0; \n                    assignedPeople <= allMask; ++assignedPeople) {\n                \n                // If there are no ways to assign caps for \n              \t// this state, continue\n                if (dp[cap - 1][assignedPeople] == 0) {\n                    continue;\n                }\n\n                // Case 1: Skip the current cap\n                dp[cap][assignedPeople] += dp[cap - 1][assignedPeople];\n\n                // Case 2: Assign current cap to each person who can wear it\n                for (int person : capToPeople[cap]) {\n                    \n                    // If the person hasn't been assigned a cap yet\n                    if ((assignedPeople & (1 << person)) == 0) {\n                        dp[cap][assignedPeople | (1 << person)] \n                                        += dp[cap - 1][assignedPeople];\n                    }\n                }\n            }\n        }\n\n        // The result will be in dp[100][allMask], \n        // as we have considered all caps and assigned all people\n        return dp[100][allMask];\n    }\n\n    public static void main(String[] args) {\n\n        List<List<Integer>> caps = new ArrayList<>();\n        caps.add(Arrays.asList(1, 2, 3));\n        caps.add(Arrays.asList(1, 2));\n        caps.add(Arrays.asList(3, 4));\n        caps.add(Arrays.asList(4, 5));\n\n        System.out.println(numberWays(caps));\n    }\n}\n# Python code to calculate the number of ways \n# to assign caps to people using Tabulation\ndef numberWays(caps):\n    n = len(caps)\n    allMask = (1 << n) - 1\n\n    # Create adjacency list for cap-to-people \n    # distribution\n    capToPeople = [[] for _ in range(101)]\n    \n    # Fill the cap-to-people adjacency list\n    for i in range(n):\n        for cap in caps[i]:\n            capToPeople[cap].append(i)\n\n    # DP table: dp[cap][assignedPeople] \n    # stores the number of ways to assign \n    # caps for the first 'cap' caps \n    # with 'assignedPeople' bitmask\n    dp = [[0] * (1 << n) for _ in range(102)]\n\n    # Base case: With 0 caps, no people assigned, \n    # there's 1 way (do nothing)\n    dp[0][0] = 1\n\n    # Fill the DP table\n    for cap in range(1, 101):\n        for assignedPeople in range(allMask + 1):\n            \n            # If there are no ways to assign caps for \n            # this state, continue\n            if dp[cap - 1][assignedPeople] == 0:\n                continue\n\n            # Case 1: Skip the current cap\n            dp[cap][assignedPeople] += dp[cap - 1][assignedPeople]\n\n            # Case 2: Assign current cap to each person who can wear it\n            for person in capToPeople[cap]:\n                \n                # If the person hasn't been assigned a cap yet\n                if (assignedPeople & (1 << person)) == 0:\n                    dp[cap][assignedPeople | (1 << person)] \\\n                                    += dp[cap - 1][assignedPeople]\n\n    # The result will be in dp[100][allMask], \n    # as we have considered all caps and assigned all people\n    return dp[100][allMask]\n\nif __name__ == \"__main__\":\n  \n    caps = [[1, 2, 3], [1, 2], [3, 4], [4, 5]]\n\n    print(numberWays(caps))\n// C# code to calculate the number of ways \n// to assign caps to people using Tabulation\nusing System;\nusing System.Collections.Generic;\n\nclass GfG {\n\n    static int NumberWays(List<List<int>> caps) {\n        int n = caps.Count;\n        int allMask = (1 << n) - 1;\n\n        // Create adjacency list for cap-to-people\n      \t// distribution\n        List<List<int>> capToPeople\n           = new List<List<int>>(new List<int>[101]);\n      \n        for (int i = 0; i < 101; ++i) {\n            capToPeople[i] = new List<int>();\n        }\n\n        // Fill the cap-to-people adjacency list\n        for (int i = 0; i < n; ++i) {\n            foreach (int cap in caps[i]) {\n                capToPeople[cap].Add(i);\n            }\n        }\n\n        // DP table: dp[cap][assignedPeople] \n        // stores the number of ways to assign \n        // caps for the first 'cap' caps \n        // with 'assignedPeople' bitmask\n        int[,] dp = new int[102, 1 << n];\n\n        // Base case: With 0 caps, no people assigned, \n        // there's 1 way (do nothing)\n        dp[0, 0] = 1;\n\n        // Fill the DP table\n        for (int cap = 1; cap <= 100; ++cap) {\n            for (int assignedPeople = 0;\n                   assignedPeople <= allMask; ++assignedPeople) {\n\n                // If there are no ways to assign caps \n                // for this state, continue\n                if (dp[cap - 1, assignedPeople] == 0) {\n                    continue;\n                }\n\n                // Case 1: Skip the current cap\n                dp[cap, assignedPeople] += dp[cap - 1, assignedPeople];\n\n                // Case 2: Assign current cap to each person who can wear it\n                foreach (int person in capToPeople[cap]) {\n\n                    // If the person hasn't been assigned a cap yet\n                    if ((assignedPeople & (1 << person)) == 0) {\n                        dp[cap, assignedPeople | (1 << person)] \n                                      += dp[cap - 1, assignedPeople];\n                    }\n                }\n            }\n        }\n\n        // The result will be in dp[100, allMask], \n        // as we have considered all caps and assigned all people\n        return dp[100, allMask];\n    }\n\n    static void Main() {\n  \n        List<List<int>> caps = new List<List<int>> {\n            new List<int> { 1, 2, 3 },\n            new List<int> { 1, 2 },\n            new List<int> { 3, 4 },\n            new List<int> { 4, 5 }\n        };\n\n        Console.WriteLine(NumberWays(caps));\n    }\n}\n// JavaScript code to calculate the number of ways \n// to assign caps to people using Tabulation\n\nfunction numberWays(caps) {\n    const n = caps.length;\n    const allMask = (1 << n) - 1;\n\n    // Create adjacency list for cap-to-people distribution\n    const capToPeople = Array.from({ length: 101 }, () => []);\n\n    // Fill the cap-to-people adjacency list\n    for (let i = 0; i < n; ++i) {\n        for (let cap of caps[i]) {\n            capToPeople[cap].push(i);\n        }\n    }\n\n    // DP table: dp[cap][assignedPeople] \n    // stores the number of ways to assign caps \n    // for the first 'cap' caps with 'assignedPeople' bitmask\n    const dp = Array.from({ length: 102 }, () => Array(1 << n).fill(0));\n\n    // Base case: With 0 caps, no people \n    // assigned, there's 1 way (do nothing)\n    dp[0][0] = 1;\n\n    // Fill the DP table\n    for (let cap = 1; cap <= 100; ++cap) {\n        for (let assignedPeople = 0; \n            assignedPeople <= allMask; ++assignedPeople) {\n            \n            // If there are no ways to assign caps\n            // for this state, continue\n            if (dp[cap - 1][assignedPeople] === 0) {\n                continue;\n            }\n\n            // Case 1: Skip the current cap\n            dp[cap][assignedPeople] += dp[cap - 1][assignedPeople];\n\n            // Case 2: Assign current cap to each person who can wear it\n            for (let person of capToPeople[cap]) {\n            \n                // If the person hasn't been assigned a cap yet\n                if ((assignedPeople & (1 << person)) === 0) {\n                    dp[cap][assignedPeople | (1 << person)] \n                                  += dp[cap - 1][assignedPeople];\n                }\n            }\n        }\n    }\n\n    // The result will be in dp[100][allMask], \n    // as we have considered all caps and assigned all people\n    return dp[100][allMask];\n}\n\nconst caps = [\n     [1, 2, 3],\n     [1, 2],\n     [3, 4],\n     [4, 5]\n];\nconsole.log(numberWays(caps));\n8\n",
        "complexity": {
            "time": "The above solution will have a exponential time complexity.",
            "space": ""
        },
        "tags": [
            "Dynamic Programming"
        ],
        "url": "https://www.geeksforgeeks.org/bitmasking-and-dynamic-programming-set-1-count-ways-to-assign-unique-cap-to-every-person/"
    },
    {
        "title": "Digit DP | Introduction",
        "description": "Prerequisite : How to solve a Dynamic Programming Problem ?There are many types of problems that ask to count the number of integers ‘x‘ between two integers say ‘a‘ and ‘b‘ such that x satisfies a specific property that can be related to its digits.So, if we say G(x) tells the number of such integers between 1 to x (inclusively), then the number of such integers between a and b can be given by G(b) – G(a-1). This is when Digit DP (Dynamic Programming) comes into action. All such integer counting problems that satisfy the above property can be solved by digit DP approach. Key Concept: Example Problem : Given two integers a and b. Your task is to print the sum of all the digits appearing in the integers between a and b.For example if a = 5 and b = 11, then answer is 38 (5 + 6 + 7 + 8 + 9 + 1 + 0 + 1 + 1)Constraints : 1 <= a < b <= 10^18Now we see that if we have calculated the answer for state having n-1 digits, i.e., tn-1 tn-2 … t2 t1 and we need to calculate answer for state having n digits tn tn-1 tn-2 … t2 t1. So, clearly, we can use the result of the previous state instead of re-calculating it. Hence, it follows the overlapping property.Let’s think for a state for this DPOur DP state will be dp(idx, tight, sum)1) idx 2) tight Unrestricted range: Now suppose the integer generated till now is : 3 1 * * ( * is empty place, where digits are to be inserted to form the integer). here, we see that index 2 has unrestricted range. Now index 2 can have digits from range 0 to 9(inclusively). For unrestricted range tight = 0Restricted range: Now suppose the integer generated till now is : 3 2 * * ( ‘*’ is an empty place, where digits are to be inserted to form the integer). here, we see that index 2 has a restricted range. Now index 2 can only have digits from range 0 to 4 (inclusively) For restricted range tight = 13) sum State Relation:The basic idea for state relation is very simple. We formulate the dp in top-down fashion. Let’s say we are at the msd having index idx. So initially the sum will be 0.Therefore, we will fill the digit at index by the digits in its range. Let’s say its range is from 0 to k (k<=9, depending on the tight value) and fetch the answer from the next state having index = idx-1 and sum = previous sum + digit chosen. How to calculate the newTight value? The new tight value from a state depends on its previous state. If tight value form the previous state is 1 and the digit at idx chosen is digit[idx](i.e the digit at idx in limiting integer) , then only our new tight will be 1 as it only then tells that the number formed till now is prefix of the limiting integer. Below is the implementation of the above approach                Output: Time Complexity:There are total idx*sum*tight states and we are performing 0 to 9 iterations to visit every state. Therefore, The Time Complexity will be O(10*idx*sum*tight). Here, we observe that tight = 2 and idx can be max 18 for 64 bit unsigned integer and moreover, the sum will be max 9*18 ~ 200. So, overall we have 10*18*200*2 ~ 10^5 iterations which can be easily executed in 0.01 seconds. Space Complexity: The space complexity of this algorithm is O(d*sum*tight) as it uses a dp array of size d*sum*tight. where d is the number of digits in the number, sum is the sum of the digits and tight is a boolean value indicating whether or not the current digit is restricted to the digit in the number or not. The above problem can also be solved using simple recursion without any memoization. The recursive solution for the above problem can be found here. We will be soon adding more problems on digit dp in our future posts. N  ",
        "code": "index  : 4 3 2 1  \n  digits : 3 2 4 5\n generated integer: 3 1 _ _\nindex  : 4 3 2 1  \n  digits : 3 2 4 5\n generated integer: 3 2 _ _\nint ans = 0;\nfor (int i=0; i<=k; i++) {\n   ans += state(idx-1, newTight, sum+i)\n}\n\nstate(idx,tight,sum) = ans;\n// digitTaken is the digit chosen\n// digit[idx] is the digit in the limiting \n//            integer at index idx from right\n// previouTight is the tight value form previous \n//              state\n\nnewTight = previousTight & (digitTake == digit[idx])\n\n\n\n\n\n\n\n\n\n\ndigit sum for given range : 12613\n",
        "complexity": {
            "time": "Time Complexity:There are total idx*sum*tight states and we are performing 0 to 9 iterations to visit every state. Therefore, The Time Complexity will be O(10*idx*sum*tight). Here, we observe that tight = 2 and idx can be max 18 for 64 bit unsigned integer and moreover, the sum will be max 9*18 ~ 200. So, overall we have 10*18*200*2 ~ 10^5 iterations which can be easily executed in 0.01 seconds.",
            "space": "The space complexity of this algorithm is O(d*sum*tight) as it uses a dp array of size d*sum*tight. where d is the number of digits in the number, sum is the sum of the digits and tight is a boolean value indicating whether or not the current digit is restricted to the digit in the number or not."
        },
        "tags": [
            "Dynamic Programming"
        ],
        "url": "https://www.geeksforgeeks.org/digit-dp-introduction/"
    },
    {
        "title": "DP on Trees for Competitive Programming",
        "description": "Dynamic Programming (DP) on trees is a powerful algorithmic technique commonly used in competitive programming. It involves solving various tree-related problems by efficiently calculating and storing intermediate results to optimize time complexity. By using the tree structure, DP on trees allows programmers to find solutions for a wide range of problems, making it an essential skill in competitive programming. Dynamic Programming (DP) on trees is a technique used to efficiently solve problems involving tree structures by breaking them down into smaller subproblems and storing intermediate results to avoid redundant calculations. Lets, understand the Dynamic Programming (DP) on by a problem: Problem: Given a tree consisting of N Nodes and N-1 edges. The task is to select the maximum set of edges such that each vertex is part of at most one of the selected edges (no two edges share a common end point) i.e., if we select an edge connecting vertex u and v, then we cannot select any other edge connected by vertex u or vertex v. Approach: The problem can be solved using DP on Tree in the following way: Root the tree: Root the tree at any of node(say 1). Define the states: For each node we have 2 options, select a edge from the current from the current vertex to any of his child or do not select any edge passing through the current vertex. dp[v][0]= Maximum set of edges selected in the subtree rooted at vertex v such that no two edges have a common end point, if we do not select any edge passing through vertex v. dp[v][1]= Maximum set of edges selected  in the subtree rooted at vertex v such that no two edges have a common end point, if we select a edge passing through vertex v. Make the Transition: Calculating dp[v][0]: Since dp[v][0] defines the state where we do not take any edge passing through vertex v (i.,e, v->u , where u is child of vertex). So for the all child nodes of vertex v we can either take an edge passing through it or do not take, and all the children of vertex v will be independent of each other in this case. dp[v][0] = \\Sigma max(dp[u][0],dp[u][1])\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n , where u is child of vertex v. Calculating dp[v][1]: dp[v][1] defines the state where we do take a edge passing through vertex v (i.,e, v->u , where u is child of vertex). Suppose we select a edge (v->u), then we cannot choose any other edge passing through vertex u. So will need dp[u][0] in this case, and for all other children of vertex v, we can either choose an edge passing through it or do not choose it as done in above case and we can use that state (dp[v][0]) for calculating this state. dp[v][1]=max(1+dp[u][0] + dp[v][0]- max(dp[u][0],dp[u][1]))\n\n\n\n\n\n\n\n\n\n\n\n\n\n , for all child u of vertex v. Since we have chosen vertex as the 1 root. Our answer will be max(dp[1][0], dp[1][1]). Below is the implementation of above approach: Time Complexity: O(N)Auxilary Space: O(N) The Rerooting technique is a method used in tree algorithms to efficiently compute values associated with nodes or subtrees of a rooted tree when the tree's root can be moved or \"rerooted\" to different nodes in the tree. This technique is particularly useful when you want to calculate values for various nodes or subtrees in a tree, but you don't want to traverse the entire tree for each query. The rerooting technique is commonly used in problems that require dynamic programming on trees, such as finding optimal paths, maximum values, or minimum values in subtrees. It allows you to reposition the root and update the values in a way that minimizes redundant work, resulting in more efficient algorithms for various tree-related problems. Lets, understand the Rerooting Techique by a problem: Problem: Given a tree consisting of N Nodes and N-1 edges. The task is to determine for each node the sum of  distance to all other nodes.The problem can be solved using Rerooting technique in the following way: Approach: Root the tree: Root the tree at node 1. Define the states: We will need 2 dp arrays for this problem. dp1[v]: The sum of distance of node v from all the other nodes in subtree rooted at vertex v. dp2[v]: The sum of distance of node v from all the other other nodes in the tree. Calculate the answer for the root: For the root, dp1[1] will be equal to dp2[1] since, all the nodes of the tree lie in the subtree rooted at vertex 1. dp1[v] can be calculated by:- dp1[v]=\\Sigma(dp1[u]+sub[u])\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n, where u is the child of vertex v and sub[u] is the number of nodes in subtree rooted at vertex u. Since dp2[1]=dp1[1], answer for the root have been determined. Calculate the answer for other nodes (Rerooting Step): Now suppose we know the final answer for vertex v, dp2[v] (sum of distance of node v from all other nodes). Now we want to compute the answer for node u, which is a child of vertex v. dp2[u], (sum of distance from node u to all other nodes in tree) will be the sum of following two parts: Sum of distance from node v to all other nodes excluding the subtree rooted at vertex v will be dp2[v]-(dp1[u]+sub[u]) From this we can calculate sum of distance from node u to all other nodes excluding the subtree rooted at vertex u by adding (N-sub[u]) to above equation, since N- sub[u] gives the total number of nodes excluding the nodes in the subtree rooted at vertex u. Summing the above two parts we get: dp2[u]=dp1[u] + (dp2[v]-(dp1[u]+sub[u])+(N-sub[u]) This can be further simplified to: dp2[u]=dp2[v]+N-2*sub[u] Below is the implementation of above approach: Time Complexity: O(N)Auxiliary Space: O(N) Dynamic Programming (DP) on trees is a powerful technique for solving a variety of problems involving tree structures. Here is a comprehensive overview of its applications and considerations: Diameter of N-ary Tree Maximum sum of the node values from root to any of the leaves without re-visiting any node Maximum height of Tree when any Node can be considered as Root Maximal Point Path Related Article: M  ",
        "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n// Function to perform dynamic programming on the tree.\nvoid dp_on_tree(vector<vector<int> >& adj, int curr,\n                int prev, vector<vector<int> >& dp,\n                int& ans)\n{\n    for (auto x : adj[curr]) {\n        if (x != prev) {\n\n            // Recursively calculate the dp values for each\n            // node.\n            dp_on_tree(adj, x, curr, dp, ans);\n\n            // Update dp[curr][0] by taking the maximum of\n            // not selecting and selecting edges.\n            dp[curr][0] += max(dp[x][0], dp[x][1]);\n        }\n    }\n\n    for (auto x : adj[curr]) {\n        if (x != prev) {\n            // Calculate dp[curr][1] using dp values of\n            // children.\n            dp[curr][1]\n                = max(dp[curr][1],\n                      (1 + dp[x][0])\n                          + (dp[curr][0]\n                             - max(dp[x][0], dp[x][1])));\n        }\n    }\n\n    // Update the global maximum answer with the maximum of\n    // dp values for the current node.\n    ans = max(ans, max(dp[curr][0], dp[curr][1]));\n}\n\n// Function to solve the problem and find the maximum set of\n// edges.\nvoid solve(int n, vector<vector<int> >& edges)\n{\n    vector<vector<int> > adj(n + 1);\n    // Create an adjacency list to represent the tree.\n    for (int i = 0; i < n - 1; i++) {\n        int x = edges[i][0];\n        int y = edges[i][1];\n        adj[x].push_back(y);\n        adj[y].push_back(x);\n    }\n\n    // Initialize the answer.\n    int ans = 0;\n\n    // Initialize the dp array.\n    vector<vector<int> > dp(n + 1, vector<int>(2, 0));\n\n    // Start dynamic programming on the tree with the root\n    // node as 1.\n    dp_on_tree(adj, 1, -1, dp, ans);\n\n    // Output the maximum set of edges.\n    cout << ans << \"\\n\";\n}\n\n// Driver Code\nint main()\n{\n    int N = 5;\n    vector<vector<int> > edges\n        = { { 1, 2 }, { 1, 3 }, { 3, 4 }, { 3, 5 } };\n    solve(N, edges);\n}\nimport java.util.ArrayList;\n\npublic class MaximumSetOfEdges {\n\n    // Function to perform dynamic programming on the tree\n    static void dpOnTree(ArrayList<ArrayList<Integer>> adj, int curr, int prev, ArrayList<ArrayList<Integer>> dp, int[] ans) {\n        // Traverse through adjacent nodes\n        for (int x : adj.get(curr)) {\n            if (x != prev) {\n                // Recursively calculate DP values for each node\n                dpOnTree(adj, x, curr, dp, ans);\n                // Update DP[curr][0] by taking the maximum of not selecting and selecting edges\n                dp.get(curr).set(0, dp.get(curr).get(0) + Math.max(dp.get(x).get(0), dp.get(x).get(1)));\n            }\n        }\n\n        // Traverse through adjacent nodes again\n        for (int x : adj.get(curr)) {\n            if (x != prev) {\n                // Calculate DP[curr][1] using DP values of children\n                dp.get(curr).set(1, Math.max(dp.get(curr).get(1), (1 + dp.get(x).get(0)) + (dp.get(curr).get(0) - Math.max(dp.get(x).get(0), dp.get(x).get(1)))));\n            }\n        }\n\n        // Update the global maximum answer with the maximum of DP values for the current node\n        ans[0] = Math.max(ans[0], Math.max(dp.get(curr).get(0), dp.get(curr).get(1)));\n    }\n\n    // Function to solve the problem and find the maximum set of edges\n    static void solve(int n, int[][] edges) {\n        ArrayList<ArrayList<Integer>> adj = new ArrayList<>(n + 1);\n        for (int i = 0; i <= n; i++) {\n            adj.add(new ArrayList<>());\n        }\n\n        // Create an adjacency list to represent the tree\n        for (int i = 0; i < n - 1; i++) {\n            int x = edges[i][0];\n            int y = edges[i][1];\n            adj.get(x).add(y);\n            adj.get(y).add(x);\n        }\n\n        int[] ans = {0};\n        ArrayList<ArrayList<Integer>> dp = new ArrayList<>(n + 1);\n        for (int i = 0; i <= n; i++) {\n            dp.add(new ArrayList<>(2));\n            dp.get(i).add(0);\n            dp.get(i).add(0);\n        }\n\n        // Start dynamic programming on the tree with the root node as 1\n        dpOnTree(adj, 1, -1, dp, ans);\n        System.out.println(ans[0]);\n    }\n\n    public static void main(String[] args) {\n        int N = 5;\n        int[][] edges = {{1, 2}, {1, 3}, {3, 4}, {3, 5}};\n        solve(N, edges);\n    }\n}\n# Function to perform dynamic programming on the tree.\ndef dp_on_tree(adj, curr, prev, dp, ans):\n    for x in adj[curr]:\n        if x != prev:\n            # Recursively calculate the dp values for each node.\n            dp_on_tree(adj, x, curr, dp, ans)\n\n            # Update dp[curr][0] by taking the maximum of not selecting and selecting edges.\n            dp[curr][0] += max(dp[x][0], dp[x][1])\n\n    for x in adj[curr]:\n        if x != prev:\n            # Calculate dp[curr][1] using dp values of children.\n            dp[curr][1] = max(dp[curr][1], (1 + dp[x][0]) +\n                              (dp[curr][0] - max(dp[x][0], dp[x][1])))\n\n    # Update the global maximum answer with the maximum of dp values for the current node.\n    ans[0] = max(ans[0], max(dp[curr][0], dp[curr][1]))\n\n# Function to solve the problem and find the maximum set of edges.\n\n\ndef solve(n, edges):\n    adj = [[] for _ in range(n + 1)]\n\n    # Create an adjacency list to represent the tree.\n    for edge in edges:\n        x, y = edge\n        adj[x].append(y)\n        adj[y].append(x)\n\n    # Initialize the answer.\n    ans = [0]\n\n    # Initialize the dp array.\n    dp = [[0, 0] for _ in range(n + 1)]\n\n    # Start dynamic programming on the tree with the root node as 1.\n    dp_on_tree(adj, 1, -1, dp, ans)\n\n    # Output the maximum set of edges.\n    print(ans[0])\n\n\n# Driver Code\nif __name__ == \"__main__\":\n    N = 5\n    edges = [[1, 2], [1, 3], [3, 4], [3, 5]]\n    solve(N, edges)\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nclass MaximumSetOfEdges\n{\n    // Function to perform dynamic programming on the tree.\n    static int dp_on_tree(List<List<int>> adj, int curr, int prev, List<List<int>> dp, ref int ans)\n    {\n        // Traverse the adjacent nodes\n        foreach (int x in adj[curr])\n        {\n            // If not the previous node, perform DP recursively\n            if (x != prev)\n            {\n                dp[curr][0] += Math.Max(dp_on_tree(adj, x, curr, dp, ref ans), dp[x][1]);\n            }\n        }\n\n        foreach (int x in adj[curr])\n        {\n            if (x != prev)\n            {\n                dp[curr][1] = Math.Max(dp[curr][1], \n                                       (1 + dp[x][0]) + (dp[curr][0] - Math.Max(dp[x][0], \n                                                                                dp[x][1])));\n            }\n        }\n\n        // Update the global maximum answer\n        ans = Math.Max(ans, Math.Max(dp[curr][0], dp[curr][1]));\n        return dp[curr][0];\n    }\n\n    // Function to solve the problem and find the maximum set of edges.\n    static void Solve(int n, List<List<int>> edges)\n    {\n        // Create adjacency list\n        List<List<int>> adj = new List<List<int>>();\n        for (int i = 0; i <= n; i++)\n        {\n            adj.Add(new List<int>());\n        }\n\n        // Construct the adjacency list for the tree\n        foreach (List<int> edge in edges)\n        {\n            int x = edge[0];\n            int y = edge[1];\n            adj[x].Add(y);\n            adj[y].Add(x);\n        }\n\n        int ans = 0;\n        // Initialize DP array\n        List<List<int>> dp = new List<List<int>>();\n        for (int i = 0; i <= n; i++)\n        {\n            dp.Add(new List<int> { 0, 0 });\n        }\n\n        // Perform DP on the tree with root node as 1\n        dp_on_tree(adj, 1, -1, dp, ref ans);\n        Console.WriteLine(ans); // Output the maximum set of edges\n    }\n\n    static void Main()\n    {\n        int N = 5;\n        // Define edges of the tree\n        List<List<int>> edges = new List<List<int>>\n        {\n            new List<int> { 1, 2 },\n            new List<int> { 1, 3 },\n            new List<int> { 3, 4 },\n            new List<int> { 3, 5 }\n        };\n        Solve(N, edges);\n    }\n}\n// Function to perform dynamic programming on the tree.\nfunction dp_on_tree(adj, curr, prev, dp, ans) {\n    for (const x of adj[curr]) {\n        if (x !== prev) {\n\n            // Recursively calculate the dp values for each node.\n            dp_on_tree(adj, x, curr, dp, ans);\n\n            // Update dp[curr][0] by taking the maximum of\n            // not selecting and selecting edges.\n            dp[curr][0] += Math.max(dp[x][0], dp[x][1]);\n        }\n    }\n\n    for (const x of adj[curr]) {\n        if (x !== prev) {\n            // Calculate dp[curr][1] using dp values of children.\n            dp[curr][1] = Math.max(dp[curr][1],\n                (1 + dp[x][0]) + (dp[curr][0] - Math.max(dp[x][0], dp[x][1])));\n        }\n    }\n\n    // Update the global maximum answer with the maximum of\n    // dp values for the current node.\n    ans[0] = Math.max(ans[0], Math.max(dp[curr][0], dp[curr][1]));\n}\n\n// Function to solve the problem and find the maximum set of edges.\nfunction solve(n, edges) {\n    const adj = new Array(n + 1).fill(0).map(() => []);\n\n    // Create an adjacency list to represent the tree.\n    for (const edge of edges) {\n        const x = edge[0];\n        const y = edge[1];\n        adj[x].push(y);\n        adj[y].push(x);\n    }\n\n    // Initialize the answer.\n    const ans = [0];\n\n    // Initialize the dp array.\n    const dp = new Array(n + 1).fill(0).map(() => new Array(2).fill(0));\n\n    // Start dynamic programming on the tree with the root node as 1.\n    dp_on_tree(adj, 1, -1, dp, ans);\n\n    // Output the maximum set of edges.\n    console.log(ans[0]);\n}\n\n// Driver Code\nconst N = 5;\nconst edges = [[1, 2], [1, 3], [3, 4], [3, 5]];\nsolve(N, edges);\n2\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Function to perform the first depth-first search to\n// calculate dp1 and sub values.\nvoid dfs1(vector<vector<int> >& adj, vector<int>& dp1,\n          vector<int>& dp2, vector<int>& sub, int curr,\n          int p, int n)\n{\n    for (auto x : adj[curr]) {\n        if (x != p) {\n          \n            // Recursively traverse the tree to calculate\n            // dp1 and sub values.\n            dfs1(adj, dp1, dp2, sub, x, curr, n);\n\n            // Update dp1[curr] by adding dp1[x] and sub[x].\n            dp1[curr] += dp1[x] + sub[x];\n\n            // Update sub[curr] by adding sub[x].\n            sub[curr] += sub[x];\n        }\n    }\n  // Increment sub[curr] to account for the current node itself.\n    sub[curr]++; \n}\n\n// Function to perform the second depth-first search to\n// calculate dp2 values.\nvoid dfs2(vector<vector<int> >& adj, vector<int>& dp1,\n          vector<int>& dp2, vector<int>& sub, int curr,\n          int p, int n)\n{\n    if (p != -1) {\n        // Calculate dp2[curr] using dp2 from the parent and\n        // sub values.\n        dp2[curr] = (dp2[p] - sub[curr]) + (n - sub[curr]);\n    }\n    else {\n      // For the root node, dp2 is equal to dp1.\n        dp2[curr] = dp1[curr]; \n    }\n\n    for (auto x : adj[curr]) {\n        if (x != p) {\n            // Recursively traverse the tree to calculate\n            // dp2 values.\n            dfs2(adj, dp1, dp2, sub, x, curr, n);\n        }\n    }\n}\n\n// Function to solve the problem and calculate the sum of\n// distances for each node.\nvoid solve(int n, vector<vector<int> >& edges)\n{\n    vector<vector<int> > adj(n + 1);\n\n    // Create an adjacency list to represent the tree.\n    for (int i = 0; i < n - 1; i++) {\n        int x = edges[i][0];\n        int y = edges[i][1];\n        adj[x].push_back(y);\n        adj[y].push_back(x);\n    }\n\n    vector<int> dp1(n + 1, 0);\n    vector<int> dp2(n + 1, 0);\n    vector<int> sub(n + 1, 0);\n\n    // Perform the first depth-first search to calculate dp1\n    // and sub values.\n    dfs1(adj, dp1, dp2, sub, 1, -1, n);\n\n    // Perform the second depth-first search to calculate\n    // dp2 values.\n    dfs2(adj, dp1, dp2, sub, 1, -1, n);\n\n    // Output the results for each node.\n    for (int i = 1; i <= n; i++) {\n        cout << dp2[i] << \" \";\n    }\n}\n\n// Driver Code\nint main()\n{\n    int N = 5;\n    vector<vector<int> > edges\n        = { { 1, 2 }, { 1, 3 }, { 3, 4 }, { 3, 5 } };\n    solve(N, edges);\n}\nimport java.util.ArrayList;\nimport java.util.List;\n\nclass TreeDistance {\n    // Function to perform the first depth-first search to\n    // calculate dp1 and sub values.\n    static void dfs1(List<List<Integer>> adj, int[] dp1, int[] dp2,\n                     int[] sub, int curr, int p, int n) {\n        for (int x : adj.get(curr)) {\n            if (x != p) {\n                // Recursively traverse the tree to calculate\n                // dp1 and sub values.\n                dfs1(adj, dp1, dp2, sub, x, curr, n);\n\n                // Update dp1[curr] by adding dp1[x] and sub[x].\n                dp1[curr] += dp1[x] + sub[x];\n\n                // Update sub[curr] by adding sub[x].\n                sub[curr] += sub[x];\n            }\n        }\n        // Increment sub[curr] to account for the current node itself.\n        sub[curr]++;\n    }\n\n    // Function to perform the second depth-first search to\n    // calculate dp2 values.\n    static void dfs2(List<List<Integer>> adj, int[] dp1, int[] dp2, \n                     int[] sub, int curr, int p, int n) {\n        if (p != -1) {\n            // Calculate dp2[curr] using dp2 from the parent and\n            // sub values.\n            dp2[curr] = (dp2[p] - sub[curr]) + (n - sub[curr]);\n        } else {\n            // For the root node, dp2 is equal to dp1.\n            dp2[curr] = dp1[curr];\n        }\n\n        for (int x : adj.get(curr)) {\n            if (x != p) {\n                // Recursively traverse the tree to calculate\n                // dp2 values.\n                dfs2(adj, dp1, dp2, sub, x, curr, n);\n            }\n        }\n    }\n\n    // Function to solve the problem and calculate the sum of\n    // distances for each node.\n    static void solve(int n, List<List<Integer>> edges) {\n        List<List<Integer>> adj = new ArrayList<>(n + 1);\n\n        // Initialize the adjacency list.\n        for (int i = 0; i <= n; i++) {\n            adj.add(new ArrayList<>());\n        }\n\n        // Create an adjacency list to represent the tree.\n        for (int i = 0; i < n - 1; i++) {\n            int x = edges.get(i).get(0);\n            int y = edges.get(i).get(1);\n            adj.get(x).add(y);\n            adj.get(y).add(x);\n        }\n\n        int[] dp1 = new int[n + 1];\n        int[] dp2 = new int[n + 1];\n        int[] sub = new int[n + 1];\n\n        // Perform the first depth-first search to calculate dp1\n        // and sub values.\n        dfs1(adj, dp1, dp2, sub, 1, -1, n);\n\n        // Perform the second depth-first search to calculate\n        // dp2 values.\n        dfs2(adj, dp1, dp2, sub, 1, -1, n);\n\n        // Output the results for each node.\n        for (int i = 1; i <= n; i++) {\n            System.out.print(dp2[i] + \" \");\n        }\n    }\n\n    // Driver Code\n    public static void main(String[] args) {\n        int N = 5;\n        List<List<Integer>> edges = List.of(\n                List.of(1, 2),\n                List.of(1, 3),\n                List.of(3, 4),\n                List.of(3, 5)\n        );\n        solve(N, edges);\n    }\n}\n# Function to perform the first depth-first search to\n# calculate dp1 and sub values.\n\n\ndef dfs1(adj, dp1, dp2, sub, curr, p, n):\n    for x in adj[curr]:\n        if x != p:\n            # Recursively traverse the tree to calculate dp1 and sub values.\n            dfs1(adj, dp1, dp2, sub, x, curr, n)\n\n            # Update dp1[curr] by adding dp1[x] and sub[x].\n            dp1[curr] += dp1[x] + sub[x]\n\n            # Update sub[curr] by adding sub[x].\n            sub[curr] += sub[x]\n\n    # Increment sub[curr] to account for the current node itself.\n    sub[curr] += 1\n\n# Function to perform the second depth-first search to\n# calculate dp2 values.\n\n\ndef dfs2(adj, dp1, dp2, sub, curr, p, n):\n    if p != -1:\n        # Calculate dp2[curr] using dp2 from the parent and sub values.\n        dp2[curr] = (dp2[p] - sub[curr]) + (n - sub[curr])\n    else:\n        # For the root node, dp2 is equal to dp1.\n        dp2[curr] = dp1[curr]\n\n    for x in adj[curr]:\n        if x != p:\n            # Recursively traverse the tree to calculate dp2 values.\n            dfs2(adj, dp1, dp2, sub, x, curr, n)\n\n# Function to solve the problem and calculate the sum of\n# distances for each node.\n\n\ndef solve(n, edges):\n    adj = [[] for _ in range(n + 1)]\n\n    # Create an adjacency list to represent the tree.\n    for edge in edges:\n        x, y = edge\n        adj[x].append(y)\n        adj[y].append(x)\n\n    dp1 = [0] * (n + 1)\n    dp2 = [0] * (n + 1)\n    sub = [0] * (n + 1)\n\n    # Perform the first depth-first search to calculate dp1 and sub values.\n    dfs1(adj, dp1, dp2, sub, 1, -1, n)\n\n    # Perform the second depth-first search to calculate dp2 values.\n    dfs2(adj, dp1, dp2, sub, 1, -1, n)\n\n    # Output the results for each node.\n    for i in range(1, n + 1):\n        print(dp2[i], end=\" \")\n\n\n# Driver Code\nif __name__ == \"__main__\":\n    N = 5\n    edges = [[1, 2], [1, 3], [3, 4], [3, 5]]\n    solve(N, edges)\nusing System;\nusing System.Collections.Generic;\n\nclass TreeDistanceSum\n{\n    // Function to perform the first depth-first search to\n    // calculate dp1 and sub values.\n    static void DFS1(List<List<int>> adj, List<int> dp1, \n                     List<int> dp2, List<int> sub, int curr, int p, int n)\n    {\n        foreach (int x in adj[curr])\n        {\n            if (x != p)\n            {\n                // Recursively traverse the tree to calculate\n                // dp1 and sub values.\n                DFS1(adj, dp1, dp2, sub, x, curr, n);\n\n                // Update dp1[curr] by adding dp1[x] and sub[x].\n                dp1[curr] += dp1[x] + sub[x];\n\n                // Update sub[curr] by adding sub[x].\n                sub[curr] += sub[x];\n            }\n        }\n        // Increment sub[curr] to account for the current node itself.\n        sub[curr]++;\n    }\n\n    // Function to perform the second depth-first search to\n    // calculate dp2 values.\n    static void DFS2(List<List<int>> adj, \n                     List<int> dp1, List<int> dp2, List<int> sub, int curr, int p, int n)\n    {\n        if (p != -1)\n        {\n            // Calculate dp2[curr] using dp2 from the parent and\n            // sub values.\n            dp2[curr] = (dp2[p] - sub[curr]) + (n - sub[curr]);\n        }\n        else\n        {\n            // For the root node, dp2 is equal to dp1.\n            dp2[curr] = dp1[curr];\n        }\n\n        foreach (int x in adj[curr])\n        {\n            if (x != p)\n            {\n                // Recursively traverse the tree to calculate\n                // dp2 values.\n                DFS2(adj, dp1, dp2, sub, x, curr, n);\n            }\n        }\n    }\n\n    // Function to solve the problem and calculate the sum of\n    // distances for each node.\n    static void Solve(int n, List<List<int>> edges)\n    {\n        List<List<int>> adj = new List<List<int>>();\n        for (int i = 0; i <= n; i++)\n        {\n            adj.Add(new List<int>());\n        }\n\n        // Create an adjacency list to represent the tree.\n        foreach (List<int> edge in edges)\n        {\n            int x = edge[0];\n            int y = edge[1];\n            adj[x].Add(y);\n            adj[y].Add(x);\n        }\n\n        List<int> dp1 = new List<int>(new int[n + 1]);\n        List<int> dp2 = new List<int>(new int[n + 1]);\n        List<int> sub = new List<int>(new int[n + 1]);\n\n        // Perform the first depth-first search to calculate dp1\n        // and sub values.\n        DFS1(adj, dp1, dp2, sub, 1, -1, n);\n\n        // Perform the second depth-first search to calculate\n        // dp2 values.\n        DFS2(adj, dp1, dp2, sub, 1, -1, n);\n\n        // Output the results for each node.\n        for (int i = 1; i <= n; i++)\n        {\n            Console.Write(dp2[i] + \" \");\n        }\n    }\n\n    // Driver Code\n    static void Main()\n    {\n        int N = 5;\n        List<List<int>> edges = new List<List<int>>\n        {\n            new List<int> { 1, 2 },\n            new List<int> { 1, 3 },\n            new List<int> { 3, 4 },\n            new List<int> { 3, 5 }\n        };\n        Solve(N, edges);\n    }\n}\n// Function to perform the first depth-first search to\n// calculate dp1 and sub values.\nfunction dfs1(adj, dp1, dp2, sub, curr, p, n) {\n    for (const x of adj[curr]) {\n        if (x !== p) {\n            // Recursively traverse the tree to calculate\n            // dp1 and sub values.\n            dfs1(adj, dp1, dp2, sub, x, curr, n);\n\n            // Update dp1[curr] by adding dp1[x] and sub[x].\n            dp1[curr] += dp1[x] + sub[x];\n\n            // Update sub[curr] by adding sub[x].\n            sub[curr] += sub[x];\n        }\n    }\n    // Increment sub[curr] to account for the current node itself.\n    sub[curr]++;\n}\n\n// Function to perform the second depth-first search to\n// calculate dp2 values.\nfunction dfs2(adj, dp1, dp2, sub, curr, p, n) {\n    if (p !== -1) {\n        // Calculate dp2[curr] using dp2 from the parent and\n        // sub values.\n        dp2[curr] = (dp2[p] - sub[curr]) + (n - sub[curr]);\n    } else {\n        // For the root node, dp2 is equal to dp1.\n        dp2[curr] = dp1[curr];\n    }\n\n    for (const x of adj[curr]) {\n        if (x !== p) {\n            // Recursively traverse the tree to calculate\n            // dp2 values.\n            dfs2(adj, dp1, dp2, sub, x, curr, n);\n        }\n    }\n}\n\n// Function to solve the problem and calculate the sum of\n// distances for each node.\nfunction solve(n, edges) {\n    const adj = Array.from({ length: n + 1 }, () => []);\n\n    // Create an adjacency list to represent the tree.\n    for (const edge of edges) {\n        const [x, y] = edge;\n        adj[x].push(y);\n        adj[y].push(x);\n    }\n\n    const dp1 = Array(n + 1).fill(0);\n    const dp2 = Array(n + 1).fill(0);\n    const sub = Array(n + 1).fill(0);\n\n    // Perform the first depth-first search to calculate dp1\n    // and sub values.\n    dfs1(adj, dp1, dp2, sub, 1, -1, n);\n\n    // Perform the second depth-first search to calculate\n    // dp2 values.\n    dfs2(adj, dp1, dp2, sub, 1, -1, n);\n\n    // Output the results for each node.\n    for (let i = 1; i <= n; i++) {\n        console.log(dp2[i] + \" \");\n    }\n}\n\n// Driver Code\nconst N = 5;\nconst edges = [[1, 2], [1, 3], [3, 4], [3, 5]];\nsolve(N, edges);\n6 9 5 8 8\n",
        "complexity": {
            "time": "Time Complexity: O(N)Auxiliary Space: O(N)",
            "space": ""
        },
        "tags": [
            "Dynamic Programming"
        ],
        "url": "https://www.geeksforgeeks.org/dp-on-trees-for-competitive-programming/"
    },
    {
        "title": "Dynamic Programming (DP) and Directed Acyclic Graphs (DAG)",
        "description": "Pre-Requisite:What is Directed Graph? | Directed Graph meaningDynamic Programming (DP) Tutorial with Problems Every Dynamic Programming problem can be represented as a Directed Acyclic Graph(DAG). The nodes of the DAG represent the subproblems and the edges represents the transitions between the subproblems.  Table of Content Let's take an example to understand the above points: Problem: Finding Longest Path in Directed Acyclic Graphs (DAG): The dp state and the transition in this case will be: Let dp[v] denote the length of the longest path ending at the node v. Initialize all the positions in dp array as 1. Clearly, For every edge from node u to node v, dp[v] = max (dp[u]+1) At the end check for the maximum value in dp[] array, which will be the longest path in the DAG. If the graph contains a cycle, then some states would lead back to themselves after a series of transitions. This would lead to infinite calculations. Thus, answer will not exist if the graph is cyclic in this case. As shown in below image, we potentially keep traversing the cycle indefinitely, making it impossible to find the longest path. Let us consider few problems which will tell how to define the states and make the transition: Given a Directed Acyclic Graph consisting of N nodes and M edges. The task is to determine the number of different ways to reach Node N from Node 1. Solution: The problem can be solved in following steps: 1. Define the States: As mentioned above each Nodes of Directed Acyclic Graph represents a state. Let dp[v] be the number of ways to reach Node N from the vertex v. 2. Make the Transitions: Like the Nodes represents states in the DAG, similarly the edges represent transition. Thus dp[v] can be calculated by: dp[v] = Σdp[u], for every edge v->u 3. Topological Consideration: We process the nodes topologically i.e., if edge v->u exists then dp[u] should be computed before dp[v]. Hence ,dp[1] will be our final answer. Below is the implementation of above approach: Time Complexity: O(N), Where ‘N’ is the number of nodes in the given graph.Auxiliary Space: O(N) Given a Directed Acyclic Graph consisting of N nodes and M edges. Each node is assigned a lowercase alphabet representing the color of that node ('a' to 'z'). The task is to determine the largest value of any path. The value of a path is defined as the number of nodes which are colored with the most occurring color in the path. Solution: The problem can be solved in following steps: 1. Define the States: We can observe that there are total 26 colors possible. So, we can make a 2D dp[][] array of size N*26. Let dp[v][i] represent the maximum count of vertices having color i  of any path starting from vertex v. 2. Make the Transitions: Again, like the Nodes represent states in the DAG, similarly the edges represent transitions. Thus dp[v][i] can be calculated by: dp[v][i] = max(dp[u][i]+col, dp[v][i]), for each edge v->u and each color i from 0 to 25. The value of col will be 1 if color of vertex v is equal to i otherwise it will be 0. 3. Topological Consideration: Again, we process the nodes topologically i.e., if edge v->u exists then the node u should be processed before node v. Hence, our final answer will be maximum of dp[v][i] for each vertex from 1 to N and color from 0 to 25. Below is the implementation of above approach: Time Complexity: O(N), Where ‘N’ is the number of nodes in the given graph.Auxiliary Space: O(N) Minimize the Maximum value Maximum Edges In the Path M  ",
        "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n// Recursive function to perform depth-first search\n// and calculate the number of ways to reach Node N from\n// vertex curr\nint dfs(int n, vector<vector<int> >& adj, vector<int>& dp,\n        vector<int>& vis, int curr)\n{\n    // If the node has already been visited, return its\n    // stored value\n    if (vis[curr] == 1)\n        return dp[curr];\n\n    // Mark the current node as visited\n    vis[curr] = 1;\n\n    // Traverse all adjacent nodes and recursively calculate\n    // the number of ways\n    for (auto x : adj[curr]) {\n        if (!vis[x]) {\n            dfs(n, adj, dp, vis, x);\n        }\n\n        // Update the number of ways to reach Node N from\n        // the current node\n        dp[curr] += dp[x];\n    }\n\n    // Return the calculated value for the current node\n    return dp[curr];\n}\n\n// Function to calculate the number of ways to reach Node N\n// from Node 1\nint noOfWays(int n, vector<vector<int> >& edges)\n{\n    // Adjacency list to represent the directed acyclic\n    // graph\n    vector<vector<int> > adj(n + 1);\n\n    // Populate the adjacency list using the provided edges\n    for (vector<int> i : edges) {\n        adj[i[0]].push_back(i[1]);\n    }\n\n    // Initialize dp array to store the number of ways to\n    // reach Node N from each vertex\n    vector<int> dp(n + 1, 0);\n\n    // Initialize visited array to keep track of visited\n    // nodes during DFS\n    vector<int> vis(n + 1, 0);\n\n    // Set the base case for Node N, i.e., there is one way\n    // to reach N from N\n    dp[n] = 1;\n\n    // Mark Node N as visited\n    vis[n] = 1;\n\n    // Call the recursive DFS function to calculate the\n    // number of ways\n    int res = dfs(n, adj, dp, vis, 1);\n\n    // Return the result, which represents the number of\n    // ways to reach Node N from Node 1\n    return res;\n}\n\nint main()\n{\n    // Example inputs\n    int N = 5;\n    vector<vector<int> > edges = {\n        { 1, 2 }, { 1, 3 }, { 2, 4 }, { 3, 4 }, { 4, 5 }\n    };\n\n    // Function call\n    int result = noOfWays(N, edges);\n\n    // Output the result\n    cout << \"No. of ways to reach Node N from Node 1: \"\n         << result << endl;\n\n    return 0;\n}\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class WaysToReachNodeN {\n\n    // Recursive function to perform depth-first search\n    // and calculate the number of ways to reach Node N from\n    // vertex curr\n    private static int dfs(int n, List<List<Integer>> adj, int[] dp,\n                           int[] vis, int curr) {\n        // If the node has already been visited, return its\n        // stored value\n        if (vis[curr] == 1)\n            return dp[curr];\n\n        // Mark the current node as visited\n        vis[curr] = 1;\n\n        // Traverse all adjacent nodes and recursively calculate\n        // the number of ways\n        for (int x : adj.get(curr)) {\n            if (vis[x] == 0) {\n                dfs(n, adj, dp, vis, x);\n            }\n\n            // Update the number of ways to reach Node N from\n            // the current node\n            dp[curr] += dp[x];\n        }\n\n        // Return the calculated value for the current node\n        return dp[curr];\n    }\n\n    // Function to calculate the number of ways to reach Node N\n    // from Node 1\n    private static int noOfWays(int n, List<List<Integer>> edges) {\n        // Adjacency list to represent the directed acyclic\n        // graph\n        List<List<Integer>> adj = new ArrayList<>(n + 1);\n\n        // Populate the adjacency list using the provided edges\n        for (int i = 0; i <= n; i++) {\n            adj.add(new ArrayList<>());\n        }\n\n        for (List<Integer> edge : edges) {\n            adj.get(edge.get(0)).add(edge.get(1));\n        }\n\n        // Initialize dp array to store the number of ways to\n        // reach Node N from each vertex\n        int[] dp = new int[n + 1];\n\n        // Initialize visited array to keep track of visited\n        // nodes during DFS\n        int[] vis = new int[n + 1];\n\n        // Set the base case for Node N, i.e., there is one way\n        // to reach N from N\n        dp[n] = 1;\n\n        // Mark Node N as visited\n        vis[n] = 1;\n\n        // Call the recursive DFS function to calculate the\n        // number of ways\n        int res = dfs(n, adj, dp, vis, 1);\n\n        // Return the result, which represents the number of\n        // ways to reach Node N from Node 1\n        return res;\n    }\n\n    public static void main(String[] args) {\n        // Example inputs\n        int N = 5;\n        List<List<Integer>> edges = List.of(\n                List.of(1, 2), List.of(1, 3), List.of(2, 4), List.of(3, 4), List.of(4, 5)\n        );\n\n        // Function call\n        int result = noOfWays(N, edges);\n\n        // Output the result\n        System.out.println(\"No. of ways to reach Node N from Node 1: \" + result);\n    }\n}\nusing System;\nusing System.Collections.Generic;\n\nclass Program\n{\n    // Recursive function to perform depth-first search\n    // and calculate the number of ways to reach Node N from\n    // vertex curr\n    static int DFS(int n, List<List<int>> adj, List<int> dp,\n                   List<int> vis, int curr)\n    {\n        // If the node has already been visited, return its\n        // stored value\n        if (vis[curr] == 1)\n            return dp[curr];\n\n        // Mark the current node as visited\n        vis[curr] = 1;\n\n        // Traverse all adjacent nodes and recursively calculate\n        // the number of ways\n        foreach (int x in adj[curr])\n        {\n            if (vis[x] == 0)\n                DFS(n, adj, dp, vis, x);\n\n            // Update the number of ways to reach Node N from\n            // the current node\n            dp[curr] += dp[x];\n        }\n\n        // Return the calculated value for the current node\n        return dp[curr];\n    }\n\n    // Function to calculate the number of ways to reach Node N\n    // from Node 1\n    static int NoOfWays(int n, List<List<int>> edges)\n    {\n        // Adjacency list to represent the directed acyclic\n        // graph\n        List<List<int>> adj = new List<List<int>>(n + 1);\n\n        // Initialize adjacency list\n        for (int i = 0; i <= n; i++)\n        {\n            adj.Add(new List<int>());\n        }\n\n        // Populate the adjacency list using the provided edges\n        foreach (List<int> i in edges)\n        {\n            adj[i[0]].Add(i[1]);\n        }\n\n        // Initialize dp array to store the number of ways to\n        // reach Node N from each vertex\n        List<int> dp = new List<int>(new int[n + 1]);\n\n        // Initialize visited array to keep track of visited\n        // nodes during DFS\n        List<int> vis = new List<int>(new int[n + 1]);\n\n        // Set the base case for Node N, i.e., there is one way\n        // to reach N from N\n        dp[n] = 1;\n\n        // Mark Node N as visited\n        vis[n] = 1;\n\n        // Call the recursive DFS function to calculate the\n        // number of ways\n        int res = DFS(n, adj, dp, vis, 1);\n\n        // Return the result, which represents the number of\n        // ways to reach Node N from Node 1\n        return res;\n    }\n\n    static void Main()\n    {\n        // Example inputs\n        int N = 5;\n        List<List<int>> edges = new List<List<int>>\n        {\n            new List<int> {1, 2},\n            new List<int> {1, 3},\n            new List<int> {2, 4},\n            new List<int> {3, 4},\n            new List<int> {4, 5}\n        };\n\n        // Function call\n        int result = NoOfWays(N, edges);\n\n        // Output the result\n        Console.WriteLine($\"No. of ways to reach Node N from Node 1: {result}\");\n    }\n}\n// Function to perform depth-first search\n// and calculate the number of ways to reach Node N from vertex curr\nfunction dfs(n, adj, dp, vis, curr) {\n    // If the node has already been visited, return its stored value\n    if (vis[curr] === 1)\n        return dp[curr];\n\n    // Mark the current node as visited\n    vis[curr] = 1;\n\n    // Traverse all adjacent nodes and recursively calculate the number of ways\n    for (let x of adj[curr]) {\n        if (vis[x] === 0) {\n            dfs(n, adj, dp, vis, x);\n        }\n\n        // Update the number of ways to reach Node N from the current node\n        dp[curr] += dp[x];\n    }\n\n    // Return the calculated value for the current node\n    return dp[curr];\n}\n\n// Function to calculate the number of ways to reach Node N from Node 1\nfunction noOfWays(n, edges) {\n    // Adjacency list to represent the directed acyclic graph\n    let adj = new Array(n + 1).fill().map(() => []);\n\n    // Populate the adjacency list using the provided edges\n    for (let edge of edges) {\n        adj[edge[0]].push(edge[1]);\n    }\n\n    // Initialize dp array to store the number of ways to reach Node N from each vertex\n    let dp = new Array(n + 1).fill(0);\n\n    // Initialize visited array to keep track of visited nodes during DFS\n    let vis = new Array(n + 1).fill(0);\n\n    // Set the base case for Node N, i.e., there is one way to reach N from N\n    dp[n] = 1;\n\n    // Mark Node N as visited\n    vis[n] = 1;\n\n    // Call the recursive DFS function to calculate the number of ways\n    let res = dfs(n, adj, dp, vis, 1);\n\n    // Return the result, which represents the number of ways to reach Node N from Node 1\n    return res;\n}\n\n// Example inputs\nlet N = 5;\nlet edges = [\n    [1, 2], [1, 3], [2, 4], [3, 4], [4, 5]\n];\n\n// Function call\nlet result = noOfWays(N, edges);\n\n// Output the result\nconsole.log(\"No. of ways to reach Node N from Node 1:\", result);\nfrom collections import defaultdict\n\ndef dfs(n, adj, dp, vis, curr):\n    # If the node has already been visited, return its stored value\n    if vis[curr] == 1:\n        return dp[curr]\n\n    # Mark the current node as visited\n    vis[curr] = 1\n\n    # Traverse all adjacent nodes and recursively calculate the number of ways\n    for x in adj[curr]:\n        if vis[x] == 0:\n            dfs(n, adj, dp, vis, x)\n\n        # Update the number of ways to reach Node N from the current node\n        dp[curr] += dp[x]\n\n    # Return the calculated value for the current node\n    return dp[curr]\n\ndef no_of_ways(n, edges):\n    # Adjacency list to represent the directed acyclic graph\n    adj = defaultdict(list)\n\n    # Populate the adjacency list using the provided edges\n    for edge in edges:\n        adj[edge[0]].append(edge[1])\n\n    # Initialize dp array to store the number of ways to reach Node N from each vertex\n    dp = [0] * (n + 1)\n\n    # Initialize visited array to keep track of visited nodes during DFS\n    vis = [0] * (n + 1)\n\n    # Set the base case for Node N, i.e., there is one way to reach N from N\n    dp[n] = 1\n\n    # Mark Node N as visited\n    vis[n] = 1\n\n    # Call the recursive DFS function to calculate the number of ways\n    res = dfs(n, adj, dp, vis, 1)\n\n    # Return the result, which represents the number of ways to reach Node N from Node 1\n    return res\n\n# Example inputs\nN = 5\nedges = [\n    (1, 2), (1, 3), (2, 4), (3, 4), (4, 5)\n]\n\n# Function call\nresult = no_of_ways(N, edges)\n\n# Output the result\nprint(\"No. of ways to reach Node N from Node 1:\", result)\nNo. of ways to reach Node N from Node 1: 2\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Recursive function to perform depth-first search\n// and calculate the maximum count of vertices having a specific color\nvoid dfs(int n, vector<vector<int>>& adj, vector<vector<int>>& dp,\n         vector<int>& vis, int curr, string& s) {\n    // If the node has already been visited, return\n    if (vis[curr] == 1)\n        return;\n\n    // Mark the current node as visited\n    vis[curr] = 1;\n\n    // Initialize the color count for the current node\n    dp[curr][s[curr - 1] - 97] = 1;\n\n    // Traverse all adjacent nodes and recursively calculate\n    // the maximum count of vertices having each color\n    for (auto x : adj[curr]) {\n        if (!vis[x]) {\n            dfs(n, adj, dp, vis, x, s);\n        }\n\n        // Update the count of vertices having each color\n        for (int j = 0; j < 26; j++) {\n            int col = 0;\n            if (s[curr - 1] - 97 == j)\n                col = 1;\n            dp[curr][j] = max(dp[curr][j], dp[x][j] + col);\n        }\n    }\n}\n\n// Function to calculate the maximum count of vertices\n// having the most occurring color in any path\nint maxcolorpath(int n, vector<vector<int>>& edges, string s) {\n    // Adjacency list to represent the directed acyclic graph\n    vector<vector<int>> adj(n + 1);\n\n    // Populate the adjacency list using the provided edges\n    for (vector<int> i : edges) {\n        adj[i[0]].push_back(i[1]);\n    }\n\n    // Initialize dp array to store the maximum count of vertices\n    // having each color for each vertex\n    vector<vector<int>> dp(n + 1, vector<int>(26, 0));\n\n    // Initialize visited array to keep track of visited nodes during DFS\n    vector<int> vis(n + 1);\n\n    // Call the recursive DFS function to calculate the maximum count\n    dfs(n, adj, dp, vis, 1, s);\n\n    // Find the maximum count of vertices having the most occurring color\n    int res = 0;\n    for (int i = 1; i <= n; i++) {\n        for (int j = 0; j < 26; j++) {\n            res = max(res, dp[i][j]);\n        }\n    }\n    return res;\n}\n\nint main() {\n    // Example inputs\n    int N = 5;\n    vector<vector<int>> edges = {\n        {1, 2}, {1, 3}, {2, 4}, {3, 4}, {4, 5}\n    };\n    string color = \"abaca\";\n\n    // Function call\n    int result = maxcolorpath(N, edges, color);\n\n    // Output the result\n    cout << \"Maximum count of vertices having the most occurring color: \"\n         << result << endl;\n\n    return 0;\n}\nimport java.util.ArrayList;\nimport java.util.Arrays;\n\npublic class MaxColorPath {\n\n    // Recursive function to perform depth-first search\n    // and calculate the maximum count of vertices having a specific color\n    static void dfs(int n, ArrayList<ArrayList<Integer>> adj, int[][] dp,\n                    int[] vis, int curr, String s) {\n        // If the node has already been visited, return\n        if (vis[curr] == 1)\n            return;\n\n        // Mark the current node as visited\n        vis[curr] = 1;\n\n        // Initialize the color count for the current node\n        dp[curr][s.charAt(curr - 1) - 'a'] = 1;\n\n        // Traverse all adjacent nodes and recursively calculate\n        // the maximum count of vertices having each color\n        for (int x : adj.get(curr)) {\n            if (vis[x] == 0) {\n                dfs(n, adj, dp, vis, x, s);\n            }\n\n            // Update the count of vertices having each color\n            for (int j = 0; j < 26; j++) {\n                int col = (s.charAt(curr - 1) - 'a' == j) ? 1 : 0;\n                dp[curr][j] = Math.max(dp[curr][j], dp[x][j] + col);\n            }\n        }\n    }\n\n    // Function to calculate the maximum count of vertices\n    // having the most occurring color in any path\n    static int maxColorPath(int n, int[][] edges, String s) {\n        // Adjacency list to represent the directed acyclic graph\n        ArrayList<ArrayList<Integer>> adj = new ArrayList<>(n + 1);\n\n        for (int i = 0; i <= n; i++) {\n            adj.add(new ArrayList<>());\n        }\n\n        // Populate the adjacency list using the provided edges\n        for (int[] edge : edges) {\n            adj.get(edge[0]).add(edge[1]);\n        }\n\n        // Initialize dp array to store the maximum count of vertices\n        // having each color for each vertex\n        int[][] dp = new int[n + 1][26];\n\n        // Initialize visited array to keep track of visited nodes during DFS\n        int[] vis = new int[n + 1];\n\n        // Call the recursive DFS function to calculate the maximum count\n        dfs(n, adj, dp, vis, 1, s);\n\n        // Find the maximum count of vertices having the most occurring color\n        int res = 0;\n        for (int i = 1; i <= n; i++) {\n            for (int j = 0; j < 26; j++) {\n                res = Math.max(res, dp[i][j]);\n            }\n        }\n        return res;\n    }\n\n    public static void main(String[] args) {\n        // Example inputs\n        int N = 5;\n        int[][] edges = {\n                {1, 2}, {1, 3}, {2, 4}, {3, 4}, {4, 5}\n        };\n        String color = \"abaca\";\n\n        // Function call\n        int result = maxColorPath(N, edges, color);\n\n        // Output the result\n        System.out.println(\"Maximum count of vertices having the most occurring color: \" + result);\n    }\n}\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nclass Program\n{\n    // Recursive function to perform depth-first search\n    // and calculate the maximum count of vertices having a specific color\n    static void Dfs(int n, List<int>[] adj, int[][] dp, int[] vis, int curr, string s)\n    {\n        // If the node has already been visited, return\n        if (vis[curr] == 1)\n            return;\n\n        // Mark the current node as visited\n        vis[curr] = 1;\n\n        // Initialize the color count for the current node\n        dp[curr][s[curr - 1] - 97] = 1;\n\n        // Traverse all adjacent nodes and recursively calculate\n        // the maximum count of vertices having each color\n        foreach (var x in adj[curr])\n        {\n            if (vis[x] == 0)\n            {\n                Dfs(n, adj, dp, vis, x, s);\n            }\n\n            // Update the count of vertices having each color\n            for (int j = 0; j < 26; j++)\n            {\n                int col = 0;\n                if (s[curr - 1] - 97 == j)\n                    col = 1;\n                dp[curr][j] = Math.Max(dp[curr][j], dp[x][j] + col);\n            }\n        }\n    }\n\n    // Function to calculate the maximum count of vertices\n    // having the most occurring color in any path\n    static int MaxColorPath(int n, int[][] edges, string s)\n    {\n        // Adjacency list to represent the directed acyclic graph\n        var adj = new List<int>[n + 1];\n        for (int i = 0; i < adj.Length; i++)\n        {\n            adj[i] = new List<int>();\n        }\n\n        // Populate the adjacency list using the provided edges\n        foreach (var i in edges)\n        {\n            adj[i[0]].Add(i[1]);\n        }\n\n        // Initialize dp array to store the maximum count of vertices\n        // having each color for each vertex\n        var dp = new int[n + 1][];\n        for (int i = 0; i < dp.Length; i++)\n        {\n            dp[i] = new int[26];\n        }\n\n        // Initialize visited array to keep track of visited nodes during DFS\n        var vis = new int[n + 1];\n\n        // Call the recursive DFS function to calculate the maximum count\n        Dfs(n, adj, dp, vis, 1, s);\n\n        // Find the maximum count of vertices having the most occurring color\n        int res = 0;\n        for (int i = 1; i <= n; i++)\n        {\n            for (int j = 0; j < 26; j++)\n            {\n                res = Math.Max(res, dp[i][j]);\n            }\n        }\n        return res;\n    }\n\n    static void Main()\n    {\n        int N = 5;\n        int[][] edges = {\n            new int[] {1, 2}, new int[] {1, 3}, new int[] {2, 4}, new int[] {3, 4}, new int[] {4, 5}\n        };\n        string color = \"abaca\";\n\n        // Function call\n        int result = MaxColorPath(N, edges, color);\n\n        // Output the result\n        Console.WriteLine(\"Maximum count of vertices having the most occurring color: \"\n             + result);\n    }\n}\n// Recursive function to perform depth-first search\n// and calculate the maximum count of vertices having a specific color\nfunction dfs(n, adj, dp, vis, curr, s) {\n    // If the node has already been visited, return\n    if (vis[curr] === 1)\n        return;\n\n    // Mark the current node as visited\n    vis[curr] = 1;\n\n    // Initialize the color count for the current node\n    dp[curr][s.charCodeAt(curr - 1) - 97] = 1;\n\n    // Traverse all adjacent nodes and recursively calculate\n    // the maximum count of vertices having each color\n    for (let x of adj[curr]) {\n        if (!vis[x]) {\n            dfs(n, adj, dp, vis, x, s);\n        }\n\n        // Update the count of vertices having each color\n        for (let j = 0; j < 26; j++) {\n            let col = 0;\n            if (s.charCodeAt(curr - 1) - 97 === j)\n                col = 1;\n            dp[curr][j] = Math.max(dp[curr][j], dp[x][j] + col);\n        }\n    }\n}\n\n// Function to calculate the maximum count of vertices\n// having the most occurring color in any path\nfunction maxcolorpath(n, edges, s) {\n    // Adjacency list to represent the directed acyclic graph\n    let adj = new Array(n + 1).fill(null).map(() => []);\n\n    // Populate the adjacency list using the provided edges\n    for (let i of edges) {\n        adj[i[0]].push(i[1]);\n    }\n\n    // Initialize dp array to store the maximum count of vertices\n    // having each color for each vertex\n    let dp = new Array(n + 1).fill(null).map(() => new Array(26).fill(0));\n\n    // Initialize visited array to keep track of visited nodes during DFS\n    let vis = new Array(n + 1).fill(0);\n\n    // Call the recursive DFS function to calculate the maximum count\n    dfs(n, adj, dp, vis, 1, s);\n\n    // Find the maximum count of vertices having the most occurring color\n    let res = 0;\n    for (let i = 1; i <= n; i++) {\n        for (let j = 0; j < 26; j++) {\n            res = Math.max(res, dp[i][j]);\n        }\n    }\n    return res;\n}\n\n// Example inputs\nlet N = 5;\nlet edges = [\n    [1, 2], [1, 3], [2, 4], [3, 4], [4, 5]\n];\nlet color = \"abaca\";\n\n// Function call\nlet result = maxcolorpath(N, edges, color);\n\n// Output the result\nconsole.log(\"Maximum count of vertices having the most occurring color: \" + result);\n//this code is contributed by Adarsh.\n# Recursive function to perform depth-first search\n# and calculate the maximum count of vertices having a specific color\ndef dfs(n, adj, dp, vis, curr, s):\n    # If the node has already been visited, return\n    if vis[curr] == 1:\n        return\n\n    # Mark the current node as visited\n    vis[curr] = 1\n\n    # Initialize the color count for the current node\n    dp[curr][ord(s[curr - 1]) - 97] = 1\n\n    # Traverse all adjacent nodes and recursively calculate\n    # the maximum count of vertices having each color\n    for x in adj[curr]:\n        if not vis[x]:\n            dfs(n, adj, dp, vis, x, s)\n\n        # Update the count of vertices having each color\n        for j in range(26):\n            col = 0\n            if ord(s[curr - 1]) - 97 == j:\n                col = 1\n            dp[curr][j] = max(dp[curr][j], dp[x][j] + col)\n\n# Function to calculate the maximum count of vertices\n# having the most occurring color in any path\ndef maxcolorpath(n, edges, s):\n    # Adjacency list to represent the directed acyclic graph\n    adj = [[] for _ in range(n + 1)]\n\n    # Populate the adjacency list using the provided edges\n    for i in edges:\n        adj[i[0]].append(i[1])\n\n    # Initialize dp array to store the maximum count of vertices\n    # having each color for each vertex\n    dp = [[0] * 26 for _ in range(n + 1)]\n\n    # Initialize visited array to keep track of visited nodes during DFS\n    vis = [0] * (n + 1)\n\n    # Call the recursive DFS function to calculate the maximum count\n    dfs(n, adj, dp, vis, 1, s)\n\n    # Find the maximum count of vertices having the most occurring color\n    res = 0\n    for i in range(1, n + 1):\n        for j in range(26):\n            res = max(res, dp[i][j])\n    return res\n\n# Example inputs\nN = 5\nedges = [\n    [1, 2], [1, 3], [2, 4], [3, 4], [4, 5]\n]\ncolor = \"abaca\"\n\n# Function call\nresult = maxcolorpath(N, edges, color)\n\n# Output the result\nprint(\"Maximum count of vertices having the most occurring color:\", result)\n# This code is contributed by prachi\nMaximum count of vertices having the most occurring color: 3\n",
        "complexity": {
            "time": "Time Complexity: O(N), Where ‘N’ is the number of nodes in the given graph.Auxiliary Space: O(N)",
            "space": ""
        },
        "tags": [
            "Dynamic Programming"
        ],
        "url": "https://www.geeksforgeeks.org/dynamic-programming-dp-and-directed-acyclic-graphs-dag/"
    },
    {
        "title": "DSA Tutorial - Learn Data Structures and Algorithms",
        "description": "DSA (Data Structures and Algorithms)  is the study of organizing data efficiently using data structures like arrays, stacks, and trees, paired with step-by-step procedures (or algorithms) to solve problems effectively. Data structures manage how data is stored and accessed, while algorithms focus on processing this data. Hoping you have learned a programming language of your choice, here comes the next stage of the roadmap - Learn about Time and Space Complexities. Once you have learned basics of a programming language, it is recommended that you learn basic logic building To analyze algorithms, we mainly measure order of growth of time or space taken in terms of input size.  We do this in the worst case scenario in most of the cases. Please refer the below links for a clear understanding of these concepts. Array is a linear data structure where elements are allocated contiguous memory, allowing for constant-time access. Searching algorithms are used to locate specific data within a large set of data. It helps find a target value within the data. There are various types of searching algorithms, each with its own approach and efficiency. Sorting algorithms are used to arrange the elements of a list in a specific order, such as numerical or alphabetical. It organizes the items in a systematic way, making it easier to search for and access specific elements. Hashing is a technique that generates a fixed-size output (hash value) from an input of variable size using mathematical formulas called hash functions. Hashing is commonly used in data structures for efficient searching, insertion and deletion. In Two Pointer Technique, we typically use two index variables from two corners of an array. We use the two pointer technique for searching a required point or value in an array. In Window Sliding Technique, we use the result of previous subarray to quickly compute the result of current. In Prefix Sum Technique, we compute prefix sums of an array to quickly find results for a subarray. String is a sequence of characters, typically immutable and have limited set of elements (lower case or all English alphabets). Recursion is a programming technique where a function calls itself within its own definition. It is usually used to solve problems that can be broken down into smaller instances of the same problem. Matrix is a two-dimensional array of elements, arranged in rows and columns. It is represented as a rectangular grid, with each element at the intersection of a row and column. Linked list is a linear data structure that stores data in nodes, which are connected by pointers. Unlike arrays, nodes of linked lists are not stored in contiguous memory locations and can only be accessed sequentially, starting from the head of list. Stack is a linear data structure that follows the Last In, First Out (LIFO) principle. Stacks play an important role in managing function calls, memory, and are widely used in algorithms like stock span problem, next greater element and largest area in a histogram. Queue is a linear data structure that follows the First In, First Out (FIFO) principle. Queues play an important role in managing tasks or data in order, scheduling and message handling systems. A deque (double-ended queue) is a data structure that allows elements to be added or removed from both ends efficiently. Tree is a non-linear, hierarchical data structure consisting of nodes connected by edges, with a top node called the root and nodes having child nodes. It is widely used in file systems, databases, decision-making algorithms, etc. Heap is a complete binary tree data structure that satisfies the heap property. Heaps are usually used to implement priority queues, where the smallest or largest element is always at the root of the tree. Graph is a non-linear data structure consisting of a finite set of vertices(or nodes) and a set of edges(or links)that connect a pair of nodes. Graphs are widely used to represent relationships between entities. Greedy Algorithm builds up the solution one piece at a time and chooses the next piece which gives the most obvious and immediate benefit i.e., which is the most optimal choice at that moment. So the problems where choosing locally optimal also leads to the global solutions are best fit for Greedy. Dynamic Programming is a method used to solve complex problems by breaking them down into simpler subproblems. By solving each subproblem only once and storing the results, it avoids redundant computations, leading to more efficient solutions for a wide range of problems. Bitwise Algorithms: Operate on individual bits of numbers. Backtracking Algorithm : Follow Recursion  with the option to revert and traces back if the solution from current point is not feasible. Divide and conquer:  A strategy to solve problems by dividing them into smaller subproblems, solving those subproblems, and combining the solutions to obtain the final solution. Branch and Bound : Used in combinatorial optimization problems to systematically search for the best solution. It works by dividing the problem into smaller subproblems, or branches, and then eliminating certain branches based on bounds on the optimal solution. This process continues until the best solution is found or all branches have been explored. Geometric algorithms are a set of algorithms that solve problems related to shapes, points, lines and polygons. Randomized algorithms are algorithms that use randomness to solve problems. They make use of random input to achieve their goals, often leading to simpler and more efficient solutions. These algorithms may not product same result but are particularly useful in situations when a probabilistic approach is acceptable. Advanced Data Structures like Trie, Segment Tree, Red-Black Tree and Binary Indexed Tree offer significant performance improvements for specific problem domains. They provide efficient solutions for tasks like fast prefix searches, range queries, dynamic updates, and maintaining balanced data structures, which are crucial for handling large datasets and real-time processing. By optimizing time complexity, they enable better scalability and faster execution in many computational problems. R  ",
        "code": "",
        "complexity": {
            "time": "Advanced Data Structures like Trie, Segment Tree, Red-Black Tree and Binary Indexed Tree offer significant performance improvements for specific problem domains. They provide efficient solutions for tasks like fast prefix searches, range queries, dynamic updates, and maintaining balanced data structures, which are crucial for handling large datasets and real-time processing. By optimizing time complexity, they enable better scalability and faster execution in many computational problems.",
            "space": ""
        },
        "tags": [
            "Divide and Conquer"
        ],
        "url": "https://www.geeksforgeeks.org/learn-data-structures-and-algorithms-dsa-tutorial/"
    },
    {
        "title": "No Title",
        "description": "",
        "code": "",
        "complexity": {
            "time": "",
            "space": ""
        },
        "tags": [
            "Divide and Conquer"
        ],
        "url": "https://www.geeksforgeeks.org/explore?page=1&category=Divide+and+Conquer&sortBy=submissions"
    },
    {
        "title": "Top MCQs on Divide and Conquer Algorithm with Answers",
        "description": "Top MCQs on Divide and Conquer Algorithm with Answers Question 1 Question 2 Question 3 Question 4 Question 5 The secant method is used to find the root of an equation f(x) = 0. It is started from two distinct estimates x a and x b for the root. It is an iterative procedure involving linear interpolation to a root. The iteration stops if f(x b ) is very small and then x b is the solution. The procedure is given below. Observe that there is an expression which is missing and is marked by? Which is the suitable expression that is to be put in place of? So that it follows all steps of the secant method? Secant xb – (fb– f(xa)) fb/ (xb – xa) xa– (fa– f(xa)) fa/ (xb – xa) xb – (fb – xa) fb/ (xb – fb(xa) xa – (xb – xa) fa/ (fb – f(xa)) Question 6 Question 7 Consider the following array.\r\n\r\n\r\nWhich algorithm out of the following options uses the least number of comparisons (among the array elements) to sort the above array in ascending order? Question 8 A binary search tree T contains n distinct elements. What is the time complexity of picking an element in T that is smaller than the maximum element in T? Θ(nlogn) Θ(n) Θ(logn) Θ(1) Question 9 Question 10 Let P be an array containing n integers. Let t be the lowest upper bound on the number of comparisons of the array elements, required to find the minimum and maximum values in an arbitrary array of n elements. Which one of the following choices is correct? t>2n−2 t>3⌈n/2⌉ and t≤2n−2 t>n and t≤3⌈n/2⌉ t>⌈log2(n)⌉ and t≤n There are 13 questions to complete. ",
        "code": "Initialize: xa, xb, ε, N     // ε = convergence indicatorfb = f(xb) i = 0while (i < N and |fb| > ε) do   i = i + 1                 // update counter   xt = ?                    // missing expression for                             // intermediate value   xa = xb                   // reset xa   xb = xt                   // reset xb   fb = f(xb)                // function value at new xbend whileif |fb| > ε  then // loop is terminated with i = N  write “Non-convergence”else  write “return xb”end if\nint partition (int a[], int n);\nint kth_smallest (int a[], int n, int k)\n{\n   int left_end = partition (a, n);\n   if (left_end+1==k)\n   {\n       return a [left_end];\n   }\n   if (left_end+1 > k)\n   {\n      return kth_smallest (____________________);\n   }\n   else\n   {\n      return kth_smallest (____________________);\n    }\n}\n",
        "complexity": {
            "time": "A binary search tree T contains n distinct elements. What is the time complexity of picking an element in T that is smaller than the maximum element in T?",
            "space": ""
        },
        "tags": [
            "Divide and Conquer"
        ],
        "url": "https://www.geeksforgeeks.org/quizzes/top-mcqs-on-divide-and-conquer-algrithm-with-answers/"
    },
    {
        "title": "Introduction to Divide and Conquer Algorithm",
        "description": "Divide and Conquer Algorithm is a problem-solving technique used to solve problems by dividing the main problem into subproblems, solving them individually and then merging them to find solution to the original problem. Divide and Conquer is mainly useful when we divide a problem into independent subproblems. If we have overlapping subproblems, then we use Dynamic Programming. In this article, we are going to discuss how Divide and Conquer Algorithm is helpful and how we can use it to solve problems. Divide and Conquer Algorithm can be divided into three steps: Divide, Conquer and Merge.  The above diagram shows working with the example of Merge Sort which is used for sorting In Merge Sort, we divide the input array in two halves. Please note that the divide step of Merge Sort  is simple, but in Quick Sort, the divide step is critical. In Quick Sort, we partition the array around a pivot. In Merge Sort, the conquer step is to sort the two halves individually. In Merge Sort, the merge step is to merge two sorted halves to create one sorted array. Please note that the merge step of Merge Sort is critical, but in Quick Sort, the merge step does not do anything as both parts become sorted in place and the left part has all elements smaller (or equal( than the right part. Divide and Conquer Algorithm involves breaking down a problem into smaller, more manageable parts, solving each part individually, and then combining the solutions to solve the original problem. The characteristics of Divide and Conquer Algorithm are: 1. Merge Sort: We can use Divide and Conquer Algorithm to sort the array in ascending or descending order by dividing the array into smaller subarrays, sorting the smaller subarrays and then merging the sorted arrays to sort the original array. Read more about Merge Sort 2. Quicksort: It is a sorting algorithm that picks a pivot element and rearranges the array elements so that all elements smaller than the picked pivot element move to the left side of the pivot, and all greater elements move to the right side. Finally, the algorithm recursively sorts the subarrays on the left and right of the pivot element. Read more about Quick Sort T(n) = aT(n/b) + f(n), where         n = size of input         a = number of subproblems in the recursion         n/b = size of each subproblem. All subproblems are assumed to have the same size.         f(n) = cost of the work done outside the recursive call, which includes the cost of dividing the problem and cost of merging the solutions The following are some standard algorithms that follow Divide and Conquer algorithm:   ",
        "code": "",
        "complexity": {
            "time": "",
            "space": ""
        },
        "tags": [
            "Divide and Conquer"
        ],
        "url": "https://www.geeksforgeeks.org/introduction-to-divide-and-conquer-algorithm/"
    },
    {
        "title": "Binary Search Algorithm – Iterative and Recursive Implementation",
        "description": "Binary Search Algorithm is a searching algorithm used in a sorted array by repeatedly dividing the search interval in half. The idea of binary search is to use the information that the array is sorted and reduce the time complexity to O(log N). Binary Search Algorithm To apply Binary Search algorithm: Below is the step-by-step algorithm for Binary Search: To understand the working of binary search, consider the following illustration: Consider an array arr[] = {2, 5, 8, 12, 16, 23, 38, 56, 72, 91}, and the target = 23.  The Binary Search Algorithm can be implemented in the following two ways Given below are the pseudocodes for the approaches. Here we use a while loop to continue the process of comparing the key and splitting the search space in two halves. Time Complexity: O(log N)Auxiliary Space: O(1) Create a recursive function and compare the mid of the search space with the key. And based on the result either return the index where the key is found or call the recursive function for the next search space. Please refer Time and Space Complexity Analysis of Binary Search for more details.  ",
        "code": "// C++ program to implement iterative Binary Search\n#include <bits/stdc++.h>\nusing namespace std;\n\n// An iterative binary search function.\nint binarySearch(int arr[], int low, int high, int x)\n{\n    while (low <= high) {\n        int mid = low + (high - low) / 2;\n\n        // Check if x is present at mid\n        if (arr[mid] == x)\n            return mid;\n\n        // If x greater, ignore left half\n        if (arr[mid] < x)\n            low = mid + 1;\n\n        // If x is smaller, ignore right half\n        else\n            high = mid - 1;\n    }\n\n    // If we reach here, then element was not present\n    return -1;\n}\n\n// Driver code\nint main(void)\n{\n    int arr[] = { 2, 3, 4, 10, 40 };\n    int x = 10;\n    int n = sizeof(arr) / sizeof(arr[0]);\n    int result = binarySearch(arr, 0, n - 1, x);\n    if(result == -1) cout << \"Element is not present in array\";\n    else cout << \"Element is present at index \" << result;\n    return 0;\n}\n// C program to implement iterative Binary Search\n#include <stdio.h>\n\n// An iterative binary search function.\nint binarySearch(int arr[], int low, int high, int x)\n{\n    while (low <= high) {\n        int mid = low + (high - low) / 2;\n\n        // Check if x is present at mid\n        if (arr[mid] == x)\n            return mid;\n\n        // If x greater, ignore left half\n        if (arr[mid] < x)\n            low = mid + 1;\n\n        // If x is smaller, ignore right half\n        else\n            high = mid - 1;\n    }\n\n    // If we reach here, then element was not present\n    return -1;\n}\n\n// Driver code\nint main(void)\n{\n    int arr[] = { 2, 3, 4, 10, 40 };\n    int n = sizeof(arr) / sizeof(arr[0]);\n    int x = 10;\n    int result = binarySearch(arr, 0, n - 1, x);\n   if(result == -1) printf(\"Element is not present in array\");\n   else printf(\"Element is present at index %d\",result);\n\n}\n// Java implementation of iterative Binary Search\n\nimport java.io.*;\n\nclass BinarySearch {\n  \n    // Returns index of x if it is present in arr[].\n    int binarySearch(int arr[], int x)\n    {\n        int low = 0, high = arr.length - 1;\n        while (low <= high) {\n            int mid = low + (high - low) / 2;\n\n            // Check if x is present at mid\n            if (arr[mid] == x)\n                return mid;\n\n            // If x greater, ignore left half\n            if (arr[mid] < x)\n                low = mid + 1;\n\n            // If x is smaller, ignore right half\n            else\n                high = mid - 1;\n        }\n\n        // If we reach here, then element was\n        // not present\n        return -1;\n    }\n\n    // Driver code\n    public static void main(String args[])\n    {\n        BinarySearch ob = new BinarySearch();\n        int arr[] = { 2, 3, 4, 10, 40 };\n        int n = arr.length;\n        int x = 10;\n        int result = ob.binarySearch(arr, x);\n        if (result == -1)\n            System.out.println(\n                \"Element is not present in array\");\n        else\n            System.out.println(\"Element is present at \"\n                               + \"index \" + result);\n    }\n}\n# Python3 code to implement iterative Binary\n# Search.\n\n\n# It returns location of x in given array arr\ndef binarySearch(arr, low, high, x):\n\n    while low <= high:\n\n        mid = low + (high - low) // 2\n\n        # Check if x is present at mid\n        if arr[mid] == x:\n            return mid\n\n        # If x is greater, ignore left half\n        elif arr[mid] < x:\n            low = mid + 1\n\n        # If x is smaller, ignore right half\n        else:\n            high = mid - 1\n\n    # If we reach here, then the element\n    # was not present\n    return -1\n\n\n# Driver Code\nif __name__ == '__main__':\n    arr = [2, 3, 4, 10, 40]\n    x = 10\n\n    # Function call\n    result = binarySearch(arr, 0, len(arr)-1, x)\n    if result != -1:\n        print(\"Element is present at index\", result)\n    else:\n        print(\"Element is not present in array\")\n// C# implementation of iterative Binary Search\nusing System;\n\nclass GFG {\n    \n    // Returns index of x if it is present in arr[]\n    static int binarySearch(int[] arr, int x)\n    {\n        int low = 0, high = arr.Length - 1;\n        while (low <= high) {\n            int mid = low + (high - low) / 2;\n\n            // Check if x is present at mid\n            if (arr[mid] == x)\n                return mid;\n\n            // If x greater, ignore left half\n            if (arr[mid] < x)\n                low = mid + 1;\n\n            // If x is smaller, ignore right half\n            else\n                high = mid - 1;\n        }\n\n        // If we reach here, then element was\n        // not present\n        return -1;\n    }\n\n    // Driver code\n    public static void Main()\n    {\n        int[] arr = { 2, 3, 4, 10, 40 };\n        int n = arr.Length;\n        int x = 10;\n        int result = binarySearch(arr, x);\n        if (result == -1)\n            Console.WriteLine(\n                \"Element is not present in array\");\n        else\n            Console.WriteLine(\"Element is present at \"\n                              + \"index \" + result);\n    }\n}\n// Program to implement iterative Binary Search\n\n// A iterative binary search function. It returns\n// location of x in given array arr[l..r] is present,\n// otherwise -1\n\nfunction binarySearch(arr, x)\n{\n    let low = 0;\n    let high = arr.length - 1;\n    let mid;\n    while (high >= low) {\n        mid = low + Math.floor((high - low) / 2);\n\n        // If the element is present at the middle\n        // itself\n        if (arr[mid] == x)\n            return mid;\n\n        // If element is smaller than mid, then\n        // it can only be present in left subarray\n        if (arr[mid] > x)\n            high = mid - 1;\n\n        // Else the element can only be present\n        // in right subarray\n        else\n            low = mid + 1;\n    }\n\n    // We reach here when element is not\n    // present in array\n    return -1;\n}\n\narr = new Array(2, 3, 4, 10, 40);\nx = 10;\nn = arr.length;\nresult = binarySearch(arr, x);\nif (result == -1)\n    console.log(\"Element is not present in array\")\n    else\n    {\n        console.log(\"Element is present at index \"\n                    + result);\n    }\n<?php\n// PHP program to implement\n// iterative Binary Search\n\n// An iterative binary search \n// function\nfunction binarySearch($arr, $low, \n                      $high, $x)\n{\n    while ($low <= $high)\n    {\n        $mid = $low + ($high - $low) / 2;\n\n        // Check if x is present at mid\n        if ($arr[$mid] == $x)\n            return floor($mid);\n\n        // If x greater, ignore\n        // left half\n        if ($arr[$mid] < $x)\n            $low = $mid + 1;\n\n        // If x is smaller, \n        // ignore right half\n        else\n            $high = $mid - 1;\n    }\n\n    // If we reach here, then \n    // element was not present\n    return -1;\n}\n\n// Driver Code\n$arr = array(2, 3, 4, 10, 40);\n$n = count($arr);\n$x = 10;\n$result = binarySearch($arr, 0, \n                       $n - 1, $x);\nif(($result == -1))\necho \"Element is not present in array\";\nelse\necho \"Element is present at index \", \n                            $result;\n\n?>\nElement is present at index 3\n#include <bits/stdc++.h>\nusing namespace std;\n\n// A recursive binary search function. It returns\n// location of x in given array arr[low..high] is present,\n// otherwise -1\nint binarySearch(int arr[], int low, int high, int x)\n{\n    if (high >= low) {\n        int mid = low + (high - low) / 2;\n\n        // If the element is present at the middle\n        // itself\n        if (arr[mid] == x)\n            return mid;\n\n        // If element is smaller than mid, then\n        // it can only be present in left subarray\n        if (arr[mid] > x)\n            return binarySearch(arr, low, mid - 1, x);\n\n        // Else the element can only be present\n        // in right subarray\n        return binarySearch(arr, mid + 1, high, x);\n    }\n  return -1;\n}\n\n// Driver code\nint main()\n{\n    int arr[] = { 2, 3, 4, 10, 40 };\n    int query = 90;\n    int n = sizeof(arr) / sizeof(arr[0]);\n    int result = binarySearch(arr, 0, n - 1, query);\n    if (result == -1) cout << \"Element is not present in array\";\n    else cout << \"Element is present at index \" << result;\n    return 0;\n}\n// C program to implement recursive Binary Search\n#include <stdio.h>\n\n// A recursive binary search function. It returns\n// location of x in given array arr[low..high] is present,\n// otherwise -1\nint binarySearch(int arr[], int low, int high, int x)\n{\n    if (high >= low) {\n        int mid = low + (high - low) / 2;\n\n        // If the element is present at the middle\n        // itself\n        if (arr[mid] == x)\n            return mid;\n\n        // If element is smaller than mid, then\n        // it can only be present in left subarray\n        if (arr[mid] > x)\n            return binarySearch(arr, low, mid - 1, x);\n\n        // Else the element can only be present\n        // in right subarray\n        return binarySearch(arr, mid + 1, high, x);\n    }\n\n    // We reach here when element is not\n    // present in array\n    return -1;\n}\n\n// Driver code\nint main()\n{\n    int arr[] = { 2, 3, 4, 10, 40 };\n    int n = sizeof(arr) / sizeof(arr[0]);\n    int x = 10;\n    int result = binarySearch(arr, 0, n - 1, x);\n    if (result == -1) printf(\"Element is not present in array\");\n    else printf(\"Element is present at index %d\", result);\n    return 0;\n}\n// Java implementation of recursive Binary Search\nclass BinarySearch {\n\n    // Returns index of x if it is present in arr[low..\n    // high], else return -1\n    int binarySearch(int arr[], int low, int high, int x)\n    {\n        if (high >= low) {\n            int mid = low + (high - low) / 2;\n\n            // If the element is present at the\n            // middle itself\n            if (arr[mid] == x)\n                return mid;\n\n            // If element is smaller than mid, then\n            // it can only be present in left subarray\n            if (arr[mid] > x)\n                return binarySearch(arr, low, mid - 1, x);\n\n            // Else the element can only be present\n            // in right subarray\n            return binarySearch(arr, mid + 1, high, x);\n        }\n\n        // We reach here when element is not present\n        // in array\n        return -1;\n    }\n\n    // Driver code\n    public static void main(String args[])\n    {\n        BinarySearch ob = new BinarySearch();\n        int arr[] = { 2, 3, 4, 10, 40 };\n        int n = arr.length;\n        int x = 10;\n        int result = ob.binarySearch(arr, 0, n - 1, x);\n        if (result == -1)\n            System.out.println(\n                \"Element is not present in array\");\n        else\n            System.out.println(\n                \"Element is present at index \" + result);\n    }\n}\n# Python3 Program for recursive binary search.\n\n\n# Returns index of x in arr if present, else -1\ndef binarySearch(arr, low, high, x):\n\n    # Check base case\n    if high >= low:\n\n        mid = low + (high - low) // 2\n\n        # If element is present at the middle itself\n        if arr[mid] == x:\n            return mid\n\n        # If element is smaller than mid, then it\n        # can only be present in left subarray\n        elif arr[mid] > x:\n            return binarySearch(arr, low, mid-1, x)\n\n        # Else the element can only be present\n        # in right subarray\n        else:\n            return binarySearch(arr, mid + 1, high, x)\n\n    # Element is not present in the array\n    else:\n        return -1\n\n\n# Driver Code\nif __name__ == '__main__':\n    arr = [2, 3, 4, 10, 40]\n    x = 10\n    \n    # Function call\n    result = binarySearch(arr, 0, len(arr)-1, x)\n    \n    if result != -1:\n        print(\"Element is present at index\", result)\n    else:\n        print(\"Element is not present in array\")\n// C# implementation of recursive Binary Search\nusing System;\n\nclass GFG {\n\n    // Returns index of x if it is present in\n    // arr[low..high], else return -1\n    static int binarySearch(int[] arr, int low, int high, int x)\n    {\n        if (high >= low) {\n            int mid = low + (high - low) / 2;\n\n            // If the element is present at the\n            // middle itself\n            if (arr[mid] == x)\n                return mid;\n\n            // If element is smaller than mid, then\n            // it can only be present in left subarray\n            if (arr[mid] > x)\n                return binarySearch(arr, low, mid - 1, x);\n\n            // Else the element can only be present\n            // in right subarray\n            return binarySearch(arr, mid + 1, high, x);\n        }\n\n        // We reach here when element is not present\n        // in array\n        return -1;\n    }\n\n    // Driver code\n    public static void Main()\n    {\n\n        int[] arr = { 2, 3, 4, 10, 40 };\n        int n = arr.Length;\n        int x = 10;\n\n        int result = binarySearch(arr, 0, n - 1, x);\n\n        if (result == -1)\n            Console.WriteLine(\n                \"Element is not present in arrau\");\n        else\n            Console.WriteLine(\"Element is present at index \"\n                              + result);\n    }\n}\n// JavaScript program to implement recursive Binary Search\n\n// A recursive binary search function. It returns\n// location of x in given array arr[low..high] is present,\n// otherwise -1\nfunction binarySearch(arr, low, high, x)\n{\n    if (high >= low) {\n        let mid = low + Math.floor((high - low) / 2);\n\n        // If the element is present at the middle\n        // itself\n        if (arr[mid] == x)\n            return mid;\n\n        // If element is smaller than mid, then\n        // it can only be present in left subarray\n        if (arr[mid] > x)\n            return binarySearch(arr, low, mid - 1, x);\n\n        // Else the element can only be present\n        // in right subarray\n        return binarySearch(arr, mid + 1, high, x);\n    }\n\n    // We reach here when element is not\n    // present in array\n    return -1;\n}\n\nlet arr = [ 2, 3, 4, 10, 40 ];\nlet x = 10;\nlet n = arr.length\nlet result = binarySearch(arr, 0, n - 1, x);\nif (result == -1)\n    console.log(\"Element is not present in array\");\nelse\n    console.log(\"Element is present at index \" + result);\n<?php\n// PHP program to implement\n// recursive Binary Search\n\n// A recursive binary search\n// function. It returns location\n// of x in given array arr[low..high] \n// is present, otherwise -1\nfunction binarySearch($arr, $low, $high, $x)\n{\nif ($high >= $low)\n{\n        $mid = ceil($low + ($high - $low) / 2);\n\n        // If the element is present \n        // at the middle itself\n        if ($arr[$mid] == $x) \n            return floor($mid);\n\n        // If element is smaller than \n        // mid, then it can only be \n        // present in left subarray\n        if ($arr[$mid] > $x) \n            return binarySearch($arr, $low, \n                                $mid - 1, $x);\n\n        // Else the element can only \n        // be present in right subarray\n        return binarySearch($arr, $mid + 1, \n                            $high, $x);\n}\n\n// We reach here when element \n// is not present in array\nreturn -1;\n}\n\n// Driver Code\n$arr = array(2, 3, 4, 10, 40);\n$n = count($arr);\n$x = 10;\n$result = binarySearch($arr, 0, $n - 1, $x);\nif(($result == -1))\necho \"Element is not present in array\";\nelse\necho \"Element is present at index \",\n                            $result;\n                          \n?>\nElement is present at index 3\n",
        "complexity": {
            "time": "Time Complexity: O(log N)Auxiliary Space: O(1)",
            "space": "Please refer Time and Space Complexity Analysis of Binary Search for more details."
        },
        "tags": [
            "Divide and Conquer"
        ],
        "url": "https://www.geeksforgeeks.org/binary-search/"
    },
    {
        "title": "Merge Sort – Data Structure and Algorithms Tutorials",
        "description": "Merge sort  is a sorting algorithm that follows the  divide-and-conquer  approach. It works by recursively dividing the input array into smaller subarrays and sorting those subarrays then merging them back together to obtain the sorted array. In simple terms, we can say that the process of  merge sort  is to divide the array into two halves, sort each half, and then merge the sorted halves back together. This process is repeated until the entire array is sorted. Merge Sort Algorithm Table of Content Merge sort is a popular sorting algorithm known for its efficiency and stability. It follows the  divide-and-conquer  approach to sort a given array of elements. Here’s a step-by-step explanation of how merge sort works: Let’s sort the array or list  [38, 27, 43, 10]  using Merge Sort Let’s look at the working of above example: Divide: Conquer: Merge: Therefore, the sorted list is  [10, 27, 38, 43]  . The recurrence relation of merge sort is:[Tex]T(n) = \\begin{cases} \\Theta(1) & \\text{if } n = 1 \\\\ 2T\\left(\\frac{n}{2}\\right) + \\Theta(n) & \\text{if } n > 1 \\end{cases}[/Tex] Advantages Disadvantages Quick Links:  ",
        "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n// Merges two subarrays of arr[].\n// First subarray is arr[left..mid]\n// Second subarray is arr[mid+1..right]\nvoid merge(vector<int>& arr, int left, \n                     int mid, int right)\n{\n    int n1 = mid - left + 1;\n    int n2 = right - mid;\n\n    // Create temp vectors\n    vector<int> L(n1), R(n2);\n\n    // Copy data to temp vectors L[] and R[]\n    for (int i = 0; i < n1; i++)\n        L[i] = arr[left + i];\n    for (int j = 0; j < n2; j++)\n        R[j] = arr[mid + 1 + j];\n\n    int i = 0, j = 0;\n    int k = left;\n\n    // Merge the temp vectors back \n    // into arr[left..right]\n    while (i < n1 && j < n2) {\n        if (L[i] <= R[j]) {\n            arr[k] = L[i];\n            i++;\n        }\n        else {\n            arr[k] = R[j];\n            j++;\n        }\n        k++;\n    }\n\n    // Copy the remaining elements of L[], \n    // if there are any\n    while (i < n1) {\n        arr[k] = L[i];\n        i++;\n        k++;\n    }\n\n    // Copy the remaining elements of R[], \n    // if there are any\n    while (j < n2) {\n        arr[k] = R[j];\n        j++;\n        k++;\n    }\n}\n\n// begin is for left index and end is right index\n// of the sub-array of arr to be sorted\nvoid mergeSort(vector<int>& arr, int left, int right)\n{\n    if (left >= right)\n        return;\n\n    int mid = left + (right - left) / 2;\n    mergeSort(arr, left, mid);\n    mergeSort(arr, mid + 1, right);\n    merge(arr, left, mid, right);\n}\n\n// Function to print a vector\nvoid printVector(vector<int>& arr)\n{\n    for (int i = 0; i < arr.size(); i++)\n        cout << arr[i] << \" \";\n    cout << endl;\n}\n\n// Driver code\nint main()\n{\n    vector<int> arr = { 12, 11, 13, 5, 6, 7 };\n    int n = arr.size();\n\n    cout << \"Given vector is \\n\";\n    printVector(arr);\n\n    mergeSort(arr, 0, n - 1);\n\n    cout << \"\\nSorted vector is \\n\";\n    printVector(arr);\n    return 0;\n}\n// C program for Merge Sort\n#include <stdio.h>\n#include <stdlib.h>\n\n// Merges two subarrays of arr[].\n// First subarray is arr[l..m]\n// Second subarray is arr[m+1..r]\nvoid merge(int arr[], int l, int m, int r)\n{\n    int i, j, k;\n    int n1 = m - l + 1;\n    int n2 = r - m;\n\n    // Create temp arrays\n    int L[n1], R[n2];\n\n    // Copy data to temp arrays L[] and R[]\n    for (i = 0; i < n1; i++)\n        L[i] = arr[l + i];\n    for (j = 0; j < n2; j++)\n        R[j] = arr[m + 1 + j];\n\n    // Merge the temp arrays back into arr[l..r\n    i = 0;\n    j = 0;\n    k = l;\n    while (i < n1 && j < n2) {\n        if (L[i] <= R[j]) {\n            arr[k] = L[i];\n            i++;\n        }\n        else {\n            arr[k] = R[j];\n            j++;\n        }\n        k++;\n    }\n\n    // Copy the remaining elements of L[],\n    // if there are any\n    while (i < n1) {\n        arr[k] = L[i];\n        i++;\n        k++;\n    }\n\n    // Copy the remaining elements of R[],\n    // if there are any\n    while (j < n2) {\n        arr[k] = R[j];\n        j++;\n        k++;\n    }\n}\n\n// l is for left index and r is right index of the\n// sub-array of arr to be sorted\nvoid mergeSort(int arr[], int l, int r)\n{\n    if (l < r) {\n        int m = l + (r - l) / 2;\n\n        // Sort first and second halves\n        mergeSort(arr, l, m);\n        mergeSort(arr, m + 1, r);\n\n        merge(arr, l, m, r);\n    }\n}\n\n// Function to print an array\nvoid printArray(int A[], int size)\n{\n    int i;\n    for (i = 0; i < size; i++)\n        printf(\"%d \", A[i]);\n    printf(\"\\n\");\n}\n\n// Driver code\nint main()\n{\n    int arr[] = { 12, 11, 13, 5, 6, 7 };\n    int arr_size = sizeof(arr) / sizeof(arr[0]);\n\n    printf(\"Given array is \\n\");\n    printArray(arr, arr_size);\n\n    mergeSort(arr, 0, arr_size - 1);\n\n    printf(\"\\nSorted array is \\n\");\n    printArray(arr, arr_size);\n    return 0;\n}\n// Java program for Merge Sort\nimport java.io.*;\n\nclass GfG {\n\n    // Merges two subarrays of arr[].\n    // First subarray is arr[l..m]\n    // Second subarray is arr[m+1..r]\n    static void merge(int arr[], int l, int m, int r)\n    {\n        // Find sizes of two subarrays to be merged\n        int n1 = m - l + 1;\n        int n2 = r - m;\n\n        // Create temp arrays\n        int L[] = new int[n1];\n        int R[] = new int[n2];\n\n        // Copy data to temp arrays\n        for (int i = 0; i < n1; ++i)\n            L[i] = arr[l + i];\n        for (int j = 0; j < n2; ++j)\n            R[j] = arr[m + 1 + j];\n\n        // Merge the temp arrays\n\n        // Initial indices of first and second subarrays\n        int i = 0, j = 0;\n\n        // Initial index of merged subarray array\n        int k = l;\n        while (i < n1 && j < n2) {\n            if (L[i] <= R[j]) {\n                arr[k] = L[i];\n                i++;\n            }\n            else {\n                arr[k] = R[j];\n                j++;\n            }\n            k++;\n        }\n\n        // Copy remaining elements of L[] if any\n        while (i < n1) {\n            arr[k] = L[i];\n            i++;\n            k++;\n        }\n\n        // Copy remaining elements of R[] if any\n        while (j < n2) {\n            arr[k] = R[j];\n            j++;\n            k++;\n        }\n    }\n\n    // Main function that sorts arr[l..r] using\n    // merge()\n    static void sort(int arr[], int l, int r)\n    {\n        if (l < r) {\n\n            // Find the middle point\n            int m = l + (r - l) / 2;\n\n            // Sort first and second halves\n            sort(arr, l, m);\n            sort(arr, m + 1, r);\n\n            // Merge the sorted halves\n            merge(arr, l, m, r);\n        }\n    }\n\n    // A utility function to print array of size n\n    static void printArray(int arr[])\n    {\n        int n = arr.length;\n        for (int i = 0; i < n; ++i)\n            System.out.print(arr[i] + \" \");\n        System.out.println();\n    }\n\n    // Driver code\n    public static void main(String args[])\n    {\n        int arr[] = { 12, 11, 13, 5, 6, 7 };\n\n        System.out.println(\"Given array is\");\n        printArray(arr);\n\n        sort(arr, 0, arr.length - 1);\n\n        System.out.println(\"\\nSorted array is\");\n        printArray(arr);\n    }\n}\ndef merge(arr, left, mid, right):\n    n1 = mid - left + 1\n    n2 = right - mid\n\n    # Create temp arrays\n    L = [0] * n1\n    R = [0] * n2\n\n    # Copy data to temp arrays L[] and R[]\n    for i in range(n1):\n        L[i] = arr[left + i]\n    for j in range(n2):\n        R[j] = arr[mid + 1 + j]\n\n    i = 0  # Initial index of first subarray\n    j = 0  # Initial index of second subarray\n    k = left  # Initial index of merged subarray\n\n    # Merge the temp arrays back\n    # into arr[left..right]\n    while i < n1 and j < n2:\n        if L[i] <= R[j]:\n            arr[k] = L[i]\n            i += 1\n        else:\n            arr[k] = R[j]\n            j += 1\n        k += 1\n\n    # Copy the remaining elements of L[],\n    # if there are any\n    while i < n1:\n        arr[k] = L[i]\n        i += 1\n        k += 1\n\n    # Copy the remaining elements of R[], \n    # if there are any\n    while j < n2:\n        arr[k] = R[j]\n        j += 1\n        k += 1\n\ndef merge_sort(arr, left, right):\n    if left < right:\n        mid = (left + right) // 2\n\n        merge_sort(arr, left, mid)\n        merge_sort(arr, mid + 1, right)\n        merge(arr, left, mid, right)\n\ndef print_list(arr):\n    for i in arr:\n        print(i, end=\" \")\n    print()\n\n# Driver code\nif __name__ == \"__main__\":\n    arr = [12, 11, 13, 5, 6, 7]\n    print(\"Given array is\")\n    print_list(arr)\n\n    merge_sort(arr, 0, len(arr) - 1)\n\n    print(\"\\nSorted array is\")\n    print_list(arr)\n// C# program for Merge Sort\nusing System;\n\nclass GfG {\n\n    // Merges two subarrays of []arr.\n    // First subarray is arr[l..m]\n    // Second subarray is arr[m+1..r]\n    static void merge(int[] arr, int l, int m, int r)\n    {\n        // Find sizes of two\n        // subarrays to be merged\n        int n1 = m - l + 1;\n        int n2 = r - m;\n\n        // Create temp arrays\n        int[] L = new int[n1];\n        int[] R = new int[n2];\n        int i, j;\n\n        // Copy data to temp arrays\n        for (i = 0; i < n1; ++i)\n            L[i] = arr[l + i];\n        for (j = 0; j < n2; ++j)\n            R[j] = arr[m + 1 + j];\n\n        // Merge the temp arrays\n\n        // Initial indexes of first\n        // and second subarrays\n        i = 0;\n        j = 0;\n\n        // Initial index of merged\n        // subarray array\n        int k = l;\n        while (i < n1 && j < n2) {\n            if (L[i] <= R[j]) {\n                arr[k] = L[i];\n                i++;\n            }\n            else {\n                arr[k] = R[j];\n                j++;\n            }\n            k++;\n        }\n\n        // Copy remaining elements\n        // of L[] if any\n        while (i < n1) {\n            arr[k] = L[i];\n            i++;\n            k++;\n        }\n\n        // Copy remaining elements\n        // of R[] if any\n        while (j < n2) {\n            arr[k] = R[j];\n            j++;\n            k++;\n        }\n    }\n\n    // Main function that\n    // sorts arr[l..r] using\n    // merge()\n    static void mergeSort(int[] arr, int l, int r)\n    {\n        if (l < r) {\n\n            // Find the middle point\n            int m = l + (r - l) / 2;\n\n            // Sort first and second halves\n            mergeSort(arr, l, m);\n            mergeSort(arr, m + 1, r);\n\n            // Merge the sorted halves\n            merge(arr, l, m, r);\n        }\n    }\n\n    // A utility function to\n    // print array of size n\n    static void printArray(int[] arr)\n    {\n        int n = arr.Length;\n        for (int i = 0; i < n; ++i)\n            Console.Write(arr[i] + \" \");\n        Console.WriteLine();\n    }\n\n    // Driver code\n    public static void Main(String[] args)\n    {\n        int[] arr = { 12, 11, 13, 5, 6, 7 };\n        Console.WriteLine(\"Given array is\");\n        printArray(arr);\n        mergeSort(arr, 0, arr.Length - 1);\n        Console.WriteLine(\"\\nSorted array is\");\n        printArray(arr);\n    }\n}\nfunction merge(arr, left, mid, right) {\n    const n1 = mid - left + 1;\n    const n2 = right - mid;\n\n    // Create temp arrays\n    const L = new Array(n1);\n    const R = new Array(n2);\n\n    // Copy data to temp arrays L[] and R[]\n    for (let i = 0; i < n1; i++)\n        L[i] = arr[left + i];\n    for (let j = 0; j < n2; j++)\n        R[j] = arr[mid + 1 + j];\n\n    let i = 0, j = 0;\n    let k = left;\n\n    // Merge the temp arrays back into arr[left..right]\n    while (i < n1 && j < n2) {\n        if (L[i] <= R[j]) {\n            arr[k] = L[i];\n            i++;\n        } else {\n            arr[k] = R[j];\n            j++;\n        }\n        k++;\n    }\n\n    // Copy the remaining elements of L[], if there are any\n    while (i < n1) {\n        arr[k] = L[i];\n        i++;\n        k++;\n    }\n\n    // Copy the remaining elements of R[], if there are any\n    while (j < n2) {\n        arr[k] = R[j];\n        j++;\n        k++;\n    }\n}\n\nfunction mergeSort(arr, left, right) {\n    if (left >= right)\n        return;\n\n    const mid = Math.floor(left + (right - left) / 2);\n    mergeSort(arr, left, mid);\n    mergeSort(arr, mid + 1, right);\n    merge(arr, left, mid, right);\n}\n\nfunction printArray(arr) {\n    console.log(arr.join(\" \"));\n}\n\n// Driver code\nconst arr = [12, 11, 13, 5, 6, 7];\nconsole.log(\"Given array is\");\nprintArray(arr);\n\nmergeSort(arr, 0, arr.length - 1);\n\nconsole.log(\"\\nSorted array is\");\nprintArray(arr);\n<?php\n/* PHP recursive program for Merge Sort */\n\n// Merges two subarrays of arr[].\n// First subarray is arr[l..m]\n// Second subarray is arr[m+1..r]\nfunction merge(&$arr, $l, $m, $r)\n{\n    $n1 = $m - $l + 1;\n    $n2 = $r - $m;\n\n    // Create temp arrays\n    $L = array();\n    $R = array();\n  \n    // Copy data to temp arrays L[] and R[]\n    for ($i = 0; $i < $n1; $i++)\n        $L[$i] = $arr[$l + $i];\n    for ($j = 0; $j < $n2; $j++)\n        $R[$j] = $arr[$m + 1 + $j];\n\n    // Merge the temp arrays back into arr[l..r]\n    $i = 0;\n    $j = 0;\n    $k = $l;\n    while ($i < $n1 && $j < $n2) {\n        if ($L[$i] <= $R[$j]) {\n            $arr[$k] = $L[$i];\n            $i++;\n        }\n        else {\n            $arr[$k] = $R[$j];\n            $j++;\n        }\n        $k++;\n    }\n\n    // Copy the remaining elements of L[], \n    // if there are any\n    while ($i < $n1) {\n        $arr[$k] = $L[$i];\n        $i++;\n        $k++;\n    }\n\n    // Copy the remaining elements of R[], \n    // if there are any\n    while ($j < $n2) {\n        $arr[$k] = $R[$j];\n        $j++;\n        $k++;\n    }\n}\n\n// l is for left index and r is right index of the\n// sub-array of arr to be sorted\nfunction mergeSort(&$arr, $l, $r)\n{\n    if ($l < $r) {\n        $m = $l + (int)(($r - $l) / 2);\n\n        // Sort first and second halves\n        mergeSort($arr, $l, $m);\n        mergeSort($arr, $m + 1, $r);\n\n        merge($arr, $l, $m, $r);\n    }\n}\n\n// Function to print an array\nfunction printArray($A, $size)\n{\n    for ($i = 0; $i < $size; $i++)\n        echo $A[$i].\" \";\n    echo \"\\n\";\n}\n\n// Driver code\n$arr = array(12, 11, 13, 5, 6, 7);\n$arr_size = sizeof($arr);\n\necho \"Given array is \\n\";\nprintArray($arr, $arr_size);\n\nmergeSort($arr, 0, $arr_size - 1);\n\necho \"\\nSorted array is \\n\";\nprintArray($arr, $arr_size);\nreturn 0;\n\n//This code is contributed by Susobhan Akhuli\n?>\nGiven array is \n12 11 13 5 6 7 \n\nSorted array is \n5 6 7 11 12 13\n",
        "complexity": {
            "time": "",
            "space": ""
        },
        "tags": [
            "Divide and Conquer"
        ],
        "url": "https://www.geeksforgeeks.org/merge-sort/"
    },
    {
        "title": "Quick Sort",
        "description": "QuickSort is a sorting algorithm based on the Divide and Conquer that picks an element as a pivot and partitions the given array around the picked pivot by placing the pivot in its correct position in the sorted array. It works on the principle of divide and conquer, breaking down the problem into smaller sub-problems. There are mainly three steps in the algorithm: Here’s a basic overview of how the QuickSort algorithm works. There are many different choices for picking pivots. The key process in quickSort is a partition(). There are three common algorithms to partition. All these algorithms have O(n) time complexity. The logic is simple, we start from the leftmost element and keep track of the index of smaller (or equal) elements as i . While traversing, if we find a smaller element, we swap the current element with arr[i]. Otherwise, we ignore the current element. Let us understand the working of partition algorithm with the help of the following example:  In the previous step, we looked at how the partitioning process rearranges the array based on the chosen pivot. Next, we apply the same method recursively to the smaller sub-arrays on the left and right of the pivot. Each time, we select new pivots and partition the arrays again. This process continues until only one element is left, which is always sorted. Once every element is in its correct position, the entire array is sorted. Below image illustrates, how the recursive method calls for the smaller sub-arrays on the left and right of the pivot: Quick Sort  is a crucial algorithm in the industry, but there are other sorting algorithms that may be more optimal in different cases. Time Complexity: Auxiliary Space: O(n), due to recursive call stack Please refer Time and Space Complexity Analysis of Quick Sort for more details. Please refer Application of Quicksort for more details.  ",
        "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint partition(vector<int>& arr, int low, int high) {\n  \n    // Choose the pivot\n    int pivot = arr[high];\n  \n    // Index of smaller element and indicates \n    // the right position of pivot found so far\n    int i = low - 1;\n\n    // Traverse arr[low..high] and move all smaller\n    // elements on left side. Elements from low to \n    // i are smaller after every iteration\n    for (int j = low; j <= high - 1; j++) {\n        if (arr[j] < pivot) {\n            i++;\n            swap(arr[i], arr[j]);\n        }\n    }\n    \n    // Move pivot after smaller elements and\n    // return its position\n    swap(arr[i + 1], arr[high]);  \n    return i + 1;\n}\n\n// The QuickSort function implementation\nvoid quickSort(vector<int>& arr, int low, int high) {\n  \n    if (low < high) {\n      \n        // pi is the partition return index of pivot\n        int pi = partition(arr, low, high);\n\n        // Recursion calls for smaller elements\n        // and greater or equals elements\n        quickSort(arr, low, pi - 1);\n        quickSort(arr, pi + 1, high);\n    }\n}\n\nint main() {\n    vector<int> arr = {10, 7, 8, 9, 1, 5};\n    int n = arr.size();\n    quickSort(arr, 0, n - 1);\n  \n    for (int i = 0; i < n; i++) {\n        cout << arr[i] << \" \";\n    }\n    return 0;\n}\n#include <stdio.h>\n\nvoid swap(int* a, int* b);\n\n// Partition function\nint partition(int arr[], int low, int high) {\n    \n    // Choose the pivot\n    int pivot = arr[high];\n    \n    // Index of smaller element and indicates \n    // the right position of pivot found so far\n    int i = low - 1;\n\n    // Traverse arr[low..high] and move all smaller\n    // elements to the left side. Elements from low to \n    // i are smaller after every iteration\n    for (int j = low; j <= high - 1; j++) {\n        if (arr[j] < pivot) {\n            i++;\n            swap(&arr[i], &arr[j]);\n        }\n    }\n    \n    // Move pivot after smaller elements and\n    // return its position\n    swap(&arr[i + 1], &arr[high]);  \n    return i + 1;\n}\n\n// The QuickSort function implementation\nvoid quickSort(int arr[], int low, int high) {\n    if (low < high) {\n        \n        // pi is the partition return index of pivot\n        int pi = partition(arr, low, high);\n\n        // Recursion calls for smaller elements\n        // and greater or equals elements\n        quickSort(arr, low, pi - 1);\n        quickSort(arr, pi + 1, high);\n    }\n}\n\nvoid swap(int* a, int* b) {\n    int t = *a;\n    *a = *b;\n    *b = t;\n}\n\nint main() {\n    int arr[] = {10, 7, 8, 9, 1, 5};\n    int n = sizeof(arr) / sizeof(arr[0]);\n\n    quickSort(arr, 0, n - 1);\n    for (int i = 0; i < n; i++) {\n        printf(\"%d \", arr[i]);\n    }\n    \n    return 0;\n}\nimport java.util.Arrays;\n\nclass GfG {\n\n    // Partition function\n    static int partition(int[] arr, int low, int high) {\n        \n        // Choose the pivot\n        int pivot = arr[high];\n        \n        // Index of smaller element and indicates \n        // the right position of pivot found so far\n        int i = low - 1;\n\n        // Traverse arr[low..high] and move all smaller\n        // elements to the left side. Elements from low to \n        // i are smaller after every iteration\n        for (int j = low; j <= high - 1; j++) {\n            if (arr[j] < pivot) {\n                i++;\n                swap(arr, i, j);\n            }\n        }\n        \n        // Move pivot after smaller elements and\n        // return its position\n        swap(arr, i + 1, high);  \n        return i + 1;\n    }\n\n    // Swap function\n    static void swap(int[] arr, int i, int j) {\n        int temp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = temp;\n    }\n\n    // The QuickSort function implementation\n    static void quickSort(int[] arr, int low, int high) {\n        if (low < high) {\n            \n            // pi is the partition return index of pivot\n            int pi = partition(arr, low, high);\n\n            // Recursion calls for smaller elements\n            // and greater or equals elements\n            quickSort(arr, low, pi - 1);\n            quickSort(arr, pi + 1, high);\n        }\n    }\n\n    public static void main(String[] args) {\n        int[] arr = {10, 7, 8, 9, 1, 5};\n        int n = arr.length;\n      \n        quickSort(arr, 0, n - 1);\n        \n        for (int val : arr) {\n            System.out.print(val + \" \");  \n        }\n    }\n}\n# Partition function\ndef partition(arr, low, high):\n    \n    # Choose the pivot\n    pivot = arr[high]\n    \n    # Index of smaller element and indicates \n    # the right position of pivot found so far\n    i = low - 1\n    \n    # Traverse arr[low..high] and move all smaller\n    # elements to the left side. Elements from low to \n    # i are smaller after every iteration\n    for j in range(low, high):\n        if arr[j] < pivot:\n            i += 1\n            swap(arr, i, j)\n    \n    # Move pivot after smaller elements and\n    # return its position\n    swap(arr, i + 1, high)\n    return i + 1\n\n# Swap function\ndef swap(arr, i, j):\n    arr[i], arr[j] = arr[j], arr[i]\n\n# The QuickSort function implementation\ndef quickSort(arr, low, high):\n    if low < high:\n        \n        # pi is the partition return index of pivot\n        pi = partition(arr, low, high)\n        \n        # Recursion calls for smaller elements\n        # and greater or equals elements\n        quickSort(arr, low, pi - 1)\n        quickSort(arr, pi + 1, high)\n\n# Main driver code\nif __name__ == \"__main__\":\n    arr = [10, 7, 8, 9, 1, 5]\n    n = len(arr)\n\n    quickSort(arr, 0, n - 1)\n    \n    for val in arr:\n        print(val, end=\" \")\nusing System;\n\nclass GfG {\n\n    // Partition function\n    static int Partition(int[] arr, int low, int high) {\n        \n        // Choose the pivot\n        int pivot = arr[high];\n        \n        // Index of smaller element and indicates \n        // the right position of pivot found so far\n        int i = low - 1;\n\n        // Traverse arr[low..high] and move all smaller\n        // elements to the left side. Elements from low to \n        // i are smaller after every iteration\n        for (int j = low; j <= high - 1; j++) {\n            if (arr[j] < pivot) {\n                i++;\n                Swap(arr, i, j);\n            }\n        }\n        \n        // Move pivot after smaller elements and\n        // return its position\n        Swap(arr, i + 1, high);  \n        return i + 1;\n    }\n\n    // Swap function\n    static void Swap(int[] arr, int i, int j) {\n        int temp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = temp;\n    }\n\n    // The QuickSort function implementation\n    static void QuickSort(int[] arr, int low, int high) {\n        if (low < high) {\n            \n            // pi is the partition return index of pivot\n            int pi = Partition(arr, low, high);\n\n            // Recursion calls for smaller elements\n            // and greater or equals elements\n            QuickSort(arr, low, pi - 1);\n            QuickSort(arr, pi + 1, high);\n        }\n    }\n\n    static void Main(string[] args) {\n        int[] arr = {10, 7, 8, 9, 1, 5};\n        int n = arr.Length;\n\n        QuickSort(arr, 0, n - 1);\n        foreach (int val in arr) {\n            Console.Write(val + \" \"); \n        }\n    }\n}\n// Partition function\nfunction partition(arr, low, high)\n{\n\n    // Choose the pivot\n    let pivot = arr[high];\n\n    // Index of smaller element and indicates\n    // the right position of pivot found so far\n    let i = low - 1;\n\n    // Traverse arr[low..high] and move all smaller\n    // elements to the left side. Elements from low to\n    // i are smaller after every iteration\n    for (let j = low; j <= high - 1; j++) {\n        if (arr[j] < pivot) {\n            i++;\n            swap(arr, i, j);\n        }\n    }\n\n    // Move pivot after smaller elements and\n    // return its position\n    swap(arr, i + 1, high);\n    return i + 1;\n}\n\n// Swap function\nfunction swap(arr, i, j)\n{\n    let temp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = temp;\n}\n\n// The QuickSort function implementation\nfunction quickSort(arr, low, high)\n{\n    if (low < high) {\n\n        // pi is the partition return index of pivot\n        let pi = partition(arr, low, high);\n\n        // Recursion calls for smaller elements\n        // and greater or equals elements\n        quickSort(arr, low, pi - 1);\n        quickSort(arr, pi + 1, high);\n    }\n}\n\n// Main driver code\nlet arr = [ 10, 7, 8, 9, 1, 5 ];\nlet n = arr.length;\n\n// Call QuickSort on the entire array\nquickSort(arr, 0, n - 1);\nfor (let i = 0; i < arr.length; i++) {\n    console.log(arr[i] + \" \");\n}\n<?php\n// Function to swap two elements\nfunction swap(&$a, &$b) {\n    $temp = $a;\n    $a = $b;\n    $b = $temp;\n}\n\n// Partition function\nfunction partition(&$arr, $low, $high) {\n    \n    // Choose the pivot\n    $pivot = $arr[$high];\n    \n    // Index of smaller element and indicates \n    // the right position of pivot found so far\n    $i = $low - 1;\n\n    // Traverse arr[low..high] and move all smaller\n    // elements to the left side. Elements from low to \n    // i are smaller after every iteration\n    for ($j = $low; $j <= $high - 1; $j++) {\n        if ($arr[$j] < $pivot) {\n            $i++;\n            swap($arr[$i], $arr[$j]);\n        }\n    }\n    \n    // Move pivot after smaller elements and\n    // return its position\n    swap($arr[$i + 1], $arr[$high]);  \n    return $i + 1;\n}\n\n// The QuickSort function implementation\nfunction quickSort(&$arr, $low, $high) {\n    if ($low < $high) {\n        \n        // pi is the partition return index of pivot\n        $pi = partition($arr, $low, $high);\n\n        // Recursion calls for smaller elements\n        // and greater or equals elements\n        quickSort($arr, $low, $pi - 1);\n        quickSort($arr, $pi + 1, $high);\n    }\n}\n\n// Main driver code\n$arr = array(10, 7, 8, 9, 1, 5);\n$n = count($arr);\n\nquickSort($arr, 0, $n - 1);\nfor ($i = 0; $i < count($arr); $i++) {\n    echo $arr[$i] . \" \";  \n}\n?>\nSorted Array\n1 5 7 8 9 10\n",
        "complexity": {
            "time": "Time Complexity:",
            "space": "Please refer Time and Space Complexity Analysis of Quick Sort for more details."
        },
        "tags": [
            "Divide and Conquer"
        ],
        "url": "https://www.geeksforgeeks.org/quick-sort-algorithm/"
    },
    {
        "title": "Write program to calculate pow(b, e)",
        "description": "Given two numbers b and e, the task is to implement a function to compute b^e. Examples: Input: b = 3.00000, e = 5Output: 243.00000 Input: b = 0.55000, e = 3Output: 0.16638 Input: b = -0.67000, e = -7Output: -16.49971 Table of Content The idea is to simply multiply b exactly e times using a iterative loop. The idea is to recursively multiply b exactly e times. To do so, define a recursive function that return b, if e > 0 else returns 1. The idea is to use Divide and Conquer and recursively bisect e in two equal parts. There are two possible cases: The idea is to use inbuilt functions provided by various languages to calculate b^e. Like in C++, pow(b, e) can be used to calculate b^e. Similarly, in Python, the exact same function can be used, or the **operator can be used to find the power. Related Articles:Write an iterative O(Log y) function for pow(x, y) Modular Exponentiation (Power in Modular Arithmetic)   ",
        "code": "// C++ program to calculate pow(b, e)\n#include <iostream>\nusing namespace std;\n\n// Naive iterative solution to calculate pow(b, e)\ndouble power(double b, int e) {\n  \n    // Initialize result to 1\n    double pow = 1;\n\n    // Multiply x for n times\n    for (int i = 0; i < abs(e); i++) \n        pow = pow * b;\n  \t\n  \tif (e < 0)\n      \treturn 1/pow;\n\n    return pow;\n}\n\nint main() {\n    double b = 3.0;\n    int e = 5;\n    double res = power(b, e);\n    cout << res;\n    return 0;\n}\n// C program to calculate pow(b, e)\n#include <stdio.h>\n#include <math.h>\n\n// Naive iterative solution to calculate pow(b, e)\ndouble power(double b, int e) {\n  \n    // Initialize result to 1\n    double pow = 1;\n\n    // Multiply b for e times\n    for (int i = 0; i < abs(e); i++) \n        pow = pow * b;\n\n    if (e < 0)\n        return 1 / pow;\n\n    return pow;\n}\n\nint main() {\n    double b = 3.0;\n    int e = 5;\n    double res = power(b, e);\n    printf(\"%f\", res);\n    return 0;\n}\n// Java program to calculate pow(b, e)\nclass GfG {\n\n    // Naive iterative solution to calculate pow(b, e)\n    static double power(double b, int e) {\n        \n        // Initialize result to 1\n        double pow = 1;\n\n        // Multiply b for e times\n        for (int i = 0; i < Math.abs(e); i++) \n            pow = pow * b;\n\n        if (e < 0)\n            return 1 / pow;\n\n        return pow;\n    }\n\n    public static void main(String[] args) {\n        double b = 3.0;\n        int e = 5;\n        double res = power(b, e);\n        System.out.println(res);\n    }\n}\n# Python program to calculate pow(b, e)\n\n# Naive iterative solution to calculate pow(b, e)\ndef power(b, e):\n    \n    # Initialize result to 1\n    pow = 1\n\n    # Multiply b for e times\n    for i in range(abs(e)):\n        pow = pow * b\n\n    if e < 0:\n        return 1 / pow\n\n    return pow\n\nif __name__ == \"__main__\":\n    b = 3.0\n    e = 5\n    res = power(b, e)\n    print(res)\n// C# program to calculate pow(b, e)\nusing System;\n\nclass GfG {\n\n    // Naive iterative solution to calculate pow(b, e)\n    static double power(double b, int e) {\n        \n        // Initialize result to 1\n        double pow = 1;\n\n        // Multiply b for e times\n        for (int i = 0; i < Math.Abs(e); i++) \n            pow = pow * b;\n\n        if (e < 0)\n            return 1 / pow;\n\n        return pow;\n    }\n\n    static void Main(string[] args) {\n        double b = 3.0;\n        int e = 5;\n        double res = power(b, e);\n        Console.WriteLine(res);\n    }\n}\n// JavaScript program to calculate pow(b, e)\n\n// Naive iterative solution to calculate pow(b, e)\nfunction power(b, e) {\n    \n    // Initialize result to 1\n    let pow = 1;\n\n    // Multiply b for e times\n    for (let i = 0; i < Math.abs(e); i++) \n        pow = pow * b;\n\n    if (e < 0)\n        return 1 / pow;\n\n    return pow;\n}\n\n// Driver Code\nconst b = 3.0;\nconst e = 5;\nconst res = power(b, e);\nconsole.log(res);\n243\n// C++ program to calculate pow(b, e)\n#include <iostream>\nusing namespace std;\n\ndouble power(double b, int e) {\n  \n    // Base Case: pow(b, 0) = 1\n    if (e == 0)\n        return 1;\n  \n    if (e < 0)\n        return 1 / power(b, -e);\n  \n    // For all other cases\n    return b * power(b, e - 1);\n}\n\nint main() {\n    double b = 3.0;\n    int e = 5;\n    double res = power(b, e);\n    cout << res;\n    return 0;\n}\n// C program to calculate pow(b, e)\n#include <stdio.h>\n\ndouble power(double b, int e) {\n  \n    // Base Case: pow(b, 0) = 1\n    if (e == 0)\n        return 1;\n  \n    if (e < 0)\n        return 1 / power(b, -e);\n  \n    // For all other cases\n    return b * power(b, e - 1);\n}\n\nint main() {\n    double b = 3.0;\n    int e = 5;\n    double res = power(b, e);\n    printf(\"%f\", res);\n    return 0;\n}\n// Java program to calculate pow(b, e)\nclass GfG {\n\n    static double power(double b, int e) {\n        \n        // Base Case: pow(b, 0) = 1\n        if (e == 0)\n            return 1;\n        \n        if (e < 0)\n            return 1 / power(b, -e);\n        \n        // For all other cases\n        return b * power(b, e - 1);\n    }\n\n    public static void main(String[] args) {\n        double b = 3.0;\n        int e = 5;\n        double res = power(b, e);\n        System.out.println(res);\n    }\n}\n# Python program to calculate pow(b, e)\n\ndef power(b, e):\n    \n    # Base Case: pow(b, 0) = 1\n    if e == 0:\n        return 1\n    \n    if e < 0:\n        return 1 / power(b, -e)\n    \n    # For all other cases\n    return b * power(b, e - 1)\n\nif __name__ == \"__main__\":\n    b = 3.0\n    e = 5\n    res = power(b, e)\n    print(res)\n// C# program to calculate pow(b, e)\nusing System;\n\nclass GfG {\n\n    static double power(double b, int e) {\n        \n        // Base Case: pow(b, 0) = 1\n        if (e == 0)\n            return 1;\n        \n        if (e < 0)\n            return 1 / power(b, -e);\n        \n        // For all other cases\n        return b * power(b, e - 1);\n    }\n\n    static void Main(string[] args) {\n        double b = 3.0;\n        int e = 5;\n        double res = power(b, e);\n        Console.WriteLine(res);\n    }\n}\n// JavaScript program to calculate pow(b, e)\n\nfunction power(b, e) {\n    \n    // Base Case: pow(b, 0) = 1\n    if (e == 0)\n        return 1;\n    \n    if (e < 0)\n        return 1 / power(b, -e);\n    \n    // For all other cases\n    return b * power(b, e - 1);\n}\n\n// Driver Code\nconst b = 3.0;\nconst e = 5;\nconst res = power(b, e);\nconsole.log(res);\n243\n// C++ program to calculate pow(b, e)\n#include <iostream>\nusing namespace std;\n\ndouble power(double b, int e) {\n  \n\t// Base Case: pow(b, 0) = 1\n    if (e == 0)\n        return 1;\n  \n    if (e < 0)\n        return 1 / power(b, -e);\n  \t\n    double temp = power(b, e / 2);\n\t\n    if (e % 2 == 0)\n        return temp * temp;\n    else\n        return b * temp * temp;\n}\n\nint main() {\n    double b = 3.0;\n    int e = 5;\n    double res = power(b, e);\n    cout << res;\n    return 0;\n}\n// C program to calculate pow(b, e)\n#include <stdio.h>\n\n// Recursive function to calculate pow(b, e)\ndouble power(double b, int e) {\n    \n    // Base Case: pow(b, 0) = 1\n    if (e == 0)\n        return 1;\n\n    if (e < 0)\n        return 1 / power(b, -e);\n\n    double temp = power(b, e / 2);\n\n    if (e % 2 == 0)\n        return temp * temp;\n    else\n        return b * temp * temp;\n}\n\nint main() {\n    double b = 3.0;\n    int e = 5;\n    double res = power(b, e);\n    printf(\"%lf\", res);\n    return 0;\n}\n// Java program to calculate pow(b, e)\npublic class Main {\n\n    // Recursive function to calculate pow(b, e)\n    static double power(double b, int e) {\n        \n        // Base Case: pow(b, 0) = 1\n        if (e == 0)\n            return 1;\n\n        if (e < 0)\n            return 1 / power(b, -e);\n\n        double temp = power(b, e / 2);\n\n        if (e % 2 == 0)\n            return temp * temp;\n        else\n            return b * temp * temp;\n    }\n\n    public static void main(String[] args) {\n        double b = 3.0;\n        int e = 5;\n        double res = power(b, e);\n        System.out.println(res);\n    }\n}\n# Python program to calculate pow(b, e)\n\n# Recursive function to calculate pow(b, e)\ndef power(b, e):\n\n    # Base Case: pow(b, 0) = 1\n    if e == 0:\n        return 1\n\n    if e < 0:\n        return 1 / power(b, -e)\n\n    temp = power(b, e // 2)\n\n    if e % 2 == 0:\n        return temp * temp\n    else:\n        return b * temp * temp\n\nif __name__ == \"__main__\":\n    b = 3.0\n    e = 5\n    res = power(b, e)\n    print(res)\n// C# program to calculate pow(b, e)\nusing System;\n\nclass Program {\n\n    // Recursive function to calculate pow(b, e)\n    static double power(double b, int e) {\n        \n        // Base Case: pow(b, 0) = 1\n        if (e == 0)\n            return 1;\n\n        if (e < 0)\n            return 1 / power(b, -e);\n\n        double temp = power(b, e / 2);\n\n        if (e % 2 == 0)\n            return temp * temp;\n        else\n            return b * temp * temp;\n    }\n\n    static void Main(string[] args) {\n        double b = 3.0;\n        int e = 5;\n        double res = power(b, e);\n        Console.WriteLine(res);\n    }\n}\n// JavaScript program to calculate pow(b, e)\n\n// Recursive function to calculate pow(b, e)\nfunction power(b, e) {\n\n    // Base Case: pow(b, 0) = 1\n    if (e == 0)\n        return 1;\n\n    if (e < 0)\n        return 1 / power(b, -e);\n\n    let temp = power(b, Math.floor(e / 2));\n\n    if (e % 2 == 0)\n        return temp * temp;\n    else\n        return b * temp * temp;\n}\n\n// Driver Code\nconst b = 3.0;\nconst e = 5;\nconst res = power(b, e);\nconsole.log(res);\n243\n// C++ program to calculate power Using builtin methods\n#include <iostream>\n#include <cmath>\nusing namespace std;\n\ndouble power(double b, int e) {  \n    return pow(b, e);\n}\n\nint main() {\n    double b = 3.0;\n    int e = 5;\n    cout << power(b, e);\n}\n// Java program to calculate power \n// Using builtin methods\n\nclass GFG {\n    static double power(double b, int e) {\n        return Math.pow(b, e);\n    }\n\n    public static void main(String[] args) {\n        double b = 3.0;\n        int e = 5;\n        System.out.println(power(b, e));\n    }\n}\n# Python program to calculate power \n# Using builtin methods\ndef power(b, e):\n\n  \t# using (**) operator\n    # return b**e\n  \n    # Return type of pow()\n    # function is double\n    return pow(b, e)\n\nif __name__ == \"__main__\":\n    b = 3.0\n    e = 5\n    print(power(b, e))\n// C# program to calculate power \n// Using builtin methods\n\nusing System;\n\nclass GFG {\n\n    static double power(double b, int e) {\n\n        // Math.pow() is a function that\n        // return floating number\n        return Math.Pow(b, e);\n    }\n  \n    static void Main() {\n        double b = 3.0;\n        int e = 5;\n        Console.WriteLine(power(b, e));\n    }\n}\n// Javascript program to calculate power \n// Using builtin methods\n\nfunction power(b, e) {\n\n    // Math.pow() is a function that\n    // return floating number\n    return parseInt(Math.pow(b, e));\n}\n\n// Driver Code\nconst b = 3.0;\nconst e = 5;\nconsole.log(power(b, e));\n243\n",
        "complexity": {
            "time": "",
            "space": ""
        },
        "tags": [
            "Divide and Conquer"
        ],
        "url": "https://www.geeksforgeeks.org/write-a-c-program-to-calculate-powxn/"
    },
    {
        "title": "Strassen’s Matrix Multiplication",
        "description": "Given two square matrices arr[][] and brr[][] of order n * n. Your task is to multiply both the matrices and find the resultant matrix. Examples: Input: arr[][] = [ [7, 8], [2, 9] ]brr[][] = [ [14, 5], [5, 18] ]Output: [ [138, 179], [73, 172] ] Input: arr[][] = [ [17, 4], [17, 16] ]brr[][] = [ [9, 2], [7, 1] ]Output: [ [181, 38], [265, 50] ] Table of Content The idea is to use simple matrix multiplication where we use nested for loops to multiply each elements of both the matrices one by one. The idea is to divide the given matrix into four sub-matrices of order (n / 2) * (n / 2). And then calculate the values ae + bg, af + bh, ce + dg and cf + dh, as shown in image.  In the above divide and conquer method, the main component for high time complexity is 8 recursive calls. The idea of Strassen’s method is to reduce the number of recursive calls to 7. Strassen’s method is similar to above simple divide and conquer method in the sense that this method also divide matrices to sub-matrices of order (n / 2) * (n / 2) as shown in the diagram, but in Strassen’s method, the four sub-matrices of result are calculated using following formulae.  Generally Strassen’s Method is not preferred for practical applications for following reasons. Time Complexity of Strassen’s Method Addition and Subtraction of two matrices takes O(N2) time. So time complexity can be written as Generally Strassen’s Method is not preferred for practical applications for following reasons.  ",
        "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef vector<vector<int>> Matrix;\n\n// to multiply two matrices\nMatrix mult(Matrix &arr, Matrix &brr) {\n    int n = arr.size();\n\n    // to store the resultant matrix\n    Matrix res(n, vector<int>(n, 0));\n\n    for(int i = 0; i < n; i++) {\n        for(int j = 0; j < n; j++) {\n            for(int k = 0; k < n; k++) {\n                res[i][j] += arr[i][k] * brr[k][j];\n            }\n        }\n    }\n\n    return res;\n}\n\nint main() {\n    Matrix arr = {{7, 8}, {2, 9}};\n    Matrix brr = {{14, 5}, {5, 18}};\n    Matrix res = mult(arr, brr);\n    for(int i = 0; i < res.size(); i++) {\n        for(int j = 0; j < res[i].size(); j++) {\n            cout << res[i][j] << \" \";\n        }\n        cout << endl;\n    }\n    return 0;\n}\nimport java.util.*;\n\nclass GfG {\n\n    // to multiply two matrices\n    static int[][] multiply(int[][] arr, int[][] brr) {\n        int n = arr.length;\n\n        // to store the resultant matrix\n        int[][] res = new int[n][n];\n\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                for (int k = 0; k < n; k++) {\n                    res[i][j] += arr[i][k] * brr[k][j];\n                }\n            }\n        }\n\n        return res;\n    }\n\n    public static void main(String[] args) {\n        int[][] arr = { {7, 8}, {2, 9} };\n        int[][] brr = { {14, 5}, {5, 18} };\n        int[][] res = multiply(arr, brr);\n        for (int i = 0; i < res.length; i++) {\n            for (int j = 0; j < res[i].length; j++) {\n                System.out.print(res[i][j] + \" \");\n            }\n            System.out.println();\n        }\n    }\n}\n# to multiply two matrices\ndef multiply(arr, brr):\n    n = len(arr)\n\n    # to store the resultant matrix\n    res = [[0 for _ in range(n)] for _ in range(n)]\n\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                res[i][j] += arr[i][k] * brr[k][j]\n\n    return res\n\nif __name__ == \"__main__\":\n    arr = [[7, 8], [2, 9]]\n    brr = [[14, 5], [5, 18]]\n    res = multiply(arr, brr)\n    for i in range(len(res)):\n        for j in range(len(res[i])):\n            print(res[i][j], end=\" \")\n        print()\nusing System;\nusing System.Collections.Generic;\n\nclass GfG {\n\n    // to multiply two matrices\n    static List<List<int>> multiply(List<List<int>> arr, \n    List<List<int>> brr) {\n        int n = arr.Count;\n\n        // to store the resultant matrix\n        List<List<int>> res = new List<List<int>>();\n        for (int i = 0; i < n; i++) {\n            List<int> row = new List<int>();\n            for (int j = 0; j < n; j++) {\n                row.Add(0);\n            }\n            res.Add(row);\n        }\n\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                for (int k = 0; k < n; k++) {\n                    res[i][j] += arr[i][k] * brr[k][j];\n                }\n            }\n        }\n\n        return res;\n    }\n\n    public static void Main() {\n        List<int> row1 = new List<int> {7, 8};\n        List<int> row2 = new List<int> {2, 9};\n        List<List<int>> arr = new List<List<int>> {row1, row2};\n\n        List<int> row3 = new List<int> {14, 5};\n        List<int> row4 = new List<int> {5, 18};\n        List<List<int>> brr = new List<List<int>> {row3, row4};\n\n        List<List<int>> res = multiply(arr, brr);\n        for (int i = 0; i < res.Count; i++) {\n            for (int j = 0; j < res[i].Count; j++) {\n                Console.Write(res[i][j] + \" \");\n            }\n            Console.WriteLine();\n        }\n    }\n}\n// to multiply two matrices\nfunction multiply(arr, brr) {\n    let n = arr.length;\n\n    // to store the resultant matrix\n    let res = new Array(n);\n    for (let i = 0; i < n; i++) {\n        res[i] = new Array(n).fill(0);\n    }\n\n    for (let i = 0; i < n; i++) {\n        for (let j = 0; j < n; j++) {\n            for (let k = 0; k < n; k++) {\n                res[i][j] += arr[i][k] * brr[k][j];\n            }\n        }\n    }\n\n    return res;\n}\n\nlet arr = [[7, 8], [2, 9]];\nlet brr = [[14, 5], [5, 18]];\nlet res = multiply(arr, brr);\nfor (let i = 0; i < res.length; i++) {\n    console.log(res[i].join(\" \"));\n}\n138 179 \n73 172\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef vector<vector<int>> Matrix;\n\n// to add two matrices\nMatrix add(Matrix arr, Matrix brr, int n) {\n    Matrix res(n, vector<int>(n, 0));\n    for(int i = 0; i < n; i++) {\n        for(int j = 0; j < n; j++) {\n            res[i][j] = arr[i][j] + brr[i][j];\n        }\n    }\n    return res;\n}\n\n// to multiply two matrices\nMatrix mult(Matrix &arr, Matrix &brr) {\n    int n = arr.size();\n\n    // to store the resultant matrix\n    Matrix res(n, vector<int>(n, 0));\n\n    if(n == 1) {\n        res[0][0] = arr[0][0] * brr[0][0];\n        return res;\n    }\n\n    // construct eight submatrices\n    vector<Matrix> subMat(8, Matrix(n/2, vector<int>(n/2, 0)));\n\n    for(int i = 0; i < n / 2; i++) {\n        for(int j = 0; j < n / 2; j++) {\n            subMat[0][i][j] = arr[i][j];\n            subMat[1][i][j] = arr[i][j + n / 2];\n            subMat[2][i][j] = arr[i + n / 2][j];\n            subMat[3][i][j] = arr[i + n / 2][j + n / 2];\n            subMat[4][i][j] = brr[i][j];\n            subMat[5][i][j] = brr[i][j + n / 2];\n            subMat[6][i][j] = brr[i + n / 2][j];\n            subMat[7][i][j] = brr[i + n / 2][j + n / 2];\n        }\n    }\n\n    // create four matrices to store the result\n    vector<Matrix> resMat(4, Matrix(n/2, vector<int>(n/2, 0)));\n\n    // calculate the product and add them\n    resMat[0] = add(mult(subMat[0], subMat[4]), mult(subMat[1], subMat[6]), n/2);\n    resMat[1] = add(mult(subMat[0], subMat[5]), mult(subMat[1], subMat[7]), n/2);\n    resMat[2] = add(mult(subMat[2], subMat[4]), mult(subMat[3], subMat[6]), n/2);\n    resMat[3] = add(mult(subMat[2], subMat[5]), mult(subMat[3], subMat[7]), n/2);\n\n    // copy the result to the resultant matrix\n    for(int i = 0; i < n / 2; i++) {\n        for(int j = 0; j < n / 2; j++) {\n            res[i][j] = resMat[0][i][j];\n            res[i][j + n / 2] = resMat[1][i][j];\n            res[i + n / 2][j] = resMat[2][i][j];\n            res[i + n / 2][j + n / 2] = resMat[3][i][j];\n        }\n    }\n\n    return res;\n}\n\nint main() {\n    Matrix arr = {{7, 8}, {2, 9}};\n    Matrix brr = {{14, 5}, {5, 18}};\n    Matrix res = mult(arr, brr);\n    for(int i = 0; i < res.size(); i++) {\n        for(int j = 0; j < res[i].size(); j++) {\n            cout << res[i][j] << \" \";\n        }\n        cout << endl;\n    }\n    return 0;\n}\n// to add two matrices\npublic static int[][] add(int[][] arr, int[][] brr) {\n    int n = arr.length;\n    int[][] res = new int[n][n];\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            res[i][j] = arr[i][j] + brr[i][j];\n        }\n    }\n    return res;\n}\n\n// to multiply two matrices\npublic static int[][] mult(int[][] arr, int[][] brr) {\n    int n = arr.length;\n\n    // to store the resultant matrix\n    int[][] res = new int[n][n];\n\n    if (n == 1) {\n        res[0][0] = arr[0][0] * brr[0][0];\n        return res;\n    }\n\n    // construct eight submatrices\n    int[][][] subMat = new int[8][n / 2][n / 2];\n\n    for (int i = 0; i < n / 2; i++) {\n        for (int j = 0; j < n / 2; j++) {\n            subMat[0][i][j] = arr[i][j];\n            subMat[1][i][j] = arr[i][j + n / 2];\n            subMat[2][i][j] = arr[i + n / 2][j];\n            subMat[3][i][j] = arr[i + n / 2][j + n / 2];\n            subMat[4][i][j] = brr[i][j];\n            subMat[5][i][j] = brr[i][j + n / 2];\n            subMat[6][i][j] = brr[i + n / 2][j];\n            subMat[7][i][j] = brr[i + n / 2][j + n / 2];\n        }\n    }\n\n    // create four matrices to store the result\n    int[][][] resMat = new int[4][n / 2][n / 2];\n\n    // calculate the product and add them\n    resMat[0] = add(mult(subMat[0], subMat[4]), mult(subMat[1], subMat[6]));\n    resMat[1] = add(mult(subMat[0], subMat[5]), mult(subMat[1], subMat[7]));\n    resMat[2] = add(mult(subMat[2], subMat[4]), mult(subMat[3], subMat[6]));\n    resMat[3] = add(mult(subMat[2], subMat[5]), mult(subMat[3], subMat[7]));\n\n    // copy the result to the resultant matrix\n    for (int i = 0; i < n / 2; i++) {\n        for (int j = 0; j < n / 2; j++) {\n            res[i][j] = resMat[0][i][j];\n            res[i][j + n / 2] = resMat[1][i][j];\n            res[i + n / 2][j] = resMat[2][i][j];\n            res[i + n / 2][j + n / 2] = resMat[3][i][j];\n        }\n    }\n\n    return res;\n}\n\npublic static void main(String[] args) {\n    int[][] arr = {{7, 8}, {2, 9}};\n    int[][] brr = {{14, 5}, {5, 18}};\n    int[][] res = mult(arr, brr);\n    for (int[] row : res) {\n        System.out.println(Arrays.toString(row));\n    }\n}\n# to add two matrices\n\ndef add(arr, brr):\n    n = len(arr)\n    res = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            res[i][j] = arr[i][j] + brr[i][j]\n    return res\n\n# to multiply two matrices\ndef mult(arr, brr):\n    n = len(arr)\n\n    # to store the resultant matrix\n    res = [[0] * n for _ in range(n)]\n\n    if n == 1:\n        res[0][0] = arr[0][0] * brr[0][0]\n        return res\n\n    # construct eight submatrices\n    subMat = [[[[0] * (n // 2) for _ in range(n // 2)] for _ in range(8)]]\n\n    for i in range(n // 2):\n        for j in range(n // 2):\n            subMat[0][i][j] = arr[i][j]\n            subMat[1][i][j] = arr[i][j + n // 2]\n            subMat[2][i][j] = arr[i + n // 2][j]\n            subMat[3][i][j] = arr[i + n // 2][j + n // 2]\n            subMat[4][i][j] = brr[i][j]\n            subMat[5][i][j] = brr[i][j + n // 2]\n            subMat[6][i][j] = brr[i + n // 2][j]\n            subMat[7][i][j] = brr[i + n // 2][j + n // 2]\n\n    # create four matrices to store the result\n    resMat = [[[[0] * (n // 2) for _ in range(n // 2)] for _ in range(4)]]\n\n    # calculate the product and add them\n    resMat[0] = add(mult(subMat[0], subMat[4]), mult(subMat[1], subMat[6]))\n    resMat[1] = add(mult(subMat[0], subMat[5]), mult(subMat[1], subMat[7]))\n    resMat[2] = add(mult(subMat[2], subMat[4]), mult(subMat[3], subMat[6]))\n    resMat[3] = add(mult(subMat[2], subMat[5]), mult(subMat[3], subMat[7]))\n\n    # copy the result to the resultant matrix\n    for i in range(n // 2):\n        for j in range(n // 2):\n            res[i][j] = resMat[0][i][j]\n            res[i][j + n // 2] = resMat[1][i][j]\n            res[i + n // 2][j] = resMat[2][i][j]\n            res[i + n // 2][j + n // 2] = resMat[3][i][j]\n\n    return res\n\nif __name__ == '__main__':\n    arr = [[7, 8], [2, 9]]\n    brr = [[14, 5], [5, 18]]\n    res = mult(arr, brr)\n    for row in res:\n        print(' '.join(map(str, row)))\n// to add two matrices\npublic static int[,] Add(int[,] arr, int[,] brr) {\n    int n = arr.GetLength(0);\n    int[,] res = new int[n, n];\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            res[i, j] = arr[i, j] + brr[i, j];\n        }\n    }\n    return res;\n}\n\n// to multiply two matrices\npublic static int[,] Mult(int[,] arr, int[,] brr) {\n    int n = arr.GetLength(0);\n\n    // to store the resultant matrix\n    int[,] res = new int[n, n];\n\n    if (n == 1) {\n        res[0, 0] = arr[0, 0] * brr[0, 0];\n        return res;\n    }\n\n    // construct eight submatrices\n    int[][,] subMat = new int[8][,];\n    for (int i = 0; i < 8; i++) {\n        subMat[i] = new int[n / 2, n / 2];\n    }\n\n    for (int i = 0; i < n / 2; i++) {\n        for (int j = 0; j < n / 2; j++) {\n            subMat[0][i, j] = arr[i, j];\n            subMat[1][i, j] = arr[i, j + n / 2];\n            subMat[2][i, j] = arr[i + n / 2, j];\n            subMat[3][i, j] = arr[i + n / 2, j + n / 2];\n            subMat[4][i, j] = brr[i, j];\n            subMat[5][i, j] = brr[i, j + n / 2];\n            subMat[6][i, j] = brr[i + n / 2, j];\n            subMat[7][i, j] = brr[i + n / 2, j + n / 2];\n        }\n    }\n\n    // create four matrices to store the result\n    int[][,] resMat = new int[4][,];\n    for (int i = 0; i < 4; i++) {\n        resMat[i] = new int[n / 2, n / 2];\n    }\n\n    // calculate the product and add them\n    resMat[0] = Add(Mult(subMat[0], subMat[4]), Mult(subMat[1], subMat[6]));\n    resMat[1] = Add(Mult(subMat[0], subMat[5]), Mult(subMat[1], subMat[7]));\n    resMat[2] = Add(Mult(subMat[2], subMat[4]), Mult(subMat[3], subMat[6]));\n    resMat[3] = Add(Mult(subMat[2], subMat[5]), Mult(subMat[3], subMat[7]));\n\n    // copy the result to the resultant matrix\n    for (int i = 0; i < n / 2; i++) {\n        for (int j = 0; j < n / 2; j++) {\n            res[i, j] = resMat[0][i, j];\n            res[i, j + n / 2] = resMat[1][i, j];\n            res[i + n / 2, j] = resMat[2][i, j];\n            res[i + n / 2, j + n / 2] = resMat[3][i, j];\n        }\n    }\n\n    return res;\n}\n\npublic static void Main() {\n    int[,] arr = {{7, 8}, {2, 9}};\n    int[,] brr = {{14, 5}, {5, 18}};\n    int[,] res = Mult(arr, brr);\n    for (int i = 0; i < res.GetLength(0); i++) {\n        for (int j = 0; j < res.GetLength(1); j++) {\n            Console.Write(res[i, j] + \" \");\n        }\n        Console.WriteLine();\n    }\n}\n// to add two matrices\nfunction add(arr, brr) {\n    const n = arr.length;\n    const res = Array.from({ length: n }, () => Array(n).fill(0));\n    for (let i = 0; i < n; i++) {\n        for (let j = 0; j < n; j++) {\n            res[i][j] = arr[i][j] + brr[i][j];\n        }\n    }\n    return res;\n}\n\n// to multiply two matrices\nfunction mult(arr, brr) {\n    const n = arr.length;\n\n    // to store the resultant matrix\n    const res = Array.from({ length: n }, () => Array(n).fill(0));\n\n    if (n === 1) {\n        res[0][0] = arr[0][0] * brr[0][0];\n        return res;\n    }\n\n    // construct eight submatrices\n    const subMat = Array.from({ length: 8 }, () => Array.from({ length: n / 2 }, () => Array(n / 2).fill(0)));\n\n    for (let i = 0; i < n / 2; i++) {\n        for (let j = 0; j < n / 2; j++) {\n            subMat[0][i][j] = arr[i][j];\n            subMat[1][i][j] = arr[i][j + n / 2];\n            subMat[2][i][j] = arr[i + n / 2][j];\n            subMat[3][i][j] = arr[i + n / 2][j + n / 2];\n            subMat[4][i][j] = brr[i][j];\n            subMat[5][i][j] = brr[i][j + n / 2];\n            subMat[6][i][j] = brr[i + n / 2][j];\n            subMat[7][i][j] = brr[i + n / 2][j + n / 2];\n        }\n    }\n\n    // create four matrices to store the result\n    const resMat = Array.from({ length: 4 }, () => Array.from({ length: n / 2 }, () => Array(n / 2).fill(0)));\n\n    // calculate the product and add them\n    resMat[0] = add(mult(subMat[0], subMat[4]), mult(subMat[1], subMat[6]));\n    resMat[1] = add(mult(subMat[0], subMat[5]), mult(subMat[1], subMat[7]));\n    resMat[2] = add(mult(subMat[2], subMat[4]), mult(subMat[3], subMat[6]));\n    resMat[3] = add(mult(subMat[2], subMat[5]), mult(subMat[3], subMat[7]));\n\n    // copy the result to the resultant matrix\n    for (let i = 0; i < n / 2; i++) {\n        for (let j = 0; j < n / 2; j++) {\n            res[i][j] = resMat[0][i][j];\n            res[i][j + n / 2] = resMat[1][i][j];\n            res[i + n / 2][j] = resMat[2][i][j];\n            res[i + n / 2][j + n / 2] = resMat[3][i][j];\n        }\n    }\n\n    return res;\n}\n\nconst arr = [[7, 8], [2, 9]];\nconst brr = [[14, 5], [5, 18]];\nconst res = mult(arr, brr);\nres.forEach(row => console.log(row.join(' ')));\n138 179 \n73 172\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef vector<vector<int>> Matrix;\n\n// Function to add or subtract two matrices\nMatrix add(Matrix arr, Matrix brr, int n, int sign = 1) {\n    Matrix res(n, vector<int>(n, 0));\n    for (int i = 0; i < n; i++)\n        for (int j = 0; j < n; j++)\n            res[i][j] = arr[i][j] + sign * brr[i][j];\n    return res;\n}\n\n// Strassen's matrix multiplication function\nMatrix mult(Matrix arr, Matrix brr) {\n    int n = arr.size();\n    Matrix res(n, vector<int>(n, 0));\n\n    // Base case\n    if (n == 1) {\n        res[0][0] = arr[0][0] * brr[0][0];\n        return res;\n    }\n\n    int nwSz = n / 2; // New Size\n    Matrix a11(nwSz, vector<int>(nwSz, 0));\n    Matrix a12(nwSz, vector<int>(nwSz, 0));\n    Matrix a21(nwSz, vector<int>(nwSz, 0));\n    Matrix a22(nwSz, vector<int>(nwSz, 0));\n    Matrix b11(nwSz, vector<int>(nwSz, 0));\n    Matrix b12(nwSz, vector<int>(nwSz, 0));\n    Matrix b21(nwSz, vector<int>(nwSz, 0));\n    Matrix b22(nwSz, vector<int>(nwSz, 0));\n\n    // Splitting arr and brr into submatrices\n    for (int i = 0; i < nwSz; i++)\n        for (int j = 0; j < nwSz; j++) {\n            a11[i][j] = arr[i][j];\n            a12[i][j] = arr[i][j + nwSz];\n            a21[i][j] = arr[i + nwSz][j];\n            a22[i][j] = arr[i + nwSz][j + nwSz];\n            b11[i][j] = brr[i][j];\n            b12[i][j] = brr[i][j + nwSz];\n            b21[i][j] = brr[i + nwSz][j];\n            b22[i][j] = brr[i + nwSz][j + nwSz];\n        }\n\n    // Strassen's seven multiplications\n    Matrix m1 = mult(add(a11, a22, nwSz), add(b11, b22, nwSz));\n    Matrix m2 = mult(add(a21, a22, nwSz), b11);\n    Matrix m3 = mult(a11, add(b12, b22, nwSz, -1));\n    Matrix m4 = mult(a22, add(b21, b11, nwSz, -1));\n    Matrix m5 = mult(add(a11, a12, nwSz), b22);\n    Matrix m6 = mult(add(a21, a11, nwSz, -1), add(b11, b12, nwSz));\n    Matrix m7 = mult(add(a12, a22, nwSz, -1), add(b21, b22, nwSz));\n\n    // Calculating result submatrices\n    Matrix c11 = add(add(m1, m4, nwSz), add(m7, m5, nwSz, -1), nwSz);\n    Matrix c12 = add(m3, m5, nwSz);\n    Matrix c21 = add(m2, m4, nwSz);\n    Matrix c22 = add(add(m1, m3, nwSz), add(m6, m2, nwSz, -1), nwSz);\n\n    // Copy results into result matrix\n    for (int i = 0; i < nwSz; i++)\n        for (int j = 0; j < nwSz; j++) {\n            res[i][j] = c11[i][j];\n            res[i][j + nwSz] = c12[i][j];\n            res[i + nwSz][j] = c21[i][j];\n            res[i + nwSz][j + nwSz] = c22[i][j];\n        }\n\n    return res;\n}\n\nint main() {\n    Matrix arr = {{7, 8}, {2, 9}};\n    Matrix brr = {{14, 5}, {5, 18}};\n    Matrix res = mult(arr, brr);\n\n    for (int i = 0; i < res.size(); i++) {\n        for (int j = 0; j < res[i].size(); j++) {\n            cout << res[i][j] << \" \";\n        }\n        cout << endl;\n    }\n    return 0;\n}\n// Function to add or subtract two matrices\npublic static int[][] add(int[][] arr, int[][] brr, int n, int sign) {\n    int[][] res = new int[n][n];\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            res[i][j] = arr[i][j] + sign * brr[i][j];\n        }\n    }\n    return res;\n}\n\n// Strassen's matrix multiplication function\npublic static int[][] mult(int[][] arr, int[][] brr) {\n    int n = arr.length;\n    int[][] res = new int[n][n];\n\n    // Base case\n    if (n == 1) {\n        res[0][0] = arr[0][0] * brr[0][0];\n        return res;\n    }\n\n    int nwSz = n / 2; // New Size\n    int[][] a11 = new int[nwSz][nwSz];\n    int[][] a12 = new int[nwSz][nwSz];\n    int[][] a21 = new int[nwSz][nwSz];\n    int[][] a22 = new int[nwSz][nwSz];\n    int[][] b11 = new int[nwSz][nwSz];\n    int[][] b12 = new int[nwSz][nwSz];\n    int[][] b21 = new int[nwSz][nwSz];\n    int[][] b22 = new int[nwSz][nwSz];\n\n    // Splitting arr and brr into submatrices\n    for (int i = 0; i < nwSz; i++) {\n        for (int j = 0; j < nwSz; j++) {\n            a11[i][j] = arr[i][j];\n            a12[i][j] = arr[i][j + nwSz];\n            a21[i][j] = arr[i + nwSz][j];\n            a22[i][j] = arr[i + nwSz][j + nwSz];\n            b11[i][j] = brr[i][j];\n            b12[i][j] = brr[i][j + nwSz];\n            b21[i][j] = brr[i + nwSz][j];\n            b22[i][j] = brr[i + nwSz][j + nwSz];\n        }\n    }\n\n    // Strassen's seven multiplications\n    int[][] m1 = mult(add(a11, a22, nwSz, 1), add(b11, b22, nwSz, 1));\n    int[][] m2 = mult(add(a21, a22, nwSz, 1), b11);\n    int[][] m3 = mult(a11, add(b12, b22, nwSz, -1));\n    int[][] m4 = mult(a22, add(b21, b11, nwSz, -1));\n    int[][] m5 = mult(add(a11, a12, nwSz, 1), b22);\n    int[][] m6 = mult(add(a21, a11, nwSz, -1), add(b11, b12, nwSz, 1));\n    int[][] m7 = mult(add(a12, a22, nwSz, -1), add(b21, b22, nwSz, 1));\n\n    // Calculating result submatrices\n    int[][] c11 = add(add(m1, m4, nwSz, 1), add(m7, m5, nwSz, -1), nwSz);\n    int[][] c12 = add(m3, m5, nwSz, 1);\n    int[][] c21 = add(m2, m4, nwSz, 1);\n    int[][] c22 = add(add(m1, m3, nwSz, 1), add(m6, m2, nwSz, -1), nwSz);\n\n    // Copy results into result matrix\n    for (int i = 0; i < nwSz; i++) {\n        for (int j = 0; j < nwSz; j++) {\n            res[i][j] = c11[i][j];\n            res[i][j + nwSz] = c12[i][j];\n            res[i + nwSz][j] = c21[i][j];\n            res[i + nwSz][j + nwSz] = c22[i][j];\n        }\n    }\n\n    return res;\n}\n\npublic static void main(String[] args) {\n    int[][] arr = {{7, 8}, {2, 9}};\n    int[][] brr = {{14, 5}, {5, 18}};\n    int[][] res = mult(arr, brr);\n\n    for (int[] row : res) {\n        System.out.println(Arrays.toString(row));\n    }\n}\n# Function to add or subtract two matrices\ndef add(arr, brr, n, sign=1):\n    res = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            res[i][j] = arr[i][j] + sign * brr[i][j]\n    return res\n\n# Strassen's matrix multiplication function\ndef mult(arr, brr):\n    n = len(arr)\n    res = [[0] * n for _ in range(n)]\n\n    # Base case\n    if n == 1:\n        res[0][0] = arr[0][0] * brr[0][0]\n        return res\n\n    nwSz = n // 2  # New Size\n    a11 = [[0] * nwSz for _ in range(nwSz)]\n    a12 = [[0] * nwSz for _ in range(nwSz)]\n    a21 = [[0] * nwSz for _ in range(nwSz)]\n    a22 = [[0] * nwSz for _ in range(nwSz)]\n    b11 = [[0] * nwSz for _ in range(nwSz)]\n    b12 = [[0] * nwSz for _ in range(nwSz)]\n    b21 = [[0] * nwSz for _ in range(nwSz)]\n    b22 = [[0] * nwSz for _ in range(nwSz)]\n\n    # Splitting arr and brr into submatrices\n    for i in range(nwSz):\n        for j in range(nwSz):\n            a11[i][j] = arr[i][j]\n            a12[i][j] = arr[i][j + nwSz]\n            a21[i][j] = arr[i + nwSz][j]\n            a22[i][j] = arr[i + nwSz][j + nwSz]\n            b11[i][j] = brr[i][j]\n            b12[i][j] = brr[i][j + nwSz]\n            b21[i][j] = brr[i + nwSz][j]\n            b22[i][j] = brr[i + nwSz][j + nwSz]\n\n    # Strassen's seven multiplications\n    m1 = mult(add(a11, a22, nwSz), add(b11, b22, nwSz))\n    m2 = mult(add(a21, a22, nwSz), b11)\n    m3 = mult(a11, add(b12, b22, nwSz, -1))\n    m4 = mult(a22, add(b21, b11, nwSz, -1))\n    m5 = mult(add(a11, a12, nwSz), b22)\n    m6 = mult(add(a21, a11, nwSz, -1), add(b11, b12, nwSz))\n    m7 = mult(add(a12, a22, nwSz, -1), add(b21, b22, nwSz))\n\n    # Calculating result submatrices\n    c11 = add(add(m1, m4, nwSz), add(m7, m5, nwSz, -1), nwSz)\n    c12 = add(m3, m5, nwSz)\n    c21 = add(m2, m4, nwSz)\n    c22 = add(add(m1, m3, nwSz), add(m6, m2, nwSz, -1), nwSz)\n\n    # Copy results into result matrix\n    for i in range(nwSz):\n        for j in range(nwSz):\n            res[i][j] = c11[i][j]\n            res[i][j + nwSz] = c12[i][j]\n            res[i + nwSz][j] = c21[i][j]\n            res[i + nwSz][j + nwSz] = c22[i][j]\n\n    return res\n\nif __name__ == '__main__':\n    arr = [[7, 8], [2, 9]]\n    brr = [[14, 5], [5, 18]]\n    res = mult(arr, brr)\n\n    for row in res:\n        print(' '.join(map(str, row)))\n// Function to add or subtract two matrices\npublic static int[,] add(int[,] arr, int[,] brr, int n, int sign) {\n    int[,] res = new int[n, n];\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            res[i, j] = arr[i, j] + sign * brr[i, j];\n        }\n    }\n    return res;\n}\n\n// Strassen's matrix multiplication function\npublic static int[,] mult(int[,] arr, int[,] brr) {\n    int n = arr.GetLength(0);\n    int[,] res = new int[n, n];\n\n    // Base case\n    if (n == 1) {\n        res[0, 0] = arr[0, 0] * brr[0, 0];\n        return res;\n    }\n\n    int nwSz = n / 2; // New Size\n    int[,] a11 = new int[nwSz, nwSz];\n    int[,] a12 = new int[nwSz, nwSz];\n    int[,] a21 = new int[nwSz, nwSz];\n    int[,] a22 = new int[nwSz, nwSz];\n    int[,] b11 = new int[nwSz, nwSz];\n    int[,] b12 = new int[nwSz, nwSz];\n    int[,] b21 = new int[nwSz, nwSz];\n    int[,] b22 = new int[nwSz, nwSz];\n\n    // Splitting arr and brr into submatrices\n    for (int i = 0; i < nwSz; i++) {\n        for (int j = 0; j < nwSz; j++) {\n            a11[i, j] = arr[i, j];\n            a12[i, j] = arr[i, j + nwSz];\n            a21[i, j] = arr[i + nwSz, j];\n            a22[i, j] = arr[i + nwSz, j + nwSz];\n            b11[i, j] = brr[i, j];\n            b12[i, j] = brr[i, j + nwSz];\n            b21[i, j] = brr[i + nwSz, j];\n            b22[i, j] = brr[i + nwSz, j + nwSz];\n        }\n    }\n\n    // Strassen's seven multiplications\n    int[,] m1 = mult(add(a11, a22, nwSz, 1), add(b11, b22, nwSz, 1));\n    int[,] m2 = mult(add(a21, a22, nwSz, 1), b11);\n    int[,] m3 = mult(a11, add(b12, b22, nwSz, -1));\n    int[,] m4 = mult(a22, add(b21, b11, nwSz, -1));\n    int[,] m5 = mult(add(a11, a12, nwSz, 1), b22);\n    int[,] m6 = mult(add(a21, a11, nwSz, -1), add(b11, b12, nwSz, 1));\n    int[,] m7 = mult(add(a12, a22, nwSz, -1), add(b21, b22, nwSz, 1));\n\n    // Calculating result submatrices\n    int[,] c11 = add(add(m1, m4, nwSz, 1), add(m7, m5, nwSz, -1), nwSz);\n    int[,] c12 = add(m3, m5, nwSz, 1);\n    int[,] c21 = add(m2, m4, nwSz, 1);\n    int[,] c22 = add(add(m1, m3, nwSz, 1), add(m6, m2, nwSz, -1), nwSz);\n\n    // Copy results into result matrix\n    for (int i = 0; i < nwSz; i++) {\n        for (int j = 0; j < nwSz; j++) {\n            res[i, j] = c11[i, j];\n            res[i, j + nwSz] = c12[i, j];\n            res[i + nwSz, j] = c21[i, j];\n            res[i + nwSz, j + nwSz] = c22[i, j];\n        }\n    }\n\n    return res;\n}\n\npublic static void Main(string[] args) {\n    int[,] arr = {{7, 8}, {2, 9}};\n    int[,] brr = {{14, 5}, {5, 18}};\n    int[,] res = mult(arr, brr);\n\n    foreach (var row in res) {\n        Console.WriteLine(string.Join(\", \", row));\n    }\n}\n// Function to add or subtract two matrices\nfunction add(arr, brr, n, sign = 1) {\n    const res = Array.from({ length: n }, () => Array(n).fill(0));\n    for (let i = 0; i < n; i++) {\n        for (let j = 0; j < n; j++) {\n            res[i][j] = arr[i][j] + sign * brr[i][j];\n        }\n    }\n    return res;\n}\n\n// Strassen's matrix multiplication function\nfunction mult(arr, brr) {\n    const n = arr.length;\n    const res = Array.from({ length: n }, () => Array(n).fill(0));\n\n    // Base case\n    if (n === 1) {\n        res[0][0] = arr[0][0] * brr[0][0];\n        return res;\n    }\n\n    const nwSz = Math.floor(n / 2);  // New Size\n    const a11 = Array.from({ length: nwSz }, () => Array(nwSz).fill(0));\n    const a12 = Array.from({ length: nwSz }, () => Array(nwSz).fill(0));\n    const a21 = Array.from({ length: nwSz }, () => Array(nwSz).fill(0));\n    const a22 = Array.from({ length: nwSz }, () => Array(nwSz).fill(0));\n    const b11 = Array.from({ length: nwSz }, () => Array(nwSz).fill(0));\n    const b12 = Array.from({ length: nwSz }, () => Array(nwSz).fill(0));\n    const b21 = Array.from({ length: nwSz }, () => Array(nwSz).fill(0));\n    const b22 = Array.from({ length: nwSz }, () => Array(nwSz).fill(0));\n\n    // Splitting arr and brr into submatrices\n    for (let i = 0; i < nwSz; i++) {\n        for (let j = 0; j < nwSz; j++) {\n            a11[i][j] = arr[i][j];\n            a12[i][j] = arr[i][j + nwSz];\n            a21[i][j] = arr[i + nwSz][j];\n            a22[i][j] = arr[i + nwSz][j + nwSz];\n            b11[i][j] = brr[i][j];\n            b12[i][j] = brr[i][j + nwSz];\n            b21[i][j] = brr[i + nwSz][j];\n            b22[i][j] = brr[i + nwSz][j + nwSz];\n        }\n    }\n\n    // Strassen's seven multiplications\n    const m1 = mult(add(a11, a22, nwSz), add(b11, b22, nwSz));\n    const m2 = mult(add(a21, a22, nwSz), b11);\n    const m3 = mult(a11, add(b12, b22, nwSz, -1));\n    const m4 = mult(a22, add(b21, b11, nwSz, -1));\n    const m5 = mult(add(a11, a12, nwSz), b22);\n    const m6 = mult(add(a21, a11, nwSz, -1), add(b11, b12, nwSz));\n    const m7 = mult(add(a12, a22, nwSz, -1), add(b21, b22, nwSz));\n\n    // Calculating result submatrices\n    const c11 = add(add(m1, m4, nwSz), add(m7, m5, nwSz, -1), nwSz);\n    const c12 = add(m3, m5, nwSz);\n    const c21 = add(m2, m4, nwSz);\n    const c22 = add(add(m1, m3, nwSz), add(m6, m2, nwSz, -1), nwSz);\n\n    // Copy results into result matrix\n    for (let i = 0; i < nwSz; i++) {\n        for (let j = 0; j < nwSz; j++) {\n            res[i][j] = c11[i][j];\n            res[i][j + nwSz] = c12[i][j];\n            res[i + nwSz][j] = c21[i][j];\n            res[i + nwSz][j + nwSz] = c22[i][j];\n        }\n    }\n\n    return res;\n}\n\nconst arr = [[7, 8], [2, 9]];\nconst brr = [[14, 5], [5, 18]];\nconst res = mult(arr, brr);\n\nfor (const row of res) {\n    console.log(row.join(' '));\n}\n138 179 \n73 172\nT(n) = 7T(n/2) +  O(n2)From Master's Theorem, time complexity of above method is O(nLog7) which is approximately O(n2.8074)\n",
        "complexity": {
            "time": "Addition and Subtraction of two matrices takes O(N2) time. So time complexity can be written as",
            "space": ""
        },
        "tags": [
            "Divide and Conquer"
        ],
        "url": "https://www.geeksforgeeks.org/strassens-matrix-multiplication/"
    },
    {
        "title": "Karatsuba algorithm for fast multiplication using Divide and Conquer algorithm",
        "description": "Given two binary strings that represent value of two integers, find the product of two strings. For example, if the first bit string is “1100” and second bit string is “1010”, output should be 120. For simplicity, let the length of two strings be same and be n. A Naive Approach is to follow the process we study in school. One by one take all bits of second number and multiply it with all bits of first number. Finally add all multiplications. This algorithm takes O(n^2) time.  Using Divide and Conquer, we can multiply two integers in less time complexity. We divide the given numbers in two halves. Let the given numbers be X and Y. For simplicity let us assume that n is even The product XY can be written as follows. If we take a look at the above formula, there are four multiplications of size n/2, so we basically divided the problem of size n into four sub-problems of size n/2. But that doesn’t help because the solution of recurrence T(n) = 4T(n/2) + O(n) is O(n^2). The tricky part of this algorithm is to change the middle two terms to some other form so that only one extra multiplication would be sufficient. The following is tricky expression for middle two terms. So the final value of XY becomes With above trick, the recurrence becomes T(n) = 3T(n/2) + O(n) and solution of this recurrence is O(n1.59). What if the lengths of input strings are different and are not even? To handle the different length case, we append 0’s in the beginning. To handle odd length, we put floor(n/2) bits in left half and ceil(n/2) bits in right half. So the expression for XY changes to following. The above algorithm is called Karatsuba algorithm and it can be used for any base. Following is C++ implementation of above algorithm. Time Complexity: Time complexity of the above solution is O(nlog23) = O(n1.59).Time complexity of multiplication can be further improved using another Divide and Conquer algorithm, fast Fourier transform. We will soon be discussing fast Fourier transform as a separate post. Auxiliary Space: O(n) Exercise:The above program returns a long int value and will not work for big strings. Extend the above program to return a string instead of a long int value. Solution:Multiplication process for large numbers is an important problem in Computer Science. Given approach uses Divide and Conquer methodology. Run the code to see the time complexity comparison for normal Binary Multiplication and Karatsuba Algorithm. You can see the full code in this repository Examples: Time Complexity:The time complexity of both Classical and Karatsuba methods of binary string multiplication is O(n^2). In the classical method, the time complexity is O(n^2) because the loop is iterated n times. The time complexity of the addBinary() method is constant because the loop runs with a maximum of two iterations. In the Karatsuba method, the time complexity is O(n^2) because the ‘multiply’ method of the Karatsuba class is called recursively for each of the three products. The time complexity of the addStrings() method is constant because the loop runs with a maximum of two iterations. Auxiliary Space :The Auxiliary Space of both Classical and Karatsuba methods of binary string multiplication is O(n). In the classical method, the Auxiliary Space is O(n) because the loop is iterated n times and a single string is used to store the result. The space complexity of the addBinary() method is constant because the loop runs with a maximum of two iterations. In the Karatsuba method, the auxiliary Space is O(n) because the ‘multiply’ method of the Karatsuba class is called recursively for each of the three products. Related Article : Multiply Large Numbers Represented as Strings  ",
        "code": "X =  Xl*2n/2 + Xr    [Xl and Xr contain leftmost and rightmost n/2 bits of X]Y =  Yl*2n/2 + Yr    [Yl and Yr contain leftmost and rightmost n/2 bits of Y]\nXY = (Xl*2n/2 + Xr)(Yl*2n/2 + Yr)   = 2n XlYl + 2n/2(XlYr + XrYl) + XrYr\nXlYr + XrYl = (Xl + Xr)(Yl + Yr) - XlYl- XrYr\nXY = 2n XlYl + 2n/2 * [(Xl + Xr)(Yl + Yr) - XlYl - XrYr] + XrYr\nXY = 22ceil(n/2) XlYl + 2ceil(n/2) * [(Xl + Xr)(Yl + Yr) - XlYl - XrYr] + XrYr\n// C++ implementation of Karatsuba algorithm for bit string multiplication.\n#include<iostream>\n#include<stdio.h>\n\nusing namespace std;\n\n// FOLLOWING TWO FUNCTIONS ARE COPIED FROM http://goo.gl/q0OhZ\n// Helper method: given two unequal sized bit strings, converts them to\n// same length by adding leading 0s in the smaller string. Returns the\n// the new length\nint makeEqualLength(string &str1, string &str2)\n{\n    int len1 = str1.size();\n    int len2 = str2.size();\n    if (len1 < len2)\n    {\n        for (int i = 0 ; i < len2 - len1 ; i++)\n            str1 = '0' + str1;\n        return len2;\n    }\n    else if (len1 > len2)\n    {\n        for (int i = 0 ; i < len1 - len2 ; i++)\n            str2 = '0' + str2;\n    }\n    return len1; // If len1 >= len2\n}\n\n// The main function that adds two bit sequences and returns the addition\nstring addBitStrings( string first, string second )\n{\n    string result;  // To store the sum bits\n\n    // make the lengths same before adding\n    int length = makeEqualLength(first, second);\n    int carry = 0;  // Initialize carry\n\n    // Add all bits one by one\n    for (int i = length-1 ; i >= 0 ; i--)\n    {\n        int firstBit = first.at(i) - '0';\n        int secondBit = second.at(i) - '0';\n\n        // boolean expression for sum of 3 bits\n        int sum = (firstBit ^ secondBit ^ carry)+'0';\n\n        result = (char)sum + result;\n\n        // boolean expression for 3-bit addition\n        carry = (firstBit&secondBit) | (secondBit&carry) | (firstBit&carry);\n    }\n\n    // if overflow, then add a leading 1\n    if (carry)  result = '1' + result;\n\n    return result;\n}\n\n// A utility function to multiply single bits of strings a and b\nint multiplyiSingleBit(string a, string b)\n{  return (a[0] - '0')*(b[0] - '0');  }\n\n// The main function that multiplies two bit strings X and Y and returns\n// result as long integer\nlong int multiply(string X, string Y)\n{\n    // Find the maximum of lengths of x and Y and make length\n    // of smaller string same as that of larger string\n    int n = makeEqualLength(X, Y);\n\n    // Base cases\n    if (n == 0) return 0;\n    if (n == 1) return multiplyiSingleBit(X, Y);\n\n    int fh = n/2;   // First half of string, floor(n/2)\n    int sh = (n-fh); // Second half of string, ceil(n/2)\n\n    // Find the first half and second half of first string.\n    // Refer http://goo.gl/lLmgn for substr method\n    string Xl = X.substr(0, fh);\n    string Xr = X.substr(fh, sh);\n\n    // Find the first half and second half of second string\n    string Yl = Y.substr(0, fh);\n    string Yr = Y.substr(fh, sh);\n\n    // Recursively calculate the three products of inputs of size n/2\n    long int P1 = multiply(Xl, Yl);\n    long int P2 = multiply(Xr, Yr);\n    long int P3 = multiply(addBitStrings(Xl, Xr), addBitStrings(Yl, Yr));\n\n    // Combine the three products to get the final result.\n    return P1*(1<<(2*sh)) + (P3 - P1 - P2)*(1<<sh) + P2;\n}\n\n// Driver program to test above functions\nint main()\n{\n    printf (\"%ld\\n\", multiply(\"1100\", \"1010\"));\n    printf (\"%ld\\n\", multiply(\"110\", \"1010\"));\n    printf (\"%ld\\n\", multiply(\"11\", \"1010\"));\n    printf (\"%ld\\n\", multiply(\"1\", \"1010\"));\n    printf (\"%ld\\n\", multiply(\"0\", \"1010\"));\n    printf (\"%ld\\n\", multiply(\"111\", \"111\"));\n    printf (\"%ld\\n\", multiply(\"11\", \"11\"));\n}\n// Java implementation of Karatsuba algorithm for bit string multiplication.\n\npublic class GFG {\n      // Driver Code\n    public static void main(String[] args)\n    {\n        System.out.println(multiply(\"1100\", \"1010\"));\n        System.out.println(multiply(\"110\", \"1010\"));\n        System.out.println(multiply(\"11\", \"1010\"));\n        System.out.println(multiply(\"1\", \"1010\"));\n        System.out.println(multiply(\"0\", \"1010\"));\n        System.out.println(multiply(\"111\", \"111\"));\n        System.out.println(multiply(\"11\", \"11\"));\n    }\n  \n    // Helper method: given two unequal sized bit strings,\n    // converts them to same length by adding leading 0s in\n    // the smaller string. Returns the new length\n    private static int makeEqualLength(StringBuilder str1,\n                                       StringBuilder str2)\n    {\n        int len1 = str1.length();\n        int len2 = str2.length();\n        if (len1 < len2) {\n            for (int i = 0; i < len2 - len1; i++) {\n                str1.insert(0, '0');\n            }\n            return len2;\n        }\n        else if (len1 > len2) {\n            for (int i = 0; i < len1 - len2; i++) {\n                str2.insert(0, '0');\n            }\n        }\n        return len1; // If len1 >= len2\n    }\n\n    // The main function that adds two bit sequences and\n    // returns the addition\n    private static StringBuilder\n    addBitStrings(StringBuilder first, StringBuilder second)\n    {\n        StringBuilder result = new StringBuilder();\n        int length = makeEqualLength(first, second);\n        int carry = 0;\n\n        // Add all bits one by one\n        for (int i = length - 1; i >= 0; i--) {\n            int firstBit = first.charAt(i) - '0';\n            int secondBit = second.charAt(i) - '0';\n\n            // boolean expression for sum of 3 bits\n            int sum = (firstBit ^ secondBit ^ carry) + '0';\n            result.insert(0, (char)sum);\n\n            // boolean expression for 3-bit addition\n            carry = (firstBit & secondBit)\n                    | (secondBit & carry)\n                    | (firstBit & carry);\n        }\n\n        // if overflow, then add a leading 1\n        if (carry == 1) {\n            result.insert(0, '1');\n        }\n\n        return result;\n    }\n\n    // A utility function to multiply single bits of strings\n    // a and b\n    private static int multiplySingleBit(int a, int b)\n    {\n        return a * b;\n    }\n\n    // The main function that multiplies two bit strings X\n    // and Y and returns result as long integer\n    public static long multiply(String X, String Y)\n    {\n        // Find the maximum of lengths of X and Y and make\n        // length of smaller string same as that of larger\n        // string\n        int n = Math.max(X.length(), Y.length());\n        X = String.format(\"%\" + n + \"s\", X)\n                .replace(' ', '0');\n        Y = String.format(\"%\" + n + \"s\", Y)\n                .replace(' ', '0');\n\n        // Base cases\n        if (n == 0)\n            return 0;\n        if (n == 1)\n            return Integer.parseInt(X)\n                * Integer.parseInt(Y);\n\n        int fh = n / 2; // First half of string\n        int sh = n - fh; // Second half of string\n\n        // Find the first half and second half of first\n        // string.\n        String Xl = X.substring(0, fh);\n        String Xr = X.substring(fh);\n\n        // Find the first half and second half of second\n        // string\n        String Yl = Y.substring(0, fh);\n        String Yr = Y.substring(fh);\n\n        // Recursively calculate the three products of\n        // inputs of size n/2\n        long P1 = multiply(Xl, Yl);\n        long P2 = multiply(Xr, Yr);\n        long P3 = multiply(Integer.toBinaryString(\n                               Integer.parseInt(Xl, 2)\n                               + Integer.parseInt(Xr, 2)),\n                           Integer.toBinaryString(\n                               Integer.parseInt(Yl, 2)\n                               + Integer.parseInt(Yr, 2)));\n\n        // Combine the three products to get the final\n        // result.\n        return P1 * (1L << (2 * sh))\n            + (P3 - P1 - P2) * (1L << sh) + P2;\n    }\n}\n# Python implementation of Karatsuba algorithm for bit string multiplication.\n\n# Helper method: given two unequal sized bit strings, converts them to\n# same length by adding leading 0s in the smaller string. Returns the\n# the new length\ndef make_equal_length(str1, str2):\n    len1 = len(str1)\n    len2 = len(str2)\n    if len1 < len2:\n        for i in range(len2 - len1):\n            str1 = '0' + str1\n        return len2\n    elif len1 > len2:\n        for i in range(len1 - len2):\n            str2 = '0' + str2\n    return len1 # If len1 >= len2\n\n# The main function that adds two bit sequences and returns the addition\ndef add_bit_strings(first, second):\n    result = \"\"  # To store the sum bits\n\n    # make the lengths same before adding\n    length = make_equal_length(first, second)\n    carry = 0  # Initialize carry\n\n    # Add all bits one by one\n    for i in range(length-1, -1, -1):\n        first_bit = int(first[i])\n        second_bit = int(second[i])\n\n        # boolean expression for sum of 3 bits\n        sum = (first_bit ^ second_bit ^ carry) + ord('0')\n\n        result = chr(sum) + result\n\n        # boolean expression for 3-bit addition\n        carry = (first_bit & second_bit) | (second_bit & carry) | (first_bit & carry)\n\n    # if overflow, then add a leading 1\n    if carry:\n        result = '1' + result\n\n    return result\n\n# A utility function to multiply single bits of strings a and b\ndef multiply_single_bit(a, b):\n    return int(a[0]) * int(b[0])\n\n# The main function that multiplies two bit strings X and Y and returns\n# result as long integer\ndef multiply(X, Y):\n    # Find the maximum of lengths of x and Y and make length\n    # of smaller string same as that of larger string\n    n = max(len(X), len(Y))\n    X = X.zfill(n)\n    Y = Y.zfill(n)\n\n    # Base cases\n    if n == 0: return 0\n    if n == 1: return int(X[0])*int(Y[0])\n\n    fh = n//2  # First half of string\n    sh = n - fh  # Second half of string\n\n    # Find the first half and second half of first string.\n    Xl = X[:fh]\n    Xr = X[fh:]\n\n    # Find the first half and second half of second string\n    Yl = Y[:fh]\n    Yr = Y[fh:]\n\n    # Recursively calculate the three products of inputs of size n/2\n    P1 = multiply(Xl, Yl)\n    P2 = multiply(Xr, Yr)\n    P3 = multiply(str(int(Xl, 2) + int(Xr, 2)), str(int(Yl, 2) + int(Yr, 2)))\n\n    # Combine the three products to get the final result.\n    return P1*(1<<(2*sh)) + (P3 - P1 - P2)*(1<<sh) + P2\n\nif __name__ == '__main__':\n    print(multiply(\"1100\", \"1010\"))\n    print(multiply(\"110\", \"1010\"))\n    print(multiply(\"11\", \"1010\"))\n    print(multiply(\"1\", \"1010\"))\n    print(multiply(\"0\", \"1010\"))\n    print(multiply(\"111\", \"111\"))\n    print(multiply(\"11\", \"11\"))\n// C# implementation of Karatsuba algorithm for bit string\n// multiplication.\nusing System;\nusing System.Collections.Generic;\n\nclass GFG {\n\n  // Convert bit strings to same length by adding leading\n  // 0s in the smaller string.\n  // Returns the new length.\n  private static int MakeEqualLength(ref string str1,\n                                     ref string str2)\n  {\n    int len1 = str1.Length;\n    int len2 = str2.Length;\n    if (len1 < len2) {\n      str1 = str1.PadLeft(len2 - len1 + len1, '0');\n      return len2;\n    }\n    else if (len1 > len2) {\n      str2 = str2.PadLeft(len1 - len2 + len2, '0');\n    }\n    return len1; // If len1 >= len2\n  }\n\n  // Adds two bit sequences and returns the addition\n  private static string AddBitStrings(string first,\n                                      string second)\n  {\n    string result = \"\"; // To store the sum bits\n\n    // make the lengths same before adding\n    int length = MakeEqualLength(ref first, ref second);\n    int carry = 0; // Initialize carry\n\n    // Add all bits one by one\n    for (int i = length - 1; i >= 0; i--) {\n      int first_bit = int.Parse(first[i].ToString());\n      int second_bit\n        = int.Parse(second[i].ToString());\n\n      // boolean expression for sum of 3 bits\n      int sum\n        = (first_bit ^ second_bit ^ carry) + '0';\n\n      result = (char)sum + result;\n\n      // boolean expression for 3-bit addition\n      carry = (first_bit & second_bit)\n        | (second_bit & carry)\n        | (first_bit & carry);\n    }\n\n    // if overflow, then add a leading 1\n    if (carry != 0) {\n      result = '1' + result;\n    }\n\n    return result;\n  }\n\n  // Multiplies single bits of strings a and b\n  private static int MultiplySingleBit(char a, char b)\n  {\n    return int.Parse(a.ToString())\n      * int.Parse(b.ToString());\n  }\n\n  // Multiplies two bit strings X and Y and returns result\n  // as long integer\n  private static long Multiply(string X, string Y)\n  {\n    // Find the maximum of lengths of x and Y and make\n    // length of smaller string same as that of larger\n    // string\n    int n = Math.Max(X.Length, Y.Length);\n    X = X.PadLeft(n, '0');\n    Y = Y.PadLeft(n, '0');\n\n    // Base cases\n    if (n == 0)\n      return 0;\n    if (n == 1)\n      return MultiplySingleBit(X[0], Y[0]);\n\n    int fh = n / 2; // First half of string\n    int sh = n - fh; // Second half of string\n\n    // Find the first half and second half of first\n    // string.\n    string Xl = X.Substring(0, fh);\n    string Xr = X.Substring(fh);\n\n    // Find the first half and second half of second\n    // string\n    string Yl = Y.Substring(0, fh);\n    string Yr = Y.Substring(fh);\n\n    // Recursively calculate the three products of\n    // inputs of size n/2\n    long P1 = Multiply(Xl, Yl);\n    long P2 = Multiply(Xr, Yr);\n    long P3 = Multiply(AddBitStrings(Xl, Xr),\n                       AddBitStrings(Yl, Yr));\n\n    // Combine the three products to get the final\n    // result.\n    return P1 * (1L << (2 * sh))\n      + (P3 - P1 - P2) * (1L << sh) + P2;\n  }\n\n  // Test the implementation\n  public static void Main(string[] args)\n  {\n    Console.WriteLine(Multiply(\"1100\", \"1010\"));\n    Console.WriteLine(Multiply(\"110\", \"1010\"));\n    Console.WriteLine(Multiply(\"11\", \"1010\"));\n    Console.WriteLine(Multiply(\"1\", \"1010\"));\n    Console.WriteLine(Multiply(\"0\", \"1010\"));\n    Console.WriteLine(Multiply(\"111\", \"111\"));\n    Console.WriteLine(Multiply(\"11\", \"11\"));\n  }\n}\n// JavaScript implementation of Karatsuba algorithm for bit string multiplication.\n\n// Helper method: given two unequal sized bit strings, converts them to\n// same length by adding leading 0s in the smaller string. Returns the\n// the new length\nfunction make_equal_length(str1, str2) {\n    let len1 = str1.length;\n    let len2 = str2.length;\n    if (len1 < len2) {\n        for (let i = 0; i < len2 - len1; i++) {\n            str1 = '0' + str1;\n        }\n        return len2;\n    } else if (len1 > len2) {\n        for (let i = 0; i < len1 - len2; i++) {\n            str2 = '0' + str2;\n        }\n    }\n    return len1; // If len1 >= len2\n}\n\n// The main function that adds two bit sequences and returns the addition\nfunction add_bit_strings(first, second) {\n    let result = \"\"; // To store the sum bits\n\n    // make the lengths same before adding\n    let length = make_equal_length(first, second);\n    let carry = 0; // Initialize carry\n\n    // Add all bits one by one\n    for (let i = length - 1; i >= 0; i--) {\n        let first_bit = parseInt(first[i]);\n        let second_bit = parseInt(second[i]);\n\n        // boolean expression for sum of 3 bits\n        let sum = (first_bit ^ second_bit ^ carry) + '0'.charCodeAt(0);\n\n        result = String.fromCharCode(sum) + result;\n\n        // boolean expression for 3-bit addition\n        carry = (first_bit & second_bit) | (second_bit & carry) | (first_bit & carry);\n    }\n\n    // if overflow, then add a leading 1\n    if (carry) {\n        result = '1' + result;\n    }\n\n    return result;\n}\n\n// A utility function to multiply single bits of strings a and b\nfunction multiply_single_bit(a, b) {\n    return parseInt(a[0]) * parseInt(b[0]);\n}\n\n// The main function that multiplies two bit strings X and Y and returns\n// result as long integer\nfunction multiply(X, Y) {\n    // Find the maximum of lengths of x and Y and make length\n    // of smaller string same as that of larger string\n    let n = Math.max(X.length, Y.length);\n    X = X.padStart(n, '0');\n    Y = Y.padStart(n, '0');\n\n\n    // Base cases\n    if (n == 0) return 0;\n    if (n == 1) return parseInt(X[0]) * parseInt(Y[0]);\n\n    let fh = Math.floor(n / 2); // First half of string\n    let sh = n - fh; // Second half of string\n\n    // Find the first half and second half of first string.\n    let Xl = X.slice(0, fh);\n    let Xr = X.slice(fh);\n\n    // Find the first half and second half of second string\n    let Yl = Y.slice(0, fh);\n    let Yr = Y.slice(fh);\n\n    // Recursively calculate the three products of inputs of size n/2\n    let P1 = multiply(Xl, Yl);\n    let P2 = multiply(Xr, Yr);\n    let P3 = multiply((parseInt(Xl, 2) + parseInt(Xr, 2)).toString(2), (parseInt(Yl, 2) + parseInt(Yr, 2)).toString(2));\n\n    // Combine the three products to get the final result.\n    return P1 * (1 << (2 * sh)) + (P3 - P1 - P2) * (1 << sh) + P2\n}\n\nconsole.log(multiply(\"1100\", \"1010\"))\nconsole.log(multiply(\"110\", \"1010\"))\nconsole.log(multiply(\"11\", \"1010\"))\nconsole.log(multiply(\"1\", \"1010\"))\nconsole.log(multiply(\"0\", \"1010\"))\nconsole.log(multiply(\"111\", \"111\"))\nconsole.log(multiply(\"11\", \"11\"))\n120\n60\n30\n10\n0\n49\n9\nFirst Binary Input : 101001010101010010101001010100101010010101010010101 Second Binary Input : 101001010101010010101001010100101010010101010010101Decimal Output : Not Representable Output : 2.1148846e+30\nFirst Binary Input : 1011 Second Binary Input : 1000Decimal Output : 88Output : 5e-05\n#include <iostream>\n#include <ctime>\n#include <fstream>\n#include <string.h>\n#include <cmath>\n#include <sstream>\n\nusing namespace std;\n\n// classical method class\nclass BinaryMultiplier\n{\npublic:\n    string MakeMultiplication(string,string);      \n    string MakeShifting(string,int);               \n    string addBinary(string,string);\n    void BinaryStringToDecimal(string);\n};\n\n// karatsuba method class\nclass Karatsuba\n{\npublic:\n    int lengthController(string &,string &);\n    string addStrings(string,string);\n    string multiply(string,string);\n    string DecimalToBinary(long long int);\n    string Subtraction(string,string);\n    string MakeShifting(string,int);\n};\n\n// this function get strings and go over str2 bit \n// if it sees 1  it calculates the shifted version according to position bit\n// Makes add operation for binary strings\n// returns result string\nstring BinaryMultiplier::MakeMultiplication(string str1, string str2)\n{\n    string allSum = \"\";\n    for (int j = 0 ; j<str2.length(); j++)\n    {\n        int secondDigit = str2[j] - '0';\n        if (secondDigit == 1)\n        {\n            string shifted = MakeShifting(str1,str2.size()-(j+1));\n            allSum = addBinary(shifted, allSum);\n        }\n        else\n        {\n            continue;\n        }\n        \n    }\n    return allSum;\n}\n\n\n// this function adds binary strings with carry\nstring BinaryMultiplier::addBinary(string a, string b)\n{\n    string result = \"\"; \n    int s = 0;\n    \n    int i = a.size() - 1;\n    int j = b.size() - 1;\n    while (i >= 0 || j >= 0 || s == 1)\n    {\n        s += ((i >= 0)? a[i] - '0': 0);\n        s += ((j >= 0)? b[j] - '0': 0);\n        \n        result = char(s % 2 + '0') + result;\n        \n        s /= 2;\n    \n        i--;\n        j--;\n    }\n    return result;\n}\n\n// this function shifts the given string according to given number\n// returns shifted version \nstring BinaryMultiplier::MakeShifting(string str, int stepnum)\n{\n    string shifted = str;\n    for (int i = 0 ; i < stepnum ; i++)\n        shifted = shifted + '0';\n    return shifted;\n}\n\n// this function converts Binary String Number to Decimal Number\n// After 32 bits it gives 0 because it overflows the size of int\nvoid BinaryMultiplier::BinaryStringToDecimal(string result)\n{\n    cout<<\"Binary Result : \"<<result<<endl;\n    unsigned long long int val = 0;\n    for (int i = result.length()-1; i >= 0; i--)\n    {\n        if (result[i] == '1')\n        {\n            val += pow(2,(result.length()-1)-i);\n        }\n    }\n    cout<<\"Decimal Result (Not proper for Large Binary Numbers):\" <<val<<endl;\n}\n\n// this function controls lengths of strings and make their lengths equal\n// returns the maximum length\nint Karatsuba::lengthController(string &str1, string &str2)\n{\n    int len1 = str1.size();\n    int len2 = str2.size();\n    if (len1 < len2)\n    {\n        for (int i = 0 ; i < len2 - len1 ; i++)\n            str1 = '0' + str1;\n        return len2;\n    }\n    else if (len1 > len2)\n    {\n        for (int i = 0 ; i < len1 - len2 ; i++)\n            str2 = '0' + str2;\n    }\n    return len1;\n}\n\n// this function add strings with carry \n// uses one by one bit addition methodology\n// returns result string\nstring Karatsuba::addStrings(string first, string second)\n{\n    string result;  // To store the sum bits\n    \n    // make the lengths same before adding\n    int length = lengthController(first, second);\n    int carry = 0;  // Initialize carry\n    \n    // Add all bits one by one\n    for (int i = length-1 ; i >= 0 ; i--)\n    {\n        int firstBit = first.at(i) - '0';\n        int secondBit = second.at(i) - '0';\n        \n        // boolean expression for sum of 3 bits\n        int sum = (firstBit ^ secondBit ^ carry)+'0';\n        \n        result = (char)sum + result;\n        \n        // Boolean expression for 3-bit addition\n        carry = (firstBit&secondBit) | (secondBit&carry) | (firstBit&carry);\n    }\n    \n    // if overflow, then add a leading 1\n    if (carry)\n    {\n        result = '1' + result;\n    }\n    \n    return result;\n}\n\n// this function converts decimal number to binary string\nstring Karatsuba::DecimalToBinary(long long int number)\n{\n    string result = \"\";\n    if (number <= 0)\n    {\n        return \"0\";\n    }\n    else\n    {\n        int i = 0;\n        while (number > 0)\n        {\n            \n            long long int num= number % 2;\n            stringstream ss;\n            ss<<num;\n            result = ss.str() + result;\n            number = number / 2;\n            i++;\n        }\n        return result;\n        \n    }\n}\n\n// this function makes binary string subtraction with overflow\nstring Karatsuba::Subtraction(string lhs, string rhs)\n{\n    \n    int length = lengthController(lhs, rhs);\n    int diff;\n    string result;\n    \n    for (int i = length-1; i >= 0; i--)\n    {\n        diff = (lhs[i]-'0') - (rhs[i]-'0');\n        if (diff >= 0)\n        {\n            result = DecimalToBinary(diff) + result;\n        }\n        else\n        {\n            for (int j = i-1; j>=0; j--)\n            {\n                lhs[j] = ((lhs[j]-'0') - 1) % 10 + '0';\n                if (lhs[j] != '1')\n                {\n                    break;\n                }\n            }\n            result = DecimalToBinary(diff+2) + result;\n        }\n    }\n    return result;\n}\n\n// this function makes shifting\nstring Karatsuba::MakeShifting(string str, int stepnum)\n{\n    string shifted = str;\n    for (int i = 0 ; i < stepnum ; i++)\n        shifted = shifted + '0';\n    return shifted;\n}\n\n// this function is the core of the Karatsuba \n// divides problem into 4 subproblems\n// recursively multiplies them\n// returns the result string\nstring Karatsuba::multiply(string X,  string Y)\n{\n    int n = lengthController(X, Y);\n    \n    if (n == 1) return ((Y[0]-'0' == 1) && (X[0]-'0' == 1)) ? \"1\" : \"0\";\n    \n    int fh = n/2;   // First half of string, floor(n/2)\n    int sh = (n-fh); // Second half of string, ceil(n/2)\n    \n    // Find the first half and second half of first string.\n    string Xl = X.substr(0, fh);\n    string Xr = X.substr(fh, sh);\n    \n    // Find the first half and second half of second string\n    string Yl = Y.substr(0, fh);\n    string Yr = Y.substr(fh, sh);\n    \n    // Recursively calculate the three products of inputs of size n/2\n    string P1 = multiply(Xl, Yl);\n    string P2 = multiply(Xr, Yr);\n    string P3 = multiply(addStrings(Xl, Xr), addStrings(Yl, Yr));\n    \n    // return added string version\n    return addStrings(addStrings(MakeShifting(P1, 2*(n-n/2)),P2),MakeShifting(Subtraction(P3,addStrings(P1,P2)), n-(n/2)));\n}\n\n\nint main(int argc, const char * argv[])\n{\n    // get the binary numbers as strings\n    string firstNumber,secondNumber;\n  \n    cout<<\"Please give the First Binary number : \";\n    cin>>firstNumber;\n    cout<<endl<<\"Please give the Second Binary number : \";\n    cin>>secondNumber;\n    cout << endl;\n    \n\n    // make the initial lengths equal by adding zeros\n    int len1 = firstNumber.size();\n    int len2 = secondNumber.size();\n    int general_len = firstNumber.size();\n    \n    if (len1 < len2)\n    {\n        for (int i = 0 ; i < len2 - len1 ; i++)\n            firstNumber = '0' + firstNumber;\n        general_len = firstNumber.size();\n    }\n    else if (len1 > len2)\n    {\n        for (int i = 0 ; i < len1 - len2 ; i++)\n            secondNumber = '0' + secondNumber;\n        general_len = secondNumber.size();\n    }\n    \n    // In classical methodology Binary String Multiplication\n    cout<<\"Classical Algorithm : \"<<endl;\n    BinaryMultiplier newobj;\n    const clock_t classical_time = clock();\n    string classic = newobj.MakeMultiplication(firstNumber, secondNumber);\n    cout << float( clock () - classical_time ) /  CLOCKS_PER_SEC<<endl<<endl;\n    float c_time = float( clock () - classical_time ) /  CLOCKS_PER_SEC;\n    newobj.BinaryStringToDecimal(classic);\n    \n    // Using Karatsuba Multiplication Algorithm Binary String Multiplication\n    cout<<endl<<\"Karatsuba Algorithm : \"<<endl;\n    Karatsuba obj;\n    const clock_t karatsuba_time = clock();\n    string karatsuba = obj.multiply(firstNumber, secondNumber);\n    cout << float( clock () - karatsuba_time ) /  CLOCKS_PER_SEC<<endl<<endl;\n    float k_time = float( clock () - classical_time ) /  CLOCKS_PER_SEC;\n    newobj.BinaryStringToDecimal(karatsuba);\n    \n    return 0;\n}\nimport java.math.BigInteger;\n\npublic class BinaryMultiplication {\n\n    // Method to add binary strings\n    public static String addBinary(String a, String b) {\n        BigInteger aBigInt = new BigInteger(a, 2);\n        BigInteger bBigInt = new BigInteger(b, 2);\n        BigInteger sum = aBigInt.add(bBigInt);\n        return sum.toString(2);\n    }\n\n    // Method to shift binary string\n    public static String shiftLeft(String str, int n) {\n        return str + \"0\".repeat(n);\n    }\n\n    // Classical binary multiplication\n    public static String classicalMultiply(String str1, String str2) {\n        String result = \"0\";\n        int n = str2.length();\n        for (int i = 0; i < n; i++) {\n            if (str2.charAt(n - 1 - i) == '1') {\n                result = addBinary(result, shiftLeft(str1, i));\n            }\n        }\n        return result;\n    }\n\n    // Karatsuba multiplication\n    public static String karatsubaMultiply(String X, String Y) {\n        int n = Math.max(X.length(), Y.length());\n\n        // Make the lengths equal\n        X = String.format(\"%\" + n + \"s\", X).replace(' ', '0');\n        Y = String.format(\"%\" + n + \"s\", Y).replace(' ', '0');\n\n        if (n == 1) {\n            return Integer.toString(Integer.parseInt(X) * Integer.parseInt(Y));\n        }\n\n        int m = n / 2;\n\n        String Xl = X.substring(0, m);\n        String Xr = X.substring(m);\n        String Yl = Y.substring(0, m);\n        String Yr = Y.substring(m);\n\n        String P1 = karatsubaMultiply(Xl, Yl);\n        String P2 = karatsubaMultiply(Xr, Yr);\n        String P3 = karatsubaMultiply(addBinary(Xl, Xr), addBinary(Yl, Yr));\n\n        String C1 = shiftLeft(P1, 2 * (n - m));\n        String C2 = shiftLeft(addBinary(subtractBinary(P3, addBinary(P1, P2)), P2), n - m);\n\n        return addBinary(addBinary(C1, C2), P2);\n    }\n\n    // Subtract binary strings\n    public static String subtractBinary(String a, String b) {\n        BigInteger aBigInt = new BigInteger(a, 2);\n        BigInteger bBigInt = new BigInteger(b, 2);\n        BigInteger difference = aBigInt.subtract(bBigInt);\n        return difference.toString(2);\n    }\n\n    public static void main(String[] args) {\n        String firstNumber = \"011011010100\";\n        String secondNumber = \"10111010111\";\n\n        System.out.println(\"Classical Algorithm:\");\n        String classicResult = classicalMultiply(firstNumber, secondNumber);\n        System.out.println(\"Binary Result: \" + classicResult);\n        System.out.println(\"Decimal Result: \" + new BigInteger(classicResult, 2).toString(10));\n\n        System.out.println(\"Karatsuba Algorithm:\");\n        String karatsubaResult = karatsubaMultiply(firstNumber, secondNumber);\n        System.out.println(\"Binary Result: \" + karatsubaResult);\n        System.out.println(\"Decimal Result: \" + new BigInteger(karatsubaResult, 2).toString(10));\n    }\n}\n# Importing required module\nimport math\n\ndef addBinary(a, b):\n    a_bigint = int(a, 2)\n    b_bigint = int(b, 2)\n    result = bin(a_bigint + b_bigint)[2:]\n    return result\n\ndef shiftLeft(string, n):\n    return string + '0' * n\n\ndef classicalMultiply(str1, str2):\n    result = '0'\n    n = len(str2)\n    for i in range(n):\n        if str2[n - 1 - i] == '1':\n            result = addBinary(result, shiftLeft(str1, i))\n    return result\n\ndef karatsubaMultiply(X, Y):\n    n = max(len(X), len(Y))\n\n    # Make the lengths equal\n    X = X.rjust(n, '0')\n    Y = Y.rjust(n, '0')\n\n    if n == 1:\n        return bin(int(X, 2) * int(Y, 2))[2:]\n\n    m = n // 2\n\n    Xl = X[:m]\n    Xr = X[m:]\n    Yl = Y[:m]\n    Yr = Y[m:]\n\n    P1 = karatsubaMultiply(Xl, Yl)\n    P2 = karatsubaMultiply(Xr, Yr)\n    P3 = karatsubaMultiply(addBinary(Xl, Xr), addBinary(Yl, Yr))\n\n    C1 = shiftLeft(P1, 2 * (n - m))\n    C2 = shiftLeft(addBinary(subtractBinary(P3, addBinary(P1, P2)), P2), n - m)\n\n    return addBinary(addBinary(C1, C2), P2)\n\ndef subtractBinary(a, b):\n    a_bigint = int(a, 2)\n    b_bigint = int(b, 2)\n    result = bin(a_bigint - b_bigint & (2 ** (max(len(a), len(b))) - 1))[2:]\n    return result\n\nif __name__ == \"__main__\":\n    # Given binary numbers\n    first_number = \"011011010100\"\n    second_number = \"10111010111\"\n\n    # Classical Algorithm\n    print(\"Classical Algorithm:\")\n    classic_result = classicalMultiply(first_number, second_number)\n    print(\"Binary Result:\", classic_result)\n    print(\"Decimal Result:\", int(classic_result, 2))\n\n    # Karatsuba Algorithm\n    print(\"\\nKaratsuba Algorithm:\")\n    karatsuba_result = karatsubaMultiply(first_number, second_number)\n    print(\"Binary Result:\", karatsuba_result)\n    print(\"Decimal Result:\", int(karatsuba_result, 2))\nusing System;\nusing System.Text;\n\n// Class for classical binary multiplication\nclass BinaryMultiplier\n{\n    public string MakeMultiplication(string str1, string str2)\n    {\n        string allSum = \"\";\n        // Iterate through each bit of the second binary string\n        for (int j = 0; j < str2.Length; j++)\n        {\n            int secondDigit = int.Parse(str2[j].ToString());\n            if (secondDigit == 1)\n            {\n                // Shift the first binary string and add it to the result\n                string shifted = MakeShifting(str1, str2.Length - (j + 1));\n                allSum = AddBinary(shifted, allSum);\n            }\n        }\n        return allSum;\n    }\n\n    // Function to add binary strings with carry\n    public string AddBinary(string a, string b)\n    {\n        string result = \"\";\n        int s = 0;\n\n        int i = a.Length - 1;\n        int j = b.Length - 1;\n        while (i >= 0 || j >= 0 || s == 1)\n        {\n            s += (i >= 0) ? int.Parse(a[i].ToString()) : 0;\n            s += (j >= 0) ? int.Parse(b[j].ToString()) : 0;\n\n            result = (s % 2).ToString() + result;\n\n            s /= 2;\n\n            i--;\n            j--;\n        }\n        return result;\n    }\n\n    // Function to shift a binary string to the left by a given number of steps\n    public string MakeShifting(string str, int stepnum)\n    {\n        string shifted = str;\n        for (int i = 0; i < stepnum; i++)\n        {\n            shifted += '0';\n        }\n        return shifted;\n    }\n\n    // Function to convert binary string to decimal number\n    public void BinaryStringToDecimal(string result)\n    {\n        Console.WriteLine(\"Binary Result: \" + result);\n        int val = 0;\n        for (int i = result.Length - 1; i >= 0; i--)\n        {\n            if (result[i] == '1')\n            {\n                val += (int)Math.Pow(2, (result.Length - 1) - i);\n            }\n        }\n        Console.WriteLine(\"Decimal Result (Not proper for Large Binary Numbers):\" + val);\n    }\n}\n\n// Class for Karatsuba binary multiplication\nclass Karatsuba\n{\n    // Function to control the lengths of binary strings and make their lengths equal\n    public int LengthController(ref string str1, ref string str2)\n    {\n        int len1 = str1.Length;\n        int len2 = str2.Length;\n        if (len1 < len2)\n        {\n            str1 = new string('0', len2 - len1) + str1;\n            return len2;\n        }\n        else if (len1 > len2)\n        {\n            str2 = new string('0', len1 - len2) + str2;\n        }\n        return len1;\n    }\n\n    // Function to add binary strings with carry\n    public string AddStrings(string first, string second)\n    {\n        string result = \"\";\n        int length = LengthController(ref first, ref second);\n        int carry = 0;\n        for (int i = length - 1; i >= 0; i--)\n        {\n            int firstBit = int.Parse(first[i].ToString());\n            int secondBit = int.Parse(second[i].ToString());\n\n            int sum = (firstBit ^ secondBit ^ carry);\n            result = sum.ToString() + result;\n\n            carry = (firstBit & secondBit) | (secondBit & carry) | (firstBit & carry);\n        }\n\n        if (carry != 0)\n        {\n            result = '1' + result;\n        }\n\n        return result;\n    }\n\n    // Function to convert decimal number to binary string\n    public string DecimalToBinary(int number)\n    {\n        string result = \"\";\n        if (number <= 0)\n        {\n            return \"0\";\n        }\n        else\n        {\n            while (number > 0)\n            {\n                int num = number % 2;\n                result = num.ToString() + result;\n                number /= 2;\n            }\n            return result;\n        }\n    }\n\n    // Function to perform binary string subtraction with overflow\n    public string Subtraction(string lhs, string rhs)\n    {\n        int length = LengthController(ref lhs, ref rhs);\n        int diff;\n        StringBuilder resultBuilder = new StringBuilder();\n\n        for (int i = length - 1; i >= 0; i--)\n        {\n            int lhsDigit, rhsDigit;\n            if (!int.TryParse(lhs[i].ToString(), out lhsDigit) || !int.TryParse(rhs[i].ToString(), out rhsDigit))\n            {\n                // Handle parsing error, e.g., throw an exception or set a default value\n                throw new FormatException(\"Error parsing integer from string.\");\n            }\n\n            diff = lhsDigit - rhsDigit;\n            if (diff >= 0)\n            {\n                resultBuilder.Insert(0, DecimalToBinary(diff));\n            }\n            else\n            {\n                for (int j = i - 1; j >= 0; j--)\n                {\n                    int currentValue = lhs[j] - '0';\n                    if (currentValue > 0)\n                    {\n                        lhs = lhs.Remove(j, 1).Insert(j, (currentValue - 1).ToString());\n                        break;\n                    }\n                }\n                resultBuilder.Insert(0, DecimalToBinary(diff + 2));\n            }\n        }\n        return resultBuilder.ToString();\n    }\n\n    // Function to shift a binary string to the left by a given number of steps\n    public string MakeShifting(string str, int stepnum)\n    {\n        string shifted = str;\n        for (int i = 0; i < stepnum; i++)\n        {\n            shifted += '0';\n        }\n        return shifted;\n    }\n\n    // Function that is the core of the Karatsuba algorithm\n    public string Multiply(string X, string Y)\n    {\n        int n = LengthController(ref X, ref Y);\n\n        if (n == 1)\n            return ((int.Parse(Y[0].ToString()) == 1) && (int.Parse(X[0].ToString()) == 1)) ? \"1\" : \"0\";\n\n        int fh = n / 2;\n        int sh = n - fh;\n\n        string Xl = X.Substring(0, fh);\n        string Xr = X.Substring(fh, sh);\n\n        string Yl = Y.Substring(0, fh);\n        string Yr = Y.Substring(fh, sh);\n\n        Karatsuba karatsuba = new Karatsuba();\n        string P1 = karatsuba.Multiply(Xl, Yl);\n        string P2 = karatsuba.Multiply(Xr, Yr);\n        string P3 = karatsuba.Multiply(karatsuba.AddStrings(Xl, Xr), karatsuba.AddStrings(Yl, Yr));\n\n        return karatsuba.AddStrings(\n            karatsuba.AddStrings(karatsuba.MakeShifting(P1, 2 * (n - n / 2)), P2),\n            karatsuba.MakeShifting(karatsuba.Subtraction(P3, karatsuba.AddStrings(P1, P2)), n - (n / 2))\n        );\n    }\n}\n\nclass Program\n{\n    static void Main()\n    {\n        /*Console.WriteLine(\"Please give the First Binary number : \");\n        string firstNumber = Console.ReadLine();\n        Console.WriteLine(\"Please give the Second Binary number : \");\n        string secondNumber = Console.ReadLine();\n        */\n        string firstNumber = \"011011010100\";\n        string secondNumber = \"10111010111\";\n\n        int len1 = firstNumber.Length;\n        int len2 = secondNumber.Length;\n\n        Karatsuba karatsubaObj = new Karatsuba();\n\n        if (len1 < len2)\n        {\n            firstNumber = new string('0', len2 - len1) + firstNumber;\n        }\n        else if (len1 > len2)\n        {\n            secondNumber = new string('0', len1 - len2) + secondNumber;\n        }\n\n        Console.WriteLine(\"\\nClassical Algorithm:\");\n        BinaryMultiplier binaryMultiplier = new BinaryMultiplier();\n        string classic = binaryMultiplier.MakeMultiplication(firstNumber, secondNumber);\n        binaryMultiplier.BinaryStringToDecimal(classic);\n\n        Console.WriteLine(\"\\nKaratsuba Algorithm:\");\n        string karatsuba = karatsubaObj.Multiply(firstNumber, secondNumber);\n        binaryMultiplier.BinaryStringToDecimal(karatsuba);\n    }\n}\nclass BinaryMultiplier {\n    makeMultiplication(str1, str2) {\n        let allSum = \"\";\n        for (let j = 0; j < str2.length; j++) {\n            const secondDigit = parseInt(str2[j]);\n            if (secondDigit === 1) {\n                const shifted = this.makeShifting(str1, str2.length - (j + 1));\n                allSum = this.addBinary(shifted, allSum);\n            }\n        }\n        return allSum;\n    }\n\n    addBinary(a, b) {\n        let result = \"\";\n        let s = 0;\n\n        let i = a.length - 1;\n        let j = b.length - 1;\n        while (i >= 0 || j >= 0 || s === 1) {\n            s += (i >= 0) ? parseInt(a[i]) : 0;\n            s += (j >= 0) ? parseInt(b[j]) : 0;\n\n            result = String(s % 2) + result;\n\n            s = Math.floor(s / 2);\n\n            i--;\n            j--;\n        }\n        return result;\n    }\n\n    makeShifting(str, stepnum) {\n        let shifted = str;\n        for (let i = 0; i < stepnum; i++) {\n            shifted += '0';\n        }\n        return shifted;\n    }\n\n    binaryStringToDecimal(result) {\n        console.log(\"Binary Result : \" + result);\n        let val = 0;\n        for (let i = result.length - 1; i >= 0; i--) {\n            if (result[i] === '1') {\n                val += Math.pow(2, (result.length - 1) - i);\n            }\n        }\n        console.log(\"Decimal Result (Not proper for Large Binary Numbers):\" + val);\n    }\n}\n\nclass Karatsuba {\n    lengthController(str1, str2) {\n        const len1 = str1.length;\n        const len2 = str2.length;\n        if (len1 < len2) {\n            for (let i = 0; i < len2 - len1; i++) {\n                str1 = '0' + str1;\n            }\n            return len2;\n        } else if (len1 > len2) {\n            for (let i = 0; i < len1 - len2; i++) {\n                str2 = '0' + str2;\n            }\n        }\n        return len1;\n    }\n\n    addStrings(first, second) {\n        let result = \"\";\n        const length = this.lengthController(first, second);\n        let carry = 0;\n        for (let i = length - 1; i >= 0; i--) {\n            const firstBit = parseInt(first[i]);\n            const secondBit = parseInt(second[i]);\n\n            const sum = (firstBit ^ secondBit ^ carry).toString();\n            result = sum + result;\n\n            carry = (firstBit & secondBit) | (secondBit & carry) | (firstBit & carry);\n        }\n\n        if (carry) {\n            result = '1' + result;\n        }\n\n        return result;\n    }\n\n    decimalToBinary(number) {\n        let result = \"\";\n        if (number <= 0) {\n            return \"0\";\n        } else {\n            let i = 0;\n            while (number > 0) {\n                const num = number % 2;\n                result = num + result;\n                number = Math.floor(number / 2);\n                i++;\n            }\n            return result;\n        }\n    }\n\n    subtraction(lhs, rhs) {\n        const length = this.lengthController(lhs, rhs);\n        let diff;\n        let result = \"\";\n\n        for (let i = length - 1; i >= 0; i--) {\n            diff = parseInt(lhs[i]) - parseInt(rhs[i]);\n            if (diff >= 0) {\n                result = this.decimalToBinary(diff) + result;\n            } else {\n                for (let j = i - 1; j >= 0; j--) {\n                    lhs[j] = (parseInt(lhs[j]) - 1) % 10 + '0';\n                    if (lhs[j] !== '1') {\n                        break;\n                    }\n                }\n                result = this.decimalToBinary(diff + 2) + result;\n            }\n        }\n        return result;\n    }\n\n    makeShifting(str, stepnum) {\n        let shifted = str;\n        for (let i = 0; i < stepnum; i++) {\n            shifted += '0';\n        }\n        return shifted;\n    }\n\n    multiply(X, Y) {\n        const n = this.lengthController(X, Y);\n\n        if (n === 1) return ((parseInt(Y[0]) === 1) && (parseInt(X[0]) === 1)) ? \"1\" : \"0\";\n\n        const fh = Math.floor(n / 2);\n        const sh = n - fh;\n\n        const Xl = X.substr(0, fh);\n        const Xr = X.substr(fh, sh);\n\n        const Yl = Y.substr(0, fh);\n        const Yr = Y.substr(fh, sh);\n\n        const P1 = this.multiply(Xl, Yl);\n        const P2 = this.multiply(Xr, Yr);\n        const P3 = this.multiply(this.addStrings(Xl, Xr), this.addStrings(Yl, Yr));\n\n        return this.addStrings(this.addStrings(this.makeShifting(P1, 2 * (n - n / 2)), P2),\n            this.makeShifting(this.subtraction(P3, this.addStrings(P1, P2)), n - (n / 2)));\n    }\n}\n\n// main function\nfunction main() {\n    const readline = require('readline');\n    const rl = readline.createInterface({\n        input: process.stdin,\n        output: process.stdout\n    });\n\n    rl.question(\"Please give the First Binary number : \", function (firstNumber) {\n        rl.question(\"\\nPlease give the Second Binary number : \", function (secondNumber) {\n            rl.close();\n\n            let len1 = firstNumber.length;\n            let len2 = secondNumber.length;\n\n            if (len1 < len2) {\n                firstNumber = '0'.repeat(len2 - len1) + firstNumber;\n            } else if (len1 > len2) {\n                secondNumber = '0'.repeat(len1 - len2) + secondNumber;\n            }\n\n            console.log(\"\\nClassical Algorithm : \");\n            const classicalTime = new Date().getTime();\n            const binaryMultiplier = new BinaryMultiplier();\n            const classic = binaryMultiplier.makeMultiplication(firstNumber, secondNumber);\n            console.log((new Date().getTime() - classicalTime) / 1000.0 + \"\\n\");\n            binaryMultiplier.binaryStringToDecimal(classic);\n\n            console.log(\"\\nKaratsuba Algorithm : \");\n            const karatsubaTime = new Date().getTime();\n            const karatsubaObj = new Karatsuba();\n            const karatsuba = karatsubaObj.multiply(firstNumber, secondNumber);\n            console.log((new Date().getTime() - karatsubaTime) / 1000.0 + \"\\n\");\n            binaryMultiplier.binaryStringToDecimal(karatsuba);\n        });\n    });\n}\n\n// call main function\nmain();\n",
        "complexity": {
            "time": "In the Karatsuba method, the time complexity is O(n^2) because the ‘multiply’ method of the Karatsuba class is called recursively for each of the three products. The time complexity of the addStrings() method is constant because the loop runs with a maximum of two iterations.",
            "space": "In the classical method, the Auxiliary Space is O(n) because the loop is iterated n times and a single string is used to store the result. The space complexity of the addBinary() method is constant because the loop runs with a maximum of two iterations."
        },
        "tags": [
            "Divide and Conquer"
        ],
        "url": "https://www.geeksforgeeks.org/karatsuba-algorithm-for-fast-multiplication-using-divide-and-conquer-algorithm/"
    },
    {
        "title": "Divide and Conquer Optimization in Dynamic Programming",
        "description": "Dynamic programming (DP) is arguably the most important tool in a competitive programmer’s repertoire. There are several optimizations in DP that reduce the time complexity of standard DP procedures by a linear factor or more, such as Knuth’s optimization, Divide and Conquer optimization, the Convex Hull Trick, etc. They are, of paramount importance for advanced competitive programming, such as at the level of olympiads. In this article, we will discover the divide and conquer optimization, NOT to be confused with the divide and conquer algorithm to solve problems. The divide and conquer optimization can be used for problems with a dp transition of the following form – dp[i][j] = min1≤k<j (dp[i-1][k-1] + cost[k][j]) Further, the cost function must satisfy the quadrangle inequality (QI), i.e., cost(a, c) + cost(b, d) ≤ cost(a, d) + cost(b, c) for all a ≤ b ≤ c ≤ d. The sub-optimal approach to solve any problem with a dynamic programming transition of the form given above would iterate through all possible values of k < j for each transition. Then, if the problem constraints give 1 ≤ i ≤ m and 1 ≤ j ≤ n, the algorithm will take O(mn2) time. The key to the optimization is the following: opt[i][j] ≤ opt[i][j+1], where opt[i][j] = argmink<j(dp[i-1][k] + cost[k][j]) Now, suppose we compute opt[i][j] for some i and j. Then, we also know that opt[i][p] ≤ opt[i][j] for all p < j. The sub-optimal solution would involve looping for each j, through all possible values of k for any fixed i. The optimization itself is as follows: The algorithm is faster by a linear factor as we don’t have to loop through all values of k, and a logarithmic factor is added due to the recursive nature of this algorithm. The time complexity is thus O(m * n * (log n)). The generic code for this approach is given below It uses a recursive approach, which is the simplest to implement given the structure of the solution.                Time Complexity: O(M*N2*log2N). Space Complexity: O(M*N) as 2d array dp has been created. To prove the correctness of this algorithm, we only need to prove the inequality – opt[i][j] ≤ opt[i][j+1] Follow the below section for proof of correctness: Assumptions: If cost(i, j) satisfies the Quadrangle Inequality, then dp[i][j] also satisfies the inequality.  Now, consider the following setup – If we can show that – dpp[i][j] ≥ dpq[i][j] ⇒ dpp[i][j+1] ≥ dpq[i][j+1] then setting q = opt[i][j], it will be clear that opt[i][j+1] will be at least as much as opt[i][j], due to the implication of the above inequality for all indices p less than opt[i][j]. This will prove that opt[i][j-1] ≤ opt[i][j]. Prrof: From the Quadrangle inequality on the dp array we get – cost(p, j) + cost(q, j+1) ≤ cost(p, j+1) + cost(q, j)⇒ (dp[i-1, p] + cost(p, j)) + (dp[i-1, q] + cost(q, j+1)) ≤ (dp[i-1, p] + cost(p, j+1)) + (dp[j-1, q] + cost(q, j))⇒ dpp[i][j] + dpq[i][j+1] ≤ dpp[i][j+1] + dpq[i][j]⇒ dpp[i][j] – dpq[i][j] ≤ dpp[i][j+1] – dpq[i][j+1] dpp[i][j] ≥ dpq[i][j] ⇒ 0 ≤ dpp[i][j] – dpq[i][j] ≤ dpp[i][j+1] – dpq[i][j+1] ⇒ dpp[i][j+1] ≥ dpq[i][j+1] This completes the proof dpp[i][j] ≥ dpq[i][j] ⇒ dpp[i][j+1] ≥ dpq[i][j+1] Given an array arr[] of N elements, the task is to divide it into K subarrays, such that the sum of the squares of the subarray sums is minimized. Examples: Input: arr []= {1, 3, 2, 6, 7, 4}, K = 3. Output: 193Explanation: The optimal division into subarrays is [1, 3, 2], [6] and [7, 4], Giving a total sum of (1 + 3 + 2)2 + (6)2 + (7 + 4)2 = 193.  This is the minimum possible sum for this particular array and K. Input: arr[] = {1, 4, 2, 3}, K = 2Output: 50Explanation: Divide it into subarrays {1, 4} and {2, 3}.The sum is (1+4)2 + (2 + 3)2 = 52 + 52 = 50.This is the minimum possible sum. Suboptimal solution: The problem can be solved based on the following idea: dp[i][j] = mini≤k≤j (dp[i-1][k-1] + cost[k][i]) where cost[k][i] denotes the square of the sum of all elements in the subarray arr[k, k+1 . . . i] Follow the steps mentioned below for solving the problem: Below is the implementation of the above approach.                Time Complexity: O(M * N2)Auxiliary Space: O(M * N) Optimal Solution (Using Divide and Conquer Optimization): This problem follows the quadrangle We can, however, notice that the cost function satisfies the quadrangle inequality cost(a, c) + cost(b, d) ≤ cost(a, d) + cost(b, c). The following is the proof: Let sum(p, q) denote the sum of values in range [p, q] (sub-array of arr[[]), and let x = sum(b, c), y = sum(a, c) − sum(b, c), and z = sum(b, d) − sum(b, c). Using this notation, the quadrangle inequality becomes (x + y)2 + (x + z)2 ≤ (x + y + z)2 + x2, which is equivalent to 0 ≤ 2yz. Since y and z are nonnegative values, this completes the proof. We can thus use the divide and conquer optimization. Note: This optimization can be used for all implementations of the divide and conquer DP speedup. Follow the steps mentioned below to implement the idea: Below is the implementation of the above approach.                Time Complexity: O(M * N * logN)Auxiliary Space: O(N) O  ",
        "code": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n193\n\n\n\n\n\n\n\n\n\n\n193\n",
        "complexity": {
            "time": "Time Complexity: O(M * N * logN)Auxiliary Space: O(N)",
            "space": "Space Complexity: O(M*N) as 2d array dp has been created."
        },
        "tags": [
            "Divide and Conquer"
        ],
        "url": "https://www.geeksforgeeks.org/divide-and-conquer-optimization-in-dynamic-programming/"
    },
    {
        "title": "Closest Pair of Points using Divide and Conquer algorithm",
        "description": "We are given an array of n points in the plane, and the problem is to find out the closest pair of points in the array. This problem arises in a number of applications. For example, in air-traffic control, you may want to monitor planes that come too close together, since this may indicate a possible collision. Recall the following formula for distance between two points p and q.The Brute force solution is O(n^2), compute the distance between each pair and return the smallest. We can calculate the smallest distance in O(nLogn) time using Divide and Conquer strategy. In this post, a O(n x (Logn)^2) approach is discussed. We will be discussing a O(nLogn) approach in a separate post. Algorithm Following are the detailed steps of a O(n (Logn)^2) algorithm. Input: An array of n points P[] Output: The smallest distance between two points in the given array.As a pre-processing step, the input array is sorted according to x coordinates.1) Find the middle point in the sorted array, we can take P[n/2] as middle point. 2) Divide the given array in two halves. The first subarray contains points from P[0] to P[n/2]. The second subarray contains points from P[n/2+1] to P[n-1].3) Recursively find the smallest distances in both subarrays. Let the distances be dl and dr. Find the minimum of dl and dr. Let the minimum be d.  4) From the above 3 steps, we have an upper bound d of minimum distance. Now we need to consider the pairs such that one point in pair is from the left half and the other is from the right half. Consider the vertical line passing through P[n/2] and find all points whose x coordinate is closer than d to the middle vertical line. Build an array strip[] of all such points.  5) Sort the array strip[] according to y coordinates. This step is O(nLogn). It can be optimized to O(n) by recursively sorting and merging. 6) Find the smallest distance in strip[]. This is tricky. From the first look, it seems to be a O(n^2) step, but it is actually O(n). It can be proved geometrically that for every point in the strip, we only need to check at most 7 points after it (note that strip is sorted according to Y coordinate). See this for more analysis.7) Finally return the minimum of d and distance calculated in the above step (step 6) Implementation Following is the implementation of the above algorithm. Time Complexity Let Time complexity of above algorithm be T(n). Let us assume that we use a O(nLogn) sorting algorithm. The above algorithm divides all points in two sets and recursively calls for two sets. After dividing, it finds the strip in O(n) time, sorts the strip in O(nLogn) time and finally finds the closest points in strip in O(n) time. So T(n) can expressed as follows T(n) = 2T(n/2) + O(n) + O(nLogn) + O(n) T(n) = 2T(n/2) + O(nLogn) T(n) = T(n x Logn x Logn) Auxiliary Space: O(log n) Notes 1) Time complexity can be improved to O(nLogn) by optimizing step 5 of the above algorithm. We will soon be discussing the optimized solution in a separate post. 2) The code finds smallest distance. It can be easily modified to find the points with the smallest distance. 3) The code uses quick sort which can be O(n^2) in the worst case. To have the upper bound as O(n (Logn)^2), a O(nLogn) sorting algorithm like merge sort or heap sort can be used References: http://www.cs.umd.edu/class/fall2013/cmsc451/Lects/lect10.pdf http://en.wikipedia.org/wiki/Closest_pair_of_points_problem  ",
        "code": "\n\n\n\n\n\n\n\n\n\n\n\nThe smallest distance is 1.41421\n",
        "complexity": {
            "time": "Notes 1) Time complexity can be improved to O(nLogn) by optimizing step 5 of the above algorithm. We will soon be discussing the optimized solution in a separate post. 2) The code finds smallest distance. It can be easily modified to find the points with the smallest distance. 3) The code uses quick sort which can be O(n^2) in the worst case. To have the upper bound as O(n (Logn)^2), a O(nLogn) sorting algorithm like merge sort or heap sort can be used",
            "space": ""
        },
        "tags": [
            "Divide and Conquer"
        ],
        "url": "https://www.geeksforgeeks.org/closest-pair-of-points-using-divide-and-conquer-algorithm/"
    },
    {
        "title": "DSA Tutorial - Learn Data Structures and Algorithms",
        "description": "DSA (Data Structures and Algorithms)  is the study of organizing data efficiently using data structures like arrays, stacks, and trees, paired with step-by-step procedures (or algorithms) to solve problems effectively. Data structures manage how data is stored and accessed, while algorithms focus on processing this data. Hoping you have learned a programming language of your choice, here comes the next stage of the roadmap - Learn about Time and Space Complexities. Once you have learned basics of a programming language, it is recommended that you learn basic logic building To analyze algorithms, we mainly measure order of growth of time or space taken in terms of input size.  We do this in the worst case scenario in most of the cases. Please refer the below links for a clear understanding of these concepts. Array is a linear data structure where elements are allocated contiguous memory, allowing for constant-time access. Searching algorithms are used to locate specific data within a large set of data. It helps find a target value within the data. There are various types of searching algorithms, each with its own approach and efficiency. Sorting algorithms are used to arrange the elements of a list in a specific order, such as numerical or alphabetical. It organizes the items in a systematic way, making it easier to search for and access specific elements. Hashing is a technique that generates a fixed-size output (hash value) from an input of variable size using mathematical formulas called hash functions. Hashing is commonly used in data structures for efficient searching, insertion and deletion. In Two Pointer Technique, we typically use two index variables from two corners of an array. We use the two pointer technique for searching a required point or value in an array. In Window Sliding Technique, we use the result of previous subarray to quickly compute the result of current. In Prefix Sum Technique, we compute prefix sums of an array to quickly find results for a subarray. String is a sequence of characters, typically immutable and have limited set of elements (lower case or all English alphabets). Recursion is a programming technique where a function calls itself within its own definition. It is usually used to solve problems that can be broken down into smaller instances of the same problem. Matrix is a two-dimensional array of elements, arranged in rows and columns. It is represented as a rectangular grid, with each element at the intersection of a row and column. Linked list is a linear data structure that stores data in nodes, which are connected by pointers. Unlike arrays, nodes of linked lists are not stored in contiguous memory locations and can only be accessed sequentially, starting from the head of list. Stack is a linear data structure that follows the Last In, First Out (LIFO) principle. Stacks play an important role in managing function calls, memory, and are widely used in algorithms like stock span problem, next greater element and largest area in a histogram. Queue is a linear data structure that follows the First In, First Out (FIFO) principle. Queues play an important role in managing tasks or data in order, scheduling and message handling systems. A deque (double-ended queue) is a data structure that allows elements to be added or removed from both ends efficiently. Tree is a non-linear, hierarchical data structure consisting of nodes connected by edges, with a top node called the root and nodes having child nodes. It is widely used in file systems, databases, decision-making algorithms, etc. Heap is a complete binary tree data structure that satisfies the heap property. Heaps are usually used to implement priority queues, where the smallest or largest element is always at the root of the tree. Graph is a non-linear data structure consisting of a finite set of vertices(or nodes) and a set of edges(or links)that connect a pair of nodes. Graphs are widely used to represent relationships between entities. Greedy Algorithm builds up the solution one piece at a time and chooses the next piece which gives the most obvious and immediate benefit i.e., which is the most optimal choice at that moment. So the problems where choosing locally optimal also leads to the global solutions are best fit for Greedy. Dynamic Programming is a method used to solve complex problems by breaking them down into simpler subproblems. By solving each subproblem only once and storing the results, it avoids redundant computations, leading to more efficient solutions for a wide range of problems. Bitwise Algorithms: Operate on individual bits of numbers. Backtracking Algorithm : Follow Recursion  with the option to revert and traces back if the solution from current point is not feasible. Divide and conquer:  A strategy to solve problems by dividing them into smaller subproblems, solving those subproblems, and combining the solutions to obtain the final solution. Branch and Bound : Used in combinatorial optimization problems to systematically search for the best solution. It works by dividing the problem into smaller subproblems, or branches, and then eliminating certain branches based on bounds on the optimal solution. This process continues until the best solution is found or all branches have been explored. Geometric algorithms are a set of algorithms that solve problems related to shapes, points, lines and polygons. Randomized algorithms are algorithms that use randomness to solve problems. They make use of random input to achieve their goals, often leading to simpler and more efficient solutions. These algorithms may not product same result but are particularly useful in situations when a probabilistic approach is acceptable. Advanced Data Structures like Trie, Segment Tree, Red-Black Tree and Binary Indexed Tree offer significant performance improvements for specific problem domains. They provide efficient solutions for tasks like fast prefix searches, range queries, dynamic updates, and maintaining balanced data structures, which are crucial for handling large datasets and real-time processing. By optimizing time complexity, they enable better scalability and faster execution in many computational problems. R  ",
        "code": "",
        "complexity": {
            "time": "Advanced Data Structures like Trie, Segment Tree, Red-Black Tree and Binary Indexed Tree offer significant performance improvements for specific problem domains. They provide efficient solutions for tasks like fast prefix searches, range queries, dynamic updates, and maintaining balanced data structures, which are crucial for handling large datasets and real-time processing. By optimizing time complexity, they enable better scalability and faster execution in many computational problems.",
            "space": ""
        },
        "tags": [
            "Geometric Algorithms"
        ],
        "url": "https://www.geeksforgeeks.org/learn-data-structures-and-algorithms-dsa-tutorial/"
    },
    {
        "title": "Geometric Algorithms",
        "description": "Geometric algorithms are a type of algorithm that deal with solving problems related to geometry. These algorithms are used to solve various geometric problems such as computing the area of a polygon, finding the intersection of geometric shapes, determining the convex hull of a set of points, and many other tasks related to geometric objects and their properties. Geometric algorithms are important in various fields such as computer graphics, computer-aided design, robotics, and geographical information systems. Table of Content Quick Links : H  ",
        "code": "",
        "complexity": {
            "time": "",
            "space": ""
        },
        "tags": [
            "Geometric Algorithms"
        ],
        "url": "https://www.geeksforgeeks.org/geometric-algorithms/"
    },
    {
        "title": "Basic Geometry for Competitive Programming",
        "description": "Ever wondered how to tackle tricky problems in competitive programming? Well, basic geometry is your secret weapon! In this article, we're diving into the basics Geometric Algorithms. It's like a power-up for your problem-solving skills, giving you the tools to crack those coding challenges like a pro. Table of Content Geometric algorithms are a set of computational techniques used in Competitive Programming to solve problems related to geometry and spatial relationships. These problems often involve points, lines, polygons, and other geometric objects. There are several questions which require basic geometric algorithms like: Operations like addition and subtraction of two vectors can be simply done by performing the operation on the individual components of the vectors. Like if we have two vectors (x1, y1) and (x2, y2), then the sum of the two vectors is (x1+x2, y1+y2) and the difference between them is (x1-x2, y1-y2). Implementation: The dot product of two vectors is simply the sum of the products of the corresponding elements. If we have two vectors (x1, y1) and (x2, y2), then the dot product of the two vectors is (x1 * x2) + (y1 * y2). The dot product of two vectors is a scalar quantity. If we have two vectors in x-y plane (x1, y1) and (x2, y2), then the magnitude of cross product of two vectors is (x1 * y2) - (x2 * y1) and direction is in ±z direction. The cross product of two vectors is a vector quantity. Similarly, the cross product of two 3D vectors (x1, y1, z1) and (x2, y2, z2) is (y1*z2 - y2*z1, z1*x2 - z2*x1, x1*y2 - x2*y1). Implementation: Suppose we are given point A and a line L and we need to calculate the distance between the point and the line (say h), we can simply do it using Cross Product of vectors.  Let's say we take 2 points on the line L, say B and C so the distance between the point and the line would simply be: h = ( \\,|\\overrightarrow{\\rm BA}| X |\\overrightarrow{\\rm BC}|) \\,/(|\\overrightarrow{\\rm BC}|) where the numerator is the magnitude of Cross Product of vector B to A and B to C and the denominator is the magnitude of vector B to C. From the above diagram, we can see that the area of the parallelogram ABCD = (|\\overrightarrow{\\rm BA}| X |\\overrightarrow{\\rm BC}|) Also, we know that area of a parallelogram = base * height = (|\\overrightarrow{\\rm BC}|) * h So, using the above two equations, we can calculate the height h, h = ( \\,|\\overrightarrow{\\rm BA}| X |\\overrightarrow{\\rm BC}|) \\,/(|\\overrightarrow{\\rm BC}|) Note: We can use the same formula for 3D vectors also. Implementation: Time Complexity: O(1)Auxiliary Space: O(1) We can find the intersection point of two lines in 2D using parametric equations. Parametric equations are a way of representing a curve in terms of one or more parameters. For a line in 2D, we can use the following parametric equation: => r = a + td where a is the starting point of the line, t is a real parameter, d is the direction vector for the line and r is a point on the line. So, for the first line the parametric equation will be, r1 = a1 + t1d1 and for the second line the parametric equation will be, r2 = a2 + t2d2. We can further simplify the second equation: => r2 - a2 = t2d2 Taking Cross Product with d2 vector on both sides. => (r2 - a2) X d2 = 0 As the lines intersect at any point, the value of r1 and r2 will be same at that intersection point. So, by substituting the value of r1 in the above equation,=> (a1 + t1d1 - a2) X d2 = 0=> t1 = ((a2 - a1) X d2) / (d1 X d2) Now, we can find the intersection point by putting the value of t1 into r1 = a1 + t1d1 Implementation: Problem Problem Link Check if two line segments intersect Practice Now Line Passing through two points Practice Now Find the missing point of parallelogram Practice Now M  ",
        "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n// Function to perform vector addition\nvector<int> addVectors(const vector<int>& v1,\n                    const vector<int>& v2)\n{\n    vector<int> result;\n    if (v1.size() != v2.size()) {\n        cerr << \"Vectors must be of the same size for \"\n                \"addition.\"\n            << endl;\n        return result; // Returning an empty vector\n                    // indicating an error\n    }\n\n    result.reserve(v1.size());\n    for (size_t i = 0; i < v1.size(); ++i) {\n        result.push_back(v1[i] + v2[i]);\n    }\n\n    return result;\n}\n\n// Function to perform vector subtraction\nvector<int> subtractVectors(const vector<int>& v1,\n                            const vector<int>& v2)\n{\n    vector<int> result;\n    if (v1.size() != v2.size()) {\n        cerr << \"Vectors must be of the same size for \"\n                \"subtraction.\"\n            << endl;\n        return result; // Returning an empty vector\n                    // indicating an error\n    }\n\n    result.reserve(v1.size());\n    for (size_t i = 0; i < v1.size(); ++i) {\n        result.push_back(v1[i] - v2[i]);\n    }\n\n    return result;\n}\n\n// Driver code\nint main()\n{\n\n    // Example vectors\n    vector<int> vector1 = { 1, 2, 3, 4, 5 };\n    vector<int> vector2 = { 5, 4, 3, 2, 1 };\n\n    // Perform vector addition\n    vector<int> sum = addVectors(vector1, vector2);\n    cout << \"Vector Addition Result: \";\n    for (int value : sum) {\n        cout << value << \" \";\n    }\n    cout << endl;\n\n    // Perform vector subtraction\n    vector<int> difference\n        = subtractVectors(vector1, vector2);\n    cout << \"Vector Subtraction Result: \";\n    for (int value : difference) {\n        cout << value << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}\nimport java.util.Arrays;\n\npublic class VectorOperations {\n\n    // Function for vector addition\n    public static int[] addVectors(int[] v1, int[] v2) {\n        int[] result = new int[v1.length];\n\n        // Check if vectors are of the same size for addition\n        if (v1.length != v2.length) {\n            System.out.println(\"Vectors must be of the same size for addition.\");\n            // Returning an empty array indicating an error\n            return result;\n        }\n\n        // Perform vector addition\n        for (int i = 0; i < v1.length; i++) {\n            result[i] = v1[i] + v2[i];\n        }\n\n        return result;\n    }\n\n    // Function for vector subtraction\n    public static int[] subtractVectors(int[] v1, int[] v2) {\n        int[] result = new int[v1.length];\n\n        // Check if vectors are of the same size for subtraction\n        if (v1.length != v2.length) {\n            System.out.println(\"Vectors must be of the same size for subtraction.\");\n            // Returning an empty array indicating an error\n            return result;\n        }\n\n        // Perform vector subtraction\n        for (int i = 0; i < v1.length; i++) {\n            result[i] = v1[i] - v2[i];\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        // Example vectors\n        int[] vector1 = {1, 2, 3, 4, 5};\n        int[] vector2 = {5, 4, 3, 2, 1};\n\n        // Perform vector addition\n        int[] sumResult = addVectors(vector1, vector2);\n        System.out.println(\"Vector Addition Result: \" + Arrays.toString(sumResult));\n\n        // Perform vector subtraction\n        int[] differenceResult = subtractVectors(vector1, vector2);\n        System.out.println(\"Vector Subtraction Result: \" + Arrays.toString(differenceResult));\n    }\n}\ndef add_vectors(v1, v2):\n    result = []\n    if len(v1) != len(v2):\n        print(\"Vectors must be of the same size for addition.\")\n        return result  # Returning an empty list indicating an error\n\n    result = [x + y for x, y in zip(v1, v2)]\n    return result\n\ndef subtract_vectors(v1, v2):\n    result = []\n    if len(v1) != len(v2):\n        print(\"Vectors must be of the same size for subtraction.\")\n        return result  # Returning an empty list indicating an error\n\n    result = [x - y for x, y in zip(v1, v2)]\n    return result\n\n# Example vectors\nvector1 = [1, 2, 3, 4, 5]\nvector2 = [5, 4, 3, 2, 1]\n\n# Perform vector addition\nsum_result = add_vectors(vector1, vector2)\nprint(\"Vector Addition Result:\", *sum_result)\n\n# Perform vector subtraction\ndifference_result = subtract_vectors(vector1, vector2)\nprint(\"Vector Subtraction Result:\", *difference_result)\nusing System;\nusing System.Collections.Generic;\n\nclass Program\n{\n    // Function to perform vector addition\n    static List<int> AddVectors(List<int> v1, List<int> v2)\n    {\n        List<int> result = new List<int>();\n\n        if (v1.Count != v2.Count)\n        {\n            Console.WriteLine(\"Vectors must be of the same size for addition.\");\n            return result; // Returning an empty list indicating an error\n        }\n\n        for (int i = 0; i < v1.Count; ++i)\n        {\n            result.Add(v1[i] + v2[i]);\n        }\n\n        return result;\n    }\n\n    // Function to perform vector subtraction\n    static List<int> SubtractVectors(List<int> v1, List<int> v2)\n    {\n        List<int> result = new List<int>();\n\n        if (v1.Count != v2.Count)\n        {\n            Console.WriteLine(\"Vectors must be of the same size for subtraction.\");\n            return result; // Returning an empty list indicating an error\n        }\n\n        for (int i = 0; i < v1.Count; ++i)\n        {\n            result.Add(v1[i] - v2[i]);\n        }\n\n        return result;\n    }\n\n    // Driver code\n    static void Main()\n    {\n        // Example lists\n        List<int> vector1 = new List<int> { 1, 2, 3, 4, 5 };\n        List<int> vector2 = new List<int> { 5, 4, 3, 2, 1 };\n\n        // Perform vector addition\n        List<int> sum = AddVectors(vector1, vector2);\n        Console.Write(\"Vector Addition Result: \");\n        foreach (int value in sum)\n        {\n            Console.Write(value + \" \");\n        }\n        Console.WriteLine();\n\n        // Perform vector subtraction\n        List<int> difference = SubtractVectors(vector1, vector2);\n        Console.Write(\"Vector Subtraction Result: \");\n        foreach (int value in difference)\n        {\n            Console.Write(value + \" \");\n        }\n        Console.WriteLine();\n    }\n}\n// Function for vector addition\nfunction addVectors(v1, v2) {\n    let result = new Array(v1.length).fill(0);\n\n    // Check if vectors are of the same size for addition\n    if (v1.length !== v2.length) {\n        console.log(\"Vectors must be of the same size for addition.\");\n        // Returning an empty array indicating an error\n        return result;\n    }\n\n    // Perform vector addition\n    for (let i = 0; i < v1.length; i++) {\n        result[i] = v1[i] + v2[i];\n    }\n\n    return result;\n}\n\n// Function for vector subtraction\nfunction subtractVectors(v1, v2) {\n    let result = new Array(v1.length).fill(0);\n\n    // Check if vectors are of the same size for subtraction\n    if (v1.length !== v2.length) {\n        console.log(\"Vectors must be of the same size for subtraction.\");\n        // Returning an empty array indicating an error\n        return result;\n    }\n\n    // Perform vector subtraction\n    for (let i = 0; i < v1.length; i++) {\n        result[i] = v1[i] - v2[i];\n    }\n\n    return result;\n}\n\n// Example vectors\nlet vector1 = [1, 2, 3, 4, 5];\nlet vector2 = [5, 4, 3, 2, 1];\n\n// Perform vector addition\nlet sumResult = addVectors(vector1, vector2);\nconsole.log(\"Vector Addition Result: \" + sumResult);\n\n// Perform vector subtraction\nlet differenceResult = subtractVectors(vector1, vector2);\nconsole.log(\"Vector Subtraction Result: \" + differenceResult);\nVector Addition Result: 6 6 6 6 6 \nVector Subtraction Result: -4 -2 0 2 4\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n// Function to calculate the dot product of two vectors\ndouble dotProduct(const vector<double>& vec1,\n                const vector<double>& vec2)\n{\n    double result = 0;\n    for (int i = 0; i < 3; ++i) {\n        result += vec1[i] * vec2[i];\n    }\n    return result;\n}\n\n// Function to calculate the cross product of two vectors\nvector<double> crossProduct(const vector<double>& vec1,\n                            const vector<double>& vec2)\n{\n    vector<double> result(3, 0);\n    result[0] = vec1[1] * vec2[2] - vec1[2] * vec2[1];\n    result[1] = vec1[2] * vec2[0] - vec1[0] * vec2[2];\n    result[2] = vec1[0] * vec2[1] - vec1[1] * vec2[0];\n    return result;\n}\n\nint main()\n{\n    // Example vectors\n    vector<double> vector1 = { 1.0, 2.0, 3.0 };\n    vector<double> vector2 = { 4.0, 5.0, 6.0 };\n\n    // Calculate and display the dot product\n    double dotResult = dotProduct(vector1, vector2);\n    cout << \"Dot Product: \" << dotResult << endl;\n\n    // Calculate and display the cross product\n    vector<double> crossResult\n        = crossProduct(vector1, vector2);\n    cout << \"Cross Product: \";\n    for (double value : crossResult) {\n        cout << value << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class VectorOperations {\n\n    // Function to calculate the dot product of two vectors\n    public static double dotProduct(List<Double> vec1, List<Double> vec2) {\n        double result = 0;\n        for (int i = 0; i < 3; ++i) {\n            result += vec1.get(i) * vec2.get(i);\n        }\n        return result;\n    }\n\n    // Function to calculate the cross product of two vectors\n    public static List<Double> crossProduct(List<Double> vec1, List<Double> vec2) {\n        List<Double> result = Arrays.asList(0.0, 0.0, 0.0);\n        result.set(0, vec1.get(1) * vec2.get(2) - vec1.get(2) * vec2.get(1));\n        result.set(1, vec1.get(2) * vec2.get(0) - vec1.get(0) * vec2.get(2));\n        result.set(2, vec1.get(0) * vec2.get(1) - vec1.get(1) * vec2.get(0));\n        return result;\n    }\n\n    public static void main(String[] args) {\n        // Example vectors\n        List<Double> vector1 = Arrays.asList(1.0, 2.0, 3.0);\n        List<Double> vector2 = Arrays.asList(4.0, 5.0, 6.0);\n\n        // Calculate and display the dot product\n        double dotResult = dotProduct(vector1, vector2);\n        System.out.println(\"Dot Product: \" + dotResult);\n\n        // Calculate and display the cross product\n        List<Double> crossResult = crossProduct(vector1, vector2);\n        System.out.print(\"Cross Product: \");\n        for (double value : crossResult) {\n            System.out.print(value + \" \");\n        }\n        System.out.println();\n    }\n}\nclass VectorOperations:\n    @staticmethod\n    def dot_product(vec1, vec2):\n        result = 0\n        for i in range(3):\n            result += vec1[i] * vec2[i]\n        return result\n\n    @staticmethod\n    def cross_product(vec1, vec2):\n        result = [0.0, 0.0, 0.0]\n        result[0] = vec1[1] * vec2[2] - vec1[2] * vec2[1]\n        result[1] = vec1[2] * vec2[0] - vec1[0] * vec2[2]\n        result[2] = vec1[0] * vec2[1] - vec1[1] * vec2[0]\n        return result\n\nif __name__ == \"__main__\":\n    # Example vectors\n    vector1 = [1.0, 2.0, 3.0]\n    vector2 = [4.0, 5.0, 6.0]\n\n    # Calculate and display the dot product\n    dot_result = VectorOperations.dot_product(vector1, vector2)\n    print(\"Dot Product:\", dot_result)\n\n    # Calculate and display the cross product\n    cross_result = VectorOperations.cross_product(vector1, vector2)\n    print(\"Cross Product:\", cross_result)\nusing System;\nusing System.Collections.Generic;\n\nclass Program\n{\n    // Function to calculate the dot product of two vectors\n    static double DotProduct(List<double> vec1, List<double> vec2)\n    {\n        double result = 0;\n        for (int i = 0; i < 3; ++i)\n        {\n            result += vec1[i] * vec2[i];\n        }\n        return result;\n    }\n\n    // Function to calculate the cross product of two vectors\n    static List<double> CrossProduct(List<double> vec1, List<double> vec2)\n    {\n        List<double> result = new List<double> { 0, 0, 0 };\n        result[0] = vec1[1] * vec2[2] - vec1[2] * vec2[1];\n        result[1] = vec1[2] * vec2[0] - vec1[0] * vec2[2];\n        result[2] = vec1[0] * vec2[1] - vec1[1] * vec2[0];\n        return result;\n    }\n\n    static void Main()\n    {\n        // Example vectors\n        List<double> vector1 = new List<double> { 1.0, 2.0, 3.0 };\n        List<double> vector2 = new List<double> { 4.0, 5.0, 6.0 };\n\n        // Calculate and display the dot product\n        double dotResult = DotProduct(vector1, vector2);\n        Console.WriteLine(\"Dot Product: \" + dotResult);\n\n        // Calculate and display the cross product\n        List<double> crossResult = CrossProduct(vector1, vector2);\n        Console.Write(\"Cross Product: \");\n        foreach (double value in crossResult)\n        {\n            Console.Write(value + \" \");\n        }\n        Console.WriteLine();\n    }\n}\n// Function to calculate the dot product of two vectors\nfunction dotProduct(vec1, vec2) {\n    let result = 0;\n    for (let i = 0; i < 3; ++i) {\n        result += vec1[i] * vec2[i];\n    }\n    return result;\n}\n\n// Function to calculate the cross product of two vectors\nfunction crossProduct(vec1, vec2) {\n    let result = [0, 0, 0];\n    result[0] = vec1[1] * vec2[2] - vec1[2] * vec2[1];\n    result[1] = vec1[2] * vec2[0] - vec1[0] * vec2[2];\n    result[2] = vec1[0] * vec2[1] - vec1[1] * vec2[0];\n    return result;\n}\n\n// Example vectors\nconst vector1 = [1.0, 2.0, 3.0];\nconst vector2 = [4.0, 5.0, 6.0];\n\n// Calculate and display the dot product\nconst dotResult = dotProduct(vector1, vector2);\nconsole.log(\"Dot Product: \" + dotResult);\n\n// Calculate and display the cross product\nconst crossResult = crossProduct(vector1, vector2);\nconsole.log(\"Cross Product: \" + crossResult.join(\" \"));\nDot Product: 32\nCross Product: -3 6 -3\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Method to get the magnitude of a vector\ndouble getMagnitude(vector<int>& v)\n{\n    return sqrt(v[0] * v[0] + v[1] * v[1] + v[2] * v[2]);\n}\n\n// Method to calculate the cross product of two vectors v1\n// and v2\nvoid getCrossProduct(vector<int>& v1, vector<int>& v2,\n                    vector<int>& crossProduct)\n{\n    crossProduct[0] = v1[1] * v2[2] - v1[2] * v2[1];\n    crossProduct[1] = v1[2] * v2[0] - v1[0] * v2[2];\n    crossProduct[2] = v1[0] * v2[1] - v1[1] * v2[0];\n}\n\nint main()\n{\n    // Point from which we need to calculate the distance\n    vector<int> pointA = { 1, 4, -2 };\n\n    // Points on the line P\n    vector<int> pointB = { 3, 1, -2 };\n    vector<int> pointC = { 6, -2, 1 };\n\n    // vector BA\n    vector<int> vecBA\n        = { pointA[0] - pointB[0], pointA[1] - pointB[1],\n            pointA[2] - pointB[2] };\n    // vector BC\n    vector<int> vecBC\n        = { pointC[0] - pointB[0], pointC[1] - pointB[1],\n            pointC[2] - pointB[2] };\n\n    // vector to store the cross prduct\n    vector<int> crossProduct(3);\n    getCrossProduct(vecBA, vecBC, crossProduct);\n\n    // Variable to store the distance of point A from line P\n    double dist\n        = getMagnitude(crossProduct) / getMagnitude(vecBC);\n\n    cout << dist;\n\n    return 0;\n}\nimport java.util.*;\n\n// Class to hold the methods\npublic class Main {\n\n    // Method to get the magnitude of a vector\n    public static double getMagnitude(int[] v) {\n        return Math.sqrt(v[0] * v[0] + v[1] * v[1] + v[2] * v[2]);\n    }\n\n    // Method to calculate the cross product of two vectors v1 and v2\n    public static int[] getCrossProduct(int[] v1, int[] v2) {\n        int[] crossProduct = new int[3];\n        crossProduct[0] = v1[1] * v2[2] - v1[2] * v2[1];\n        crossProduct[1] = v1[2] * v2[0] - v1[0] * v2[2];\n        crossProduct[2] = v1[0] * v2[1] - v1[1] * v2[0];\n        return crossProduct;\n    }\n\n    public static void main(String[] args) {\n        // Point from which we need to calculate the distance\n        int[] pointA = { 1, 4, -2 };\n\n        // Points on the line P\n        int[] pointB = { 3, 1, -2 };\n        int[] pointC = { 6, -2, 1 };\n\n        // vector BA\n        int[] vecBA = { pointA[0] - pointB[0], pointA[1] - pointB[1], pointA[2] - pointB[2] };\n        // vector BC\n        int[] vecBC = { pointC[0] - pointB[0], pointC[1] - pointB[1], pointC[2] - pointB[2] };\n\n        // vector to store the cross product\n        int[] crossProduct = getCrossProduct(vecBA, vecBC);\n\n        // Variable to store the distance of point A from line P\n        double dist = getMagnitude(crossProduct) / getMagnitude(vecBC);\n\n        System.out.println(dist);\n    }\n}\nimport math\n\n# Method to get the magnitude of a vector\ndef get_magnitude(v):\n    return math.sqrt(v[0] * v[0] + v[1] * v[1] + v[2] * v[2])\n\n# Method to calculate the cross product of two vectors v1\n# and v2\ndef get_cross_product(v1, v2):\n    cross_product = [0, 0, 0]\n    cross_product[0] = v1[1] * v2[2] - v1[2] * v2[1]\n    cross_product[1] = v1[2] * v2[0] - v1[0] * v2[2]\n    cross_product[2] = v1[0] * v2[1] - v1[1] * v2[0]\n    return cross_product\n\n# Point from which we need to calculate the distance\npointA = [1, 4, -2]\n\n# Points on the line P\npointB = [3, 1, -2]\npointC = [6, -2, 1]\n\n# vector BA\nvecBA = [pointA[0] - pointB[0], pointA[1] - pointB[1], pointA[2] - pointB[2]]\n# vector BC\nvecBC = [pointC[0] - pointB[0], pointC[1] - pointB[1], pointC[2] - pointB[2]]\n\n# vector to store the cross product\ncross_product = get_cross_product(vecBA, vecBC)\n\n# Variable to store the distance of point A from line P\ndist = get_magnitude(cross_product) / get_magnitude(vecBC)\n\nprint(dist)\nusing System;\n\npublic class MainClass {\n    // Method to calculate the magnitude of a vector\n    static double GetMagnitude(int[] v)\n    {\n        return Math.Sqrt(v[0] * v[0] + v[1] * v[1]\n                         + v[2] * v[2]);\n    }\n\n    // Method to calculate the cross product of two vectors\n    // v1 and v2\n    static void GetCrossProduct(int[] v1, int[] v2,\n                                int[] crossProduct)\n    {\n        crossProduct[0] = v1[1] * v2[2] - v1[2] * v2[1];\n        crossProduct[1] = v1[2] * v2[0] - v1[0] * v2[2];\n        crossProduct[2] = v1[0] * v2[1] - v1[1] * v2[0];\n    }\n\n    public static void Main(string[] args)\n    {\n        // Point from which we need to calculate the\n        // distance\n        int[] pointA = { 1, 4, -2 };\n\n        // Points on the line P\n        int[] pointB = { 3, 1, -2 };\n        int[] pointC = { 6, -2, 1 };\n\n        // Vector BA\n        int[] vecBA = { pointA[0] - pointB[0],\n                        pointA[1] - pointB[1],\n                        pointA[2] - pointB[2] };\n\n        // Vector BC\n        int[] vecBC = { pointC[0] - pointB[0],\n                        pointC[1] - pointB[1],\n                        pointC[2] - pointB[2] };\n\n        // Array to store the cross product\n        int[] crossProduct = new int[3];\n\n        // Calculate the cross product of vecBA and vecBC\n        GetCrossProduct(vecBA, vecBC, crossProduct);\n\n        // Variable to store the distance of point A from\n        // line P\n        double dist = GetMagnitude(crossProduct)\n                      / GetMagnitude(vecBC);\n\n        // Output the distance\n        Console.WriteLine(dist);\n    }\n}\n// Get the magnitude of a vector\nconst getMagnitude = (v) => {\n  return Math.sqrt(v[0] * v[0] + v[1] * v[1] + v[2] * v[2]);\n};\n\n// Calculate the cross product of two vectors v1 and v2\nconst getCrossProduct = (v1, v2, crossProduct) => {\n  crossProduct[0] = v1[1] * v2[2] - v1[2] * v2[1];\n  crossProduct[1] = v1[2] * v2[0] - v1[0] * v2[2];\n  crossProduct[2] = v1[0] * v2[1] - v1[1] * v2[0];\n};\n\n// Main function\nconst main = () => {\n  // Point from which we need to calculate the distance\n  const pointA = [1, 4, -2];\n\n  // Points on the line P\n  const pointB = [3, 1, -2];\n  const pointC = [6, -2, 1];\n\n  // Vector BA\n  const vecBA = [pointA[0] - pointB[0], pointA[1] - pointB[1], pointA[2] - pointB[2]];\n\n  // Vector BC\n  const vecBC = [pointC[0] - pointB[0], pointC[1] - pointB[1], pointC[2] - pointB[2]];\n\n  // Vector to store the cross product\n  const crossProduct = [0, 0, 0];\n  getCrossProduct(vecBA, vecBC, crossProduct);\n\n  // Distance of point A from line P\n  const dist = getMagnitude(crossProduct) / getMagnitude(vecBC);\n\n  console.log(dist);\n};\n\nmain();\n2.16025\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Since the product of 2D(x, y) vectors is a vector in z\n// direction, we simply return the magnitude of the vector\ndouble getCrossProduct(vector<double> v1, vector<double> v2)\n{\n    return v1[0] * v2[1] - v1[1] * v2[0];\n}\n\nvector<double> getDifference(vector<double> v1,\n                            vector<double> v2)\n{\n    vector<double> diff(2);\n    diff[0] = v2[0] - v1[0];\n    diff[1] = v2[1] - v1[1];\n    return diff;\n}\n\nvector<double> getSum(vector<double> v1, vector<double> v2)\n{\n    vector<double> sum(2);\n    sum[0] = v1[0] + v2[0];\n    sum[1] = v1[1] + v2[1];\n    return sum;\n}\n\nint main()\n{\n    // Points of lines\n    vector<double> pointA = { 1, 1 };\n    vector<double> pointB = { 4, 4 };\n    vector<double> pointC = { 1, 8 };\n    vector<double> pointD = { 2, 4 };\n\n    // direction vector d1\n    vector<double> d1 = getDifference(pointA, pointB);\n    // direction vector d2\n    vector<double> d2 = getDifference(pointC, pointD);\n    double t1\n        = getCrossProduct(getDifference(pointA, pointC), d2)\n        / (getCrossProduct(d1, d2) * 1.0);\n    d1[0] *= t1;\n    d1[1] *= t1;\n    // Now, we can find the intersection point by putting\n    // the value of t1 into r1 = A + t1d1\n    vector<double> intersectionPoint = getSum(pointA, d1);\n\n    cout << intersectionPoint[0] << \" \"\n        << intersectionPoint[1];\n\n    return 0;\n}\nimport java.util.*;\n\npublic class Main {\n    // Since the product of 2D(x, y) vectors is a vector in z\n    // direction, we simply return the magnitude of the vector\n    public static double getCrossProduct(double[] v1, double[] v2) {\n        return v1[0] * v2[1] - v1[1] * v2[0];\n    }\n\n    public static double[] getDifference(double[] v1, double[] v2) {\n        double[] diff = new double[2];\n        diff[0] = v2[0] - v1[0];\n        diff[1] = v2[1] - v1[1];\n        return diff;\n    }\n\n    public static double[] getSum(double[] v1, double[] v2) {\n        double[] sum = new double[2];\n        sum[0] = v1[0] + v2[0];\n        sum[1] = v1[1] + v2[1];\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        // Points of lines\n        double[] pointA = { 1, 1 };\n        double[] pointB = { 4, 4 };\n        double[] pointC = { 1, 8 };\n        double[] pointD = { 2, 4 };\n\n        // direction vector d1\n        double[] d1 = getDifference(pointA, pointB);\n        // direction vector d2\n        double[] d2 = getDifference(pointC, pointD);\n        double t1 = getCrossProduct(getDifference(pointA, pointC), d2) / getCrossProduct(d1, d2);\n        d1[0] *= t1;\n        d1[1] *= t1;\n        // Now, we can find the intersection point by putting\n        // the value of t1 into r1 = A + t1d1\n        double[] intersectionPoint = getSum(pointA, d1);\n\n        System.out.println(intersectionPoint[0] + \" \" + intersectionPoint[1]);\n    }\n}\nfrom typing import List\n\n# Since the product of 2D(x, y) vectors is a vector in z\n# direction, we simply return the magnitude of the vector\ndef getCrossProduct(v1: List[float], v2: List[float]) -> float:\n    return v1[0] * v2[1] - v1[1] * v2[0]\n\ndef getDifference(v1: List[float], v2: List[float]) -> List[float]:\n    diff = [0.0, 0.0]\n    diff[0] = v2[0] - v1[0]\n    diff[1] = v2[1] - v1[1]\n    return diff\n\ndef getSum(v1: List[float], v2: List[float]) -> List[float]:\n    sum = [0.0, 0.0]\n    sum[0] = v1[0] + v2[0]\n    sum[1] = v1[1] + v2[1]\n    return sum\n\n# Points of lines\npointA = [1, 1]\npointB = [4, 4]\npointC = [1, 8]\npointD = [2, 4]\n\n# direction vector d1\nd1 = getDifference(pointA, pointB)\n# direction vector d2\nd2 = getDifference(pointC, pointD)\nt1 = getCrossProduct(getDifference(pointA, pointC), d2) / getCrossProduct(d1, d2)\nd1[0] *= t1\nd1[1] *= t1\n# Now, we can find the intersection point by putting\n# the value of t1 into r1 = A + t1d1\nintersectionPoint = getSum(pointA, d1)\n\nprint(intersectionPoint[0], intersectionPoint[1])\n// Function to calculate the cross product of two 2D vectors\nfunction getCrossProduct(v1, v2) {\n    return v1[0] * v2[1] - v1[1] * v2[0];\n}\n\n// Function to calculate the difference between two 2D vectors\nfunction getDifference(v1, v2) {\n    return [v2[0] - v1[0], v2[1] - v1[1]];\n}\n\n// Function to calculate the sum of two 2D vectors\nfunction getSum(v1, v2) {\n    return [v1[0] + v2[0], v1[1] + v2[1]];\n}\n\n// Main function\nfunction main() {\n    // Points of lines\n    const pointA = [1, 1];\n    const pointB = [4, 4];\n    const pointC = [1, 8];\n    const pointD = [2, 4];\n\n    // Direction vector d1\n    const d1 = getDifference(pointA, pointB);\n    // Direction vector d2\n    const d2 = getDifference(pointC, pointD);\n\n    // Calculate t1\n    const t1 = getCrossProduct(getDifference(pointA, pointC), d2) / getCrossProduct(d1, d2);\n\n    // Calculate the scaled direction vector d1\n    const scaledD1 = [d1[0] * t1, d1[1] * t1];\n\n    // Calculate the intersection point by adding the scaled direction vector to pointA\n    const intersectionPoint = getSum(pointA, scaledD1);\n\n    // Output the intersection point\n    console.log(intersectionPoint[0] + \" \" + intersectionPoint[1]);\n}\n\n// Invoke the main function\nmain();\n2.4 2.4\n",
        "complexity": {
            "time": "Time Complexity: O(1)Auxiliary Space: O(1)",
            "space": ""
        },
        "tags": [
            "Geometric Algorithms"
        ],
        "url": "https://www.geeksforgeeks.org/basic-geometry-for-competitive-programming/"
    },
    {
        "title": "Computational Geometry – Algorithms for Geometry",
        "description": "Computational geometry is a field of study that focuses on developing algorithms and data structures for solving problems that involve geometric shapes and structures. The field has applications in a variety of areas, including computer graphics, robotics, geographic information systems, and more. In this article, we will explore some of the key concepts and applications of computational geometry. One of the key goals of computational geometry is to find efficient solutions to geometric problems that arise in various fields. Some common geometric problems include: To solve these problems, computational geometry uses a variety of algorithms and data structures, the most commonly used algorithms include: A method for solving a wide range of geometric problems, including computing the intersection of two lines or planes and triangulating a polygon. The algorithm works by sweeping a line or plane across the geometry and updating a data structure as it goes. Use Cases: Line segment intersection problem using Sweep line algorithm:                Limitations of the Sweep line algorithm: Use Cases: Let’s see the implementation of Graham’s algorithm for the convex hull problem:                Limitations of the Graham scan algorithm: G  ",
        "code": "\n\n\n\n\n\n\n\n\n\nIntersection point: (0.5, 0.5)\n\n\n\n\n\n\n\n\n\n\nVertices of the convex hull:\n(0, 3)\n(0, 0)\n",
        "complexity": {
            "time": "",
            "space": ""
        },
        "tags": [
            "Geometric Algorithms"
        ],
        "url": "https://www.geeksforgeeks.org/what-is-computational-geometry-and-how-is-it-applied-in-solving-geometric-problems/"
    },
    {
        "title": "Program to find slope of a line",
        "description": "Given two coordinates, find the slope of a straight line. Examples: Approach: To calculate the slope of a line you need only two points from that line, (x1, y1) and (x2, y2). The equation used to calculate the slope from two points is:  Below is the implementation of the above approach:                   Time Complexity: O(1)Auxiliary Space: O(1) S  ",
        "code": "Input  : x1 = 4, y1 = 2, \r\n         x2 = 2, y2 = 5 \r\nOutput : Slope is -1.5\n\n\n\n\n\n\n\n\n\n\n\n\nSlope is: -1.5\n",
        "complexity": {
            "time": "Time Complexity: O(1)Auxiliary Space: O(1)",
            "space": ""
        },
        "tags": [
            "Geometric Algorithms"
        ],
        "url": "https://www.geeksforgeeks.org/program-find-slope-line/"
    },
    {
        "title": "Program for Point of Intersection of Two Lines",
        "description": "Given points A and B corresponding to line AB and points P and Q corresponding to line PQ, find the point of intersection of these lines. The points are given in 2D Plane with their X and Y Coordinates. Examples: First of all, let us assume that we have two points (x1, y1) and (x2, y2). Now, we find the equation of line formed by these points. Let the given lines be : We have to now solve these 2 equations to find the point of intersection. To solve, we multiply 1. by b2 and 2 by b1 This gives us, a1b2x + b1b2y = c1b2 a2b1x + b2b1y = c2b1 Subtracting these we get, (a1b2 – a2b1) x = c1b2 – c2b1 This gives us the value of x. Similarly, we can find the value of y. (x, y) gives us the point of intersection. Note: This gives the point of intersection of two lines, but if we are given line segments instead of lines, we have to also recheck that the point so computed actually lies on both the line segments. If the line segment is specified by points (x1, y1) and (x2, y2), then to check if (x, y) is on the segment we have to just check that The pseudo code for the above implementation: These can be derived by first getting the slope directly and then finding the intercept of the line.                Output: Time Complexity: O(1) Auxiliary Space: O(1) A  ",
        "code": "Input : A = (1, 1), B = (4, 4)\n        C = (1, 8), D = (2, 4)\nOutput : The intersection of the given lines \n         AB and CD is: (2.4, 2.4)\n\nInput : A = (0, 1), B = (0, 4)\n        C = (1, 8), D = (1, 4)\nOutput : The given lines AB and CD are parallel.\ndeterminant = a1 b2 - a2 b1\nif (determinant == 0)\n{\n    // Lines are parallel\n}\nelse\n{\n    x = (c1b2 - c2b1)/determinant\n    y = (a1c2 - a2c1)/determinant\n}\n\n\n\n\n\n\n\n\n\n\nThe intersection of the given lines AB and \nCD is: (2.4, 2.4)\n",
        "complexity": {
            "time": "Time Complexity: O(1) Auxiliary Space: O(1)",
            "space": ""
        },
        "tags": [
            "Geometric Algorithms"
        ],
        "url": "https://www.geeksforgeeks.org/program-for-point-of-intersection-of-two-lines/"
    },
    {
        "title": "Closest Pair of Points using Sweep Line Algorithm",
        "description": "Given an array of N points in the plane, the task is to find a pair of points with the smallest distance between them, where the distance between two points (x1, y1) and (x2, y2) can be calculated as [(x1 – x2) ^ 2] + [(y1 – y2) ^ 2]. Examples: Input: P[] = { {1, 2}, {2, 3}, {3, 4}, {5, 6}, {2, 1} }Output: The smallest distance is 2.Explanation: Distance between points as:P[0] and P[1] = 2, P[0] and P[2] = 8, P[0] and P[3] = 32, P[0] and P[4] = 2P[1] and P[2] = 2, P[1] and P[3] = 18, P[1] and P[4] = 4P[2] and P[3] = 8, P[2] and P[4] = 10P[3] and P[4] = 34Minimum distance among them all is 2. Input: P[] = { {0, 0}, {2, 1}, {1, 1} }Output: The smallest distance is 1. Approach: To solve the problem follow the below idea: The idea is to use Sweep Line Algorithm to find the smallest distance between a pair of points. We can sort the points on the basis of their x-coordinates and start iterating over all the points in increasing order of their x-coordinates. Suppose we are at the Kth point so all the points to the left of Kth point will be already processed. Let the minimum distance between 2 points found so far be D. So, to process the Kth point, we will consider only those points whose distance from Kth point < D. Maintain a set to store the previously processed points whose x-coordinates are less than D distance from Kth point. All the points in the set are ordered by their y-coordinates. In the below image, the light-green shaded region represents all the points which are available in the set. Now to search for the points in the set which are less than D distance away from point K, we will consider only those points whose y-coordinates are less than D distance from Kth point (points having their y-coordinates in range (YK – D, YK + D)). This can be performed in O(logN) time using Binary Search on set. Iterate over all those points and if distance is less than D, then update the minimum distance. In the above image, the dark-green region represents all the points in the set whose y-coordinates are less than D distance from Kth point. The efficiency of the algorithm is based on the fact that this region will contain O(1) points on an average. After iterating over all the points, return the smallest distance found between any 2 points. Below is the implementation of the above approach: Time Complexity: O(N * logN), because we iterate over all the N points and logN for binary search to find the points whose Y coordinates are less than D distance away from the current point where D is the minimum distance between any two points covered so far. Auxiliary Space: O(N)  ",
        "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n// To find the closest pair of points\nlong long\nclosestPair(vector<pair<long long, long long> > coordinates,\n            int n)\n{\n    // Sort points according to x-coordinates\n    sort(coordinates.begin(), coordinates.end());\n\n    // Set to store already processed points whose distance\n    // from the current points is less than the smaller\n    // distance so far\n    set<pair<long long, long long> > s;\n\n    long long squaredDistance = LLONG_MAX;\n    long long j = 0;\n\n    for (long long i = 0; i < n; ++i) {\n        // Find the value of D\n        long long D = ceil(sqrt(squaredDistance));\n        while (coordinates[i].first - coordinates[j].first >= D) {\n            s.erase({ coordinates[j].second, coordinates[j].first });\n            j += 1;\n        }\n\t\t\n      \t// Find the first point in the set whose y-coordinate is less than D distance from ith point \n        auto start\n            = s.lower_bound({ coordinates[i].second - D,\n                              coordinates[i].first });\n      \t// Find the last point in the set whose y-coordinate is less than D distance from ith point \n        auto end\n            = s.upper_bound({ coordinates[i].second + D,\n                              coordinates[i].first });\n\n      \t// Iterate over all such points and update the minimum distance\n        for (auto it = start; it != end; ++it) {\n            long long dx = coordinates[i].first - it->second;\n            long long dy = coordinates[i].second - it->first;\n            squaredDistance = min(squaredDistance, 1LL * dx * dx + 1LL * dy * dy);\n        }\n      \n      \t// Insert the point as {y-coordinate, x-coordinate}\n        s.insert({ coordinates[i].second,\n                   coordinates[i].first });\n    }\n    return squaredDistance;\n}\n\n// Driver code\nint main()\n{\n\n    // Points on a plane P[i] = {x, y}\n    vector<pair<long long, long long> > P = {\n        { 1, 2 }, { 2, 3 }, { 3, 4 }, { 5, 6 }, { 2, 1 }\n    };\n    int n = P.size();\n\n    // Function call\n    cout << \"The smallest distance is \"\n         << closestPair(P, n);\n    return 0;\n}\nimport java.util.*;\n\npublic class ClosestPair {\n    // To find the closest pair of points\n    public static long closestPair(List<long[]> coordinates, int n) {\n        // Sort points according to x-coordinates\n        Collections.sort(coordinates, Comparator.comparingLong(a -> a[0]));\n\n        // TreeSet to store already processed points whose distance\n        // from the current points is less than the smallest distance so far\n        TreeSet<long[]> set = new TreeSet<>(Comparator.comparingLong(a -> a[1]));\n\n        long squaredDistance = Long.MAX_VALUE;\n        int j = 0;\n\n        for (int i = 0; i < n; ++i) {\n            // Find the value of D\n            long D = (long) Math.ceil(Math.sqrt(squaredDistance));\n            while (coordinates.get(i)[0] - coordinates.get(j)[0] >= D) {\n                set.remove(new long[]{coordinates.get(j)[1], coordinates.get(j)[0]});\n                j += 1;\n            }\n\n            // Find the first point in the set whose y-coordinate is less than D distance from ith point\n            long[] lowerBound = new long[]{coordinates.get(i)[1] - D, Long.MIN_VALUE};\n            // Find the last point in the set whose y-coordinate is less than D distance from ith point\n            long[] upperBound = new long[]{coordinates.get(i)[1] + D, Long.MAX_VALUE};\n\n            // Iterate over all such points and update the minimum distance\n            for (long[] point : set.subSet(lowerBound, upperBound)) {\n                long dx = coordinates.get(i)[0] - point[1];\n                long dy = coordinates.get(i)[1] - point[0];\n                squaredDistance = Math.min(squaredDistance, dx * dx + dy * dy);\n            }\n\n            // Insert the point as {y-coordinate, x-coordinate}\n            set.add(new long[]{coordinates.get(i)[1], coordinates.get(i)[0]});\n        }\n        return squaredDistance;\n    }\n\n    public static void main(String[] args) {\n        // Points on a plane P[i] = {x, y}\n        List<long[]> P = new ArrayList<>();\n        P.add(new long[]{1, 2});\n        P.add(new long[]{2, 3});\n        P.add(new long[]{3, 4});\n        P.add(new long[]{5, 6});\n        P.add(new long[]{2, 1});\n        int n = P.size();\n\n        // Function call\n        System.out.println(\"The smallest distance is \" + closestPair(P, n));\n    }\n}\nimport math\nfrom sortedcontainers import SortedSet\n\n\n# Point class for 2-D points\n\nclass Point:\n    def __init__(self, x, y) :\n\n        self.x = x\n        self.y = y\n\n\ndef closestPair(coordinates, n) :\n\n\t# Sort points according to x-coordinates\n    coordinates.sort(key=lambda p: p.x)\n\n    # SortedSet to store already processed points whose distance\n    # from the current points is less than the smaller distance so far\n    s = SortedSet(key=lambda p: (p.y, p.x))\n\n    squaredDistance = 1e18\n    j = 0\n\n    for i in range(len(coordinates)):\n        # Find the value of D\n        D = math.ceil(math.sqrt(squaredDistance))\n        while j <= i and coordinates[i].x - coordinates[j].x >= D:\n            s.discard(Point(coordinates[j].x, coordinates[j].y))\n            j += 1\n\n        # Find the first point in the set whose y-coordinate is less than D distance from ith point\n        start = Point(coordinates[i].x, coordinates[i].y - D)\n        # Find the last point in the set whose y-coordinate is less than D distance from ith point\n        end = Point(coordinates[i].x, coordinates[i].y + D)\n\n        # Iterate over all such points and update the minimum distance\n        for it in s.irange(start, end):\n            dx = coordinates[i].x - it.x\n            dy = coordinates[i].y - it.y\n            squaredDistance = min(squaredDistance, dx * dx + dy * dy)\n\n        # Insert the point into the SortedSet\n        s.add(Point(coordinates[i].x, coordinates[i].y))\n\n    return squaredDistance\n\n# Driver code\nif __name__ == \"__main__\":\n    # Points on a plane P[i] = {x, y}\n    P = [\n        Point(1, 2),\n        Point(2, 3),\n        Point(3, 4),\n        Point(5, 6),\n        Point(2, 1)\n    ]\n\t\n    n = 5\n    # Function call\n    print(\"The smallest distance is\", closestPair(P, n))\n// To find the closest pair of points\nfunction closestPair(coordinates) {\n    // Sort points according to x-coordinates\n    coordinates.sort((a, b) => a[0] - b[0]);\n\n    // Array to store already processed points\n    let s = [];\n    let squaredDistance = Number.MAX_SAFE_INTEGER;\n    let j = 0;\n\n    for (let i = 0; i < coordinates.length; ++i) {\n        // Find the value of D\n        let D = Math.ceil(Math.sqrt(squaredDistance));\n        \n        // Remove points from the set that are too far from the current point\n        while (coordinates[i][0] - coordinates[j][0] >= D) {\n            s.shift();\n            j += 1;\n        }\n\n        // Find points within the range [coordinates[i][1] - D, coordinates[i][1] + D]\n        let start = coordinates[i][1] - D;\n        let end = coordinates[i][1] + D;\n\n        // Iterate over all such points and update the minimum distance\n        for (let k = 0; k < s.length; ++k) {\n            let dx = coordinates[i][0] - s[k][1];\n            let dy = coordinates[i][1] - s[k][0];\n            squaredDistance = Math.min(squaredDistance, dx * dx + dy * dy);\n        }\n\n        // Insert the point into the set\n        s.push([coordinates[i][1], coordinates[i][0]]);\n    }\n    return squaredDistance;\n}\n\n// Driver code\nfunction main() {\n    // Points on a plane P[i] = [x, y]\n    let P = [\n        [1, 2],\n        [2, 3],\n        [3, 4],\n        [5, 6],\n        [2, 1]\n    ];\n    \n    // Function call\n    console.log(\"The smallest distance is\", closestPair(P));\n}\n\n// Call main function\nmain();\nThe smallest distance is 2\n",
        "complexity": {
            "time": "Time Complexity: O(N * logN), because we iterate over all the N points and logN for binary search to find the points whose Y coordinates are less than D distance away from the current point where D is the minimum distance between any two points covered so far. Auxiliary Space: O(N)",
            "space": ""
        },
        "tags": [
            "Geometric Algorithms"
        ],
        "url": "https://www.geeksforgeeks.org/closest-pair-of-points-using-sweep-line-algorithm/"
    },
    {
        "title": "Convex Hull using Jarvis’ Algorithm or Wrapping",
        "description": "Given a set of points in the plane. the convex hull of the set is the smallest convex polygon that contains all the points of it.  We strongly recommend to see the following post first. How to check if two given line segments intersect?The idea of Jarvis’s Algorithm is simple, we start from the leftmost point (or point with minimum x coordinate value) and we keep wrapping points in counterclockwise direction. The big question is, given a point p as current point, how to find the next point in output? The idea is to use orientation() here. Next point is selected as the point that beats all other points at counterclockwise orientation, i.e., next point is q if for any other point r, we have “orientation(p, q, r) = counterclockwise”. Algorithm:Step 1) Initialize p as leftmost point. Step 2) Do following while we don’t come back to the first (or leftmost) point.             2.1) The next point q is the point, such that the triplet (p, q, r) is counter clockwise for any other point r. To find this, we simply initialize q as next point, then we traverse through all points. For any point i, if i is more counter clockwise, i.e., orientation(p, i, q) is counter clockwise, then we update q as i. Our final value of q is going to be the most counter clockwise point.            2.2) next[p] = q (Store q as next of p in the output convex hull).            2.3) p = q (Set p as q for next iteration). Below is the implementation of above algorithm. Time Complexity:  O(m * n), where n is number of input points and m is number of output or hull points (m <= n).  For every point on the hull we examine all the other points to determine the next point. Worst case, Time complexity: O(n2).  The worst case occurs when all the points are on the hull (m = n). Auxiliary Space: O(n), since n extra space has been taken.Set 2- Convex Hull (Graham  Scan) Note : The above code may produce different results for different order of inputs, when there are collinear points in the convex hull. For example, it produces output as (0, 3) (0, 0) (3, 0) (3, 3) for input (0, 3), (0, 0), (0, 1), (3, 0), (3, 3) and output as (0, 3) (0, 1) (0, 0) (3, 0) (3, 3) for input as (0, 3), (0, 1), (0, 0), (3, 0), (3, 3). We generally need the farthest next point in case of collinear, we can get the desired result in case of collinear points by adding one more if condition.Sources: http://www.cs.uiuc.edu/~jeffe/teaching/373/notes/x05-convexhull.pdf http://www.dcs.gla.ac.uk/~pat/52233/slides/Hull1x1.pdfPlease write comments if you find anything incorrect, or you want to share more information about the topic discussed above  ",
        "code": "// A C++ program to find convex hull of a set of points. Refer\n// https://www.geeksforgeeks.org/orientation-3-ordered-points/\n// for explanation of orientation()\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Point\n{\n    int x, y;\n};\n\n// To find orientation of ordered triplet (p, q, r).\n// The function returns following values\n// 0 --> p, q and r are collinear\n// 1 --> Clockwise\n// 2 --> Counterclockwise\nint orientation(Point p, Point q, Point r)\n{\n    int val = (q.y - p.y) * (r.x - q.x) -\n              (q.x - p.x) * (r.y - q.y);\n\n    if (val == 0) return 0;  // collinear\n    return (val > 0)? 1: 2; // clock or counterclock wise\n}\n\n// Prints convex hull of a set of n points.\nvoid convexHull(Point points[], int n)\n{\n    // There must be at least 3 points\n    if (n < 3) return;\n\n    // Initialize Result\n    vector<Point> hull;\n\n    // Find the leftmost point\n    int l = 0;\n    for (int i = 1; i < n; i++)\n        if (points[i].x < points[l].x)\n            l = i;\n\n    // Start from leftmost point, keep moving counterclockwise\n    // until reach the start point again.  This loop runs O(h)\n    // times where h is number of points in result or output.\n    int p = l, q;\n    do\n    {\n        // Add current point to result\n        hull.push_back(points[p]);\n\n        // Search for a point 'q' such that orientation(p, q,\n        // x) is counterclockwise for all points 'x'. The idea\n        // is to keep track of last visited most counterclock-\n        // wise point in q. If any point 'i' is more counterclock-\n        // wise than q, then update q.\n        q = (p+1)%n;\n        for (int i = 0; i < n; i++)\n        {\n           // If i is more counterclockwise than current q, then\n           // update q\n           if (orientation(points[p], points[i], points[q]) == 2)\n               q = i;\n        }\n\n        // Now q is the most counterclockwise with respect to p\n        // Set p as q for next iteration, so that q is added to\n        // result 'hull'\n        p = q;\n\n    } while (p != l);  // While we don't come to first point\n\n    // Print Result\n    for (int i = 0; i < hull.size(); i++)\n        cout << \"(\" << hull[i].x << \", \"\n              << hull[i].y << \")\\n\";\n}\n\n// Driver program to test above functions\nint main()\n{\n    Point points[] = {{0, 3}, {2, 2}, {1, 1}, {2, 1},\n                      {3, 0}, {0, 0}, {3, 3}};\n    int n = sizeof(points)/sizeof(points[0]);\n    convexHull(points, n);\n    return 0;\n}\n// Java program to find convex hull of a set of points. Refer \n// https://www.geeksforgeeks.org/orientation-3-ordered-points/\n// for explanation of orientation()\nimport java.util.*;\n\nclass Point\n{\n    int x, y;\n    Point(int x, int y){\n        this.x=x;\n        this.y=y;\n    }\n}\n\nclass GFG {\n    \n    // To find orientation of ordered triplet (p, q, r).\n    // The function returns following values\n    // 0 --> p, q and r are collinear\n    // 1 --> Clockwise\n    // 2 --> Counterclockwise\n    public static int orientation(Point p, Point q, Point r)\n    {\n        int val = (q.y - p.y) * (r.x - q.x) -\n                  (q.x - p.x) * (r.y - q.y);\n     \n        if (val == 0) return 0;  // collinear\n        return (val > 0)? 1: 2; // clock or counterclock wise\n    }\n    \n    // Prints convex hull of a set of n points.\n    public static void convexHull(Point points[], int n)\n    {\n        // There must be at least 3 points\n        if (n < 3) return;\n     \n        // Initialize Result\n        Vector<Point> hull = new Vector<Point>();\n     \n        // Find the leftmost point\n        int l = 0;\n        for (int i = 1; i < n; i++)\n            if (points[i].x < points[l].x)\n                l = i;\n     \n        // Start from leftmost point, keep moving \n        // counterclockwise until reach the start point\n        // again. This loop runs O(h) times where h is\n        // number of points in result or output.\n        int p = l, q;\n        do\n        {\n            // Add current point to result\n            hull.add(points[p]);\n     \n            // Search for a point 'q' such that \n            // orientation(p, q, x) is counterclockwise \n            // for all points 'x'. The idea is to keep \n            // track of last visited most counterclock-\n            // wise point in q. If any point 'i' is more \n            // counterclock-wise than q, then update q.\n            q = (p + 1) % n;\n            \n            for (int i = 0; i < n; i++)\n            {\n               // If i is more counterclockwise than \n               // current q, then update q\n               if (orientation(points[p], points[i], points[q])\n                                                   == 2)\n                   q = i;\n            }\n     \n            // Now q is the most counterclockwise with\n            // respect to p. Set p as q for next iteration, \n            // so that q is added to result 'hull'\n            p = q;\n     \n        } while (p != l);  // While we don't come to first \n                           // point\n     \n        // Print Result\n        for (Point temp : hull)\n            System.out.println(\"(\" + temp.x + \", \" +\n                                temp.y + \")\");\n    }\n    \n    /* Driver program to test above function */\n    public static void main(String[] args) \n    {\n\n        Point points[] = new Point[7];\n        points[0]=new Point(0, 3);\n        points[1]=new Point(2, 3);\n        points[2]=new Point(1, 1);\n        points[3]=new Point(2, 1);\n        points[4]=new Point(3, 0);\n        points[5]=new Point(0, 0);\n        points[6]=new Point(3, 3);\n        \n        int n = points.length;\n        convexHull(points, n);\n       \n    }\n}\n  \n// This code is contributed by Arnav Kr. Mandal.\n# Python3 program to find convex hull of a set of points. Refer \n# https://www.geeksforgeeks.org/orientation-3-ordered-points/\n# for explanation of orientation()\n\n# point class with x, y as point \nclass Point:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\ndef Left_index(points):\n    \n    '''\n    Finding the left most point\n    '''\n    minn = 0\n    for i in range(1,len(points)):\n        if points[i].x < points[minn].x:\n            minn = i\n        elif points[i].x == points[minn].x:\n            if points[i].y > points[minn].y:\n                minn = i\n    return minn\n\ndef orientation(p, q, r):\n    '''\n    To find orientation of ordered triplet (p, q, r). \n    The function returns following values \n    0 --> p, q and r are collinear \n    1 --> Clockwise \n    2 --> Counterclockwise \n    '''\n    val = (q.y - p.y) * (r.x - q.x) - \\\n          (q.x - p.x) * (r.y - q.y)\n\n    if val == 0:\n        return 0\n    elif val > 0:\n        return 1\n    else:\n        return 2\n\ndef convexHull(points, n):\n    \n    # There must be at least 3 points \n    if n < 3:\n        return\n\n    # Find the leftmost point\n    l = Left_index(points)\n\n    hull = []\n    \n    '''\n    Start from leftmost point, keep moving counterclockwise \n    until reach the start point again. This loop runs O(h) \n    times where h is number of points in result or output. \n    '''\n    p = l\n    q = 0\n    while(True):\n        \n        # Add current point to result \n        hull.append(p)\n\n        '''\n        Search for a point 'q' such that orientation(p, q, \n        x) is counterclockwise for all points 'x'. The idea \n        is to keep track of last visited most counterclock- \n        wise point in q. If any point 'i' is more counterclock- \n        wise than q, then update q. \n        '''\n        q = (p + 1) % n\n\n        for i in range(n):\n            \n            # If i is more counterclockwise \n            # than current q, then update q \n            if(orientation(points[p], \n                           points[i], points[q]) == 2):\n                q = i\n\n        '''\n        Now q is the most counterclockwise with respect to p \n        Set p as q for next iteration, so that q is added to \n        result 'hull' \n        '''\n        p = q\n\n        # While we don't come to first point\n        if(p == l):\n            break\n\n    # Print Result \n    for each in hull:\n        print(points[each].x, points[each].y)\n\n# Driver Code\npoints = []\npoints.append(Point(0, 3))\npoints.append(Point(2, 2))\npoints.append(Point(1, 1))\npoints.append(Point(2, 1))\npoints.append(Point(3, 0))\npoints.append(Point(0, 0))\npoints.append(Point(3, 3))\n\nconvexHull(points, len(points))\n\n# This code is contributed by \n# Akarsh Somani, IIIT Kalyani\n// C# program to find convex hull of a set of points. Refer \n// https://www.geeksforgeeks.org/orientation-3-ordered-points/\n// for explanation of orientation()\nusing System;\nusing System.Collections.Generic; \n    \npublic class Point\n{\n    public int x, y;\n    public Point(int x, int y)\n    {\n        this.x = x;\n        this.y = y;\n    }\n}\n\npublic class GFG \n{\n    \n    // To find orientation of ordered triplet (p, q, r).\n    // The function returns following values\n    // 0 --> p, q and r are collinear\n    // 1 --> Clockwise\n    // 2 --> Counterclockwise\n    public static int orientation(Point p, Point q, Point r)\n    {\n        int val = (q.y - p.y) * (r.x - q.x) -\n                (q.x - p.x) * (r.y - q.y);\n    \n        if (val == 0) return 0; // collinear\n        return (val > 0)? 1: 2; // clock or counterclock wise\n    }\n    \n    // Prints convex hull of a set of n points.\n    public static void convexHull(Point []points, int n)\n    {\n        // There must be at least 3 points\n        if (n < 3) return;\n    \n        // Initialize Result\n        List<Point> hull = new List<Point>();\n    \n        // Find the leftmost point\n        int l = 0;\n        for (int i = 1; i < n; i++)\n            if (points[i].x < points[l].x)\n                l = i;\n    \n        // Start from leftmost point, keep moving \n        // counterclockwise until reach the start point\n        // again. This loop runs O(h) times where h is\n        // number of points in result or output.\n        int p = l, q;\n        do\n        {\n            // Add current point to result\n            hull.Add(points[p]);\n    \n            // Search for a point 'q' such that \n            // orientation(p, q, x) is counterclockwise \n            // for all points 'x'. The idea is to keep \n            // track of last visited most counterclock-\n            // wise point in q. If any point 'i' is more \n            // counterclock-wise than q, then update q.\n            q = (p + 1) % n;\n            \n            for (int i = 0; i < n; i++)\n            {\n            // If i is more counterclockwise than \n            // current q, then update q\n            if (orientation(points[p], points[i], points[q])\n                                                == 2)\n                q = i;\n            }\n    \n            // Now q is the most counterclockwise with\n            // respect to p. Set p as q for next iteration, \n            // so that q is added to result 'hull'\n            p = q;\n    \n        } while (p != l); // While we don't come to first \n                        // point\n    \n        // Print Result\n        foreach (Point temp in hull)\n            Console.WriteLine(\"(\" + temp.x + \", \" +\n                                temp.y + \")\");\n    }\n    \n    /* Driver code */\n    public static void Main(String[] args) \n    {\n\n        Point []points = new Point[7];\n        points[0]=new Point(0, 3);\n        points[1]=new Point(2, 3);\n        points[2]=new Point(1, 1);\n        points[3]=new Point(2, 1);\n        points[4]=new Point(3, 0);\n        points[5]=new Point(0, 0);\n        points[6]=new Point(3, 3);\n        \n        int n = points.Length;\n        convexHull(points, n);\n        \n    }\n}\n\n// This code is contributed by Princi Singh\n<script>\n// Javascript program to find convex hull of a set of points. Refer \n// https://www.geeksforgeeks.org/orientation-3-ordered-points/\n// for explanation of orientation()\n\nclass Point\n{\n    constructor(x, y)\n    {\n        this.x = x;\n        this.y = y;\n    }\n}\n\n// To find orientation of ordered triplet (p, q, r).\n    // The function returns following values\n    // 0 --> p, q and r are collinear\n    // 1 --> Clockwise\n    // 2 --> Counterclockwise\nfunction orientation(p, q, r)\n{\n    let val = (q.y - p.y) * (r.x - q.x) -\n                  (q.x - p.x) * (r.y - q.y);\n       \n        if (val == 0) return 0;  // collinear\n        return (val > 0)? 1: 2; // clock or counterclock wise\n}\n\n// Prints convex hull of a set of n points.\nfunction convexHull(points, n)\n{\n    // There must be at least 3 points\n        if (n < 3) return;\n       \n        // Initialize Result\n        let hull = [];\n       \n        // Find the leftmost point\n        let l = 0;\n        for (let i = 1; i < n; i++)\n            if (points[i].x < points[l].x)\n                l = i;\n       \n        // Start from leftmost point, keep moving \n        // counterclockwise until reach the start point\n        // again. This loop runs O(h) times where h is\n        // number of points in result or output.\n        let p = l, q;\n        do\n        {\n        \n            // Add current point to result\n            hull.push(points[p]);\n       \n            // Search for a point 'q' such that \n            // orientation(p, q, x) is counterclockwise \n            // for all points 'x'. The idea is to keep \n            // track of last visited most counterclock-\n            // wise point in q. If any point 'i' is more \n            // counterclock-wise than q, then update q.\n            q = (p + 1) % n;\n              \n            for (let i = 0; i < n; i++)\n            {\n               // If i is more counterclockwise than \n               // current q, then update q\n               if (orientation(points[p], points[i], points[q])\n                                                   == 2)\n                   q = i;\n            }\n       \n            // Now q is the most counterclockwise with\n            // respect to p. Set p as q for next iteration, \n            // so that q is added to result 'hull'\n            p = q;\n       \n        } while (p != l);  // While we don't come to first \n                           // point\n       \n        // Print Result\n        for (let temp of hull.values())\n            document.write(\"(\" + temp.x + \", \" +\n                                temp.y + \")<br>\");\n}\n\n/* Driver program to test above function */\nlet points = new Array(7);\npoints[0] = new Point(0, 3);\npoints[1] = new Point(2, 3);\npoints[2] = new Point(1, 1);\npoints[3] = new Point(2, 1);\npoints[4] = new Point(3, 0);\npoints[5] = new Point(0, 0);\npoints[6] = new Point(3, 3);\n\nlet n = points.length;\nconvexHull(points, n);\n\n// This code is contributed by avanitrachhadiya2155\n</script>\n(0, 3)\n(0, 0)\n(3, 0)\n(3, 3)\n",
        "complexity": {
            "time": "Worst case, Time complexity: O(n2).  The worst case occurs when all the points are on the hull (m = n).",
            "space": ""
        },
        "tags": [
            "Geometric Algorithms"
        ],
        "url": "https://www.geeksforgeeks.org/convex-hull-using-jarvis-algorithm-or-wrapping/"
    },
    {
        "title": "Pythagorean Quadruple",
        "description": "Given four points, check whether they form Pythagorean Quadruple. It is defined as a tuple of integers a, b, c, d such that . They are basically the solutions of Diophantine Equations. In the geometric interpretation it represents a cuboid with integer side lengths |a|, |b|, |c| and whose space diagonal is |d| .  The cuboids sides shown here are examples of pythagorean quadruples. It is primitive when their greatest common divisor is 1. Every Pythagorean quadruple is an integer multiple of a primitive quadruple. We can generate the set of primitive pythagorean quadruples for which a is odd can be generated by formula : a = m2 + n2 – p2 – q2, b = 2(mq + np), c = 2(nq – mp), d = m2 + n2 + p2 + q2 where m, n, p, q are non-negative integers with greatest common divisor 1 such that m + n + p + q are odd. Thus, all primitive Pythagorean quadruples are characterized by Lebesgue’s identity. (m2 + n2 + p2 + q2)2 = (2mq + 2nq)2 + 2(nq – mp)2 + (m2 + n2 – p2 – q2)m2 + n2 – p2 – q2  Output: Time Complexity: O(1) Auxiliary Space: O(1) References Wiki mathworld S  ",
        "code": "\n\n\n\n\n\n\n\n\n\n\n\nYes\n",
        "complexity": {
            "time": "Time Complexity: O(1) Auxiliary Space: O(1)",
            "space": ""
        },
        "tags": [
            "Geometric Algorithms"
        ],
        "url": "https://www.geeksforgeeks.org/pythagorean-quadruple/"
    },
    {
        "title": "Minimum Cost Polygon Triangulation",
        "description": "A triangulation of a convex polygon is formed by drawing diagonals between non-adjacent vertices (corners) such that the diagonals never intersect. The problem is to find the cost of triangulation with the minimum cost. The cost of a triangulation is sum of the weights of its component triangles. Weight of each triangle is its perimeter (sum of lengths of all sides)See following example taken from this source.  Two triangulations of the same convex pentagon. The triangulation on the left has a cost of 8 + 2?2 + 2?5 (approximately 15.30), the one on the right has a cost of 4 + 2?2 + 4?5 (approximately 15.77). This problem has recursive substructure. The idea is to divide the polygon into three parts: a single triangle, the sub-polygon to the left, and the sub-polygon to the right. We try all possible divisions like this and find the one that minimizes the cost of the triangle plus the cost of the triangulation of the two sub-polygons. Following is implementation of above naive recursive formula. Output: Time Complexity: O(2n) Space Complexity: O(n) for the recursive stack space. The above problem is similar to Matrix Chain Multiplication. The following is recursion tree for mTC(points[], 0, 4).  It can be easily seen in the above recursion tree that the problem has many overlapping subproblems. Since the problem has both properties: Optimal Substructure and Overlapping Subproblems, it can be efficiently solved using dynamic programming.Following is C++ implementation of dynamic programming solution. Output: Time complexity of the above dynamic programming solution is O(n3). Auxiliary Space: O(n*n)Please note that the above implementations assume that the points of convex polygon are given in order (either clockwise or anticlockwise)Exercise: Extend the above solution to print triangulation also. For the above example, the optimal triangulation is 0 3 4, 0 1 3, and 1 2 3.Sources: http://www.cs.utexas.edu/users/djimenez/utsa/cs3343/lecture12.html http://www.cs.utoronto.ca/~heap/Courses/270F02/A4/chains/node2.html  ",
        "code": "Let Minimum Cost of triangulation of vertices from i to j be minCost(i, j)If j < i + 2 Then  minCost(i, j) = 0Else  minCost(i, j) = Min { minCost(i, k) + minCost(k, j) + cost(i, k, j) }                  Here k varies from 'i+1' to 'j-1'Cost of a triangle formed by edges (i, j), (j, k) and (k, i) is   cost(i, j, k)  = dist(i, j) + dist(j, k) + dist(k, i)\n// Recursive implementation for minimum cost convex polygon triangulation\n#include <iostream>\n#include <cmath>\n#define MAX 1000000.0\nusing namespace std;\n\n// Structure of a point in 2D plane\nstruct Point\n{\n    int x, y;\n};\n\n// Utility function to find minimum of two double values\ndouble min(double x, double y)\n{\n    return (x <= y)? x : y;\n}\n\n// A utility function to find distance between two points in a plane\ndouble dist(Point p1, Point p2)\n{\n    return sqrt((p1.x - p2.x)*(p1.x - p2.x) +\n                (p1.y - p2.y)*(p1.y - p2.y));\n}\n\n// A utility function to find cost of a triangle. The cost is considered\n// as perimeter (sum of lengths of all edges) of the triangle\ndouble cost(Point points[], int i, int j, int k)\n{\n    Point p1 = points[i], p2 = points[j], p3 = points[k];\n    return dist(p1, p2) + dist(p2, p3) + dist(p3, p1);\n}\n\n// A recursive function to find minimum cost of polygon triangulation\n// The polygon is represented by points[i..j].\ndouble mTC(Point points[], int i, int j)\n{\n   // There must be at least three points between i and j\n   // (including i and j)\n   if (j < i+2)\n      return 0;\n\n   // Initialize result as infinite\n   double res = MAX;\n\n   // Find minimum triangulation by considering all\n   for (int k=i+1; k<j; k++)\n        res = min(res, (mTC(points, i, k) + mTC(points, k, j) +\n                        cost(points, i, k, j)));\n   return  res;\n}\n\n// Driver program to test above functions\nint main()\n{\n    Point points[] = {{0, 0}, {1, 0}, {2, 1}, {1, 2}, {0, 2}};\n    int n = sizeof(points)/sizeof(points[0]);\n    cout << mTC(points, 0, n-1);\n    return 0;\n}\n// Class to store a point in the Euclidean plane\nclass Point \n{\n  int x, y;\n  public Point(int x, int y)\n  {\n    this.x = x;\n    this.y = y;\n  }\n\n  // Utility function to return the distance between two\n  // vertices in a 2-dimensional plane\n  public double dist(Point p)\n  {\n\n    // The distance between vertices `(x1, y1)` & `(x2,\n    // y2)` is `?((x2 ? x1) ^ 2 + (y2 ? y1) ^ 2)`\n    return Math.sqrt((this.x - p.x) * (this.x - p.x)\n                     + (this.y - p.y) * (this.y - p.y));\n  }\n}\n\nclass GFG \n{\n\n  // Function to calculate the weight of optimal\n  // triangulation of a convex polygon represented by a\n  // given set of vertices `vertices[i..j]`\n  public static double MWT(Point[] vertices, int i, int j)\n  {\n\n    // If the polygon has less than 3 vertices,\n    // triangulation is not possible\n    if (j < i + 2) \n    {\n      return 0;\n    }\n\n    // keep track of the total weight of the minimum\n    // weight triangulation of `MWT(i,j)`\n    double cost = Double.MAX_VALUE;\n\n    // consider all possible triangles `ikj` within the\n    // polygon\n    for (int k = i + 1; k <= j - 1; k++)\n    {\n\n      // The weight of a triangulation is the length\n      // of perimeter of the triangle\n      double weight = vertices[i].dist(vertices[j])\n        + vertices[j].dist(vertices[k])\n        + vertices[k].dist(vertices[i]);\n\n      // choose the vertex `k` that leads to the\n      // minimum total weight\n      cost = Double.min(cost,\n                        weight + MWT(vertices, i, k)\n                        + MWT(vertices, k, j));\n    }\n    return cost;\n  }\n\n  // Driver code\n  public static void main(String[] args)\n  {\n\n    // vertices are given in clockwise order\n    Point[] vertices\n      = { new Point(0, 0), new Point(2, 0),\n         new Point(2, 1), new Point(1, 2),\n         new Point(0, 1) };\n\n    System.out.println(MWT(vertices,\n                           0, vertices.length - 1));\n  }\n}\n\n// This code is contributed by Priiyadarshini Kumari\n# Recursive implementation for minimum \n# cost convex polygon triangulation\nfrom math import sqrt\nMAX = 1000000.0\n\n# A utility function to find distance\n# between two points in a plane\ndef dist(p1, p2):\n    return sqrt((p1[0] - p2[0])*(p1[0] - p2[0]) + \\\n                (p1[1] - p2[1])*(p1[1] - p2[1]))\n\n# A utility function to find cost of \n# a triangle. The cost is considered\n# as perimeter (sum of lengths of all edges)\n# of the triangle\ndef cost(points, i, j, k):\n    p1 = points[i]\n    p2 = points[j]\n    p3 = points[k]\n    return dist(p1, p2) + dist(p2, p3) + dist(p3, p1)\n\n\n# A recursive function to find minimum \n# cost of polygon triangulation\n# The polygon is represented by points[i..j].\ndef mTC(points, i, j):\n    \n    # There must be at least three points between i and j\n    # (including i and j)\n    if (j < i + 2):\n        return 0\n        \n    # Initialize result as infinite\n    res = MAX\n    \n    # Find minimum triangulation by considering all\n    for k in range(i + 1, j):\n        res = min(res, (mTC(points, i, k) + \\\n                        mTC(points, k, j) + \\\n                        cost(points, i, k, j)))\n    \n    return round(res, 4)\n\n\n# Driver code\npoints = [[0, 0], [1, 0], [2, 1], [1, 2], [0, 2]]\nn = len(points)\nprint(mTC(points, 0, n-1))\n\n# This code is contributed by SHUBHAMSINGH10\nusing System;\nusing System.Collections.Generic;\n\n// Class to store a point in the Euclidean plane\npublic  class Point {\n  public int x, y;\n\n  public Point(int x, int y) {\n    this.x = x;\n    this.y = y;\n  }\n\n  // Utility function to return the distance between two\n  // vertices in a 2-dimensional plane\n  public double dist(Point p) {\n\n    // The distance between vertices `(x1, y1)` & `(x2,\n    // y2)` is `?((x2 ? x1) ^ 2 + (y2 ? y1) ^ 2)`\n    return Math.Sqrt((this.x - p.x) * (this.x - p.x) + \n                     (this.y - p.y) * (this.y - p.y));\n  }\n}\n\npublic class GFG {\n\n  // Function to calculate the weight of optimal\n  // triangulation of a convex polygon represented by a\n  // given set of vertices `vertices[i..j]`\n  public static double MWT(Point[] vertices, int i, int j) {\n\n    // If the polygon has less than 3 vertices,\n    // triangulation is not possible\n    if (j < i + 2) {\n      return 0;\n    }\n\n    // keep track of the total weight of the minimum\n    // weight triangulation of `MWT(i,j)`\n    double cost = 9999999999999.09;\n\n    // consider all possible triangles `ikj` within the\n    // polygon\n    for (int k = i + 1; k <= j - 1; k++) {\n\n      // The weight of a triangulation is the length\n      // of perimeter of the triangle\n      double weight = vertices[i].dist(vertices[j]) + \n        vertices[j].dist(vertices[k])\n        + vertices[k].dist(vertices[i]);\n\n      // choose the vertex `k` that leads to the\n      // minimum total weight\n      cost = Math.Min(cost, weight + \n                      MWT(vertices, i, k) + \n                      MWT(vertices, k, j));\n    }\n    return Math.Round(cost,4);\n  }\n\n  // Driver code\n  public static void Main(String[] args) {\n\n    // vertices are given in clockwise order\n    Point[] vertices = { new Point(0, 0),\n                        new Point(2, 0), \n                        new Point(2, 1), \n                        new Point(1, 2), \n                        new Point(0, 1) };\n\n    Console.WriteLine(MWT(vertices, 0, vertices.Length - 1));\n  }\n}\n\n// This code is contributed by gauravrajput1\n// A JavaScript program for a \n// Recursive implementation for minimum cost convex polygon triangulation\nconst MAX = 1.79769e+308;\n\n// Utility function to find minimum of two double values\nfunction min(x, y)\n{\n    return (x <= y)? x : y;\n}\n\n// A utility function to find distance between two points in a plane\nfunction dist(p1, p2)\n{\n    return Math.sqrt((p1[0] - p2[0])*(p1[0] - p2[0]) + (p1[1] - p2[1])*(p1[1] - p2[1]));\n}\n\n// A utility function to find cost of a triangle. The cost is considered\n// as perimeter (sum of lengths of all edges) of the triangle\nfunction cost(points, i, j, k)\n{\n    p1 = points[i], p2 = points[j], p3 = points[k];\n    return dist(p1, p2) + dist(p2, p3) + dist(p3, p1);\n}\n\n// A recursive function to find minimum cost of polygon triangulation\n// The polygon is represented by points[i..j].\nfunction mTC(points, i, j)\n{\n   // There must be at least three points between i and j\n   // (including i and j)\n   if (j < i+2){\n       return 0;\n   }\n      \n   // Initialize result as infinite\n   let res = MAX;\n\n   // Find minimum triangulation by considering all\n   for (let k=i+1; k<j; k++){\n       res = min(res, (mTC(points, i, k) + mTC(points, k, j) + cost(points, i, k, j)));\n   }\n    \n   return  res;\n}\n\n// Driver program to test above functions\n{\n    let points =    [[0, 0], [1, 0], [2, 1], [1, 2],[0, 2]]\n    let n = points.length;\n    console.log(mTC(points, 0, n-1));\n}\n\n// The code is contributed by Nidhi Goel\n15.3006\n// A Dynamic Programming based program to find minimum cost of convex\n// polygon triangulation\n#include <iostream>\n#include <cmath>\n#define MAX 1000000.0\nusing namespace std;\n\n// Structure of a point in 2D plane\nstruct Point\n{\n    int x, y;\n};\n\n// Utility function to find minimum of two double values\ndouble min(double x, double y)\n{\n    return (x <= y)? x : y;\n}\n\n// A utility function to find distance between two points in a plane\ndouble dist(Point p1, Point p2)\n{\n    return sqrt((p1.x - p2.x)*(p1.x - p2.x) +\n                (p1.y - p2.y)*(p1.y - p2.y));\n}\n\n// A utility function to find cost of a triangle. The cost is considered\n// as perimeter (sum of lengths of all edges) of the triangle\ndouble cost(Point points[], int i, int j, int k)\n{\n    Point p1 = points[i], p2 = points[j], p3 = points[k];\n    return dist(p1, p2) + dist(p2, p3) + dist(p3, p1);\n}\n\n// A Dynamic programming based function to find minimum cost for convex\n// polygon triangulation.\ndouble mTCDP(Point points[], int n)\n{\n   // There must be at least 3 points to form a triangle\n   if (n < 3)\n      return 0;\n\n   // table to store results of subproblems.  table[i][j] stores cost of\n   // triangulation of points from i to j.  The entry table[0][n-1] stores\n   // the final result.\n   double table[n][n];\n\n   // Fill table using above recursive formula. Note that the table\n   // is filled in diagonal fashion i.e., from diagonal elements to\n   // table[0][n-1] which is the result.\n   for (int gap = 0; gap < n; gap++)\n   {\n      for (int i = 0, j = gap; j < n; i++, j++)\n      {\n          if (j < i+2)\n             table[i][j] = 0.0;\n          else\n          {\n              table[i][j] = MAX;\n              for (int k = i+1; k < j; k++)\n              {\n                double val = table[i][k] + table[k][j] + cost(points,i,j,k);\n                if (table[i][j] > val)\n                     table[i][j] = val;\n              }\n          }\n      }\n   }\n   return  table[0][n-1];\n}\n\n// Driver program to test above functions\nint main()\n{\n    Point points[] = {{0, 0}, {1, 0}, {2, 1}, {1, 2}, {0, 2}};\n    int n = sizeof(points)/sizeof(points[0]);\n    cout << mTCDP(points, n);\n    return 0;\n}\n// A Dynamic Programming based program to find minimum cost\n// of convex polygon triangulation\nimport java.util.*;\n\nclass GFG\n{\n  \n  // Structure of a point in 2D plane\n  static class Point {\n    int x, y;\n    Point(int x, int y)\n    {\n      this.x = x;\n      this.y = y;\n    }\n  }\n\n  // Utility function to find minimum of two double values\n  static double min(double x, double y)\n  {\n    return (x <= y) ? x : y;\n  }\n\n  // A utility function to find distance between two\n  // points in a plane\n  static double dist(Point p1, Point p2)\n  {\n    return Math.sqrt((p1.x - p2.x) * (p1.x - p2.x)\n                     + (p1.y - p2.y) * (p1.y - p2.y));\n  }\n\n  // A utility function to find cost of a triangle. The\n  // cost is considered as perimeter (sum of lengths of\n  // all edges) of the triangle\n  static double cost(Point points[], int i, int j, int k)\n  {\n    Point p1 = points[i], p2 = points[j],\n    p3 = points[k];\n    return dist(p1, p2) + dist(p2, p3) + dist(p3, p1);\n  }\n\n  // A Dynamic programming based function to find minimum\n  // cost for convex polygon triangulation.\n  static double mTCDP(Point points[], int n)\n  {\n    // There must be at least 3 points to form a\n    // triangle\n    if (n < 3)\n      return 0;\n\n    // table to store results of subproblems.\n    // table[i][j] stores cost of triangulation of\n    // points from i to j.  The entry table[0][n-1]\n    // stores the final result.\n    double[][] table = new double[n][n];\n\n    // Fill table using above recursive formula. Note\n    // that the table is filled in diagonal fashion\n    // i.e., from diagonal elements to table[0][n-1]\n    // which is the result.\n    for (int gap = 0; gap < n; gap++) {\n      for (int i = 0, j = gap; j < n; i++, j++) {\n        if (j < i + 2)\n          table[i][j] = 0.0;\n        else {\n          table[i][j] = 1000000.0;\n          for (int k = i + 1; k < j; k++) {\n            double val\n              = table[i][k] + table[k][j]\n              + cost(points, i, j, k);\n            if (table[i][j] > val)\n              table[i][j] = val;\n          }\n        }\n      }\n    }\n    return table[0][n - 1];\n  }\n\n  // Driver program to test above functions\n  public static void main(String[] args)\n  {\n    Point[] points = { new Point(0, 0), new Point(1, 0),\n                      new Point(2, 1), new Point(1, 2),\n                      new Point(0, 2) };\n    int n = points.length;\n    System.out.println(mTCDP(points, n));\n  }\n}\n\n// This code is contributed by Karandeep Singh\n# A Dynamic Programming based program to find minimum cost\n# of convex polygon triangulation\n\nimport math\n\n\nclass GFG:\n    # Structure of a point in 2D plane\n    class Point:\n        x = 0\n        y = 0\n\n        def __init__(self, x,  y):\n            self.x = x\n            self.y = y\n    # Utility function to find minimum of two double values\n\n    @staticmethod\n    def min(x,  y):\n        return x if (x <= y) else y\n    # A utility function to find distance between two\n    # points in a plane\n\n    @staticmethod\n    def dist(p1,  p2):\n        return math.sqrt((p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y - p2.y))\n    # A utility function to find cost of a triangle. The\n    # cost is considered as perimeter (sum of lengths of\n    # all edges) of the triangle\n\n    @staticmethod\n    def cost(points,  i,  j,  k):\n        p1 = points[i]\n        p2 = points[j]\n        p3 = points[k]\n        return GFG.dist(p1, p2) + GFG.dist(p2, p3) + GFG.dist(p3, p1)\n    # A Dynamic programming based function to find minimum\n    # cost for convex polygon triangulation.\n\n    @staticmethod\n    def mTCDP(points,  n):\n        # There must be at least 3 points to form a\n        # triangle\n        if (n < 3):\n            return 0\n        # table to store results of subproblems.\n        # table[i][j] stores cost of triangulation of\n        # points from i to j. The entry table[0][n-1]\n        # stores the final result.\n        table = [[0.0] * (n) for _ in range(n)]\n        # Fill table using above recursive formula. Note\n        # that the table is filled in diagonal fashion\n        # i.e., from diagonal elements to table[0][n-1]\n        # which is the result.\n        gap = 0\n        while (gap < n):\n            i = 0\n            j = gap\n            while (j < n):\n                if (j < i + 2):\n                    table[i][j] = 0.0\n                else:\n                    table[i][j] = 1000000.0\n                    k = i + 1\n                    while (k < j):\n                        val = table[i][k] + table[k][j] + \\\n                            GFG.cost(points, i, j, k)\n                        if (table[i][j] > val):\n                            table[i][j] = val\n                        k += 1\n                i += 1\n                j += 1\n            gap += 1\n        return table[0][n - 1]\n\n\n# Driver program to test above functions\nif __name__ == \"__main__\":\n    points = [GFG.Point(0, 0), GFG.Point(1, 0), GFG.Point(\n        2, 1), GFG.Point(1, 2), GFG.Point(0, 2)]\n    n = len(points)\n    print(GFG.mTCDP(points, n))\n\n# This code is contributed by Aarti_Rathi\nusing System;\n\n// A Dynamic Programming based program to find minimum cost\n// of convex polygon triangulation\n\n// Structure of a point in 2D plane\npublic class Point {\n  public int x;\n  public int y;\n}\n\npublic static class Globals {\n  public const double MAX = 1000000.0;\n  // Utility function to find minimum of two double values\n  public static double min(double x, double y)\n  {\n    return (x <= y) ? x : y;\n  }\n\n  // A utility function to find distance between two\n  // points in a plane\n  public static double dist(Point p1, Point p2)\n  {\n    return Math.Sqrt((p1.x - p2.x) * (p1.x - p2.x)\n                     + (p1.y - p2.y) * (p1.y - p2.y));\n  }\n\n  // A utility function to find cost of a triangle. The\n  // cost is considered as perimeter (sum of lengths of\n  // all edges) of the triangle\n  public static double cost(Point[] points, int i, int j,\n                            int k)\n  {\n    Point p1 = points[i];\n    Point p2 = points[j];\n    Point p3 = points[k];\n\n    return (dist(p1, p2) + dist(p2, p3) + dist(p3, p1));\n  }\n\n  // A Dynamic programming based function to find minimum\n  // cost for convex polygon triangulation.\n  public static double mTCDP(Point[] points, int n)\n  {\n    // There must be at least 3 points to form a\n    // triangle\n    if (n < 3) {\n      return 0;\n    }\n\n    // table to store results of subproblems.\n    // table[i][j] stores cost of triangulation of\n    // points from i to j. The entry table[0][n-1]\n    // stores the final result.\n    double[, ] table = new double[n, n];\n    ;\n\n    // Fill table using above recursive formula. Note\n    // that the table is filled in diagonal fashion\n    // i.e., from diagonal elements to table[0][n-1]\n    // which is the result.\n    for (int gap = 0; gap < n; gap++) {\n      for (int i = 0, j = gap; j < n; i++, j++) {\n        if (j < i + 2) {\n          table[i, j] = 0.0;\n        }\n        else {\n          table[i, j] = MAX;\n          for (int k = i + 1; k < j; k++) {\n            double val\n              = table[i, k] + table[k, j]\n              + cost(points, i, j, k);\n            if (table[i, j] > val) {\n              table[i, j] = val;\n            }\n          }\n        }\n      }\n    }\n    return table[0, n - 1];\n  }\n\n  // Driver program to test above functions\n  public static void Main()\n  {\n    Point[] points = { new Point(){ x = 0, y = 0 },\n                      new Point(){ x = 1, y = 0 },\n                      new Point(){ x = 2, y = 1 },\n                      new Point(){ x = 1, y = 2 },\n                      new Point(){ x = 0, y = 2 } };\n\n    int n = points.Length;\n    Console.Write(mTCDP(points, n));\n  }\n}\n\n// This code is contributed by Aarti_Rathi\n// A Dynamic Programming based program to \n// find minimum cost of convex polygon triangulation\nconst MAX = 1000000.0;\n\n// Structure of a point in 2D plane\nclass Point {\n  constructor(x, y) {\n    this.x = x;\n    this.y = y;\n  }\n}\n\n// Utility function to find minimum of two double values\nfunction min(x, y) {\n  return x <= y ? x : y;\n}\n\n// A utility function to find distance between two points in a plane\nfunction dist(p1, p2) {\n  return Math.sqrt((p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y - p2.y));\n}\n\n// A utility function to find cost of a triangle. The cost is considered as perimeter (sum of lengths of all edges) of the triangle\nfunction cost(points, i, j, k) {\n  let p1 = points[i],\n    p2 = points[j],\n    p3 = points[k];\n  return dist(p1, p2) + dist(p2, p3) + dist(p3, p1);\n}\n\n// A Dynamic programming based function to find minimum cost for convex polygon triangulation.\nfunction mTCDP(points, n) {\n  // There must be at least 3 points to form a triangle\n  if (n < 3) return 0;\n\n  // table to store results of subproblems. \n  // table[i][j] stores cost of triangulation \n  // of points from i to j.  The entry table[0][n-1] stores the final result.\n  let table = new Array(n);\n  for (let i = 0; i < n; i++) {\n    table[i] = new Array(n);\n  }\n\n  // Fill table using above recursive formula. \n  // Note that the table is filled in \n  // diagonal fashion i.e., from diagonal \n  // elements to table[0][n-1] which is the result.\n  for (let gap = 0; gap < n; gap++) {\n    for (let i = 0, j = gap; j < n; i++, j++) {\n      if (j < i + 2) {\n        table[i][j] = 0;\n      } else {\n        table[i][j] = MAX;\n        for (let k = i + 1; k < j; k++) {\n          let val = table[i][k] + table[k][j] + cost(points, i, j, k);\n          if (table[i][j] > val) {\n            table[i][j] = val;\n          }\n        }\n      }\n    }\n  }\n  return table[0][n - 1];\n}\n\n// Driver program to test above functions\nlet points = [new Point(0, 0), new Point(1, 0), new Point(2, 1), new Point(1, 2), new Point(0, 2)];\nlet n = points.length;\nlet result = mTCDP(points, n);\nconsole.log(Math.ceil(result * 10000) / 10000);\n\n// This code is contributed by lokeshpotta20.\n15.3006\n",
        "complexity": {
            "time": "Time complexity of the above dynamic programming solution is O(n3).",
            "space": "Space Complexity: O(n) for the recursive stack space."
        },
        "tags": [
            "Geometric Algorithms"
        ],
        "url": "https://www.geeksforgeeks.org/minimum-cost-polygon-triangulation/"
    },
    {
        "title": "DSA Tutorial - Learn Data Structures and Algorithms",
        "description": "DSA (Data Structures and Algorithms)  is the study of organizing data efficiently using data structures like arrays, stacks, and trees, paired with step-by-step procedures (or algorithms) to solve problems effectively. Data structures manage how data is stored and accessed, while algorithms focus on processing this data. Hoping you have learned a programming language of your choice, here comes the next stage of the roadmap - Learn about Time and Space Complexities. Once you have learned basics of a programming language, it is recommended that you learn basic logic building To analyze algorithms, we mainly measure order of growth of time or space taken in terms of input size.  We do this in the worst case scenario in most of the cases. Please refer the below links for a clear understanding of these concepts. Array is a linear data structure where elements are allocated contiguous memory, allowing for constant-time access. Searching algorithms are used to locate specific data within a large set of data. It helps find a target value within the data. There are various types of searching algorithms, each with its own approach and efficiency. Sorting algorithms are used to arrange the elements of a list in a specific order, such as numerical or alphabetical. It organizes the items in a systematic way, making it easier to search for and access specific elements. Hashing is a technique that generates a fixed-size output (hash value) from an input of variable size using mathematical formulas called hash functions. Hashing is commonly used in data structures for efficient searching, insertion and deletion. In Two Pointer Technique, we typically use two index variables from two corners of an array. We use the two pointer technique for searching a required point or value in an array. In Window Sliding Technique, we use the result of previous subarray to quickly compute the result of current. In Prefix Sum Technique, we compute prefix sums of an array to quickly find results for a subarray. String is a sequence of characters, typically immutable and have limited set of elements (lower case or all English alphabets). Recursion is a programming technique where a function calls itself within its own definition. It is usually used to solve problems that can be broken down into smaller instances of the same problem. Matrix is a two-dimensional array of elements, arranged in rows and columns. It is represented as a rectangular grid, with each element at the intersection of a row and column. Linked list is a linear data structure that stores data in nodes, which are connected by pointers. Unlike arrays, nodes of linked lists are not stored in contiguous memory locations and can only be accessed sequentially, starting from the head of list. Stack is a linear data structure that follows the Last In, First Out (LIFO) principle. Stacks play an important role in managing function calls, memory, and are widely used in algorithms like stock span problem, next greater element and largest area in a histogram. Queue is a linear data structure that follows the First In, First Out (FIFO) principle. Queues play an important role in managing tasks or data in order, scheduling and message handling systems. A deque (double-ended queue) is a data structure that allows elements to be added or removed from both ends efficiently. Tree is a non-linear, hierarchical data structure consisting of nodes connected by edges, with a top node called the root and nodes having child nodes. It is widely used in file systems, databases, decision-making algorithms, etc. Heap is a complete binary tree data structure that satisfies the heap property. Heaps are usually used to implement priority queues, where the smallest or largest element is always at the root of the tree. Graph is a non-linear data structure consisting of a finite set of vertices(or nodes) and a set of edges(or links)that connect a pair of nodes. Graphs are widely used to represent relationships between entities. Greedy Algorithm builds up the solution one piece at a time and chooses the next piece which gives the most obvious and immediate benefit i.e., which is the most optimal choice at that moment. So the problems where choosing locally optimal also leads to the global solutions are best fit for Greedy. Dynamic Programming is a method used to solve complex problems by breaking them down into simpler subproblems. By solving each subproblem only once and storing the results, it avoids redundant computations, leading to more efficient solutions for a wide range of problems. Bitwise Algorithms: Operate on individual bits of numbers. Backtracking Algorithm : Follow Recursion  with the option to revert and traces back if the solution from current point is not feasible. Divide and conquer:  A strategy to solve problems by dividing them into smaller subproblems, solving those subproblems, and combining the solutions to obtain the final solution. Branch and Bound : Used in combinatorial optimization problems to systematically search for the best solution. It works by dividing the problem into smaller subproblems, or branches, and then eliminating certain branches based on bounds on the optimal solution. This process continues until the best solution is found or all branches have been explored. Geometric algorithms are a set of algorithms that solve problems related to shapes, points, lines and polygons. Randomized algorithms are algorithms that use randomness to solve problems. They make use of random input to achieve their goals, often leading to simpler and more efficient solutions. These algorithms may not product same result but are particularly useful in situations when a probabilistic approach is acceptable. Advanced Data Structures like Trie, Segment Tree, Red-Black Tree and Binary Indexed Tree offer significant performance improvements for specific problem domains. They provide efficient solutions for tasks like fast prefix searches, range queries, dynamic updates, and maintaining balanced data structures, which are crucial for handling large datasets and real-time processing. By optimizing time complexity, they enable better scalability and faster execution in many computational problems. R  ",
        "code": "",
        "complexity": {
            "time": "Advanced Data Structures like Trie, Segment Tree, Red-Black Tree and Binary Indexed Tree offer significant performance improvements for specific problem domains. They provide efficient solutions for tasks like fast prefix searches, range queries, dynamic updates, and maintaining balanced data structures, which are crucial for handling large datasets and real-time processing. By optimizing time complexity, they enable better scalability and faster execution in many computational problems.",
            "space": ""
        },
        "tags": [
            "Mathematical Algorithms"
        ],
        "url": "https://www.geeksforgeeks.org/learn-data-structures-and-algorithms-dsa-tutorial"
    },
    {
        "title": "No Title",
        "description": "",
        "code": "",
        "complexity": {
            "time": "",
            "space": ""
        },
        "tags": [
            "Mathematical Algorithms"
        ],
        "url": "https://www.geeksforgeeks.org/explore?page=1&category=Mathematical&sortBy=submissions"
    },
    {
        "title": "Mathematical Algorithms",
        "description": "The following is the list of mathematical coding problem ordered topic wise. Please refer Mathematical Algorithms (Difficulty Wise) for the difficulty wise list of problems. Quick Links : H  ",
        "code": "",
        "complexity": {
            "time": "",
            "space": ""
        },
        "tags": [
            "Mathematical Algorithms"
        ],
        "url": "https://www.geeksforgeeks.org/mathematical-algorithms/"
    },
    {
        "title": "Generate Pythagorean Triplets",
        "description": "Given a positive integer limit, your task is to find all possible Pythagorean Triplet (a, b, c), such that a <= b <= c <= limit. Note: A Pythagorean triplet is a set of three positive integers a, b, and c such that a2 + b2 = c2. Input: limit = 20Output: 3 4 5               5 12 13               6 8 10               8 15 17              9 12 15              12 16 20Explanation: All the triplets are arranged in the format (a, b, c), where a2 + b2 = c2. The idea is to use nested loops to generate all possible combinations of a, b, and c. For each combination check if a2 + b2 = c2, if the condition satisfies store the triplet, else move to next combination. Time Complexity: O(n3), where n is representing the limit.Space Complexity: O(1) The idea is to use Two Pointers to generate combinations of a & b in linear time, and check if a2 + b2 = c2. To do so, iterate through all values of c from 1 to limit, and set a = 1, and b = c – 1. At each iteration there are three possibilities: Time Complexity: O(n2), where n is representing the triplets.Space Complexity: O(1) Note: The below given method doesn’t generate all triplets smaller than a given limit. For example “9 12 15” which is a valid triplet is not printed by above method. The idea is to use square sum relation of Pythagorean Triplet that states that addition of squares of a and b is equal to square of c. We can write these numbers in terms of m and n such that, a = m2 – n2 b = 2 * m * n       c  = m2 + n2because,       a2 = m4 + n4 – 2 * m2 * n2 b2 = 4 * m2 * n2 c2 = m4 + n4 + 2* m2 * n2 We can see that a2 + b2 = c2, so instead of iterating for a, b and c we can iterate for m and n and can generate these triplets. Time complexity of this approach is O(√n) where n is the given limit. We are iterating until c <= limit ,where c = m^2 + n^2. Thus the iteration will take place approximately sqrt(limit) times.Auxiliary space: O(1) as it is using constant space for variablesReferences: https://en.wikipedia.org/wiki/Formulas_for_generating_Pythagorean_triples U  ",
        "code": "// C++ program to find all Pythagorean\n// Triplets smaller than a given limit\n#include<bits/stdc++.h>\nusing namespace std;\n\n// Function to generate all Pythagorean\n// Triplets smaller than limit\nvector<vector<int>> pythagoreanTriplets(int limit) {\n\n    // to hold the triplets\n    vector<vector<int>> ans;\n\n    for(int a = 1; a<=limit; a++) {\n        for(int b = a; b<=limit; b++) {\n            for(int c = b; c<=limit; c++) {\n                if(a * a + b * b == c * c) {\n                    ans.push_back({a,b,c});\n                }\n            }\n        }\n    }\n    return ans;\n}\n\nint main() {\n    int limit = 20;\n    vector<vector<int>> ans = pythagoreanTriplets(limit);\n    for (int i = 0; i < ans.size(); i++) {\n        for (int j = 0; j < 3; j++) {\n            cout << ans[i][j] << \" \";\n        }\n        cout << endl;\n    }\n    return 0;\n}\n// C program to find all Pythagorean\n// Triplets smaller than a given limit\n#include <stdio.h>\n\nvoid pythagoreanTriplets(int limit) {\n\n    // to hold the triplets\n    int a, b, c;\n\n    for(a = 1; a <= limit; a++) {\n        for(b = a; b <= limit; b++) {\n            for(c = b; c <= limit; c++) {\n                if(a * a + b * b == c * c) {\n                    printf(\"%d %d %d\\n\", a, b, c);\n                }\n            }\n        }\n    }\n}\n\nint main() {\n    int limit = 20;\n    pythagoreanTriplets(limit);\n    return 0;\n}\n// Java program to find all Pythagorean\n// Triplets smaller than a given limit\nimport java.util.*;\n\nclass GFG {\n\n    // Function to generate all Pythagorean\n    // Triplets smaller than limit\n    static List<List<Integer>> pythagoreanTriplets(int limit) {\n\n        // to hold the triplets\n        List<List<Integer>> ans = new ArrayList<>();\n\n        for(int a = 1; a <= limit; a++) {\n            for(int b = a; b <= limit; b++) {\n                for(int c = b; c <= limit; c++) {\n                    if(a * a + b * b == c * c) {\n                        ans.add(Arrays.asList(a, b, c));\n                    }\n                }\n            }\n        }\n        return ans;\n    }\n\n    public static void main(String[] args) {\n        int limit = 20;\n        List<List<Integer>> ans = pythagoreanTriplets(limit);\n\n        for (List<Integer> triplet : ans) {\n            for (int num : triplet) {\n                System.out.print(num + \" \");\n            }\n            System.out.println();\n        }\n    }\n}\n# Python program to find all Pythagorean\n# Triplets smaller than a given limit\n\ndef pythagoreanTriplets(limit):\n\n    # to hold the triplets\n    ans = []\n\n    for a in range(1, limit + 1):\n        for b in range(a, limit + 1):\n            for c in range(b, limit + 1):\n                if a * a + b * b == c * c:\n                    ans.append([a, b, c])\n\n    return ans\n\n# Driver code\nlimit = 20\nans = pythagoreanTriplets(limit)\n\nfor triplet in ans:\n    for num in triplet:\n        print(num, end=\" \")\n    print()\n// C# program to find all Pythagorean\n// Triplets smaller than a given limit\n\nusing System;\nusing System.Collections.Generic;\n\nclass GFG {\n\n    // Function to generate all Pythagorean\n    // Triplets smaller than limit\n    static List<List<int>> pythagoreanTriplets(int limit) {\n\n        // to hold the triplets\n        List<List<int>> ans = new List<List<int>>();\n\n        for(int a = 1; a <= limit; a++) {\n            for(int b = a; b <= limit; b++) {\n                for(int c = b; c <= limit; c++) {\n                    if(a * a + b * b == c * c) {\n                        ans.Add(new List<int> { a, b, c });\n                    }\n                }\n            }\n        }\n        return ans;\n    }\n\n    static void Main() {\n        int limit = 20;\n        List<List<int>> ans = pythagoreanTriplets(limit);\n\n        foreach (List<int> triplet in ans) {\n            foreach (int num in triplet) {\n                Console.Write(num + \" \");\n            }\n            Console.WriteLine();\n        }\n    }\n}\n// JavaScript program to find all Pythagorean\n// Triplets smaller than a given limit\n\nfunction pythagoreanTriplets(limit) {\n\n    // to hold the triplets\n    let ans = [];\n\n    for(let a = 1; a <= limit; a++) {\n        for(let b = a; b <= limit; b++) {\n            for(let c = b; c <= limit; c++) {\n                if(a * a + b * b === c * c) {\n                    ans.push([a, b, c]);\n                }\n            }\n        }\n    }\n    return ans;\n}\n\n// Driver code\nlet limit = 20;\nlet ans = pythagoreanTriplets(limit);\n\nfor (let triplet of ans) {\n    console.log(triplet.join(\" \"));\n}\n3 4 5 \n5 12 13 \n6 8 10 \n8 15 17 \n9 12 15 \n12 16 20\n// C++ program to find all Pythagorean\n// Triplets smaller than a given limit\n#include<bits/stdc++.h>\nusing namespace std;\n\n// Function to generate all Pythagorean\n// Triplets smaller than limit\nvector<vector<int>> pythagoreanTriplets(int limit) {\n\n    // to hold the triplets\n    vector<vector<int>> ans;\n\n    for(int c = 1; c<=limit; c++) {\n        int a = 1, b = c - 1;\n        while (a <= b) {\n            if (a * a + b * b == c * c) {\n                ans.push_back({a,b,c});\n                break;\n            }\n            else if (a * a + b * b < c * c) {\n                a++;\n            }\n            else {\n                b--;\n            }\n        }\n    }\n    return ans;\n}\n\nint main() {\n    int limit = 20;\n    vector<vector<int>> ans = pythagoreanTriplets(limit);\n    for (int i = 0; i < ans.size(); i++) {\n        for (int j = 0; j < 3; j++) {\n            cout << ans[i][j] << \" \";\n        }\n        cout << endl;\n    }\n    return 0;\n}\n// Java program to find all Pythagorean\n// Triplets smaller than a given limit\nimport java.util.*;\n\nclass GFG {\n\n    // Function to generate all Pythagorean\n    // Triplets smaller than limit\n    static List<List<Integer>> pythagoreanTriplets(int limit) {\n\n        // to hold the triplets\n        List<List<Integer>> ans = new ArrayList<>();\n\n        for(int c = 1; c <= limit; c++) {\n            int a = 1, b = c - 1;\n            while (a <= b) {\n                if (a * a + b * b == c * c) {\n                    ans.add(Arrays.asList(a, b, c));\n                    break;\n                }\n                else if (a * a + b * b < c * c) {\n                    a++;\n                }\n                else {\n                    b--;\n                }\n            }\n        }\n        return ans;\n    }\n\n    public static void main(String[] args) {\n        int limit = 20;\n        List<List<Integer>> ans = pythagoreanTriplets(limit);\n        for (int i = 0; i < ans.size(); i++) {\n            for (int j = 0; j < 3; j++) {\n                System.out.print(ans.get(i).get(j) + \" \");\n            }\n            System.out.println();\n        }\n    }\n}\n# Python program to find all Pythagorean\n# Triplets smaller than a given limit\n\ndef pythagoreanTriplets(limit):\n\n    # to hold the triplets\n    ans = []\n\n    for c in range(1, limit + 1):\n        a, b = 1, c - 1\n        while a <= b:\n            if a * a + b * b == c * c:\n                ans.append([a, b, c])\n                break\n            elif a * a + b * b < c * c:\n                a += 1\n            else:\n                b -= 1\n    return ans\n\n# Driver code\nlimit = 20\nans = pythagoreanTriplets(limit)\nfor i in range(len(ans)):\n    for j in range(3):\n        print(ans[i][j], end=\" \")\n    print()\n// C# program to find all Pythagorean\n// Triplets smaller than a given limit\n\nusing System;\nusing System.Collections.Generic;\n\nclass GFG {\n\n    // Function to generate all Pythagorean\n    // Triplets smaller than limit\n    static List<List<int>> pythagoreanTriplets(int limit) {\n\n        // to hold the triplets\n        List<List<int>> ans = new List<List<int>>();\n\n        for(int c = 1; c <= limit; c++) {\n            int a = 1, b = c - 1;\n            while (a <= b) {\n                if (a * a + b * b == c * c) {\n                    ans.Add(new List<int> { a, b, c });\n                    break;\n                }\n                else if (a * a + b * b < c * c) {\n                    a++;\n                }\n                else {\n                    b--;\n                }\n            }\n        }\n        return ans;\n    }\n\n    public static void Main() {\n        int limit = 20;\n        List<List<int>> ans = pythagoreanTriplets(limit);\n        for (int i = 0; i < ans.Count; i++) {\n            for (int j = 0; j < 3; j++) {\n                Console.Write(ans[i][j] + \" \");\n            }\n            Console.WriteLine();\n        }\n    }\n}\n// JavaScript program to find all Pythagorean\n// Triplets smaller than a given limit\n\nfunction pythagoreanTriplets(limit) {\n\n    // to hold the triplets\n    let ans = [];\n\n    for(let c = 1; c <= limit; c++) {\n        let a = 1, b = c - 1;\n        while (a <= b) {\n            if (a * a + b * b === c * c) {\n                ans.push([a, b, c]);\n                break;\n            }\n            else if (a * a + b * b < c * c) {\n                a++;\n            }\n            else {\n                b--;\n            }\n        }\n    }\n    return ans;\n}\n\n// Driver code\nlet limit = 20;\nlet ans = pythagoreanTriplets(limit);\nfor (let i = 0; i < ans.length; i++) {\n    for (let j = 0; j < 3; j++) {\n        process.stdout.write(ans[i][j] + \" \");\n    }\n    console.log();\n}\n3 4 5 \n6 8 10 \n5 12 13 \n9 12 15 \n8 15 17 \n12 16 20\n// C++ program to generate pythagorean\n// triplets smaller than a given limit\n#include <bits/stdc++.h>\n\n// Function to generate pythagorean\n// triplets smaller than limit\nvoid pythagoreanTriplets(int limit)\n{\n\n    // triplet: a^2 + b^2 = c^2\n    int a, b, c = 0;\n\n    // loop from 2 to max_limit\n    int m = 2;\n\n    // Limiting c would limit\n    // all a, b and c\n    while (c < limit) {\n\n        // now loop on j from 1 to i-1\n        for (int n = 1; n < m; ++n) {\n\n            // Evaluate and print triplets using\n            // the relation between a, b and c\n            a = m * m - n * n;\n            b = 2 * m * n;\n            c = m * m + n * n;\n\n            if (c > limit)\n                break;\n\n            printf(\"%d %d %d\\n\", a, b, c);\n        }\n        m++;\n    }\n}\n\n// Driver Code\nint main()\n{\n    int limit = 20;\n    pythagoreanTriplets(limit);\n    return 0;\n}\n// Java program to generate pythagorean\n// triplets smaller than a given limit\nimport java.io.*;\nimport java.util.*;\n\nclass GFG {\n\n    // Function to generate pythagorean\n    // triplets smaller than limit\n    static void pythagoreanTriplets(int limit)\n    {\n\n        // triplet: a^2 + b^2 = c^2\n        int a, b, c = 0;\n\n        // loop from 2 to max_limit\n        int m = 2;\n\n        // Limiting c would limit\n        // all a, b and c\n        while (c < limit) {\n\n            // now loop on j from 1 to i-1\n            for (int n = 1; n < m; ++n) {\n                // Evaluate and print\n                // triplets using\n                // the relation between\n                // a, b and c\n                a = m * m - n * n;\n                b = 2 * m * n;\n                c = m * m + n * n;\n\n                if (c > limit)\n                    break;\n\n                System.out.println(a + \" \" + b + \" \" + c);\n            }\n            m++;\n        }\n    }\n\n    // Driver Code\n    public static void main(String args[])\n    {\n        int limit = 20;\n        pythagoreanTriplets(limit);\n    }\n}\n\n// This code is contributed by Manish.\n# Python3 program to generate pythagorean \n# triplets smaller than a given limit\n\n# Function to generate pythagorean \n# triplets smaller than limit\ndef pythagoreanTriplets(limits) :\n    c, m = 0, 2\n\n    # Limiting c would limit \n    # all a, b and c\n    while c < limits :\n        \n        # Now loop on n from 1 to m-1\n        for n in range(1, m) :\n            a = m * m - n * n\n            b = 2 * m * n\n            c = m * m + n * n\n\n            # if c is greater than\n            # limit then break it\n            if c > limits :\n                break\n\n            print(a, b, c)\n\n        m = m + 1\n\n\n# Driver Code\nif __name__ == '__main__' :\n    \n    limit = 20\n    pythagoreanTriplets(limit)\n\n\n# This code is contributed by Shrikant13.\n// C# program to generate pythagorean\n// triplets smaller than a given limit\nusing System;\n\nclass GFG {\n\n    // Function to generate pythagorean\n    // triplets smaller than limit\n    static void pythagoreanTriplets(int limit)\n    {\n\n        // triplet: a^2 + b^2 = c^2\n        int a, b, c = 0;\n\n        // loop from 2 to max_limit\n        int m = 2;\n\n        // Limiting c would limit\n        // all a, b and c\n        while (c < limit) {\n\n            // now loop on j from 1 to i-1\n            for (int n = 1; n < m; ++n)\n            {\n                \n                // Evaluate and print\n                // triplets using\n                // the relation between\n                // a, b and c\n                a = m * m - n * n;\n                b = 2 * m * n;\n                c = m * m + n * n;\n\n                if (c > limit)\n                    break;\n\n                Console.WriteLine(a + \" \" \n                            + b + \" \" + c);\n            }\n            m++;\n        }\n    }\n\n    // Driver Code\n    public static void Main()\n    {\n        int limit = 20;\n        pythagoreanTriplets(limit);\n    }\n}\n\n// This code is contributed by anuj_67.\n<script>\n\n// Javascript program to generate pythagorean\n// triplets smaller than a given limit\n\n// Function to generate pythagorean\n// triplets smaller than limit\nfunction pythagoreanTriplets(limit)\n{\n    \n    // Triplet: a^2 + b^2 = c^2\n    let a, b, c = 0;\n\n    // Loop from 2 to max_limit\n    let m = 2;\n\n    // Limiting c would limit\n    // all a, b and c\n    while (c < limit)\n    {\n        \n        // Now loop on j from 1 to i-1\n        for(let n = 1; n < m; ++n)\n        {\n            \n            // Evaluate and print\n            // triplets using\n            // the relation between\n            // a, b and c\n            a = m * m - n * n;\n            b = 2 * m * n;\n            c = m * m + n * n;\n\n            if (c > limit)\n                break;\n\n            document.write(a + \" \" + b + \n                               \" \" + c + \"</br>\");\n        }\n        m++;\n    }\n}\n\n// Driver code \nlet limit = 20;\npythagoreanTriplets(limit);\n\n// This code is contributed by divyesh072019\n\n</script>\n<?php\n// PHP program to generate pythagorean \n// triplets smaller than a given limit\n\n// Function to generate pythagorean \n// triplets smaller than limit\nfunction pythagoreanTriplets($limit)\n{\n    \n    // triplet: a^2 + b^2 = c^2\n    $a; \n    $b; \n    $c=0;\n\n    // loop from 2 to max_limit\n    $m = 2;\n\n    // Limiting c would limit\n    // all a, b and c\n    while ($c < $limit)\n    {\n        \n        // now loop on j from 1 to i-1\n        for ($n = 1; $n < $m; ++$n)\n        {\n            \n            // Evaluate and print\n            // triplets using the\n            // relation between a, \n            // b and c\n            $a = $m *$m - $n * $n;\n            $b = 2 * $m * $n;\n            $c = $m * $m + $n * $n;\n\n            if ($c > $limit)\n                break;\n\n            echo $a, \" \", $b, \" \", $c, \"\\n\";\n        }\n        $m++;\n    }\n}\n\n    // Driver Code\n    $limit = 20;\n    pythagoreanTriplets($limit);\n\n// This code is contributed by ajit.\n?>\n3 4 5\n8 6 10\n5 12 13\n15 8 17\n12 16 20\n",
        "complexity": {
            "time": "Time complexity of this approach is O(√n) where n is the given limit. We are iterating until c <= limit ,where c = m^2 + n^2. Thus the iteration will take place approximately sqrt(limit) times.Auxiliary space: O(1) as it is using constant space for variablesReferences: https://en.wikipedia.org/wiki/Formulas_for_generating_Pythagorean_triples",
            "space": ""
        },
        "tags": [
            "Mathematical Algorithms"
        ],
        "url": "https://www.geeksforgeeks.org/generate-pythagorean-triplets/"
    },
    {
        "title": "Nth Fibonacci Number",
        "description": "Given a positive integer n, the task is to find the nth Fibonacci number. The Fibonacci sequence is a sequence where the next term is the sum of the previous two terms. The first two terms of the Fibonacci sequence are 0 followed by 1. The Fibonacci sequence: 0, 1, 1, 2, 3, 5, 8, 13, 21 Example: Input: n = 2Output: 1 Explanation: 1 is the 2nd number of Fibonacci series. Input: n = 5Output: 5Explanation: 5 is the 5th number of Fibonacci series. Table of Content We can use recursion to solve this problem because any Fibonacci number n depends on previous two Fibonacci numbers. Therefore, this approach repeatedly breaks down the problem until it reaches the base cases. Recurrence relation: Time Complexity: O(2n)Auxiliary Space: O(n), due to recursion stack In the previous approach there is a lot of redundant calculation that are calculating again and again, So we can store the results of previously computed Fibonacci numbers in a memo table to avoid redundant calculations. This will make sure that each Fibonacci number is only computed once, this will reduce the exponential time complexity of the naive approach O(2^n) into a more efficient O(n) time complexity. Time Complexity: O(n), each fibonacci number is calculated only one times from 1 to n;Auxiliary Space: O(n), due to memo table This approach uses dynamic programming to solve the Fibonacci problem by storing previously calculated Fibonacci numbers, avoiding the repeated calculations of the recursive approach. Instead of breaking down the problem recursively, it iteratively builds up the solution by calculating Fibonacci numbers from the bottom up. Time Complexity: O(n), the loop runs from 2 to n, performing a constant amount of work per iteration.Auxiliary Space: O(n), due to the use of an extra array to store Fibonacci numbers up to n. This approach is just an optimization of the above iterative approach, Instead of using the extra array for storing the Fibonacci numbers, we can store the values in the variables. We keep the previous two numbers only because that is all we need to get the next Fibonacci number in series. Time Complexity: O(n), The loop runs from 2 to n, performing constant time operations in each iteration.)Auxiliary Space: O(1), Only a constant amount of extra space is used to store the current and two previous Fibonacci numbers. We know that each Fibonacci number is the sum of previous two Fibonacci numbers. we would either add numbers repeatedly or use loops or recursion, which takes time. But with matrix exponentiation, we can calculate Fibonacci numbers much faster by working with matrices. There’s a special matrix (transformation matrix) that represents how Fibonacci numbers work. It looks like this: [Tex]\\begin{pmatrix}1 & 1 \\\\1 & 0 \\end{pmatrix}[/Tex]This matrix captures the Fibonacci relationship. If we multiply this matrix by itself multiple times, it can give us Fibonacci numbers. To find the Nth Fibonacci number we need to multiple transformation matrix (n-1) times, the matrix equation for the Fibonacci sequence looks like: [Tex]\\begin{pmatrix}1 & 1 \\\\1 & 0\\end{pmatrix}^{n-1}=\\begin{pmatrix}F(n) & F(n-1) \\\\F(n-1) & F(n-2)\\end{pmatrix}[/Tex] After raising the transformation matrix to the power n – 1, the top-left element F(n) will gives the nth Fibonacci number. Time Complexity: O(log(n), We have used exponentiation by squaring, which reduces the number of matrix multiplications to O(log n), because with each recursive call, the power is halved.Auxiliary Space: O(log n), due to the recursion stack. The nth Fibonacci number can be found using the Golden Ratio, which is approximately = [Tex]\\phi = \\frac{1 + \\sqrt{5}}{2}[/Tex]. The intuition behind this method is based on Binet’s formula, which expresses the nth Fibonacci number directly in terms of the Golden Ratio. Binet’s Formula: The nth Fibonacci number F(n) can be calculated using the formula: [Tex]F(n) = \\frac{\\phi^n – (1 – \\phi)^n}{\\sqrt{5}}[/Tex]For more detail for this approach, please refer to our article “Find nth Fibonacci number using Golden ratio“ Related Articles:  ",
        "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n// Function to calculate the nth Fibonacci number using recursion\nint nthFibonacci(int n){\n\n    // Base case: if n is 0 or 1, return n\n    if (n <= 1){\n        return n;\n    }\n\n    // Recursive case: sum of the two preceding Fibonacci numbers\n    return nthFibonacci(n - 1) + nthFibonacci(n - 2);\n}\n\nint main(){\n    int n = 5;\n    int result = nthFibonacci(n);\n    cout << result << endl;\n\n    return 0;\n}\n#include <stdio.h>\n\n// Function to calculate the nth Fibonacci number using recursion\nint nthFibonacci(int n){\n    // Base case: if n is 0 or 1, return n\n    if (n <= 1){\n        return n;\n    }\n    // Recursive case: sum of the two preceding Fibonacci numbers\n    return nthFibonacci(n - 1) + nthFibonacci(n - 2);\n}\n\nint main(){\n    int n = 5;\n    int result = nthFibonacci(n);\n    printf(\"%d\\n\", result);\n    return 0;\n}\nclass GfG {\n  \n    // Function to calculate the nth Fibonacci number using\n    // recursion\n    static int nthFibonacci(int n){\n        // Base case: if n is 0 or 1, return n\n        if (n <= 1) {\n            return n;\n        }\n        // Recursive case: sum of the two preceding\n        // Fibonacci numbers\n        return nthFibonacci(n - 1) + nthFibonacci(n - 2);\n    }\n\n    public static void main(String[] args){\n        int n = 5;\n        int result = nthFibonacci(n);\n        System.out.println(result);\n    }\n}\ndef nth_fibonacci(n):\n  \n    # Base case: if n is 0 or 1, return n\n    if n <= 1:\n        return n\n      \n    # Recursive case: sum of the two preceding Fibonacci numbers\n    return nth_fibonacci(n - 1) + nth_fibonacci(n - 2)\n\nn = 5\nresult = nth_fibonacci(n)\nprint(result)\nusing System;\n\nclass GfG {\n  \n    // Function to calculate the nth Fibonacci number using\n    // recursion\n    static int nthFibonacci(int n){\n        // Base case: if n is 0 or 1, return n\n        if (n <= 1) {\n            return n;\n        }\n        // Recursive case: sum of the two preceding\n        // Fibonacci numbers\n        return nthFibonacci(n - 1) + nthFibonacci(n - 2);\n    }\n\n    static void Main(){\n        int n = 5;\n        int result = nthFibonacci(n);\n        Console.WriteLine(result);\n    }\n}\nfunction nthFibonacci(n){\n\n    // Base case: if n is 0 or 1, return n\n    if (n <= 1) {\n        return n;\n    }\n    \n    // Recursive case: sum of the two preceding Fibonacci\n    // numbers\n    return nthFibonacci(n - 1) + nthFibonacci(n - 2);\n}\n\nlet n = 5;\nlet result = nthFibonacci(n);\nconsole.log(result);\n5\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Function to calculate the nth Fibonacci number using memoization\nint nthFibonacciUtil(int n, vector<int>& memo) {\n  \n    // Base case: if n is 0 or 1, return n\n    if (n <= 1) {\n        return n;\n    }\n\n    // Check if the result is already in the memo table\n    if (memo[n] != -1) {\n        return memo[n];\n    }\n\n    // Recursive case: calculate Fibonacci number\n    // and store it in memo\n    memo[n] = nthFibonacciUtil(n - 1, memo) \n                       + nthFibonacciUtil(n - 2, memo);\n\n    return memo[n];\n}\n\n// Wrapper function that handles both initialization\n// and Fibonacci calculation\nint nthFibonacci(int n) {\n\n    // Create a memoization table and initialize with -1\n    vector<int> memo(n + 1, -1);\n    \n    // Call the utility function\n    return nthFibonacciUtil(n, memo);\n}\n\nint main() {\n    int n = 5;\n    int result = nthFibonacci(n);\n    cout << result << endl;\n\n    return 0;\n}\n#include <stdio.h>\n\n// Function to calculate the nth Fibonacci number using memoization\nint nthFibonacciUtil(int n, int memo[]) {\n\n    // Base case: if n is 0 or 1, return n\n    if (n <= 1) {\n        return n;\n    }\n\n    // Check if the result is already in the memo table\n    if (memo[n] != -1) {\n        return memo[n];\n    }\n\n    // Recursive case: calculate Fibonacci number\n    // and store it in memo\n    memo[n] = nthFibonacciUtil(n - 1, memo) \n                   + nthFibonacciUtil(n - 2, memo);\n\n    return memo[n];\n}\n\n// Wrapper function that handles both initialization\n// and Fibonacci calculation\nint nthFibonacci(int n) {\n\n    // Create a memoization table and initialize with -1\n    int memo[n + 1];\n    for (int i = 0; i <= n; i++) {\n        memo[i] = -1;\n    }\n\n    // Call the utility function\n    return nthFibonacciUtil(n, memo);\n}\n\nint main() {\n    int n = 5;\n    int result = nthFibonacci(n);\n    printf(\"%d\\n\", result);\n\n    return 0;\n}\nimport java.util.Arrays;\n\nclass GfG {\n\n    // Function to calculate the nth Fibonacci number using memoization\n    static int nthFibonacciUtil(int n, int[] memo) {\n      \n        // Base case: if n is 0 or 1, return n\n        if (n <= 1) {\n            return n;\n        }\n\n        // Check if the result is already in the memo table\n        if (memo[n] != -1) {\n            return memo[n];\n        }\n\n        // Recursive case: calculate Fibonacci number\n        // and store it in memo\n        memo[n] = nthFibonacciUtil(n - 1, memo) \n                       + nthFibonacciUtil(n - 2, memo);\n\n        return memo[n];\n    }\n\n    // Wrapper function that handles both initialization\n    // and Fibonacci calculation\n    static int nthFibonacci(int n) {\n\n        // Create a memoization table and initialize with -1\n        int[] memo = new int[n + 1];\n        Arrays.fill(memo, -1);\n        \n        // Call the utility function\n        return nthFibonacciUtil(n, memo);\n    }\n\n    public static void main(String[] args) {\n        int n = 5;\n        int result = nthFibonacci(n);\n        System.out.println(result);\n    }\n}\n# Function to calculate the nth Fibonacci number using memoization\ndef nth_fibonacci_util(n, memo):\n\n    # Base case: if n is 0 or 1, return n\n    if n <= 1:\n        return n\n\n    # Check if the result is already in the memo table\n    if memo[n] != -1:\n        return memo[n]\n\n    # Recursive case: calculate Fibonacci number\n    # and store it in memo\n    memo[n] = nth_fibonacci_util(n - 1, memo) + nth_fibonacci_util(n - 2, memo)\n\n    return memo[n]\n\n\n# Wrapper function that handles both initialization\n# and Fibonacci calculation\ndef nth_fibonacci(n):\n\n    # Create a memoization table and initialize with -1\n    memo = [-1] * (n + 1)\n\n    # Call the utility function\n    return nth_fibonacci_util(n, memo)\n\n\nif __name__ == \"__main__\":\n    n = 5\n    result = nth_fibonacci(n)\n    print(result)\nusing System;\n\nclass GfG {\n\n    // Function to calculate the nth Fibonacci number using memoization\n    static int nthFibonacciUtil(int n, int[] memo) {\n\n        // Base case: if n is 0 or 1, return n\n        if (n <= 1) {\n            return n;\n        }\n\n        // Check if the result is already in the memo table\n        if (memo[n] != -1) {\n            return memo[n];\n        }\n\n        // Recursive case: calculate Fibonacci number\n        // and store it in memo\n        memo[n] = nthFibonacciUtil(n - 1, memo) \n                        + nthFibonacciUtil(n - 2, memo);\n\n        return memo[n];\n    }\n\n    // Wrapper function that handles both initialization\n    // and Fibonacci calculation\n    static int nthFibonacci(int n) {\n\n        // Create a memoization table and initialize with -1\n        int[] memo = new int[n + 1];\n        Array.Fill(memo, -1);\n\n        // Call the utility function\n        return nthFibonacciUtil(n, memo);\n    }\n\n    public static void Main(string[] args) {\n        int n = 5;\n        int result = nthFibonacci(n);\n        Console.WriteLine(result);\n    }\n}\n// Function to calculate the nth Fibonacci number using memoization\nfunction nthFibonacciUtil(n, memo) {\n\n    // Base case: if n is 0 or 1, return n\n    if (n <= 1) {\n        return n;\n    }\n\n    // Check if the result is already in the memo table\n    if (memo[n] !== -1) {\n        return memo[n];\n    }\n\n    // Recursive case: calculate Fibonacci number\n    // and store it in memo\n    memo[n] = nthFibonacciUtil(n - 1, memo) \n                   + nthFibonacciUtil(n - 2, memo);\n\n    return memo[n];\n}\n\n// Wrapper function that handles both initialization\n// and Fibonacci calculation\nfunction nthFibonacci(n) {\n\n    // Create a memoization table and initialize with -1\n    let memo = new Array(n + 1).fill(-1);\n\n    // Call the utility function\n    return nthFibonacciUtil(n, memo);\n}\n\nlet n = 5;\nlet result = nthFibonacci(n);\nconsole.log(result);\n5\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Function to calculate the nth Fibonacci number using recursion\nint nthFibonacci(int n){\n    // Handle the edge cases\n    if (n <= 1)\n        return n;\n\n    // Create a vector to store Fibonacci numbers\n    vector<int> dp(n + 1);\n\n    // Initialize the first two Fibonacci numbers\n    dp[0] = 0;\n    dp[1] = 1;\n\n    // Fill the vector iteratively\n    for (int i = 2; i <= n; ++i){\n\n        // Calculate the next Fibonacci number\n        dp[i] = dp[i - 1] + dp[i - 2];\n    }\n\n    // Return the nth Fibonacci number\n    return dp[n];\n}\n\nint main(){\n    int n = 5;\n    int result = nthFibonacci(n);\n\n    cout << result << endl;\n\n    return 0;\n}\n#include <stdio.h>\n\n// Function to calculate the nth Fibonacci number\n// using iteration\nint nthFibonacci(int n) {\n  \n    // Handle the edge cases\n    if (n <= 1) return n;\n\n    // Create an array to store Fibonacci numbers\n    int dp[n + 1];\n\n    // Initialize the first two Fibonacci numbers\n    dp[0] = 0;\n    dp[1] = 1;\n\n    // Fill the array iteratively\n    for (int i = 2; i <= n; ++i) {\n        dp[i] = dp[i - 1] + dp[i - 2];\n    }\n\n    // Return the nth Fibonacci number\n    return dp[n];\n}\n\nint main() {\n    int n = 5;\n    int result = nthFibonacci(n);\n    printf(\"%d\\n\", result);\n    return 0;\n}\nclass GfG {\n  \n    // Function to calculate the nth Fibonacci number using iteration\n    static int nthFibonacci(int n) {\n        // Handle the edge cases\n        if (n <= 1) return n;\n      \n        // Create an array to store Fibonacci numbers\n        int[] dp = new int[n + 1];\n\n        // Initialize the first two Fibonacci numbers\n        dp[0] = 0;\n        dp[1] = 1;\n\n        // Fill the array iteratively\n        for (int i = 2; i <= n; ++i) {\n            dp[i] = dp[i - 1] + dp[i - 2];\n        }\n\n        // Return the nth Fibonacci number\n        return dp[n];\n    }\n\n    public static void main(String[] args) {\n        int n = 5;\n        int result = nthFibonacci(n);\n        System.out.println(result);\n    }\n}\ndef nth_fibonacci(n):\n  \n    # Handle the edge cases\n    if n <= 1:\n        return n\n\n    # Create a list to store Fibonacci numbers\n    dp = [0] * (n + 1)\n\n    # Initialize the first two Fibonacci numbers\n    dp[0] = 0\n    dp[1] = 1\n\n    # Fill the list iteratively\n    for i in range(2, n + 1):\n        dp[i] = dp[i - 1] + dp[i - 2]\n\n    # Return the nth Fibonacci number\n    return dp[n]\n\nn = 5\nresult = nth_fibonacci(n)\nprint(result)\nusing System;\n\nclass GfG {\n  \n    // Function to calculate the nth Fibonacci number using iteration\n    public static int nthFibonacci(int n) {\n      \n        // Handle the edge cases\n        if (n <= 1) return n;\n\n        // Create an array to store Fibonacci numbers\n        int[] dp = new int[n + 1];\n\n        // Initialize the first two Fibonacci numbers\n        dp[0] = 0;\n        dp[1] = 1;\n\n        // Fill the array iteratively\n        for (int i = 2; i <= n; ++i) {\n            dp[i] = dp[i - 1] + dp[i - 2];\n        }\n\n        // Return the nth Fibonacci number\n        return dp[n];\n    }\n\n    static void Main() {\n        int n = 5;\n        int result = nthFibonacci(n);\n        Console.WriteLine(result);\n    }\n}\nfunction nthFibonacci(n) {\n\n    // Handle the edge cases\n    if (n <= 1) return n;\n\n    // Create an array to store Fibonacci numbers\n    let dp = new Array(n + 1);\n\n    // Initialize the first two Fibonacci numbers\n    dp[0] = 0;\n    dp[1] = 1;\n\n    // Fill the array iteratively\n    for (let i = 2; i <= n; i++) {\n        dp[i] = dp[i - 1] + dp[i - 2];\n    }\n\n    // Return the nth Fibonacci number\n    return dp[n];\n}\n\nlet n = 5;\nlet result = nthFibonacci(n);\nconsole.log(result);\n5\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Function to calculate the nth Fibonacci number\n// using space optimization\nint nthFibonacci(int n){\n\n    if (n <= 1) return n;\n\n    // To store the curr Fibonacci number\n    int curr = 0;\n\n    // To store the previous Fibonacci number\n    int prev1 = 1;\n    int prev2 = 0;\n\n    // Loop to calculate Fibonacci numbers from 2 to n\n    for (int i = 2; i <= n; i++){\n\n        // Calculate the curr Fibonacci number\n        curr = prev1 + prev2;\n\n        // Update prev2 to the last Fibonacci number\n        prev2 = prev1;\n\n        // Update prev1 to the curr Fibonacci number\n        prev1 = curr;\n    }\n\n    return curr;\n}\n\n\nint main() {\n    int n = 5;\n    int result = nthFibonacci(n);\n    cout << result << endl;\n    \n    return 0;\n}\n#include <stdio.h>\n\n// Function to calculate the nth Fibonacci number\n// using space optimization\nint nthFibonacci(int n) {\n    if (n <= 1) return n;\n\n    // To store the curr Fibonacci number\n    int curr = 0;\n\n    // To store the previous Fibonacci numbers\n    int prev1 = 1;\n    int prev2 = 0;\n\n    // Loop to calculate Fibonacci numbers from 2 to n\n    for (int i = 2; i <= n; i++) {\n      \n        // Calculate the curr Fibonacci number\n        curr = prev1 + prev2;\n\n        // Update prev2 to the last Fibonacci number\n        prev2 = prev1;\n\n        // Update prev1 to the curr Fibonacci number\n        prev1 = curr;\n    }\n\n    return curr;\n}\n\nint main() {\n    int n = 5;\n    int result = nthFibonacci(n);\n    printf(\"%d\\n\", result);\n    return 0;\n}\nclass GfG {\n  \n    // Function to calculate the nth Fibonacci number\n    // using space optimization\n    static int nthFibonacci(int n) {\n        if (n <= 1) return n;\n\n        // To store the curr Fibonacci number\n        int curr = 0;\n\n        // To store the previous Fibonacci numbers\n        int prev1 = 1;\n        int prev2 = 0;\n\n        // Loop to calculate Fibonacci numbers from 2 to n\n        for (int i = 2; i <= n; i++) {\n          \n            // Calculate the curr Fibonacci number\n            curr = prev1 + prev2;\n\n            // Update prev2 to the last Fibonacci number\n            prev2 = prev1;\n\n            // Update prev1 to the curr Fibonacci number\n            prev1 = curr;\n        }\n\n        return curr;\n    }\n\n    public static void main(String[] args) {\n        int n = 5;\n        int result = nthFibonacci(n);\n        System.out.println(result);\n    }\n}\ndef nth_fibonacci(n):\n    if n <= 1:\n        return n\n\n    # To store the curr Fibonacci number\n    curr = 0\n\n    # To store the previous Fibonacci numbers\n    prev1 = 1\n    prev2 = 0\n\n    # Loop to calculate Fibonacci numbers from 2 to n\n    for i in range(2, n + 1):\n      \n        # Calculate the curr Fibonacci number\n        curr = prev1 + prev2\n\n        # Update prev2 to the last Fibonacci number\n        prev2 = prev1\n\n        # Update prev1 to the curr Fibonacci number\n        prev1 = curr\n\n    return curr\n\nn = 5\nresult = nth_fibonacci(n)\nprint(result)\nusing System;\n\nclass GfG {\n  \n    // Function to calculate the nth Fibonacci number\n    // using space optimization\n    public static int nthFibonacci(int n) {\n        if (n <= 1) return n;\n\n        // To store the curr Fibonacci number\n        int curr = 0;\n\n        // To store the previous Fibonacci numbers\n        int prev1 = 1;\n        int prev2 = 0;\n\n        // Loop to calculate Fibonacci numbers from 2 to n\n        for (int i = 2; i <= n; i++) {\n          \n            // Calculate the curr Fibonacci number\n            curr = prev1 + prev2;\n\n            // Update prev2 to the last Fibonacci number\n            prev2 = prev1;\n\n            // Update prev1 to the curr Fibonacci number\n            prev1 = curr;\n        }\n\n        return curr;\n    }\n\n    static void Main() {\n        int n = 5;\n        int result = nthFibonacci(n);\n        Console.WriteLine(result);\n    }\n}\nfunction nthFibonacci(n) {\n    if (n <= 1) return n;\n\n    // To store the curr Fibonacci number\n    let curr = 0;\n\n    // To store the previous Fibonacci numbers\n    let prev1 = 1;\n    let prev2 = 0;\n\n    // Loop to calculate Fibonacci numbers from 2 to n\n    for (let i = 2; i <= n; i++) {\n    \n        // Calculate the curr Fibonacci number\n        curr = prev1 + prev2;\n\n        // Update prev2 to the last Fibonacci number\n        prev2 = prev1;\n\n        // Update prev1 to the curr Fibonacci number\n        prev1 = curr;\n    }\n\n    return curr;\n}\n\nlet n = 5;\nlet result = nthFibonacci(n);\nconsole.log(result);\n5\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Function to multiply two 2x2 matrices\nvoid multiply(vector<vector<int>>& mat1,\n                                vector<vector<int>>& mat2) {\n    // Perform matrix multiplication\n    int x = mat1[0][0] * mat2[0][0] + mat1[0][1] * mat2[1][0];\n    int y = mat1[0][0] * mat2[0][1] + mat1[0][1] * mat2[1][1];\n    int z = mat1[1][0] * mat2[0][0] + mat1[1][1] * mat2[1][0];\n    int w = mat1[1][0] * mat2[0][1] + mat1[1][1] * mat2[1][1];\n\n    // Update matrix mat1 with the result\n    mat1[0][0] = x;\n    mat1[0][1] = y;\n    mat1[1][0] = z;\n    mat1[1][1] = w;\n}\n\n// Function to perform matrix exponentiation\nvoid matrixPower(vector<vector<int>>& mat1, int n) {\n    // Base case for recursion\n    if (n == 0 || n == 1) return;\n\n    // Initialize a helper matrix\n    vector<vector<int>> mat2 = {{1, 1}, {1, 0}};\n\n    // Recursively calculate mat1^(n/2)\n    matrixPower(mat1, n / 2);\n\n    // Square the matrix mat1\n    multiply(mat1, mat1);\n\n    // If n is odd, multiply by the helper matrix mat2\n    if (n % 2 != 0) {\n        multiply(mat1, mat2);\n    }\n}\n\n// Function to calculate the nth Fibonacci number\n// using matrix exponentiation\nint nthFibonacci(int n) {\n    if (n <= 1) return n;\n\n    // Initialize the transformation matrix\n    vector<vector<int>> mat1 = {{1, 1}, {1, 0}};\n\n    // Raise the matrix mat1 to the power of (n - 1)\n    matrixPower(mat1, n - 1);\n\n    // The result is in the top-left cell of the matrix\n    return mat1[0][0];\n}\n\nint main() {\n    int n = 5;\n    int result = nthFibonacci(n);\n    cout << result << endl;\n\n    return 0;\n}\n#include <stdio.h>\n\n// Function to multiply two 2x2 matrices\nvoid multiply(int mat1[2][2], int mat2[2][2]) {\n  \n    // Perform matrix multiplication\n    int x = mat1[0][0] * mat2[0][0] + mat1[0][1] * mat2[1][0];\n    int y = mat1[0][0] * mat2[0][1] + mat1[0][1] * mat2[1][1];\n    int z = mat1[1][0] * mat2[0][0] + mat1[1][1] * mat2[1][0];\n    int w = mat1[1][0] * mat2[0][1] + mat1[1][1] * mat2[1][1];\n\n    // Update matrix mat1 with the result\n    mat1[0][0] = x;\n    mat1[0][1] = y;\n    mat1[1][0] = z;\n    mat1[1][1] = w;\n}\n\n// Function to perform matrix exponentiation\nvoid matrixPower(int mat1[2][2], int n) {\n    // Base case for recursion\n    if (n == 0 || n == 1) return;\n\n    // Initialize a helper matrix\n    int mat2[2][2] = {{1, 1}, {1, 0}};\n\n    // Recursively calculate mat1^(n/2)\n    matrixPower(mat1, n / 2);\n\n    // Square the matrix mat1\n    multiply(mat1, mat1);\n\n    // If n is odd, multiply by the helper matrix mat2\n    if (n % 2 != 0) {\n        multiply(mat1, mat2);\n    }\n}\n\n// Function to calculate the nth Fibonacci number\nint nthFibonacci(int n) {\n    if (n <= 1) return n;\n\n    // Initialize the transformation matrix\n    int mat1[2][2] = {{1, 1}, {1, 0}};\n\n    // Raise the matrix mat1 to the power of (n - 1)\n    matrixPower(mat1, n - 1);\n\n    // The result is in the top-left cell of the matrix\n    return mat1[0][0];\n}\n\nint main() {\n    int n = 5;\n    int result = nthFibonacci(n);\n    printf(\"%d\\n\", result);\n\n    return 0;\n}\nimport java.util.*;\n\n// Function to multiply two 2x2 matrices\nclass GfG {\n    static void multiply(int[][] mat1, int[][] mat2) {\n      \n        // Perform matrix multiplication\n        int x = mat1[0][0] * mat2[0][0] + mat1[0][1] * mat2[1][0];\n        int y = mat1[0][0] * mat2[0][1] + mat1[0][1] * mat2[1][1];\n        int z = mat1[1][0] * mat2[0][0] + mat1[1][1] * mat2[1][0];\n        int w = mat1[1][0] * mat2[0][1] + mat1[1][1] * mat2[1][1];\n\n        // Update matrix mat1 with the result\n        mat1[0][0] = x;\n        mat1[0][1] = y;\n        mat1[1][0] = z;\n        mat1[1][1] = w;\n    }\n\n    // Function to perform matrix exponentiation\n    static void matrixPower(int[][] mat1, int n) {\n      \n        // Base case for recursion\n        if (n == 0 || n == 1) return;\n\n        // Initialize a helper matrix\n        int[][] mat2 = {{1, 1}, {1, 0}};\n\n        // Recursively calculate mat1^(n/2)\n        matrixPower(mat1, n / 2);\n\n        // Square the matrix mat1\n        multiply(mat1, mat1);\n\n        // If n is odd, multiply by the helper matrix mat2\n        if (n % 2 != 0) {\n            multiply(mat1, mat2);\n        }\n    }\n\n    // Function to calculate the nth Fibonacci number\n    static int nthFibonacci(int n) {\n        if (n <= 1) return n;\n\n        // Initialize the transformation matrix\n        int[][] mat1 = {{1, 1}, {1, 0}};\n\n        // Raise the matrix mat1 to the power of (n - 1)\n        matrixPower(mat1, n - 1);\n\n        // The result is in the top-left cell of the matrix\n        return mat1[0][0];\n    }\n\n    public static void main(String[] args) {\n        int n = 5;\n        int result = nthFibonacci(n);\n        System.out.println(result);\n    }\n}\n# Function to multiply two 2x2 matrices\ndef multiply(mat1, mat2):\n  \n    # Perform matrix multiplication\n    x = mat1[0][0] * mat2[0][0] + mat1[0][1] * mat2[1][0]\n    y = mat1[0][0] * mat2[0][1] + mat1[0][1] * mat2[1][1]\n    z = mat1[1][0] * mat2[0][0] + mat1[1][1] * mat2[1][0]\n    w = mat1[1][0] * mat2[0][1] + mat1[1][1] * mat2[1][1]\n\n    # Update matrix mat1 with the result\n    mat1[0][0], mat1[0][1] = x, y\n    mat1[1][0], mat1[1][1] = z, w\n\n# Function to perform matrix exponentiation\ndef matrix_power(mat1, n):\n  \n    # Base case for recursion\n    if n == 0 or n == 1:\n        return\n\n    # Initialize a helper matrix\n    mat2 = [[1, 1], [1, 0]]\n\n    # Recursively calculate mat1^(n // 2)\n    matrix_power(mat1, n // 2)\n\n    # Square the matrix mat1\n    multiply(mat1, mat1)\n\n    # If n is odd, multiply by the helper matrix mat2\n    if n % 2 != 0:\n        multiply(mat1, mat2)\n\n# Function to calculate the nth Fibonacci number\ndef nth_fibonacci(n):\n    if n <= 1:\n        return n\n\n    # Initialize the transformation matrix\n    mat1 = [[1, 1], [1, 0]]\n\n    # Raise the matrix mat1 to the power of (n - 1)\n    matrix_power(mat1, n - 1)\n\n    # The result is in the top-left cell of the matrix\n    return mat1[0][0]\n\nif __name__ == \"__main__\":\n    n = 5\n    result = nth_fibonacci(n)\n    print(result)\nusing System;\n\nclass GfG {\n\n    // Function to multiply two 2x2 matrices\n    static void Multiply(int[,] mat1, int[,] mat2) {\n      \n        // Perform matrix multiplication\n        int x = mat1[0,0] * mat2[0,0] + mat1[0,1] * mat2[1,0];\n        int y = mat1[0,0] * mat2[0,1] + mat1[0,1] * mat2[1,1];\n        int z = mat1[1,0] * mat2[0,0] + mat1[1,1] * mat2[1,0];\n        int w = mat1[1,0] * mat2[0,1] + mat1[1,1] * mat2[1,1];\n\n        // Update matrix mat1 with the result\n        mat1[0,0] = x;\n        mat1[0,1] = y;\n        mat1[1,0] = z;\n        mat1[1,1] = w;\n    }\n\n    // Function to perform matrix exponentiation\n    static void MatrixPower(int[,] mat1, int n) {\n      \n        // Base case for recursion\n        if (n == 0 || n == 1) return;\n\n        // Initialize a helper matrix\n        int[,] mat2 = { {1, 1}, {1, 0} };\n\n        // Recursively calculate mat1^(n / 2)\n        MatrixPower(mat1, n / 2);\n\n        // Square the matrix mat1\n        Multiply(mat1, mat1);\n\n        // If n is odd, multiply by the helper matrix mat2\n        if (n % 2 != 0) {\n            Multiply(mat1, mat2);\n        }\n    }\n\n    // Function to calculate the nth Fibonacci number\n    static int NthFibonacci(int n) {\n        if (n <= 1) return n;\n\n        // Initialize the transformation matrix\n        int[,] mat1 = { {1, 1}, {1, 0} };\n\n        // Raise the matrix mat1 to the power of (n - 1)\n        MatrixPower(mat1, n - 1);\n\n        // The result is in the top-left cell of the matrix\n        return mat1[0,0];\n    }\n\n    public static void Main(string[] args) {\n        int n = 5;\n        int result = NthFibonacci(n);\n        Console.WriteLine(result);\n    }\n}\n// Function to multiply two 2x2 matrices\nfunction multiply(mat1, mat2) {\n    // Perform matrix multiplication\n    const x = mat1[0][0] * mat2[0][0] + mat1[0][1] * mat2[1][0];\n    const y = mat1[0][0] * mat2[0][1] + mat1[0][1] * mat2[1][1];\n    const z = mat1[1][0] * mat2[0][0] + mat1[1][1] * mat2[1][0];\n    const w = mat1[1][0] * mat2[0][1] + mat1[1][1] * mat2[1][1];\n\n    // Update matrix mat1 with the result\n    mat1[0][0] = x;\n    mat1[0][1] = y;\n    mat1[1][0] = z;\n    mat1[1][1] = w;\n}\n\n// Function to perform matrix exponentiation\nfunction matrixPower(mat1, n) {\n    // Base case for recursion\n    if (n === 0 || n === 1) return;\n\n    // Initialize a helper matrix\n    const mat2 = [[1, 1], [1, 0]];\n\n    // Recursively calculate mat1^(n // 2)\n    matrixPower(mat1, Math.floor(n / 2));\n\n    // Square the matrix mat1\n    multiply(mat1, mat1);\n\n    // If n is odd, multiply by the helper matrix mat2\n    if (n % 2 !== 0) {\n        multiply(mat1, mat2);\n    }\n}\n\n// Function to calculate the nth Fibonacci number\nfunction nthFibonacci(n) {\n    if (n <= 1) return n;\n\n    // Initialize the transformation matrix\n    const mat1 = [[1, 1], [1, 0]];\n\n    // Raise the matrix mat1 to the power of (n - 1)\n    matrixPower(mat1, n - 1);\n\n    // The result is in the top-left cell of the matrix\n    return mat1[0][0];\n}\n\nconst n = 5;\nconst result = nthFibonacci(n);\nconsole.log(result);\n5\n",
        "complexity": {
            "time": "Time Complexity: O(log(n), We have used exponentiation by squaring, which reduces the number of matrix multiplications to O(log n), because with each recursive call, the power is halved.Auxiliary Space: O(log n), due to the recursion stack.",
            "space": ""
        },
        "tags": [
            "Mathematical Algorithms"
        ],
        "url": "https://www.geeksforgeeks.org/program-for-nth-fibonacci-number/"
    },
    {
        "title": "Euclidean algorithms (Basic and Extended)",
        "description": "The Euclidean algorithm is a way to find the greatest common divisor of two positive integers. GCD of two numbers is the largest number that divides both of them. A simple way to find GCD is to factorize both numbers and multiply common prime factors. Examples: input: a = 12, b = 20Output: 4Explanation:  The Common factors of (12, 20) are 1, 2, and 4 and greatest is 4. input: a =  18, b = 33Output: 3Explanation:  The Common factors of (18, 33) are 1 and 3 and greatest is 3.  Table of Content The algorithm is based on the below facts. Time Complexity: O(log min(a, b))Auxiliary Space: O(log (min(a,b))) Extended Euclidean algorithm also finds integer coefficients x and y such that: ax + by = gcd(a, b) Examples: Input: a = 30, b = 20Output: gcd = 10, x = 1, y = -1Explanation: 30*1 + 20*(-1) = 10 Input: a = 35, b = 15Output: gcd = 5, x = 1, y = -2Explanation: 35*1 + 15*(-2) = 5 The extended Euclidean algorithm updates the results of gcd(a, b) using the results calculated by the recursive call gcd(b%a, a). Let values of x and y calculated by the recursive call be x1 and y1. x and y are updated using the below expressions. ax + by = gcd(a, b)gcd(a, b) = gcd(b%a, a)gcd(b%a, a) = (b%a)x1 + ay1ax + by = (b%a)x1 + ay1ax + by = (b – [b/a] * a)x1 + ay1ax + by = a(y1 – [b/a] * x1) + bx1 Comparing LHS and RHS,x = y1 – [Tex]\\lfloor b/a \\rfloor[/Tex]* x1 y = x1 Time Complexity: O(log min(a, b))Auxiliary Space: O(log (min(a,b))) As seen above, x and y are results for inputs a and b, a.x + b.y = gcd                      —-(1) And x1 and y1 are results for inputs b%a and a (b%a).x1 + a.y1 = gcd When we put b%a = [Tex](b – (\\lfloor b/a \\rfloor).a)[/Tex] in above, we get following. Note that [Tex]\\lfloor b/a\\rfloor[/Tex] is floor(b/a) [Tex](b – (\\lfloor b/a \\rfloor).a).x1 + a.y1  = gcd[/Tex] Above equation can also be written as below [Tex]b.x1 + a.(y1 – (\\lfloor b/a \\rfloor).x1) = gcd [/Tex]     —(2) After comparing coefficients of ‘a’ and ‘b’ in (1) and (2), we get following, [Tex]x = y1 – \\lfloor b/a \\rfloor * x1[/Tex]y = x1 The extended Euclidean algorithm is particularly useful when a and b are coprime (or gcd is 1). Since x is the modular multiplicative inverse of “a modulo b”, and y is the modular multiplicative inverse of “b modulo a”. In particular, the computation of the modular multiplicative inverse is an essential step in RSA public-key encryption method.  A  ",
        "code": "// C++ program to demonstrate working of \n// extended Euclidean Algorithm \n#include <bits/stdc++.h> \nusing namespace std;\n\n// Function to return\n// gcd of a and b\nint findGCD(int a, int b) {\n    if (a == 0)\n        return b;\n    return findGCD(b % a, a);\n}\n\nint main()  { \n    int a = 35, b = 15;\n    int g = findGCD(a, b); \n    cout << g << endl;\n    return 0; \n}\n// C program to demonstrate working of \n// extended Euclidean Algorithm \n#include <stdio.h>\n\n// Function to return\n// gcd of a and b\nint findGCD(int a, int b) {\n    if (a == 0)\n        return b;\n    return findGCD(b % a, a);\n}\n\nint main() { \n    int a = 35, b = 15;\n    int g = findGCD(a, b); \n    printf(\"%d\\n\", g);\n    return 0; \n}\n// Java program to demonstrate working of \n// extended Euclidean Algorithm \nclass GFG {\n\n    // Function to return\n    // gcd of a and b\n    static int findGCD(int a, int b) {\n        if (a == 0)\n            return b;\n        return findGCD(b % a, a);\n    }\n\n    public static void main(String[] args) { \n        int a = 35, b = 15;\n        int g = findGCD(a, b); \n        System.out.println(g);\n    }\n}\n# Python program to demonstrate working of \n# extended Euclidean Algorithm \n\n# Function to return\n# gcd of a and b\ndef findGCD(a, b):\n    if a == 0:\n        return b\n    return findGCD(b % a, a)\n\n# Main function\ndef main():\n    a, b = 35, 15\n    g = findGCD(a, b)\n    print(g)\n\nif __name__ == \"__main__\":\n    main()\n// C# program to demonstrate working of \n// extended Euclidean Algorithm \nusing System;\n\nclass GFG {\n\n    // Function to return\n    // gcd of a and b\n    static int FindGCD(int a, int b) {\n        if (a == 0)\n            return b;\n        return FindGCD(b % a, a);\n    }\n\n    public static void Main() { \n        int a = 35, b = 15;\n        int g = FindGCD(a, b); \n        Console.WriteLine(g);\n    }\n}\n// JavaScript program to demonstrate working of \n// extended Euclidean Algorithm \n\n// Function to return\n// gcd of a and b\nfunction findGCD(a, b) {\n    if (a === 0)\n        return b;\n    return findGCD(b % a, a);\n}\n\nfunction main() { \n    let a = 35, b = 15;\n    let g = findGCD(a, b);\n    console.log(g);\n}\n\n// Run the main function\nmain();\nGCD(10, 15) = 5\nGCD(35, 10) = 5\nGCD(31, 2) = 1\n// C++ program to demonstrate working of \n// extended Euclidean Algorithm \n#include <bits/stdc++.h> \nusing namespace std;\n\n// Function for extended Euclidean Algorithm \nint gcdExtended(int a, int b, int &x, int &y) {\n\n    // Base Case \n    if (a == 0)  { \n        x = 0; \n        y = 1; \n        return b; \n    } \n\n    int x1, y1; \n    int gcd = gcdExtended(b%a, a, x1, y1); \n\n    // Update x and y using results of \n    // recursive call \n    x = y1 - (b/a) * x1; \n    y = x1; \n    return gcd; \n} \n\nint findGCD(int a, int b) {\n\n    int x = 1, y = 1;\n    return gcdExtended(a, b, x, y);\n}\n\nint main()  { \n    int a = 35, b = 15;\n    int g = findGCD(a, b); \n    cout << g << endl;\n    return 0; \n}\n// C program to demonstrate working of \n// extended Euclidean Algorithm \n#include <stdio.h>\n\n// Function for extended Euclidean Algorithm \nint gcdExtended(int a, int b, int *x, int *y) {\n\n    // Base Case \n    if (a == 0) { \n        *x = 0; \n        *y = 1; \n        return b; \n    } \n\n    int x1, y1; \n    int gcd = gcdExtended(b % a, a, &x1, &y1); \n\n    // Update x and y using results of \n    // recursive call \n    *x = y1 - (b / a) * x1; \n    *y = x1; \n    return gcd; \n} \n\nint findGCD(int a, int b) {\n\n    int x = 1, y = 1;\n    return gcdExtended(a, b, &x, &y);\n}\n\nint main() { \n    int a = 35, b = 15;\n    int g = findGCD(a, b); \n    printf(\"%d\\n\", g);\n    return 0; \n}\n// Java program to demonstrate working of \n// extended Euclidean Algorithm \nclass GFG {\n\n    // Function for extended Euclidean Algorithm \n    static int gcdExtended(int a, int b, int[] x, int[] y) {\n\n        // Base Case \n        if (a == 0) { \n            x[0] = 0; \n            y[0] = 1; \n            return b; \n        } \n\n        int[] x1 = {0}, y1 = {0}; \n        int gcd = gcdExtended(b % a, a, x1, y1); \n\n        // Update x and y using results of \n        // recursive call \n        x[0] = y1[0] - (b / a) * x1[0]; \n        y[0] = x1[0]; \n        return gcd; \n    } \n\n    static int findGCD(int a, int b) {\n        int[] x = {1}, y = {1};\n        return gcdExtended(a, b, x, y);\n    }\n\n    public static void main(String[] args) { \n        int a = 35, b = 15;\n        int g = findGCD(a, b); \n        System.out.println(g);\n    }\n}\n# Python program to demonstrate working of \n# extended Euclidean Algorithm \n\n# Function for extended Euclidean Algorithm \ndef gcdExtended(a, b, x, y):\n\n    # Base Case \n    if a == 0: \n        x[0] = 0\n        y[0] = 1\n        return b \n\n    x1, y1 = [0], [0]\n    gcd = gcdExtended(b % a, a, x1, y1)\n\n    # Update x and y using results of \n    # recursive call \n    x[0] = y1[0] - (b // a) * x1[0] \n    y[0] = x1[0] \n    return gcd \n\ndef findGCD(a, b):\n    x, y = [1], [1]\n    return gcdExtended(a, b, x, y)\n\n# Main function\ndef main():\n    a, b = 35, 15\n    g = findGCD(a, b)\n    print(g)\n\nif __name__ == \"__main__\":\n    main()\n// C# program to demonstrate working of \n// extended Euclidean Algorithm \nusing System;\n\nclass GFG {\n\n    // Function for extended Euclidean Algorithm \n    static int GcdExtended(int a, int b, ref int x, ref int y) {\n\n        // Base Case \n        if (a == 0) { \n            x = 0; \n            y = 1; \n            return b; \n        } \n\n        int x1 = 0, y1 = 0; \n        int gcd = GcdExtended(b % a, a, ref x1, ref y1); \n\n        // Update x and y using results of \n        // recursive call \n        x = y1 - (b / a) * x1; \n        y = x1; \n        return gcd; \n    } \n\n    static int FindGCD(int a, int b) {\n        int x = 1, y = 1;\n        return GcdExtended(a, b, ref x, ref y);\n    }\n\n    public static void Main() { \n        int a = 35, b = 15;\n        int g = FindGCD(a, b); \n        Console.WriteLine(g);\n    }\n}\n// JavaScript program to demonstrate working of \n// extended Euclidean Algorithm \n\n// Function for extended Euclidean Algorithm \nfunction gcdExtended(a, b, x, y) {\n\n    // Base Case \n    if (a === 0) { \n        x[0] = 0; \n        y[0] = 1; \n        return b; \n    } \n\n    let x1 = [0], y1 = [0]; \n    let gcd = gcdExtended(b % a, a, x1, y1); \n\n    // Update x and y using results of \n    // recursive call \n    x[0] = y1[0] - Math.floor(b / a) * x1[0]; \n    y[0] = x1[0]; \n    return gcd; \n} \n\nfunction findGCD(a, b) {\n    let x = [1], y = [1];\n    return gcdExtended(a, b, x, y);\n}\n\n// Main function\nfunction main() {\n    let a = 35, b = 15;\n    let g = findGCD(a, b);\n    console.log(g);\n}\n\n// Run the main function\nmain();\n5\n",
        "complexity": {
            "time": "Time Complexity: O(log min(a, b))Auxiliary Space: O(log (min(a,b)))",
            "space": ""
        },
        "tags": [
            "Mathematical Algorithms"
        ],
        "url": "https://www.geeksforgeeks.org/basic-and-extended-euclidean-algorithms/"
    },
    {
        "title": "LCM of given array elements",
        "description": "In this article, we will learn how to find the LCM of given array elements. Given an array of n numbers, find the LCM of it. Example: Input : {1, 2, 8, 3}Output : 24LCM of 1, 2, 8 and 3 is 24Input : {2, 7, 3, 9, 4}Output : 252 Table of Content We know, [Tex]LCM(a, b)=\\frac{a*b}{gcd(a, b)}                                        [/Tex]The above relation only holds for two numbers, [Tex]LCM(a, b, c)\\neq \\frac{a*b*c}{gcd(a, b, c)}                [/Tex] The idea here is to extend our relation for more than 2 numbers. Let’s say we have an array arr[] that contains n elements whose LCM needed to be calculated. The main steps of our algorithm are: Below is the implementation of the above algorithm : Time Complexity: O(n * log(min(a, b))), where n represents the size of the given array.Auxiliary Space: O(n*log(min(a, b))) due to recursive stack space. Below is the implementation of the above algorithm Recursively : Time Complexity: O(n * log(max(a, b)), where n represents the size of the given array.Auxiliary Space: O(n) due to recursive stack space. The function starts by initializing the lcm variable to the first element in the array. It then iterates through the rest of the array, and for each element, it calculates the GCD of the current lcm and the element using the Euclidean algorithm. The calculated GCD is stored in the gcd variable. Once the GCD is calculated, the LCM is updated by multiplying the current lcm with the element and dividing by the GCD. This is done using the formula LCM(a,b) = (a * b) / GCD(a,b). The time complexity of the above code is O(n log n), where n is the length of the input array. This is because for each element of the array, we need to find the GCD, which has a time complexity of O(log n) using the Euclidean algorithm. Since we are iterating over n elements of the array, the overall time complexity becomes O(n log n). The auxiliary space used by this algorithm is O(1), as only a constant number of variables are used throughout the algorithm, regardless of the size of the input array. This code uses the reduce function from the functools library and the gcd function from the math library to find the LCM of a list of numbers. The reduce function applies the lambda function to the elements of the list, cumulatively reducing the list to a single value (the LCM in this case). The lambda function calculates the LCM of two numbers using the same approach as the previous implementation. The final LCM is returned as the result. The time complexity of the program is O(n log n) The auxiliary space used by the program is O(1) Related Article : M  ",
        "code": "// C++ program to find LCM of n elements\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long int ll;\n\n// Utility function to find\n// GCD of 'a' and 'b'\nint gcd(int a, int b)\n{\n    if (b == 0)\n        return a;\n    return gcd(b, a % b);\n}\n\n// Returns LCM of array elements\nll findlcm(int arr[], int n)\n{\n    // Initialize result\n    ll ans = arr[0];\n\n    // ans contains LCM of arr[0], ..arr[i]\n    // after i'th iteration,\n    for (int i = 1; i < n; i++)\n        ans = (((arr[i] * ans)) /\n                (gcd(arr[i], ans)));\n\n    return ans;\n}\n\n// Driver Code\nint main()\n{\n    int arr[] = { 2, 7, 3, 9, 4 };\n    int n = sizeof(arr) / sizeof(arr[0]);\n    printf(\"%lld\", findlcm(arr, n));\n    return 0;\n}\n// Java Program to find LCM of n elements\nimport java.io.*;\n\npublic class GFG {\n    \n    public static long lcm_of_array_elements(int[] element_array)\n    {\n        long lcm_of_array_elements = 1;\n        int divisor = 2;\n        \n        while (true) {\n            int counter = 0;\n            boolean divisible = false;\n            \n            for (int i = 0; i < element_array.length; i++) {\n\n                // lcm_of_array_elements (n1, n2, ... 0) = 0.\n                // For negative number we convert into\n                // positive and calculate lcm_of_array_elements.\n\n                if (element_array[i] == 0) {\n                    return 0;\n                }\n                else if (element_array[i] < 0) {\n                    element_array[i] = element_array[i] * (-1);\n                }\n                if (element_array[i] == 1) {\n                    counter++;\n                }\n\n                // Divide element_array by devisor if complete\n                // division i.e. without remainder then replace\n                // number with quotient; used for find next factor\n                if (element_array[i] % divisor == 0) {\n                    divisible = true;\n                    element_array[i] = element_array[i] / divisor;\n                }\n            }\n\n            // If divisor able to completely divide any number\n            // from array multiply with lcm_of_array_elements\n            // and store into lcm_of_array_elements and continue\n            // to same divisor for next factor finding.\n            // else increment divisor\n            if (divisible) {\n                lcm_of_array_elements = lcm_of_array_elements * divisor;\n            }\n            else {\n                divisor++;\n            }\n\n            // Check if all element_array is 1 indicate \n            // we found all factors and terminate while loop.\n            if (counter == element_array.length) {\n                return lcm_of_array_elements;\n            }\n        }\n    }\n    \n    // Driver Code\n    public static void main(String[] args)\n    {\n        int[] element_array = { 2, 7, 3, 9, 4 };\n        System.out.println(lcm_of_array_elements(element_array));\n    }\n}\n\n// Code contributed by Mohit Gupta_OMG\n# Python Program to find LCM of n elements\n\ndef find_lcm(num1, num2):\n    if(num1>num2):\n        num = num1\n        den = num2\n    else:\n        num = num2\n        den = num1\n    rem = num % den\n    while(rem != 0):\n        num = den\n        den = rem\n        rem = num % den\n    gcd = den\n    lcm = int(int(num1 * num2)/int(gcd))\n    return lcm\n    \nl = [2, 7, 3, 9, 4]\n\nnum1 = l[0]\nnum2 = l[1]\nlcm = find_lcm(num1, num2)\n\nfor i in range(2, len(l)):\n    lcm = find_lcm(lcm, l[i])\n    \nprint(lcm)\n\n# Code contributed by Mohit Gupta_OMG\n// C# Program to find LCM of n elements\nusing System;\n\npublic class GFG {\n    \n    public static long lcm_of_array_elements(int[] element_array)\n    {\n        long lcm_of_array_elements = 1;\n        int divisor = 2;\n        \n        while (true) {\n            \n            int counter = 0;\n            bool divisible = false;\n            for (int i = 0; i < element_array.Length; i++) {\n\n                // lcm_of_array_elements (n1, n2, ... 0) = 0.\n                // For negative number we convert into\n                // positive and calculate lcm_of_array_elements.\n                if (element_array[i] == 0) {\n                    return 0;\n                }\n                else if (element_array[i] < 0) {\n                    element_array[i] = element_array[i] * (-1);\n                }\n                if (element_array[i] == 1) {\n                    counter++;\n                }\n\n                // Divide element_array by devisor if complete\n                // division i.e. without remainder then replace\n                // number with quotient; used for find next factor\n                if (element_array[i] % divisor == 0) {\n                    divisible = true;\n                    element_array[i] = element_array[i] / divisor;\n                }\n            }\n\n            // If divisor able to completely divide any number\n            // from array multiply with lcm_of_array_elements\n            // and store into lcm_of_array_elements and continue\n            // to same divisor for next factor finding.\n            // else increment divisor\n            if (divisible) {\n                lcm_of_array_elements = lcm_of_array_elements * divisor;\n            }\n            else {\n                divisor++;\n            }\n\n            // Check if all element_array is 1 indicate \n            // we found all factors and terminate while loop.\n            if (counter == element_array.Length) {\n                return lcm_of_array_elements;\n            }\n        }\n    }\n    \n    // Driver Code\n    public static void Main()\n    {\n        int[] element_array = { 2, 7, 3, 9, 4 };\n        Console.Write(lcm_of_array_elements(element_array));\n    }\n}\n\n// This Code is contributed by nitin mittal\n<script>\n\n// Javascript program to find LCM of n elements \n\n// Utility function to find \n// GCD of 'a' and 'b' \nfunction gcd(a, b) \n{ \n    if (b == 0) \n        return a; \n    return gcd(b, a % b); \n} \n\n// Returns LCM of array elements \nfunction findlcm(arr, n) \n{ \n    // Initialize result \n    let ans = arr[0]; \n\n    // ans contains LCM of arr[0], ..arr[i] \n    // after i'th iteration, \n    for (let i = 1; i < n; i++) \n        ans = (((arr[i] * ans)) / \n                (gcd(arr[i], ans))); \n\n    return ans; \n} \n\n// Driver Code \n \n    let arr = [ 2, 7, 3, 9, 4 ]; \n    let n = arr.length; \n    document.write(findlcm(arr, n)); \n\n// This code is contributed by Mayank Tyagi\n\n</script>\n<?php\n// PHP program to find LCM of n elements\n\n// Utility function to find\n// GCD of 'a' and 'b'\nfunction gcd($a, $b)\n{\n    if ($b == 0)\n        return $a;\n    return gcd($b, $a % $b);\n}\n\n// Returns LCM of array elements\nfunction findlcm($arr, $n)\n{\n    \n    // Initialize result\n    $ans = $arr[0];\n\n    // ans contains LCM of \n    // arr[0], ..arr[i]\n    // after i'th iteration,\n    for ($i = 1; $i < $n; $i++)\n        $ans = ((($arr[$i] * $ans)) /\n                (gcd($arr[$i], $ans)));\n\n    return $ans;\n}\n\n// Driver Code\n$arr = array(2, 7, 3, 9, 4 );\n$n = sizeof($arr);\necho findlcm($arr, $n);\n\n// This code is contributed by ChitraNayal\n?>\n252\n#include <bits/stdc++.h>\nusing namespace std;\n\n//recursive implementation\nint LcmOfArray(vector<int> arr, int idx){\n    // lcm(a,b) = (a*b/gcd(a,b))\n    if (idx == arr.size()-1){\n        return arr[idx];\n    }\n    int a = arr[idx];\n    int b = LcmOfArray(arr, idx+1);\n    return (a*b/__gcd(a,b)); // __gcd(a,b) is inbuilt library function\n}\n\n\nint main() {\n    \n    vector<int> arr = {1,2,8,3};\n    cout << LcmOfArray(arr, 0) << \"\\n\";\n      arr = {2,7,3,9,4};\n      cout << LcmOfArray(arr,0) << \"\\n\";\n    return 0;\n}\nimport java.util.*;\nimport java.io.*;\n\nclass GFG\n{\n\n  // Recursive function to return gcd of a and b  \n  static int __gcd(int a, int b)  \n  {  \n    return b == 0? a:__gcd(b, a % b);     \n  }\n\n  // recursive implementation\n  static int LcmOfArray(int[] arr, int idx)\n  {\n\n    // lcm(a,b) = (a*b/gcd(a,b))\n    if (idx == arr.length - 1){\n      return arr[idx];\n    }\n    int a = arr[idx];\n    int b = LcmOfArray(arr, idx+1);\n    return (a*b/__gcd(a,b)); // \n  }\n\n\n  public static void main(String[] args)\n  {\n\n    int[] arr = {1,2,8,3};\n    System.out.print(LcmOfArray(arr, 0)+ \"\\n\");\n    int[]  arr1 = {2,7,3,9,4};\n    System.out.print(LcmOfArray(arr1,0)+ \"\\n\");\n  }\n} \n\n// This code is contributed by gauravrajput1\ndef __gcd(a, b):\n    if (a == 0):\n        return b\n    return __gcd(b % a, a)\n\n# recursive implementation\ndef LcmOfArray(arr, idx):\n  \n    # lcm(a,b) = (a*b/gcd(a,b))\n    if (idx == len(arr)-1):\n        return arr[idx]\n    a = arr[idx]\n    b = LcmOfArray(arr, idx+1)\n    return int(a*b/__gcd(a,b)) # __gcd(a,b) is inbuilt library function\n\narr = [1,2,8,3]\nprint(LcmOfArray(arr, 0))\narr = [2,7,3,9,4]\nprint(LcmOfArray(arr,0))\n\n# This code is contributed by divyeshrabadiya07.\nusing System;\nclass GFG {\n    \n    // Function to return\n    // gcd of a and b\n    static int __gcd(int a, int b)\n    {\n        if (a == 0)\n            return b;\n        return __gcd(b % a, a);\n    }\n \n    //recursive implementation\n    static int LcmOfArray(int[] arr, int idx){\n        // lcm(a,b) = (a*b/gcd(a,b))\n        if (idx == arr.Length-1){\n            return arr[idx];\n        }\n        int a = arr[idx];\n        int b = LcmOfArray(arr, idx+1);\n        return (a*b/__gcd(a,b)); // __gcd(a,b) is inbuilt library function\n    }\n    \n  static void Main() {\n    int[] arr = {1,2,8,3};\n    Console.WriteLine(LcmOfArray(arr, 0));\n    int[] arr1 = {2,7,3,9,4};\n    Console.WriteLine(LcmOfArray(arr1,0));\n  }\n}\n<script>\n\n    // Function to return\n    // gcd of a and b\n    function __gcd(a, b)\n    {\n        if (a == 0)\n            return b;\n        return __gcd(b % a, a);\n    }\n\n    //recursive implementation\n    function LcmOfArray(arr, idx){\n        // lcm(a,b) = (a*b/gcd(a,b))\n        if (idx == arr.length-1){\n            return arr[idx];\n        }\n        let a = arr[idx];\n        let b = LcmOfArray(arr, idx+1);\n        return (a*b/__gcd(a,b)); // __gcd(a,b) is inbuilt library function\n    }\n    \n    let arr = [1,2,8,3];\n    document.write(LcmOfArray(arr, 0) + \"</br>\");\n    arr = [2,7,3,9,4];\n    document.write(LcmOfArray(arr,0));\n\n// This code is contributed by decode2207.\n</script>\n24\n252\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nint gcd(int num1, int num2)\n{\n    if (num2 == 0)\n        return num1;\n    return gcd(num2, num1 % num2);\n}\n\nint lcm_of_array(vector<int> arr)\n{\n    int lcm = arr[0];\n    for (int i = 1; i < arr.size(); i++) {\n        int num1 = lcm;\n        int num2 = arr[i];\n        int gcd_val = gcd(num1, num2);\n        lcm = (lcm * arr[i]) / gcd_val;\n    }\n    return lcm;\n}\n\nint main()\n{\n    vector<int> arr1 = { 1, 2, 8, 3 };\n    vector<int> arr2 = { 2, 7, 3, 9, 4 };\n    cout << lcm_of_array(arr1) << endl; // Output: 24\n    cout << lcm_of_array(arr2) << endl; // Output: 252\n    return 0;\n}\nimport java.util.*;\n\npublic class Main {\n\n    public static int gcd(int num1, int num2)\n    {\n        if (num2 == 0)\n            return num1;\n        return gcd(num2, num1 % num2);\n    }\n\n    public static int lcm_of_array(ArrayList<Integer> arr)\n    {\n        int lcm = arr.get(0);\n        for (int i = 1; i < arr.size(); i++) {\n            int num1 = lcm;\n            int num2 = arr.get(i);\n            int gcd_val = gcd(num1, num2);\n            lcm = (lcm * arr.get(i)) / gcd_val;\n        }\n        return lcm;\n    }\n\n    public static void main(String[] args)\n    {\n        ArrayList<Integer> arr1\n            = new ArrayList<>(Arrays.asList(1, 2, 8, 3));\n        ArrayList<Integer> arr2\n            = new ArrayList<>(Arrays.asList(2, 7, 3, 9, 4));\n        System.out.println(\n            lcm_of_array(arr1)); // Output: 24\n        System.out.println(\n            lcm_of_array(arr2)); // Output: 252\n    }\n}\ndef lcm_of_array(arr):\n    lcm = arr[0]\n    for i in range(1, len(arr)):\n        num1 = lcm\n        num2 = arr[i]\n        gcd = 1\n        # Finding GCD using Euclidean algorithm\n        while num2 != 0:\n            temp = num2\n            num2 = num1 % num2\n            num1 = temp\n        gcd = num1\n        lcm = (lcm * arr[i]) // gcd\n    return lcm\n\n\n# Example usage\narr1 = [1, 2, 8, 3]\narr2 = [2, 7, 3, 9, 4]\nprint(lcm_of_array(arr1))  # Output: 24\nprint(lcm_of_array(arr2))  # Output: 252\nusing System;\nusing System.Collections.Generic;\n\nclass Program {\n    static int Gcd(int num1, int num2)\n    {\n        if (num2 == 0)\n            return num1;\n        return Gcd(num2, num1 % num2);\n    }\n\n    static int LcmOfArray(List<int> arr)\n    {\n        int lcm = arr[0];\n        for (int i = 1; i < arr.Count; i++) {\n            int num1 = lcm;\n            int num2 = arr[i];\n            int gcdVal = Gcd(num1, num2);\n            lcm = (lcm * arr[i]) / gcdVal;\n        }\n        return lcm;\n    }\n\n    static void Main()\n    {\n        List<int> arr1 = new List<int>{ 1, 2, 8, 3 };\n        List<int> arr2 = new List<int>{ 2, 7, 3, 9, 4 };\n        Console.WriteLine(LcmOfArray(arr1)); // Output: 24\n        Console.WriteLine(LcmOfArray(arr2)); // Output: 252\n    }\n}\nfunction gcd(num1, num2) {\n    if (num2 == 0)\n        return num1;\n    return gcd(num2, num1 % num2);\n}\n\nfunction lcm_of_array(arr) {\n    let lcm = arr[0];\n    for (let i = 1; i < arr.length; i++) {\n        let num1 = lcm;\n        let num2 = arr[i];\n        let gcd_val = gcd(num1, num2);\n        lcm = (lcm * arr[i]) / gcd_val;\n    }\n    return lcm;\n}\n\nlet arr1 = [1, 2, 8, 3];\nlet arr2 = [2, 7, 3, 9, 4];\nconsole.log(lcm_of_array(arr1)); // Output: 24\nconsole.log(lcm_of_array(arr2)); // Output: 252\n24\n252\n#include <iostream>\n#include <vector>\n#include <numeric> // for std::accumulate\n\nint gcd(int a, int b)\n{\n    if (b == 0)\n        return a;\n    return gcd(b, a % b);\n}\n\nint lcm(std::vector<int> numbers)\n{\n    return std::accumulate(numbers.begin(), numbers.end(), 1,\n        [](int x, int y) { return (x * y) / gcd(x, y); });\n}\n\nint main()\n{\n    std::vector<int> numbers = {2, 3, 4, 5};\n    int LCM = lcm(numbers);\n    std::cout << \"LCM of \" << numbers.size() << \" numbers is \" << LCM << std::endl;\n    return 0;\n}\n// Java code to find LCM of given numbers using reduce()\n// function\nimport java.util.*;\nimport java.util.function.*;\nimport java.util.stream.*;\n\nclass Main {\n    static int lcm(List<Integer> numbers)\n    {\n        return numbers.stream().reduce(\n            1, (x, y) -> (x * y) / gcd(x, y));\n    }\n\n    static int gcd(int a, int b)\n    {\n        if (b == 0)\n            return a;\n        return gcd(b, a % b);\n    }\n\n    public static void main(String[] args)\n    {\n        List<Integer> numbers = Arrays.asList(2, 3, 4, 5);\n        int LCM = lcm(numbers);\n        System.out.println(\"LCM of \" + numbers + \" is \"\n                           + LCM);\n    }\n}\nfrom functools import reduce\nimport math\n\ndef lcm(numbers):\n    return reduce(lambda x, y: x * y // math.gcd(x, y), numbers, 1)\n\nnumbers = [2, 3, 4, 5]\nprint(\"LCM of\", numbers, \"is\", lcm(numbers))\nusing System;\nusing System.Linq;\n\nclass Program\n{\n    static int Lcm(int[] numbers)\n    {\n        return numbers.Aggregate((x, y) => x * y / Gcd(x, y));\n    }\n\n    static int Gcd(int a, int b)\n    {\n        if (b == 0)\n            return a;\n        return Gcd(b, a % b);\n    }\n\n    static void Main()\n    {\n        int[] numbers = { 2, 3, 4, 5 };\n        int lcm = Lcm(numbers);\n        Console.WriteLine(\"LCM of {0} is {1}\", string.Join(\", \", numbers), lcm);\n    }\n}\nfunction lcm(numbers) {\n  function gcd(a, b) {\n    // If the second argument is 0, return the first argument (base case)\n    if (b === 0) {\n      return a;\n    }\n    // Otherwise, recursively call gcd with arguments b and the remainder of a divided by b\n    return gcd(b, a % b);\n  }\n  // Reduce the array of numbers by multiplying each number together and dividing by their gcd\n  // This finds the Least Common Multiple (LCM) of the numbers in the array\n  return numbers.reduce((a, b) => a * b / gcd(a, b));\n}\n\n// array \nlet numbers = [2, 3, 4, 5];\n\n// Call the lcm function \nlet lcmValue = lcm(numbers);\n\n// Print the Output \nconsole.log(`LCM of ${numbers.join(', ')} is ${lcmValue}`);\nLCM of 4 numbers is 60\n",
        "complexity": {
            "time": "The time complexity of the program is O(n log n)",
            "space": ""
        },
        "tags": [
            "Mathematical Algorithms"
        ],
        "url": "https://www.geeksforgeeks.org/lcm-of-given-array-elements/"
    },
    {
        "title": "GCD of more than two (or array) numbers",
        "description": "Given an array arr[] of non-negative numbers, the task is to find GCD of all the array elements. In a previous post we find GCD of two number. Examples: Input: arr[] = [1, 2, 3]Output: 1Input: arr[] = [2, 4, 6, 8]Output: 2 The GCD of three or more numbers equals the product of the prime factors common to all the numbers, but it can also be calculated by repeatedly taking the GCDs of pairs of numbers. gcd(a, b, c) = gcd(a, gcd(b, c))              = gcd(gcd(a, b), c)              = gcd(gcd(a, c), b) We traverse the array while keeping track of a variable that stores the GCD of all the elements processed up to that point. During the ith iteration, we update this GCD by calculating the GCD of the current element and the GCD obtained so far. We will also check for the result if the result at any step becomes 1 then return 1 as gcd(1, any number) = 1. Time Complexity: O(n * log(x)), where x is the largest element of the arrayAuxiliary Space: O(1) Time Complexity: O(n * log(x)), where x is the largest element of the arrayAuxiliary Space: O(1) Languages like C++, Python, C#, etc., have built-in methods for calculating the GCD of two numbers. Time Complexity: O(n * log(x)), where x is the largest element of the arrayAuxiliary Space: O(1)  D  ",
        "code": "// C++ program to find GCD of two or\n// more numbers\n#include <iostream>\n#include <vector>\nusing namespace std;\n\n// Recursive function to return gcd of a and b\nint gcd(int a, int b) {\n    if (a == 0)\n        return b;\n    return gcd(b % a, a);\n}\n\n// Function to find gcd of array of numbers\nint findGCD(vector<int> &arr) {\n    int res = arr[0];\n    for (int i = 1; i < arr.size(); i++) {\n        res = gcd(arr[i], res);\n\n        // If res becomes 1 at any iteration then it remains 1\n        // So no need to check further\n        if (res == 1)\n            return 1;\n    }\n    return res;\n}\n\nint main() {\n    vector<int> arr = {2, 4, 6, 8, 16};\n\n    cout << findGCD(arr) << endl;\n    return 0;\n}\n// C program to find GCD of two or\n// more numbers\n#include <stdio.h>\n\n// Recursive function to return gcd of a and b\nint gcd(int a, int b) {\n    if (a == 0)\n        return b;\n    return gcd(b % a, a);\n}\n\n// Function to find gcd of array of numbers\nint findGCD(int array[], int n) {\n    int res = array[0];\n    for (int i = 1; i < n; i++) {\n        res = gcd(array[i], res);\n\n        // If res becomes 1 at any iteration then it remains 1\n        // So no need to check further\n        if (res == 1)\n            return 1;\n    }\n    return res;\n}\n\nint main() {\n    int array[] = {2, 4, 6, 8, 16};\n    int n = sizeof(array) / sizeof(array[0]);\n\n    printf(\"%d\\n\", findGCD(array, n));\n    return 0;\n}\n// Java program to find GCD of two or\n// more numbers\nimport java.util.*;\n\npublic class GCDArray {\n\n    // Recursive function to return gcd of a and b\n    public static int gcd(int a, int b) {\n        if (a == 0)\n            return b;\n        return gcd(b % a, a);\n    }\n\n    // Function to find gcd of array of numbers\n    public static int findGCD(int[] array) {\n        int res = array[0];\n        for (int i = 1; i < array.length; i++) {\n            res = gcd(array[i], res);\n\n            // If res becomes 1 at any iteration then it remains 1\n            // So no need to check further\n            if (res == 1)\n                return 1;\n        }\n        return res;\n    }\n\n    public static void main(String[] args) {\n        int[] array = {2, 4, 6, 8, 16};\n\n        System.out.println(findGCD(array));\n    }\n}\n# Python program to find GCD of two or\n# more numbers\nfrom functools import reduce\n\n# Recursive function to return gcd of a and b\ndef gcd(a, b):\n    if a == 0:\n        return b\n    return gcd(b % a, a)\n\n\n# Function to find gcd of array of numbers\ndef findGCD(array):\n    res = array[0]\n    for num in array[1:]:\n        res = gcd(num, res)\n\n        # If res becomes 1 at any iteration then it remains 1\n        # So no need to check further\n        if res == 1:\n            return 1\n    return res\n\nif __name__ == \"__main__\":\n    array = [2, 4, 6, 8, 16]\n\n    print(findGCD(array))\n// C# program to find GCD of two or\n// more numbers\nusing System;\nusing System.Collections.Generic;\n\nclass GCDArray {\n\n    // Recursive function to return gcd of a and b\n    public static int gcd(int a, int b) {\n        if (a == 0)\n            return b;\n        return gcd(b % a, a);\n    }\n\n    // Function to find gcd of array of numbers\n    public static int findGCD(int[] array) {\n        int res = array[0];\n        for (int i = 1; i < array.Length; i++) {\n            res = gcd(array[i], res);\n\n            // If res becomes 1 at any iteration then it remains 1\n            // So no need to check further\n            if (res == 1)\n                return 1;\n        }\n        return res;\n    }\n\n    static void Main(string[] args) {\n        int[] array = {2, 4, 6, 8, 16};\n\n        Console.WriteLine(findGCD(array));\n    }\n}\n// JavaScript program to find GCD of two or\n// more numbers\n\n// Recursive function to return gcd of a and b\nfunction gcd(a, b) {\n    if (a === 0)\n        return b;\n    return gcd(b % a, a);\n}\n\n// Function to find gcd of array of numbers\nfunction findGCD(array) {\n    let res = array[0];\n    for (let i = 1; i < array.length; i++) {\n        res = gcd(array[i], res);\n\n        // If res becomes 1 at any iteration then it remains 1\n        // So no need to check further\n        if (res === 1)\n            return 1;\n    }\n    return res;\n}\n\n// Driver Code\nconst array = [2, 4, 6, 8, 16];\nconsole.log(findGCD(array));\n2\n// C++ program to find GCD of two or more numbers\n#include <iostream>\n#include <vector>\nusing namespace std;\n\n// Iterative implementation\nint getGCD(int a, int b) {\n    while (a > 0 && b > 0) {\n        if (a > b) {\n            a = a % b;\n        }\n        else {\n            b = b % a;\n        }\n    }\n    if (a == 0) {\n        return b;\n    }\n    return a;\n}\n\nint GcdOfArray(vector<int>& arr) {\n    int gcd = arr[0];\n    for (int i = 1; i < arr.size(); i++) {\n        gcd = getGCD(gcd, arr[i]);\n    }\n    return gcd;\n}\n\nint main() {\n    vector<int> arr = { 2, 4, 6, 8 };\n    cout << GcdOfArray(arr) << \"\\n\";\n    return 0;\n}\n// C program to find GCD of two or more numbers \n#include <stdio.h>\n\n// Iterative implementation\nint getGCD(int a, int b) {\n    while (a > 0 && b > 0) {\n        if (a > b) {\n            a = a % b;\n        } else {\n            b = b % a;\n        }\n    }\n    return (a == 0) ? b : a;\n}\n\nint GcdOfArray(int arr[], int n) {\n    int gcd = arr[0];\n    for (int i = 1; i < n; i++) {\n        gcd = getGCD(gcd, arr[i]);\n    }\n    return gcd;\n}\n\nint main() {\n    int arr[] = {2, 4, 6, 8};\n    int n = sizeof(arr) / sizeof(arr[0]);\n    printf(\"%d\\n\", GcdOfArray(arr, n));\n    return 0;\n}\n// Java program to find GCD of two or more numbers\nimport java.util.Arrays;\nimport java.util.List;\n\nclass GfG {\n  \n    // Iterative implementation\n    static int getGCD(int a, int b) {\n        while (a > 0 && b > 0) {\n            if (a > b) {\n                a = a % b;\n            } else {\n                b = b % a;\n            }\n        }\n        return (a == 0) ? b : a;\n    }\n\n    static int GcdOfArray(int[] arr) {\n        int gcd = arr[0];\n        for (int num : arr) {\n            gcd = getGCD(gcd, num);\n        }\n        return gcd;\n    }\n\n    public static void main(String[] args) {\n        int[] arr = { 2, 4, 6, 8 };\n        System.out.println(GcdOfArray(arr));\n    }\n}\n# Function to find GCD of two numbers\n\ndef getGcd(a, b):\n    while a > 0 and b > 0:\n        if a > b:\n            a = a % b\n        else:\n            b = b % a\n    return b if a == 0 else a\n\n# Function to find GCD of an array\ndef GcdOfArray(arr):\n    gcd = arr[0]\n    for num in arr:\n        gcd = getGcd(gcd, num)\n    return gcd\n\n# Main function\nif __name__ == '__main__':\n    arr = [2, 4, 6, 8]\n    print(GcdOfArray(arr))\n// C# program to find GCD of two or more numbers\nusing System;\nusing System.Linq;\n\nclass GCD {\n  \n    // Iterative implementation\n    static int getGCD(int a, int b) {\n        while (a > 0 && b > 0) {\n            if (a > b) {\n                a = a % b;\n            } else {\n                b = b % a;\n            }\n        }\n        return (a == 0) ? b : a;\n    }\n\n    static int GcdOfArray(int[] arr) {\n        int gcd = arr[0];\n        foreach (int num in arr) {\n            gcd = getGCD(gcd, num);\n        }\n        return gcd;\n    }\n\n    public static void Main() {\n        int[] arr = {2, 4, 6, 8};\n        Console.WriteLine(GcdOfArray(arr));\n    }\n}\n// JavaScript program to find GCD of two or more numbers\n\nfunction getGCD(a, b) {\n    while (a > 0 && b > 0) {\n        if (a > b) {\n            a = a % b;\n        } else {\n            b = b % a;\n        }\n    }\n    return (a === 0) ? b : a;\n}\n\nfunction GcdOfArray(arr) {\n    let gcd = 0;\n    for (let num of arr) {\n        gcd = getGCD(gcd, num);\n    }\n    return gcd;\n}\n\n// Driver Code\nconst arr = [2, 4, 6, 8];\nconsole.log(GcdOfArray(arr));\n2\n// C++ program to find GCD of two or more numbers \n// Using built-in function\n#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n// Function to return gcd of a and b\nint GcdOfArray(vector<int>& arr) {\n  \tint res = arr[0];\n    for (int i = 1; i < arr.size(); i++) {\n      \n      \t// Find gcd(a, b) using inbuilt library function\n        res = __gcd(arr[i], res);\n\n        // If res becomes 1 at any iteration then it remains 1\n        // So no need to check further\n        if (res == 1)\n            return 1;\n    }\n    return res;\n}\n\nint main() {\n    vector<int> arr = { 2, 4, 6, 8 };\n    cout << GcdOfArray(arr) << \"\\n\";\n    return 0;\n}\n// Java program to find GCD of two or more numbers \n// Using built-in function\nimport java.util.*;\n\npublic class GCDArray {\n\n    // Function to return gcd of a and b\n    public static int GcdOfArray(int[] array) {\n        int res = array[0];\n        for (int i = 1; i < array.length; i++) {\n\n            // Find gcd(a, b) using inbuilt library function\n            res = gcd(array[i], res);\n\n            // If res becomes 1 at any iteration then it remains 1\n            // So no need to check further\n            if (res == 1)\n                return 1;\n        }\n        return res;\n    }\n\n    // Helper function for GCD using inbuilt method\n    public static int gcd(int a, int b) {\n        return b == 0 ? a : gcd(b, a % b);\n    }\n\n    public static void main(String[] args) {\n        int[] array = {2, 4, 6, 8};\n        System.out.println(GcdOfArray(array));\n    }\n}\n# Python program to find GCD of two or more numbers \n# Using built-in function\nfrom math import gcd\n\n# Function to return gcd of a and b\ndef GcdOfArray(array):\n    res = array[0]\n    for num in array[1:]:\n      \n        # Find gcd(a, b) using inbuilt library function\n        res = gcd(num, res)\n\n        # If res becomes 1 at any iteration then it remains 1\n        # So no need to check further\n        if res == 1:\n            return 1\n    return res\n\nif __name__ == \"__main__\":\n    array = [2, 4, 6, 8]\n    print(GcdOfArray(array))\n// C# program to find GCD of two or more numbers \n// Using built-in function\nusing System;\n\nclass GCDArray {\n\n    // Function to return gcd of a and b\n    public static int GcdOfArray(int[] array) {\n        int res = array[0];\n        for (int i = 1; i < array.Length; i++) {\n\n            // Find gcd(a, b) using inbuilt library function\n            res = Gcd(array[i], res);\n\n            // If res becomes 1 at any iteration then it remains 1\n            // So no need to check further\n            if (res == 1)\n                return 1;\n        }\n        return res;\n    }\n\n    // Helper method for GCD\n    public static int Gcd(int a, int b) {\n        return b == 0 ? a : Gcd(b, a % b);\n    }\n\n    public static void Main(string[] args) {\n        int[] array = {2, 4, 6, 8};\n        Console.WriteLine(GcdOfArray(array));\n    }\n}\n// JavaScript program to find GCD of two or more numbers \n// Using built-in function\n\n// Function to return gcd of a and b\nfunction GcdOfArray(array) {\n    let res = array[0];\n    for (let i = 1; i < array.length; i++) {\n\n        // Find gcd(a, b) using inbuilt library function\n        res = gcd(array[i], res);\n\n        // If res becomes 1 at any iteration then it remains 1\n        // So no need to check further\n        if (res === 1)\n            return 1;\n    }\n    return res;\n}\n\n// Helper function for GCD\nfunction gcd(a, b) {\n    return b === 0 ? a : gcd(b, a % b);\n}\n\nconst array = [2, 4, 6, 8];\nconsole.log(GcdOfArray(array));\n2\n",
        "complexity": {
            "time": "Time Complexity: O(n * log(x)), where x is the largest element of the arrayAuxiliary Space: O(1)",
            "space": ""
        },
        "tags": [
            "Mathematical Algorithms"
        ],
        "url": "https://www.geeksforgeeks.org/gcd-two-array-numbers/"
    },
    {
        "title": "Binomial Coefficient",
        "description": "Given an integer values n and k, the task is to find the value of Binomial Coefficient C(n, k). Input: n = 4, k = 2Output: 6Explanation: The value of 4C2 is (4 × 3) / (2 × 1) = 6. Input: n = 5, k = 2Output: 10Explanation: The value of 5C2 is (5 × 4) / (2 × 1) = 10. Input: n = 6, k = 3Output: 20Explanation: The value of 6C3 is (6 × 5 × 4) / (3 × 2 × 1) = 20. Table of Content The idea is to use recursion to find C(n, k).The value of C(n, k) can be recursively calculated using the following standard formula for Binomial Coefficients. C(n, k) = C(n-1, k-1) + C(n-1, k). C(n, 0) = C(n, n) = 1. So we just need to make recursive calls of C(n-1, k-1) and C(n – 1, k). The base conditions will be when k = 0 or value of k and n be equal. It should be noted that the above function computes the same subproblems again and again. And have two properties of Dynamic Programming: 1. Optimal Substructure: The value of C(n, k)depends on the optimal solutions of the subproblemsC(n-1, k-1) and C(n-1, k). By adding these optimal substrutures, we can efficiently calculate the total value of C(n, k). 2. Overlapping Subproblems: While applying a recursive approach in this problem, we notice that certain subproblems are computed multiple times. Recursion tree for n = 5 and k = 2. The function C(3, 1) is called two times. For large values of n, there will be many common subproblems. The Binomial Coefficient C(n, k) is computed recursively, but to avoid redundant calculations, dynamic programming with memoization is used. A 2D table stores previously computed values, allowing efficient lookups instead of recalculating. If a value is already computed, it is returned directly; otherwise, it is computed recursively and stored for future use. The approach is similar to the previous one. just instead of breaking down the problem recursively, we iteratively build up the solution by calculating in bottom-up manner. Maintain a dp[][] table such that dp[i][j] stores the count all unique possible paths to reach the cell (i, j). Base Case: Recursive Case: In the previous approach using dynamic programming, we derived a relation between states as follows: We do not need to maitain whole matrix for this. We can just maintain one array of length k and add dp[j-1] every time to dp[j]; Related articles:   ",
        "code": "// C++ implementation to find \n// Binomial Coefficient using recursion\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Returns value of Binomial Coefficient C(n, k)\nint binomialCoeff(int n, int k) {\n  \t\n    // k can not be grater then k so we return 0 here\n    if (k > n)\n        return 0;\n  \n  \t// base condition when k and n are equal or k = 0\n    if (k == 0 || k == n)\n        return 1;\n\n    // Recurvie add the value \n    return binomialCoeff(n - 1, k - 1)\n           + binomialCoeff(n - 1, k);\n}\n\nint main() {\n    int n = 5, k = 2;\n    cout << binomialCoeff(n, k);\n    return 0;\n}\n// C implementation to find \n// Binomial Coefficient using recursion\n\n#include <stdio.h>\n\n// Returns value of Binomial Coefficient C(n, k)\nint binomialCoeff(int n, int k) {\n    // k can not be grater then k so we return 0 here\n    if (k > n)\n        return 0;\n  \n  \t// base condition when k and n are equal or k = 0\n    if (k == 0 || k == n)\n        return 1;\n\n    // Recursive add the value \n    return binomialCoeff(n - 1, k - 1)\n           + binomialCoeff(n - 1, k);\n}\n\nint main() {\n    int n = 5, k = 2;\n    printf(\"%d\", binomialCoeff(n, k));\n    return 0;\n}\n// Java implementation to find \n// Binomial Coefficient using recursion\n\nclass GfG {\n  \n    // Returns value of Binomial Coefficient C(n, k)\n    static int binomialCoeff(int n, int k) {\n      \n        // k can not be grater then k so we \n      \t// return 0 here\n        if (k > n)\n            return 0;\n      \n      \t// base condition when k and n are\n      \t// equal or k = 0\n        if (k == 0 || k == n)\n            return 1;\n\n        // Recursive add the value \n        return binomialCoeff(n - 1, k - 1)\n               + binomialCoeff(n - 1, k);\n    }\n\n    public static void main(String[] args) {\n        int n = 5, k = 2;\n        System.out.println(binomialCoeff(n, k));\n    }\n}\n# Python implementation to find \n# Binomial Coefficient using recursion\n\n# Returns value of Binomial Coefficient C(n, k)\ndef binomialCoeff(n, k):\n  \n    # k can not be grater then k so we\n    # return 0 here\n    if k > n:\n        return 0\n      \n    # base condition when k and n are equal \n    # or k = 0\n    if k == 0 or k == n:\n        return 1\n\n    # Recursive add the value \n    return binomialCoeff(n - 1, k - 1) + binomialCoeff(n - 1, k)\n\nn = 5\nk = 2\nprint(binomialCoeff(n, k))\n// C# implementation to find \n// Binomial Coefficient using recursion\nusing System;\n\nclass GfG {\n  \n    // Returns value of Binomial Coefficient C(n, k)\n    static int BinomialCoeff(int n, int k) {\n      \n        // k can not be grater then k so we \n      \t// return 0 here\n        if (k > n)\n            return 0;\n      \n      \t// base condition when k and n are \n      \t// equal or k = 0\n        if (k == 0 || k == n)\n            return 1;\n\n        // Recursive add the value \n        return BinomialCoeff(n - 1, k - 1)\n               + BinomialCoeff(n - 1, k);\n    }\n\n    static void Main(string[] args) {\n        int n = 5, k = 2;\n        Console.WriteLine(BinomialCoeff(n, k));\n    }\n}\n// Javascript implementation to find \n// Binomial Coefficient using recursion\n\n// Returns value of Binomial Coefficient C(n, k)\nfunction binomialCoeff(n, k) {\n\n    // k can not be grater then k so we \n    // return 0 here\n    if (k > n)\n        return 0;\n        \n    // base condition when k and n are equal\n    // or k = 0\n    if (k === 0 || k === n)\n        return 1;\n\n    // Recursive add the value \n    return binomialCoeff(n - 1, k - 1) + binomialCoeff(n - 1, k);\n}\n\nlet n = 5, k = 2;\nconsole.log(binomialCoeff(n, k));\n10\n// C++ implementation to find \n// Binomial Coefficient using memoization\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Returns value of Binomial Coefficient C(n, k)\nint getnCk(int n, int k, vector<vector<int>> &memo) {\n  \n    // k can not be grater then k so we\n  \t// return 0 here\n    if (k > n)\n        return 0;\n  \n  \t// base condition when k and n are \n  \t// equal or k = 0\n    if (k == 0 || k == n)\n        return 1;\n\t\n  \t// Check if pair n and k is already \n  \t// calculated then return it from here\n  \tif(memo[n][k] != -1) return memo[n][k];\n  \n    // Recurvie add the value and store to memorize table\n    return memo[n][k] = getnCk(n - 1, k - 1, memo) \n      \t\t\t\t\t+ getnCk(n - 1, k, memo);\n}\nint binomialCoeff(int n, int k) {\n  \t\n  \t// Create table for memorization\n\tvector<vector<int>> memo(n + 1, vector<int> (k + 1, -1));\n  \n  \treturn getnCk(n, k, memo);\n}\nint main() {\n    int n = 5, k = 2;\n    cout << binomialCoeff(n, k);\n    return 0;\n}\n// Java implementation to find \n// Binomial Coefficient using memoization\n\nimport java.util.Arrays;\n\nclass GfG {\n  \n    // Returns value of Binomial Coefficient C(n, k)\n    static int getnCk(int n, int k, int[][] memo) {\n      \n        // k cannot be greater than n so we return 0 here\n        if (k > n)\n            return 0;\n      \n        // base condition when k and n are equal or k = 0\n        if (k == 0 || k == n)\n            return 1;\n        \n        // Check if pair n and k is already \n        // calculated then return it from here\n        if (memo[n][k] != -1) return memo[n][k];\n      \n        // Recursive add the value and store to memo table\n        return memo[n][k] = getnCk(n - 1, k - 1, memo) \n                            + getnCk(n - 1, k, memo);\n    }\n\n    static int binomialCoeff(int n, int k) {\n      \n        // Create table for memoization\n        int[][] memo = new int[n + 1][k + 1];\n        for (int[] row : memo)\n            Arrays.fill(row, -1);\n\n        return getnCk(n, k, memo);\n    }\n\n    public static void main(String[] args) {\n        int n = 5, k = 2;\n        System.out.println(binomialCoeff(n, k));\n    }\n}\n# Python implementation to find \n# Binomial Coefficient using memoization\n\ndef getnCk(n, k, memo):\n  \n    # k cannot be greater than n so we return 0 here\n    if k > n:\n        return 0\n    \n    # base condition when k and n are equal or k = 0\n    if k == 0 or k == n:\n        return 1\n    \n    # Check if pair n and k is already \n    # calculated then return it from here\n    if memo[n][k] != -1:\n        return memo[n][k]\n    \n    # Recursive add the value and store to memo table\n    memo[n][k] = getnCk(n - 1, k - 1, memo) + \\\n    getnCk(n - 1, k, memo)\n    return memo[n][k]\n\ndef binomialCoeff(n, k):\n  \n    # Create table for memoization\n    memo = [[-1 for _ in range(k + 1)] for _ in range(n + 1)]\n    \n    return getnCk(n, k, memo)\n\nn, k = 5, 2\nprint(binomialCoeff(n, k))\n// C# implementation to find \n// Binomial Coefficient using memoization\n\nusing System;\n\nclass GfG {\n  \n    // Returns value of Binomial \n  \t// Coefficient C(n, k)\n    static int GetnCk(int n, int k, int[,] memo) {\n      \n        // k cannot be greater than n so we\n      \t// return 0 here\n        if (k > n)\n            return 0;\n      \n        // base condition when k and n are \n      \t// equal or k = 0\n        if (k == 0 || k == n)\n            return 1;\n        \n        // Check if pair n and k is already \n        // calculated then return it from here\n        if (memo[n, k] != -1) return memo[n, k];\n      \n        // Recursive add the value and store to memo table\n        return memo[n, k] = GetnCk(n - 1, k - 1, memo) \n                            + GetnCk(n - 1, k, memo);\n    }\n\n    static int BinomialCoeff(int n, int k) {\n      \n        // Create table for memoization\n        int[,] memo = new int[n + 1, k + 1];\n        for (int i = 0; i <= n; i++)\n            for (int j = 0; j <= k; j++)\n                memo[i, j] = -1;\n        \n        return GetnCk(n, k, memo);\n    }\n\n   \tstatic void Main() {\n        int n = 5, k = 2;\n        Console.WriteLine(BinomialCoeff(n, k));\n    }\n}\n// Javascript implementation to find\n// Binomial Coefficient using memoization\n\nfunction getnCk(n, k, memo) {\n\n    // k cannot be greater than n so we\n    // return 0 here\n    if (k > n)\n        return 0;\n\n    // base condition when k and n are \n    // equal or k = 0\n    if (k === 0 || k === n)\n        return 1;\n\n    // Check if pair n and k is already\n    // calculated then return it from here\n    if (memo[n][k] !== -1)\n        return memo[n][k];\n\n    // Recursive add the value and store to memo table\n    return memo[n][k] = getnCk(n - 1, k - 1, memo)\n                        + getnCk(n - 1, k, memo);\n}\n\nfunction binomialCoeff(n, k) {\n\n    // Create table for memoization\n    const memo = Array.from({length : n + 1},\n                            () => Array(k + 1).fill(-1));\n\n    return getnCk(n, k, memo);\n}\n\nconst n = 5, k = 2;\nconsole.log(binomialCoeff(n, k));\n10\n// C++ implementation to find \n// Binomial Coefficient using tabulation\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Returns value of Binomial Coefficient C(n, k)\nint binomialCoeff(int n, int k) {\n  \tvector<vector<int>> dp(n + 1, vector<int> (k + 1));\n  \n    // Calculate value of Binomial Coefficient\n    // in bottom up manner\n    for (int i = 0; i <= n; i++) {\n        for (int j = 0; j <= min(i, k); j++) {\n          \n            // Base Cases\n            if (j == 0 || j == i)\n                dp[i][j] = 1;\n\n            // Calculate value using previously\n            // stored values\n            else\n                dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];\n        }\n    }\n\n    return dp[n][k];\n}\n\nint main() {\n    int n = 5, k = 2;\n    cout << binomialCoeff(n, k);\n}\n// C implementation to find \n// Binomial Coefficient using tabulation\n\n#include <stdio.h>\n\n// Returns value of Binomial Coefficient C(n, k)\nint binomialCoeff(int n, int k) {\n    int dp[n + 1][k + 1];\n\n    // Calculate value of Binomial Coefficient\n    // in bottom up manner\n    for (int i = 0; i <= n; i++) {\n        for (int j = 0; j <= (i < k ? i : k); j++) {\n            if (j == 0 || j == i)\n                dp[i][j] = 1;\n\n            // Calculate value using previously\n            // stored values\n            else\n                dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];\n        }\n    }\n\n    return dp[n][k];\n}\n\nint main() {\n    int n = 5, k = 2;\n    printf(\"%d\", binomialCoeff(n, k));\n    return 0;\n}\n// Java implementation to find \n// Binomial Coefficient using tabulation\nclass GfG {\n\n    // Returns value of Binomial Coefficient C(n, k)\n    static int binomialCoeff(int n, int k) {\n        int[][] dp = new int[n + 1][k + 1];\n\n        // Calculate value of Binomial Coefficient\n        // in bottom up manner\n        for (int i = 0; i <= n; i++) {\n            for (int j = 0; j <= Math.min(i, k); j++) {\n                if (j == 0 || j == i)\n                    dp[i][j] = 1;\n\n                // Calculate value using previously\n                // stored values\n                else\n                    dp[i][j]\n                        = dp[i - 1][j - 1] + dp[i - 1][j];\n            }\n        }\n\n        return dp[n][k];\n    }\n\n    public static void main(String[] args) {\n        int n = 5, k = 2;\n        System.out.println(binomialCoeff(n, k));\n    }\n}\n# Python implementation to find \n# Binomial Coefficient using tabulation\n\n# Returns value of Binomial Coefficient C(n, k)\ndef binomialCoeff(n, k):\n    dp = [[0 for _ in range(k + 1)] for _ in range(n + 1)]\n\n    # Calculate value of Binomial Coefficient\n    # in bottom up manner\n    for i in range(n + 1):\n        for j in range(min(i, k) + 1):\n          \n            # Base Cases\n            if j == 0 or j == i:\n                dp[i][j] = 1\n\n            # Calculate value using previously\n            # stored values\n            else:\n                dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]\n\n    return dp[n][k]\n\n\nn = 5\nk = 2\nprint(binomialCoeff(n, k))\n// C3 implementation to find \n// Binomial Coefficient using tabulation\n\nusing System;\n\nclass GfG {\n  \n    // Returns value of Binomial Coefficient C(n, k)\n    public static int BinomialCoeff(int n, int k) {\n        int[, ] dp = new int[n + 1, k + 1];\n\n        // Calculate value of Binomial Coefficient\n        // in bottom up manner\n        for (int i = 0; i <= n; i++) {\n            for (int j = 0; j <= Math.Min(i, k); j++) {\n              \n                // Base Cases\n                if (j == 0 || j == i)\n                    dp[i, j] = 1;\n\n                // Calculate value using previously\n                // stored values\n                else\n                    dp[i, j]\n                        = dp[i - 1, j - 1] + dp[i - 1, j];\n            }\n        }\n\n        return dp[n, k];\n    }\n\n    static void Main(string[] args) {\n        int n = 5, k = 2;\n        Console.WriteLine(BinomialCoeff(n, k));\n    }\n}\n// Javascript implementation to find \n// Binomial Coefficient using tabulation\n\n// Returns value of Binomial Coefficient C(n, k)\nfunction binomialCoeff(n, k) {\n    let dp = Array.from({ length: n + 1 }, () => Array(k + 1).fill(0));\n\n    // Calculate value of Binomial Coefficient\n    // in bottom up manner\n    for (let i = 0; i <= n; i++) {\n        for (let j = 0; j <= Math.min(i, k); j++) {\n        \n            // Base Cases\n            if (j === 0 || j === i) {\n                dp[i][j] = 1;\n            }\n\n            // Calculate value using previously\n            // stored values\n            else {\n                dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];\n            }\n        }\n    }\n\n    return dp[n][k];\n}\n\nlet n = 5, k = 2;\nconsole.log(binomialCoeff(n, k));\n10\n// C++ program for space optimized Dynamic Programming\n// Solution of Binomial Coefficient\n#include <bits/stdc++.h>\nusing namespace std;\n\nint binomialCoeff(int n, int k) {\n    vector<int> dp(k + 1);\n\n  \t// nC0 is 1\n    dp[0] = 1; \n\n    for (int i = 1; i <= n; i++) {\n      \n        // Compute next row of pascal triangle using\n        // the previous row\n        for (int j = min(i, k); j > 0; j--)\n            dp[j] = dp[j] + dp[j - 1];\n    }\n    return dp[k];\n}\n\nint main() {\n    int n = 5, k = 2;\n    cout << binomialCoeff(n, k);\n    return 0;\n}\n// Java program for space optimized Dynamic Programming\n// Solution of Binomial Coefficient\n\nclass GfG {\n\n    // Returns value of Binomial Coefficient C(n, k)\n    static int binomialCoeff(int n, int k) {\n        int[] dp = new int[k + 1];\n\n        // nC0 is 1\n        dp[0] = 1;\n\n        for (int i = 1; i <= n; i++) {\n          \n            // Compute next row of pascal triangle using\n            // the previous row\n            for (int j = Math.min(i, k); j > 0; j--)\n                dp[j] = dp[j] + dp[j - 1];\n        }\n        return dp[k];\n    }\n\n    public static void main(String[] args) {\n        int n = 5, k = 2;\n        System.out.println(binomialCoeff(n, k));\n    }\n}\n# Python program for space optimized Dynamic Programming\n# Solution of Binomial Coefficient\n\ndef binomialCoeff(n, k):\n    dp = [0] * (k + 1)\n\n    # nC0 is 1\n    dp[0] = 1\n\n    for i in range(1, n + 1):\n      \n        # Compute next row of pascal triangle using\n        # the previous row\n        for j in range(min(i, k), 0, -1):\n            dp[j] = dp[j] + dp[j - 1]\n    \n    return dp[k]\n\nn = 5\nk = 2\nprint(binomialCoeff(n, k))\n// C# program for space optimized Dynamic Programming\n// Solution of Binomial Coefficient\n\nusing System;\n\nclass GfG {\n\n    // Returns value of Binomial Coefficient C(n, k)\n    static int BinomialCoeff(int n, int k) {\n        int[] dp = new int[k + 1];\n\n        // nC0 is 1\n        dp[0] = 1;\n\n        for (int i = 1; i <= n; i++) {\n          \n            // Compute next row of pascal triangle using\n            // the previous row\n            for (int j = Math.Min(i, k); j > 0; j--)\n                dp[j] = dp[j] + dp[j - 1];\n        }\n        return dp[k];\n    }\n\n    static void Main(string[] args) {\n        int n = 5, k = 2;\n        Console.WriteLine(BinomialCoeff(n, k));\n    }\n}\n// JavaScript program for space optimized Dynamic\n// Programming Solution of Binomial Coefficient\n\nfunction binomialCoeff(n, k) {\n\n    let dp = Array(k + 1).fill(0);\n\n    // nC0 is 1\n    dp[0] = 1;\n\n    for (let i = 1; i <= n; i++) {\n    \n        // Compute next row of pascal triangle using\n        // the previous row\n        for (let j = Math.min(i, k); j > 0; j--) {\n            dp[j] = dp[j] + dp[j - 1];\n        }\n    }\n\n    return dp[k];\n}\n\nlet n = 5, k = 2;\nconsole.log(binomialCoeff(n, k));\n10\n",
        "complexity": {
            "time": "",
            "space": ""
        },
        "tags": [
            "Mathematical Algorithms"
        ],
        "url": "https://www.geeksforgeeks.org/dynamic-programming-set-9-binomial-coefficient/"
    },
    {
        "title": "Program for nth Catalan Number",
        "description": "Catalan numbers are defined as a mathematical sequence that consists of positive integers, which can be used to find the number of possibilities of various combinations.  The nth term in the sequence denoted Cn, is found in the following formula: [Tex]\\frac{(2n)!}{((n + 1)! n!)}              [/Tex] The first few Catalan numbers for n = 0, 1, 2, 3, 4, 5… are: 1, 1, 2, 5, 14, 42, 132, 429, 1430, 4862, …  so on. Catalan numbers occur in many interesting counting problems like the following. Refer to this for more applications. Input: n = 6Output: 132Explanation: C(6)=C(0)C(5)+C(1)C(4)+C(2)C(3)+C(3)C(2)+C(4)C(1)+C(5)C(0)=132 Input: n = 8Output: 1430Explanation: C(8)=C(0)C(7)+C(1)C(6)+C(2)C(5)+C(3)C(4)+C(4)C(3)+C(5)C(2)+C(6)C(1)+C(7)C(0)=1430 Input: n = 5Output: 42Explanation: C(5)=C(0)C(4)+C(1)C(3)+C(2)C(2)+C(3)C(1)+C(4)C(0)=42 Catalan numbers satisfy the following recursive formula: [Tex]C_0=C_1=1 \\ and \\ C_{n}=\\sum_{i=0}^{n-1}C_iC_{n-i-1} \\ for \\ n\\geq 2           [/Tex] Step-by-step approach: Time Complexity: O(2n) [Tex](T(n)=\\sum_{i=0}^{n-1}T(i)*T(n-i-1) \\ for \\ n\\geq 1)[/Tex]Auxiliary Space: O(n) We can observe that the above recursive implementation does a lot of repeated work. Since there are overlapping subproblems, we can use dynamic programming for this. Step-by-step approach: Time Complexity: O(n2)Auxiliary Space: O(n) We can also use the below formula to find nth Catalan number in O(n) time. [Tex]C_n=\\frac{1}{n+1}\\binom{2n}{n}                                        [/Tex] Below are the steps for calculating nCr. Below are steps to calculate Catalan numbers using the formula: 2nCn/(n+1) Time Complexity: O(n).Auxiliary Space: O(1) We can also use the below formulas to find nth Catalan number in O(n) time. We already know how to calculate the nth Catalan Number using the below formula, This formula can be further simplified to express the nth Catalan Number in the terms of (n-1)th Catalan Number,  Below are steps to calculate Catalan numbers using the above formula: Time Complexity: O(n)Auxiliary Space: O(1), since no extra space has been taken.   ",
        "code": "// C++ program to find nth catalan number\n\n#include <iostream>\nusing namespace std;\n\nint findCatalan(int n) {\n    \n    // Base case\n    if (n <= 1)\n        return 1;\n\n    // catalan(n) is sum of\n    // catalan(i)*catalan(n-i-1)\n    int res = 0;\n    for (int i = 0; i < n; i++)\n        res += findCatalan(i) * findCatalan(n - i - 1);\n\n    return res;\n}\n\nint main() {\n    int n = 6;\n    int res = findCatalan(n);\n    cout << res;\n    return 0;\n}\n// Java program to find nth catalan number\n\nclass GfG {\n \n    static int findCatalan(int n) {\n      \n        // Base case\n        if (n <= 1) {\n            return 1;\n        }\n\n        // catalan(n) is the sum of catalan(i) *\n        // catalan(n-i-1)\n        int res = 0;\n        for (int i = 0; i < n; i++) {\n            res += findCatalan(i) * findCatalan(n - i - 1);\n        }\n\n        return res;\n    }\n\n    public static void main(String[] args) {\n        int n = 6;\n        int res = findCatalan(n);\n         System.out.println(res);\n    }\n}\n# Python program to find nth catalan number\n \ndef findCatalan(n):\n  \n    # Base case\n    if n <= 1:\n        return 1\n\n    # catalan(n) is sum of catalan(i) * catalan(n-i-1)\n    res = 0\n    for i in range(n):\n        res += findCatalan(i) * findCatalan(n - i - 1)\n\n    return res\n\n\nn = 6\nres = findCatalan(n)\nprint(res)\n// C# program to find nth catalan number\n\nusing System;\n\nclass GfG {\n\n    static int findCatalan(int n) {\n      \n        // Base case\n        if (n <= 1)\n            return 1;\n\n        // catalan(n) is the sum of catalan(i) *\n        // catalan(n-i-1)\n        int res = 0;\n        for (int i = 0; i < n; i++) {\n            res += findCatalan(i) * findCatalan(n - i - 1);\n        }\n\n        return res;\n    }\n\n    static void Main(string[] args) {\n        int n = 6;\n        int res = findCatalan(n);\n        Console.WriteLine(res);\n    }\n}\n// JavaScript program to find nth catalan number\n\nfunction findCatalan(n) {\n\n    // Base case\n    if (n <= 1) {\n        return 1;\n    }\n\n    // catalan(n) is the sum of catalan(i) * catalan(n-i-1)\n    let res = 0;\n    for (let i = 0; i < n; i++) {\n        res += findCatalan(i) * findCatalan(n - i - 1);\n    }\n\n    return res;\n}\n\nlet n = 6;\nlet res = findCatalan(n);\nconsole.log(res);\n1 1 2 5 14 42 132 429 1430 4862\n// C++ program to find nth catalan number\n\n#include <iostream>\nusing namespace std;\n\nint findCatalan(int n) {\n  \n    // Table to store results of subproblems\n    int catalan[n + 1];\n\n    // Initialize first two values in table\n    catalan[0] = catalan[1] = 1;\n\n    // Fill entries in catalan[] using recursive formula\n    for (int i = 2; i <= n; i++) {\n        catalan[i] = 0;\n        for (int j = 0; j < i; j++)\n            catalan[i] += catalan[j] * catalan[i - j - 1];\n    }\n\n    // Return last entry\n    return catalan[n];\n}\n\nint main() {\n    int n = 6;\n    int res = findCatalan(n);\n    cout << res;\n    return 0;\n}\n// Java program to find nth catalan number\n\nclass GfG {\n\n    static int findCatalan(int n) {\n      \n        // Table to store results of subproblems\n        int[] catalan = new int[n + 1];\n\n        // Initialize first two values in the table\n        catalan[0] = catalan[1] = 1;\n\n        // Fill entries in catalan[] using the recursive\n        // formula\n        for (int i = 2; i <= n; i++) {\n            catalan[i] = 0;\n            for (int j = 0; j < i; j++) {\n                catalan[i]\n                    += catalan[j] * catalan[i - j - 1];\n            }\n        }\n\n        // Return the last entry\n        return catalan[n];\n    }\n\n    public static void main(String[] args) {\n        int n = 6;\n        int res = findCatalan(n);\n         System.out.println(res);\n    }\n}\n# Python program to find nth catalan number\n \ndef findCatalan(n):\n  \n    # Table to store results of subproblems\n    catalan = [0] * (n + 1)\n\n    # Initialize first two values in the table\n    catalan[0] = catalan[1] = 1\n\n    # Fill entries in catalan[] using the recursive formula\n    for i in range(2, n + 1):\n        catalan[i] = 0\n        for j in range(i):\n            catalan[i] += catalan[j] * catalan[i - j - 1]\n\n    # Return the last entry\n    return catalan[n]\n\n\nn = 6\nres = findCatalan(n)\nprint(res)\n// C# program to find nth catalan number\n\nusing System;\n\nclass GfG {\n\n    static int findCatalan(int n) {\n      \n        // Table to store results of subproblems\n        int[] catalan = new int[n + 1];\n\n        // Initialize first two values in the table\n        catalan[0] = catalan[1] = 1;\n\n        // Fill entries in catalan[] using the recursive\n        // formula\n        for (int i = 2; i <= n; i++) {\n            catalan[i] = 0;\n            for (int j = 0; j < i; j++) {\n                catalan[i]\n                    += catalan[j] * catalan[i - j - 1];\n            }\n        }\n\n        // Return the last entry\n        return catalan[n];\n    }\n\n    static void Main() {\n        int n = 6;\n        int res = findCatalan(n);\n        Console.WriteLine(res);\n    }\n}\n// JavaScript program to find nth catalan number\n\nfunction findCatalan(n) {\n\n    // Table to store results of subproblems\n    let catalan = new Array(n + 1).fill(0);\n\n    // Initialize first two values in the table\n    catalan[0] = catalan[1] = 1;\n\n    // Fill entries in catalan[] using the recursive formula\n    for (let i = 2; i <= n; i++) {\n        catalan[i] = 0;\n        for (let j = 0; j < i; j++) {\n            catalan[i] += catalan[j] * catalan[i - j - 1];\n        }\n    }\n\n    // Return the last entry\n    return catalan[n];\n}\n\n \nlet n = 6;\n let res = findCatalan(n);\n console.log(res);\n1 1 2 5 14 42 132 429 1430 4862\n// C++ program for nth Catalan Number\n\n#include <iostream>\nusing namespace std;\n\n// Returns value of Binomial Coefficient C(n, k)\nint binomialCoeff(int n, int k) {\n    int res = 1;\n\n    // Since C(n, k) = C(n, n-k)\n    if (k > n - k)\n        k = n - k;\n\n    // Calculate value of [n*(n-1)*---*(n-k+1)] /\n    // [k*(k-1)*---*1]\n    for (int i = 0; i < k; ++i)\n    {\n        res *= (n - i);\n        res /= (i + 1);\n    }\n\n    return res;\n}\n\n// A Binomial coefficient based function to find nth catalan\n// number in O(n) time\nint findCatalan(int n) {\n  \n    // Calculate value of 2nCn\n    int c = binomialCoeff(2 * n, n);\n\n    // return 2nCn/(n+1)\n    return c / (n + 1);\n}\n\nint main() {\n    int n = 6;\n    int res = findCatalan(n);\n    cout << res;\n    return 0;\n}\n// Java program for nth Catalan Number\n\nclass GfG {\n\n    // Returns value of Binomial Coefficient C(n, k)\n    static int binomialCoeff(int n, int k) {\n        int res = 1;\n\n        // Since C(n, k) = C(n, n-k)\n        if (k > n - k) {\n            k = n - k;\n        }\n\n        // Calculate value of [n*(n-1)*...*(n-k+1)] /\n        // [k*(k-1)*...*1]\n        for (int i = 0; i < k; ++i) {\n            res *= (n - i);\n            res /= (i + 1);\n        }\n\n        return res;\n    }\n\n    // A Binomial coefficient based function to find nth\n    // catalan number in O(n) time\n      static int findCatalan(int n) {\n        // Calculate value of 2nCn\n        int c = binomialCoeff(2 * n, n);\n\n        // return 2nCn / (n+1)\n        return c / (n + 1);\n    }\n\n    public static void main(String[] args) {\n        int n = 6;\n        int res = findCatalan(n);\n         System.out.println(res);\n    }\n}\n# Python program for nth Catalan Number\n\n# Returns value of Binomial Coefficient C(n, k)\ndef binomialCoeff(n, k):\n    res = 1\n\n    # Since C(n, k) = C(n, n-k)\n    if k > n - k:\n        k = n - k\n\n    # Calculate value of [n*(n-1)*...*(n-k+1)] / [k*(k-1)*...*1]\n    for i in range(k):\n        res *= (n - i)\n        res //= (i + 1)\n\n    return res\n\n# A Binomial coefficient based function to find nth \n# catalan number in O(n) time\n\n\ndef findCatalan(n):\n  \n    # Calculate value of 2nCn\n    c = binomialCoeff(2 * n, n)\n\n    # return 2nCn / (n+1)\n    return c // (n + 1)\n\n \nn = 6\nres = findCatalan(n)\nprint(res)\n// C# program for nth Catalan Number\n\nusing System;\n\nclass GfG {\n  \n    // Returns value of Binomial Coefficient C(n, k)\n      static int binomialCoeff(int n, int k) {\n        int res = 1;\n\n        // Since C(n, k) = C(n, n-k)\n        if (k > n - k) {\n            k = n - k;\n        }\n\n        // Calculate value of [n*(n-1)*...*(n-k+1)] / [k*(k-1)*...*1]\n        for (int i = 0; i < k; ++i) {\n            res *= (n - i);\n            res /= (i + 1);\n        }\n\n        return res;\n    }\n\n    // A Binomial coefficient based function to find nth \n  // catalan number in O(n) time\n      static int findCatalan(int n) {\n        \n        // Calculate value of 2nCn\n        int c = binomialCoeff(2 * n, n);\n\n        // return 2nCn / (n+1)\n        return c / (n + 1);\n    }\n\n    static void Main() {\n        int n = 6;\n        int res = findCatalan(n);\n         Console.WriteLine(res);\n    }\n}\n// JavaScript program for nth Catalan Number\n\n// Function to calculate the Binomial Coefficient C(n, k)\nfunction binomialCoeff(n, k) {\n    let result = 1;\n\n    // Since C(n, k) = C(n, n-k)\n    if (k > n - k) {\n        k = n - k;\n    }\n\n    // Calculate value of [n*(n-1)*---*(n-k+1)] /\n    // [k*(k-1)*---*1]\n    for (let i = 0; i < k; i++) {\n        result *= (n - i);\n        result /= (i + 1);\n    }\n\n    return result;\n}\n\n// A function to find the nth Catalan number using the\n// Binomial Coefficient\nfunction findCatalan(n) {\n\n    // Calculate value of 2nCn\n    const c = binomialCoeff(2 * n, n);\n\n    // Return 2nCn / (n+1)\n    return Math.floor(c\n                      / (n + 1));  \n                                   \n}\n \nconst n = 6;\nconst res = findCatalan(n);\nconsole.log(res);\n1 1 2 5 14 42 132 429 1430 4862\n// C++ program for nth Catalan Number\n\n#include <iostream>\nusing namespace std;\n\nint findCatalan(int n) {\n    int res = 1;\n\n    // Use the iterative approach to \n  // calculate the nth Catalan number\n    for (int i = 2; i <= n; i++) {\n\n        res = ((res * (4 * i - 2)) / (i + 1));\n    }\n\n    return res;\n}\n\nint main() {\n    int n = 6;\n    int res = findCatalan(n);\n    cout << res;\n    return 0;\n}\n// Java program for nth Catalan Number \n\nclass GfG {\n\n      static int findCatalan(int n) {\n        int res = 1;\n\n        // Use the iterative approach to  \n        // calculate the nth Catalan number\n        for (int i = 2; i <= n; i++) {\n            res = (res * (4 * i - 2)) / (i + 1);\n        }\n\n        return res;\n    }\n\n    public static void main(String[] args) {\n        int n = 6;\n        int res = findCatalan(n);\n        System.out.println(res);\n    }\n}\n# Python program for nth Catalan Number\n\ndef findCatalan(n):\n    result = 1\n\n    # Use the iterative approach to calculate \n    # the nth Catalan number\n    for i in range(2, n + 1):\n        result = (result * (4 * i - 2)) // (i + 1)\n\n    return result\n\n \nn = 6\nres = findCatalan(n)\nprint(res)\n// C# program for nth Catalan Number\n\nusing System;\n\nclass GfG {\n    static int findCatalan(int n) {\n        int result = 1;\n\n        // Use the iterative approach to calculate the nth\n        // Catalan number\n        for (int i = 2; i <= n; i++) {\n            result = (result * (4 * i - 2)) / (i + 1);\n        }\n\n        return result;\n    }\n\n    static void Main(string[] args) {\n        int n = 6;\n        int res = findCatalan(n);\n        Console.WriteLine(res);\n    }\n}\n// JavaScript program for nth Catalan Number\n\nfunction findCatalan(n) {\n    let result = 1;\n\n    // Use the iterative approach to calculate the nth\n    // Catalan number\n    for (let i = 2; i <= n; i++) {\n        result = (result * (4 * i - 2)) / (i + 1);\n    }\n\n    return result;\n}\n\nconst n = 6;\nconst res = findCatalan(n);\nconsole.log(res);\n132\n",
        "complexity": {
            "time": "Time Complexity: O(n)Auxiliary Space: O(1), since no extra space has been taken.",
            "space": ""
        },
        "tags": [
            "Mathematical Algorithms"
        ],
        "url": "https://www.geeksforgeeks.org/program-nth-catalan-number"
    },
    {
        "title": "Sieve of Eratosthenes",
        "description": "Given a number n, print all primes smaller than or equal to n. It is also given that n is a small number. Examples: Input: n = 10Output: 2 3 5 7Explanation: The prime numbers up to 10 obtained by Sieve of Eratosthenes are 2 3 5 7 . Input: n = 20Output: 2 3 5 7 11 13 17 19Explanation: The prime numbers up to 20 obtained by Sieve of Eratosthenes are 2 3 5 7 11 13 17 19 . Input: n = 30Output: 2 3 5 7 11 13 17 19 23 29Explanation: The prime numbers up to 30 obtained by Sieve of Eratosthenes are 2 3 5 7 11 13 17 19 23 29 . A Naive Approach is to one by one do prime check for all numbers from 1 to n The Sieve of Eratosthenes works by iteratively marking the multiples of each prime starting from 2, marking them as non-prime, and continuing this process up to sqrt(n), leaving only the prime numbers unmarked. The sieve of Eratosthenes is one of the most efficient ways to find all prime numbers smaller than n when n is smaller than 10 million or so. Time Complexity: O(N*log(log(N))) : The time complexity of the Sieve of Eratosthenes is O(nlog⁡log⁡n)O(n \\log \\log n)O(nloglogn) because for each prime ppp, it marks its multiples up to nnn, and the marking process grows logarithmically. Auxiliary Space: O(N) : Because an array of n size is used to keep track of the primes. Related articles  ",
        "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nvoid SieveOfEratosthenes(int n)\n{\n    // Create a boolean array \"prime[0..n]\" and initialize\n    // all entries it as true. A value in prime[i] will\n    // finally be false if i is Not a prime, else true.\n    vector<bool> prime(n + 1, true);\n\n    for (int p = 2; p * p <= n; p++) {\n\n\n        if (prime[p] == true) {\n            \n            // Update all multiples of p greater than or\n            // equal to the square of it numbers which are\n            // multiple of p and are less than p^2 are\n            // already been marked.\n            for (int i = p * p; i <= n; i += p)\n                prime[i] = false;\n        }\n    }\n\n    // Print all prime numbers\n    for (int p = 2; p <= n; p++)\n        if (prime[p])\n            cout << p << \" \";\n}\n\n// Driver Code\nint main()\n{\n    int n = 30;\n    SieveOfEratosthenes(n);\n    return 0;\n}\n#include <stdio.h>\n#include <stdbool.h>\n#include <string.h>\n\nvoid SieveOfEratosthenes(int n)\n{\n  \n    // Create a boolean array \"prime[0..n]\" and initialize\n    // all entries it as true. A value in prime[i] will\n    // finally be false if i is Not a prime, else true.\n    bool prime[n + 1];\n    memset(prime, true, sizeof(prime));\n\n    for (int p = 2; p * p <= n; p++) {\n        // If prime[p] is not changed, then it is a prime\n        if (prime[p] == true) {\n            // Update all multiples of p greater than or\n            // equal to the square of it numbers which are\n            // multiple of p and are less than p^2 are\n            // already been marked.\n            for (int i = p * p; i <= n; i += p)\n                prime[i] = false;\n        }\n    }\n    for (int p = 2; p <= n; p++)\n        if (prime[p])\n            printf(\"%d \",p);\n}\n\n\nint main()\n{\n    int n = 30;\n    SieveOfEratosthenes(n);\n    return 0;\n}\nclass SieveOfEratosthenes {\n    void sieveOfEratosthenes(int n)\n    {\n        // Create a boolean array \"prime[0..n]\" and\n        // initialize all entries it as true. A value in\n        // prime[i] will finally be false if i is Not a\n        // prime, else true.\n        boolean prime[] = new boolean[n + 1];\n        for (int i = 0; i <= n; i++)\n            prime[i] = true;\n\n        for (int p = 2; p * p <= n; p++) {\n            // If prime[p] is not changed, then it is a\n            // prime\n            if (prime[p] == true) {\n                // Update all multiples of p greater than or\n                // equal to the square of it numbers which\n                // are multiple of p and are less than p^2\n                // are already been marked.\n                for (int i = p * p; i <= n; i += p)\n                    prime[i] = false;\n            }\n        }\n\n        // Print all prime numbers\n        for (int i = 2; i <= n; i++) {\n            if (prime[i] == true)\n                System.out.print(i + \" \");\n        }\n    }\n\n\n    public static void main(String args[])\n    {\n        int n = 30;\n        System.out.print(\"Following are the prime numbers \");\n        System.out.println(\"smaller than or equal to \" + n);\n        SieveOfEratosthenes g = new SieveOfEratosthenes();\n        g.sieveOfEratosthenes(n);\n    }\n}\ndef SieveOfEratosthenes(n):\n\n    # Create a boolean array\n    # \"prime[0..n]\" and initialize\n    #  all entries it as true.\n    # A value in prime[i] will\n    # finally be false if i is\n    # Not a prime, else true.\n    prime = [True for i in range(n+1)]\n    p = 2\n    while (p * p <= n):\n\n        # If prime[p] is not\n        # changed, then it is a prime\n        if (prime[p] == True):\n\n            # Update all multiples of p\n            for i in range(p * p, n+1, p):\n                prime[i] = False\n        p += 1\n\n    # Print all prime numbers\n    for p in range(2, n+1):\n        if prime[p]:\n            print(p)\n\n\nif __name__ == '__main__':\n    n = 30\n    SieveOfEratosthenes(n)\nusing System;\n\nnamespace prime {\npublic class GFG {\n\n    public static void SieveOfEratosthenes(int n)\n    {\n\n        // Create a boolean array \n        // \"prime[0..n]\" and\n        // initialize all entries\n        // it as true. A value in\n        // prime[i] will finally be \n        // false if i is Not a\n        // prime, else true.\n\n        bool[] prime = new bool[n + 1];\n\n        for (int i = 0; i <= n; i++)\n            prime[i] = true;\n\n        for (int p = 2; p * p <= n; p++) \n        {\n            // If prime[p] is not changed,\n            // then it is a prime\n            if (prime[p] == true)\n            {\n                // Update all multiples of p\n                for (int i = p * p; i <= n; i += p)\n                    prime[i] = false;\n            }\n        }\n\n        // Print all prime numbers\n        for (int i = 2; i <= n; i++)\n        {\n            if (prime[i] == true)\n                Console.Write(i + \" \");\n        }\n    }\n\n\n    public static void Main()\n    {\n        int n = 30;\n        SieveOfEratosthenes(n);\n    }\n}\n}\nfunction sieveOfEratosthenes(n)\n{\n    // Create a boolean array \n    // \"prime[0..n]\" and\n    // initialize all entries \n    // it as true. A value in\n    // prime[i] will finally be \n    // false if i is Not a\n    // prime, else true.\n    prime = Array.from({length: n+1}, (_, i) => true);\n\n    for (p = 2; p * p <= n; p++) \n    {\n        // If prime[p] is not changed, then it is a\n        // prime\n        if (prime[p] == true) \n        {\n            // Update all multiples of p\n            for (i = p * p; i <= n; i += p)\n                prime[i] = false;\n        }\n    }\n\n    // Print all prime numbers\n    for (i = 2; i <= n; i++)\n    {\n        if (prime[i] == true)\n            process.stdout.write(i + \" \");\n    }\n}\n\nvar n = 30;\nsieveOfEratosthenes(n);\n2 3 5 7 11 13 17 19 23 29\n",
        "complexity": {
            "time": "Time Complexity: O(N*log(log(N))) : The time complexity of the Sieve of Eratosthenes is O(nlog⁡log⁡n)O(n \\log \\log n)O(nloglogn) because for each prime ppp, it marks its multiples up to nnn, and the marking process grows logarithmically. Auxiliary Space: O(N) : Because an array of n size is used to keep track of the primes.",
            "space": ""
        },
        "tags": [
            "Mathematical Algorithms"
        ],
        "url": "https://www.geeksforgeeks.org/sieve-of-eratosthenes/"
    },
    {
        "title": "Euler’s Totient Function",
        "description": "Euler’s Totient function Φ(n) for an input n is the count of numbers in {1, 2, 3, …, n-1} that are relatively prime to n, i.e., the numbers whose GCD (Greatest Common Divisor) with n is 1. If n is a positive integer and its prime factorization is; [Tex]n = p_1^{e_1} \\cdot p_2^{e_2} \\cdot \\ldots \\cdot p_k^{e_k}[/Tex] Where [Tex]p_1, p_2, \\ldots, p_k[/Tex]​ are distinct prime factors of n, then: [Tex]\\phi(n) = n \\cdot \\left(1 – \\frac{1}{p_1}\\right) \\cdot \\left(1 – \\frac{1}{p_2}\\right) \\cdot \\ldots \\cdot \\left(1 – \\frac{1}{p_k}\\right)[/Tex] Some common properties of ϕ(n) are: Φ(1) = 1  gcd(1, 1) is 1Φ(2) = 1gcd(1, 2) is 1, but gcd(2, 2) is 2.Φ(3) = 2gcd(1, 3) is 1 and gcd(2, 3) is 1Φ(4) = 2gcd(1, 4) is 1 and gcd(3, 4) is 1Φ(5) = 4gcd(1, 5) is 1, gcd(2, 5) is 1, gcd(3, 5) is 1 and gcd(4, 5) is 1Φ(6) = 2gcd(1, 6) is 1 and gcd(5, 6) is 1, A simple solution is to iterate through all numbers from 1 to n-1 and count numbers with gcd with n as 1. Below is the implementation of the simple method to compute Euler’s Totient function for an input integer n. Time Complexity: O(n log n)Auxiliary Space: O(log n) Below is a Better Solution. The idea is based on Euler’s product formula which states that the value of totient functions is below the product overall prime factors p of n.  The formula basically says that the value of Φ(n) is equal to n multiplied by-product of (1 – 1/p) for all prime factors p of n. For example value of Φ(6) = 6 * (1-1/2) * (1 – 1/3) = 2. 1) Initialize : result = n2) Run a loop from ‘p’ = 2 to sqrt(n), do following for every ‘p’.     a) If p divides n, then            Set: result = result  * (1.0 – (1.0 / (float) p));           Divide all occurrences of p in n.3) Return result Time Complexity: O(√n)Auxiliary Space: O(1) We can avoid floating-point calculations in the above method. The idea is to count all prime factors and their multiples and subtract this count from n to get the totient function value (Prime factors and multiples of prime factors won’t have gcd as 1) 1) Initialize result as n2) Consider every number ‘p’ (where ‘p’ varies from 2 to Φ(n)).    If p divides n, then do following   a) Subtract all multiples of p from 1 to n [all multiples of p      will have gcd more than 1 (at least p) with n]   b) Update n by repeatedly dividing it by p.3) If the reduced n is more than 1, then remove all multiples   of n from result. Time Complexity: O(√n)Auxiliary Space: O(1) Let us take an example to understand the above algorithm. n = 10. Initialize: result = 102 is a prime factor, so n = n/i = 5, result = 53 is not a prime factor.The for loop stops after 3 as 4*4 is not less than or equalto 10.After for loop, result = 5, n = 5Since n > 1, result = result – result/n = 4 1) For a prime number p, [Tex]\\phi(p) = p – 1[/Tex] Proof : [Tex]\\phi(p) =  p - 1[/Tex] , where p is any prime numberWe know that [Tex]gcd(p, k) = 1[/Tex] where k is any random number and [Tex]k \\neq p[/Tex][Tex]\\\\[/Tex]Total number from 1 to p = p Number for which [Tex]gcd(p, k) = 1[/Tex] is [Tex]1[/Tex], i.e the number p itself, so subtracting 1 from p [Tex]\\phi(p) = p - 1[/Tex] Examples : [Tex]\\phi(5) = 5 - 1 = 4[/Tex][Tex]\\\\[/Tex][Tex]\\phi(13) = 13 - 1 = 12[/Tex][Tex]\\\\[/Tex][Tex]\\phi(29) = 29 - 1 = 28[/Tex] 2) For two prime numbers a and b[Tex] \\phi(a \\cdot b) = \\phi(a) \\cdot \\phi(b) = (a – 1) \\cdot (b – 1)           [/Tex], used in RSA Algorithm Proof : [Tex]\\phi(a\\cdot b) = \\phi(a) \\cdot  \\phi(b)[/Tex], where a and b are prime numbers[Tex]\\phi(a) = a - 1[/Tex] , [Tex]\\phi(b) = b - 1[/Tex][Tex]\\\\[/Tex]Total number from 1 to ab = ab Total multiples of a from 1 to ab = [Tex]\\frac{a \\cdot b} {a}[/Tex] = [Tex]b[/Tex]Total multiples of b from 1 to ab = [Tex]\\frac{a \\cdot b} {b}[/Tex] = [Tex]a[/Tex]Example:a = 5, b = 7, ab = 35Multiples of a = [Tex]\\frac {35} {5}[/Tex] = 7 {5, 10, 15, 20, 25, 30, 35}Multiples of b = [Tex]\\frac {35} {7}[/Tex] = 5 {7, 14, 21, 28, 35}[Tex]\\\\[/Tex]Can there be any double counting ?(watch above example carefully, try with other prime numbers also for more grasp)Ofcourse, we have counted [Tex]ab[/Tex]twice in multiples of a and multiples of b so, Total multiples =  a + b - 1 (with which [Tex]gcd \\neq 1[/Tex] with [Tex]ab[/Tex])[Tex]\\\\[/Tex][Tex]\\phi(ab) = ab - (a + b - 1)[/Tex] , removing all number with [Tex]gcd \\neq 1[/Tex] with [Tex]ab[/Tex][Tex]\\phi(ab) = a(b - 1) - (b - 1)[/Tex][Tex]\\phi(ab) = (a - 1) \\cdot (b - 1)[/Tex][Tex]\\phi(ab) = \\phi(a) \\cdot \\phi(b)[/Tex] Examples : [Tex]\\phi(5 \\cdot 7) = \\phi(5) \\cdot \\phi(7) = (5 - 1) \\cdot (7 - 1) = 24[/Tex][Tex]\\\\[/Tex][Tex]\\phi(3 \\cdot 5) = \\phi(3) \\cdot \\phi(5) = (3 - 1) \\cdot (5 - 1) = 8[/Tex][Tex]\\\\[/Tex][Tex]\\phi(3 \\cdot 7) = \\phi(3) \\cdot \\phi(7) = (3 - 1) \\cdot (7 - 1) = 12[/Tex] 3) For a prime number p, [Tex]\\phi(p ^ k) = p ^ k – p ^ {k – 1}[/Tex] Proof : [Tex]\\phi(p^k) = p ^ k - p ^{k - 1}[/Tex] , where p is a prime number[Tex]\\\\[/Tex]Total numbers from 1 to [Tex]p ^ k = p ^ k[/Tex] Total multiples of [Tex]p = \\frac {p ^ k} {p} = p ^ {k - 1}[/Tex]Removing these multiples as with them [Tex]gcd \\neq 1[/Tex][Tex]\\\\[/Tex]Example : p = 2, k = 5, [Tex]p ^ k[/Tex] = 32Multiples of 2 (as with them [Tex]gcd \\neq 1[/Tex]) = 32 / 2 = 16 {2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32}[Tex]\\\\[/Tex][Tex]\\phi(p ^ k) = p ^ k - p ^ {k - 1}[/Tex] Examples : [Tex]\\phi(2 ^ 5) = 2 ^ 5 - 2 ^ {5 - 1} = 32 - 16 = 16[/Tex][Tex]\\\\[/Tex][Tex]\\phi(5 ^ 3) = 5 ^ 3 - 5 ^ {3 - 1} = 125 - 25 = 100[/Tex][Tex]\\\\[/Tex][Tex]\\phi(3 ^ 5) = 3 ^ 5 - 3 ^ {5 - 1} = 243 - 81 = 162[/Tex]4) For two number a and b [Tex]\\phi(a \\cdot b)           [/Tex] [Tex]= \\phi(a) \\cdot \\phi(b)           [/Tex] [Tex]\\cdot \\frac {gcd(a, b)} {\\phi(gcd(a, b))}[/Tex] Special Case : gcd(a, b) = 1 [Tex]\\phi(a \\cdot b) = \\phi(a) \\cdot \\phi(b) \\cdot \\frac {1} {\\phi(1)} = \\phi(a) \\cdot \\phi(b)[/Tex] Examples : Special Case : [Tex]gcd(a, b) = 1[/Tex], [Tex]\\phi(a \\cdot b) = \\phi(a) \\cdot \\phi(b)[/Tex][Tex]\\phi(2 \\cdot 9) = \\phi(2) \\cdot \\phi(9) = 1 \\cdot 6 = 6[/Tex][Tex]\\\\[/Tex][Tex]\\phi(8 \\cdot 9) = \\phi(8) \\cdot \\phi(9) = 4 \\cdot 6 = 24[/Tex][Tex]\\\\[/Tex][Tex]\\phi(5 \\cdot 6) = \\phi(5) \\cdot \\phi(6) = 4 \\cdot 2 = 8[/Tex][Tex]\\\\[/Tex][Tex]\\\\[/Tex]Normal Case : [Tex]gcd(a, b) \\neq 1[/Tex], [Tex]\\phi(a \\cdot b) = \\phi(a) \\cdot \\phi(b) \\cdot \\frac {gcd(a, b)} {\\phi(gcd(a, b))}[/Tex][Tex]\\\\[/Tex][Tex]\\phi(4 \\cdot 6) = \\phi(4) \\cdot \\phi(6) \\cdot \\frac {gcd(4, 6)} {\\phi(gcd(4, 6))}[/Tex][Tex]= 2 \\cdot 2 \\cdot \\frac{2}{1}[/Tex][Tex]= 2 \\cdot 2 \\cdot 2 = 8[/Tex][Tex]\\\\[/Tex][Tex]\\phi(4 \\cdot 8) = \\phi(4) \\cdot \\phi(8) \\cdot \\frac {gcd(4, 8)} {\\phi(gcd(4, 8))} = 2 \\cdot 4 \\cdot \\frac{4}{2} = 2 \\cdot 4 \\cdot 2 = 16[/Tex][Tex]\\\\[/Tex][Tex]\\phi(6 \\cdot 8) = \\phi(6) \\cdot \\phi(8) \\cdot \\frac {gcd(6, 8)} {\\phi(gcd(6, 8))} = 2 \\cdot 4 \\cdot \\frac{2}{1} = 2 \\cdot 4 \\cdot 2 = 16[/Tex] 5) Sum of values of totient functions of all divisors of n is equal to n.  Examples : n = 6 \nfactors = {1, 2, 3, 6} \nn = [Tex]\\phi(1) + \\phi(2) + \\phi(3) + \\phi(6)[/Tex] = 1 + 1 + 2 + 2 = 6[Tex]\\\\[/Tex]n = 8factors = {1, 2, 4, 8}n = [Tex]\\phi(1) + \\phi(2) + \\phi(4) + \\phi(8)[/Tex] = 1 + 1 + 2 + 4 = 8[Tex]\\\\[/Tex]n = 10factors = {1, 2, 5, 10}n = [Tex]\\phi(1) + \\phi(2) + \\phi(5) + \\phi(10)[/Tex] = 1 + 1 + 4 + 4 = 10 6) The most famous and important feature is expressed in Euler’s theorem : The theorem states that if n and a are coprime\n(or relatively prime) positive integers, then\n\naΦ(n) Φ 1 (mod n) The RSA cryptosystem is based on this theorem:In the particular case when m is prime say p, Euler’s theorem turns into the so-called Fermat’s little theorem : ap-1 Φ 1 (mod p) 7)Number of generators of a finite cyclic group under modulo n addition is Φ(n). Related Article: Euler’s Totient function for all numbers smaller than or equal to n Optimized Euler Totient Function for Multiple Evaluations A  ",
        "code": "// A simple C++ program to calculate\n// Euler's Totient Function \n#include <iostream>\nusing namespace std; \n\n// Function to return gcd of a and b \nint gcd(int a, int b) \n{ \n    if (a == 0) \n        return b; \n    return gcd(b % a, a); \n} \n\n// A simple method to evaluate Euler Totient Function \nint phi(unsigned int n) \n{ \n    unsigned int result = 1; \n    for (int i = 2; i < n; i++) \n        if (gcd(i, n) == 1) \n            result++; \n    return result; \n} \n\n// Driver program to test above function \nint main() \n{ \n    int n; \n    for (n = 1; n <= 10; n++) \n        cout << \"phi(\"<<n<<\") = \" << phi(n) << endl; \n    return 0; \n}\n// A simple C program to calculate Euler's Totient Function\n#include <stdio.h>\n\n// Function to return gcd of a and b\nint gcd(int a, int b)\n{\n    if (a == 0)\n        return b;\n    return gcd(b % a, a);\n}\n\n// A simple method to evaluate Euler Totient Function\nint phi(unsigned int n)\n{\n    unsigned int result = 1;\n    for (int i = 2; i < n; i++)\n        if (gcd(i, n) == 1)\n            result++;\n    return result;\n}\n\n// Driver program to test above function\nint main()\n{\n    int n;\n    for (n = 1; n <= 10; n++)\n        printf(\"phi(%d) = %d\\n\", n, phi(n));\n    return 0;\n}\n// A simple java program to calculate\n// Euler's Totient Function\nimport java.io.*;\n\nclass GFG {\n\n    // Function to return GCD of a and b\n    static int gcd(int a, int b)\n    {\n        if (a == 0)\n            return b;\n        return gcd(b % a, a);\n    }\n\n    // A simple method to evaluate\n    // Euler Totient Function\n    static int phi(int n)\n    {\n        int result = 1;\n        for (int i = 2; i < n; i++)\n            if (gcd(i, n) == 1)\n                result++;\n        return result;\n    }\n\n    // Driver code\n    public static void main(String[] args)\n    {\n        int n;\n\n        for (n = 1; n <= 10; n++)\n            System.out.println(\"phi(\" + n + \") = \" + phi(n));\n    }\n}\n# A simple Python3 program \n# to calculate Euler's \n# Totient Function\n\n# Function to return\n# gcd of a and b\ndef gcd(a, b):\n\n    if (a == 0):\n        return b\n    return gcd(b % a, a)\n\n# A simple method to evaluate\n# Euler Totient Function\ndef phi(n):\n\n    result = 1\n    for i in range(2, n):\n        if (gcd(i, n) == 1):\n            result+=1\n    return result\n\n# Driver Code\nfor n in range(1, 11):\n    print(\"phi(\",n,\") = \", \n           phi(n), sep = \"\")\n// A simple C# program to calculate\n// Euler's Totient Function\nusing System;\n\nclass GFG {\n\n    // Function to return GCD of a and b\n    static int gcd(int a, int b)\n    {\n        if (a == 0)\n            return b;\n        return gcd(b % a, a);\n    }\n\n    // A simple method to evaluate\n    // Euler Totient Function\n    static int phi(int n)\n    {\n        int result = 1;\n        for (int i = 2; i < n; i++)\n            if (gcd(i, n) == 1)\n                result++;\n        return result;\n    }\n\n    // Driver code\n    public static void Main()\n    {\n        for (int n = 1; n <= 10; n++)\n        Console.WriteLine(\"phi(\" + n + \") = \" + phi(n));\n    }\n}\n// Javascript program to calculate \n// Euler's Totient Function\n\n// Function to return \n// gcd of a and b\nfunction gcd(a, b)\n{\n    if (a == 0)\n        return b;\n    return gcd(b % a, a);\n}\n\n// A simple method to evaluate\n// Euler Totient Function\nfunction phi(n)\n{\n    let result = 1;\n    for (let i = 2; i < n; i++)\n        if (gcd(i, n) == 1)\n            result++;\n    return result;\n}\n\n// Driver Code\nfor (let n = 1; n <= 10; n++)\n    console.log (`phi(${n}) = ${phi(n)} <br>`);\nphi(1) = 1\nphi(2) = 1\nphi(3) = 2\nphi(4) = 2\nphi(5) = 4\nphi(6) = 2\nphi(7) = 6\nphi(8) = 4\nphi(9) = 6\nphi(10) = 4\n// C++ program to calculate Euler's \n// Totient Function using Euler's\n// product formula\n#include <bits/stdc++.h>\nusing namespace std;\n\nint phi(int n)\n{\n    \n    // Initialize result as n\n    float result = n; \n \n    // Consider all prime factors of n \n    // and for every prime factor p,\n    // multiply result with (1 - 1/p)\n    for(int p = 2; p * p <= n; ++p)\n    {\n        \n        // Check if p is a prime factor.\n        if (n % p == 0)\n        {\n            \n            // If yes, then update n and result\n            while (n % p == 0)\n                n /= p;\n                \n            result *= (1.0 - (1.0 / (float)p));\n        }\n    }\n \n    // If n has a prime factor greater than sqrt(n)\n    // (There can be at-most one such prime factor)\n    if (n > 1)\n        result -= result / n;\n  //Since in the set {1,2,....,n-1}, all numbers are relatively prime with n\n  //if n is a prime number\n \n    return (int)result;\n}\n \n// Driver code\nint main()\n{\n    int n;\n    \n    for(n = 1; n <= 10; n++)\n    {\n        cout << \"Phi\" << \"(\" \n             << n << \")\" << \" = \"\n             << phi(n) <<endl;\n    }\n    return 0;\n}\n// C program to calculate Euler's Totient Function\n// using Euler's product formula\n#include <stdio.h>\n\nint phi(int n)\n{\n    float result = n; // Initialize result as n\n\n    // Consider all prime factors of n and for every prime\n    // factor p, multiply result with (1 - 1/p)\n    for (int p = 2; p * p <= n; ++p) {\n        \n        // Check if p is a prime factor.\n        if (n % p == 0) {\n            \n            // If yes, then update n and result\n            while (n % p == 0)\n                n /= p;\n            result *= (1.0 - (1.0 / (float)p));\n        }\n    }\n\n    // If n has a prime factor greater than sqrt(n)\n    // (There can be at-most one such prime factor)\n    if (n > 1)\n        result -= result / n;\n  //Since in the set {1,2,....,n-1}, all numbers are relatively prime with n\n  //if n is a prime number\n\n    return (int)result;\n}\n\n// Driver program to test above function\nint main()\n{\n    int n;\n    for (n = 1; n <= 10; n++)\n        printf(\"phi(%d) = %d\\n\", n, phi(n));\n    return 0;\n}\n// Java program to calculate Euler's Totient\n// Function using Euler's product formula\nimport java.io.*;\n\nclass GFG {\n    static int phi(int n)\n    {\n        // Initialize result as n\n        float result = n;\n\n        // Consider all prime factors of n and for\n        // every prime factor p, multiply result\n        // with (1 - 1/p)\n        for (int p = 2; p * p <= n; ++p) {\n            // Check if p is a prime factor.\n            if (n % p == 0) {\n                // If yes, then update n and result\n                while (n % p == 0)\n                    n /= p;\n                result *= (1.0 - (1.0 / (float)p));\n            }\n        }\n\n        // If n has a prime factor greater than sqrt(n)\n        // (There can be at-most one such prime factor)\n        if (n > 1)\n            result -= result / n;\n  //Since in the set {1,2,....,n-1}, all numbers are relatively prime with n\n  //if n is a prime number\n\n        return (int)result;\n    }\n\n    // Driver program to test above function\n    public static void main(String args[])\n    {\n        int n;\n        for (n = 1; n <= 10; n++)\n            System.out.println(\"phi(\" + n + \") = \" + phi(n));\n    }\n}\n# Python 3 program to calculate\n# Euler's Totient Function\n# using Euler's product formula\n\ndef phi(n) :\n\n    result = n   # Initialize result as n\n     \n    # Consider all prime factors\n    # of n and for every prime\n    # factor p, multiply result with (1 - 1 / p)\n    p = 2\n    while p * p<= n :\n\n        # Check if p is a prime factor.\n        if n % p == 0 :\n\n            # If yes, then update n and result\n            while n % p == 0 :\n                n = n // p\n            result = result * (1.0 - (1.0 / float(p)))\n        p = p + 1\n        \n        \n    # If n has a prime factor\n    # greater than sqrt(n)\n    # (There can be at-most one\n    # such prime factor)\n    if n > 1 :\n        result -= result // n\n  #Since in the set {1,2,....,n-1}, all numbers are relatively prime with n\n  #if n is a prime number\n \n    return int(result)\n    \n    \n# Driver program to test above function\nfor n in range(1, 11) :\n    print(\"phi(\", n, \") = \", phi(n))\n// C# program to calculate Euler's Totient\n// Function using Euler's product formula\nusing System;\n\nclass GFG {\n    \n    static int phi(int n)\n    {\n        \n        // Initialize result as n\n        float result = n;\n\n        // Consider all prime factors\n        // of n and for every prime \n        // factor p, multiply result\n        // with (1 - 1 / p)\n        for (int p = 2; p * p <= n; ++p) \n        {\n            \n            // Check if p is a prime factor.\n            if (n % p == 0) \n            {\n                \n                // If yes, then update\n                // n and result\n                while (n % p == 0)\n                    n /= p;\n                result *= (float)(1.0 - (1.0 / (float)p));\n            }\n        }\n\n        // If n has a prime factor \n        // greater than sqrt(n)\n        // (There can be at-most \n        // one such prime factor)\n        if (n > 1)\n            result -= result / n;\n  //Since in the set {1,2,....,n-1}, all numbers are relatively prime with n\n  //if n is a prime number\n\n        return (int)result;\n    }\n\n    // Driver Code\n    public static void Main()\n    {\n        int n;\n        for (n = 1; n <= 10; n++)\n            Console.WriteLine(\"phi(\" + n + \") = \" + phi(n));\n    }\n}\n// Javascript program to calculate \n// Euler's Totient Function \n// using Euler's product formula\nfunction phi(n)\n{\n    // Initialize result as n\n    let result = n; \n\n    // Consider all prime factors\n    // of n and for every prime\n    // factor p, multiply result \n    // with (1 - 1/p)\n    for (let p = 2; p * p <= n; ++p) \n    {\n        \n        // Check if p is\n        // a prime factor.\n        if (n % p == 0) \n        {\n            \n            // If yes, then update\n            // n and result\n            while (n % p == 0)\n                n /= p;\n            result *= (1.0 - (1.0 / p));\n        }\n    }\n\n    // If n has a prime factor greater \n    // than sqrt(n) (There can be at-most\n    // one such prime factor)\n    if (n > 1)\n        result -= result / n;\n  //Since in the set {1,2,....,n-1}, all numbers are relatively prime with n\n  //if n is a prime number\n\n    return parseInt(result);\n}\n\n// Driver Code\nfor (let n = 1; n <= 10; n++)\n console.log(`phi(${n}) = ${phi(n)} <br>`);\n<&Phi;php\n// PHP program to calculate \n// Euler's Totient Function \n// using Euler's product formula\nfunction phi($n)\n{\n    // Initialize result as n\n    $result = $n; \n\n    // Consider all prime factors\n    // of n and for every prime\n    // factor p, multiply result \n    // with (1 - 1/p)\n    for ($p = 2; $p * $p <= $n; ++$p) \n    {\n        \n        // Check if p is\n        // a prime factor.\n        if ($n % $p == 0) \n        {\n            \n            // If yes, then update\n            // n and result\n            while ($n % $p == 0)\n                $n /= $p;\n            $result *= (1.0 - (1.0 / $p));\n        }\n    }\n\n    // If n has a prime factor greater \n    // than sqrt(n) (There can be at-most\n    // one such prime factor)\n    if ($n > 1)\n        $result -= $result / $n;\n  //Since in the set {1,2,....,n-1}, all numbers are relatively prime with n\n  //if n is a prime number\n\n    return intval($result);\n}\n\n// Driver Code\nfor ($n = 1; $n <= 10; $n++)\necho \"phi(\" .$n. \") =\" . phi($n).\"\\n\";\n    \n// This code is contributed by Sam007\n&Phi;>\nPhi(1) = 1\nPhi(2) = 1\nPhi(3) = 2\nPhi(4) = 2\nPhi(5) = 4\nPhi(6) = 2\nPhi(7) = 6\nPhi(8) = 4\nPhi(9) = 6\nPhi(10) = 4\n// C++ program to calculate Euler's\n// Totient Function\n#include <bits/stdc++.h>\nusing namespace std;\n\nint phi(int n)\n{\n    // Initialize result as n\n    int result = n; \n \n    // Consider all prime factors of n \n    // and subtract their multiples \n    // from result\n    for(int p = 2; p * p <= n; ++p)\n    {\n        \n        // Check if p is a prime factor.\n        if (n % p == 0) \n        {\n            \n            // If yes, then update n and result\n            while (n % p == 0)\n                n /= p;\n                \n            result -= result / p;\n        }\n    }\n \n    // If n has a prime factor greater than sqrt(n)\n    // (There can be at-most one such prime factor)\n    if (n > 1)\n        result -= result / n;\n        \n    return result;\n}\n \n// Driver code\nint main()\n{\n    int n;\n    for(n = 1; n <= 10; n++)\n    {\n        cout << \"Phi\" << \"(\" \n             << n << \")\" << \" = \"\n             << phi(n) << endl;\n    }\n    return 0;\n}\n// C program to calculate Euler's Totient Function\n#include <stdio.h>\n\nint phi(int n)\n{\n    int result = n; // Initialize result as n\n\n    // Consider all prime factors of n and subtract their\n    // multiples from result\n    for (int p = 2; p * p <= n; ++p) {\n        \n        // Check if p is a prime factor.\n        if (n % p == 0) {\n            \n            // If yes, then update n and result\n            while (n % p == 0)\n                n /= p;\n            result -= result / p;\n        }\n    }\n\n    // If n has a prime factor greater than sqrt(n)\n    // (There can be at-most one such prime factor)\n    if (n > 1)\n        result -= result / n;\n    return result;\n}\n\n// Driver program to test above function\nint main()\n{\n    int n;\n    for (n = 1; n <= 10; n++)\n        printf(\"phi(%d) = %d\\n\", n, phi(n));\n    return 0;\n}\n// Java program to calculate \n// Euler's Totient Function\nimport java.io.*;\n\nclass GFG \n{\nstatic int phi(int n)\n{\n    // Initialize result as n\n    int result = n; \n\n    // Consider all prime factors \n    // of n and subtract their\n    // multiples from result\n    for (int p = 2; p * p <= n; ++p)\n    {\n        \n        // Check if p is \n        // a prime factor.\n        if (n % p == 0) \n        {\n            \n            // If yes, then update\n            // n and result\n            while (n % p == 0)\n                n /= p;\n            result -= result / p;\n        }\n    }\n\n    // If n has a prime factor\n    // greater than sqrt(n)\n    // (There can be at-most \n    // one such prime factor)\n    if (n > 1)\n        result -= result / n;\n    return result;\n}\n\n// Driver Code\npublic static void main (String[] args)\n{\n    int n;\n    for (n = 1; n <= 10; n++)\n        System.out.println(\"phi(\" + n + \n                           \") = \" + phi(n));\n}\n}\n# Python3 program to calculate \n# Euler's Totient Function\ndef phi(n):\n    \n    # Initialize result as n\n    result = n; \n\n    # Consider all prime factors\n    # of n and subtract their\n    # multiples from result\n    p = 2; \n    while(p * p <= n):\n        \n        # Check if p is a \n        # prime factor.\n        if (n % p == 0): \n            \n            # If yes, then \n            # update n and result\n            while (n % p == 0):\n                n = int(n / p);\n            result -= int(result / p);\n        p += 1;\n\n    # If n has a prime factor\n    # greater than sqrt(n)\n    # (There can be at-most \n    # one such prime factor)\n    if (n > 1):\n        result -= int(result / n);\n    return result;\n\n# Driver Code\nfor n in range(1, 11):\n    print(\"phi(\",n,\") =\", phi(n));\n// C# program to calculate \n// Euler's Totient Function\nusing System;\n\nclass GFG\n{\n    \nstatic int phi(int n)\n{\n// Initialize result as n\nint result = n; \n\n// Consider all prime  \n// factors of n and \n// subtract their \n// multiples from result\nfor (int p = 2;\n         p * p <= n; ++p)\n{\n    \n    // Check if p is \n    // a prime factor.\n    if (n % p == 0) \n    {\n        \n        // If yes, then update\n        // n and result\n        while (n % p == 0)\n            n /= p;\n        result -= result / p;\n    }\n}\n\n// If n has a prime factor\n// greater than sqrt(n)\n// (There can be at-most \n// one such prime factor)\nif (n > 1)\n    result -= result / n;\nreturn result;\n}\n\n// Driver Code\nstatic public void Main ()\n{\n    int n;\n    for (n = 1; n <= 10; n++)\n        Console.WriteLine(\"phi(\" + n + \n                              \") = \" +\n                              phi(n));\n}\n}\n\n// This code is contributed \n// by akt_mit\n// Javascript program to calculate \n// Euler's Totient Function\n\nfunction phi(n)\n{\n    // Initialize \n    // result as n\n    let result = n; \n\n    // Consider all prime \n    // factors of n and subtract \n    // their multiples from result\n    for (let p = 2; \n         p * p <= n; ++p)\n    {\n        \n        // Check if p is \n        // a prime factor.\n        if (n % p == 0) \n        {\n            \n            // If yes, then \n            // update n and result\n            while (n % p == 0)\n                n = parseInt(n / p);\n            result -= parseInt(result / p);\n        }\n    }\n\n    // If n has a prime factor\n    // greater than sqrt(n)\n    // (There can be at-most \n    // one such prime factor)\n    if (n > 1)\n        result -= parseInt(result / n);\n    return result;\n}\n\n// Driver Code\nfor (let n = 1; n <= 10; n++)\n    console.log(`phi(${n}) = ${phi(n)} <br>`);\n<&Phi;php\n// PHP program to calculate \n// Euler's Totient Function\n\nfunction phi($n)\n{\n    // Initialize \n    // result as n\n    $result = $n; \n\n    // Consider all prime \n    // factors of n and subtract \n    // their multiples from result\n    for ($p = 2; \n         $p * $p <= $n; ++$p)\n    {\n        \n        // Check if p is \n        // a prime factor.\n        if ($n % $p == 0) \n        {\n            \n            // If yes, then \n            // update n and result\n            while ($n % $p == 0)\n                $n = (int)$n / $p;\n            $result -= (int)$result / $p;\n        }\n    }\n\n    // If n has a prime factor\n    // greater than sqrt(n)\n    // (There can be at-most \n    // one such prime factor)\n    if ($n > 1)\n        $result -= (int)$result / $n;\n    return $result;\n}\n\n// Driver Code\nfor ($n = 1; $n <= 10; $n++)\n    echo \"phi(\", $n,\") =\", \n          phi($n), \"\\n\";\n    \n// This code is contributed \n// by ajit\n&Phi;>\nPhi(1) = 1\nPhi(2) = 1\nPhi(3) = 2\nPhi(4) = 2\nPhi(5) = 4\nPhi(6) = 2\nPhi(7) = 6\nPhi(8) = 4\nPhi(9) = 6\nPhi(10) = 4\n",
        "complexity": {
            "time": "Time Complexity: O(√n)Auxiliary Space: O(1)",
            "space": ""
        },
        "tags": [
            "Mathematical Algorithms"
        ],
        "url": "https://www.geeksforgeeks.org/eulers-totient-function/"
    },
    {
        "title": "Modular Exponentiation (Power in Modular Arithmetic)",
        "description": "Modular Exponentiation is the process of computing: xy (mod  p). where x, y, and p are integers. It efficiently calculates the remainder when xy is divided by p or (xy) % p, even for very large y. Input:  x = 2, y = 3, p = 5Output: 3Explanation: 2^3 % 5 = 8 % 5 = 3.Input:  x = 2, y = 5, p = 13Output: 6Explanation: 2^5 % 13 = 32 % 13 = 6. The simplest way to calculate exponentiation is by multiplying x by itself y times. We use a loop that runs y times, multiplying x with the result in each step while taking the modulus to keep the value manageable. We start with answer = 1 and update it in every step. Time Complexity – O(y) Auxiliary Space – O(1) Binary exponentiation is a method to compute large powers efficiently using the properties of binary representation. Instead of multiplying the base repeatedly, it breaks the exponent down into powers of 2. Since every number can be represented as a sum of powers of 2, we can use only the set bits (1s) in the binary form of the exponent to determine which multiplications are necessary. (ab) mod p = ( (a mod p) (b mod p) ) mod p For example, if we want to compute 310, we express 10 in binary as 1010. This means 310 can be rewritten as 38×32, skipping unnecessary calculations. Similarly, for 319, where 19 is 10011 in binary, the exponentiation is reduced to 316×32×31. The method works iteratively by checking each bit of the exponent from least significant to most significant. If the bit is 1, we multiply the corresponding power of the base. The exponent is then divided by 2 at each step, which effectively shifts the binary representation, reducing the number of operations to O(log n) instead of O(n), making it highly efficient. Time Complexity – O(Log y)Auxiliary Space – O(1) To read about recursive method visit, Modular exponentiation (Recursive) S  ",
        "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint exponentiation(int x, int y, int p){\n    int answer = 1;\n    for(int i=0;i<y;i++){\n        answer = (answer*x)%p;\n    }\n    return answer%p;\n}\n\nint main()\n{\n    int x = 2;\n    int y = 5;\n    int p = 13;\n    cout<< \"Power is \"<< exponentiation(x,y,p) << endl;\n}\n#include <stdio.h>\n\nint exponentiation(int x, int y, int p) {\n    int answer = 1;\n    for (int i = 0; i < y; i++) {\n        answer = (answer * x) % p;\n    }\n    return answer % p;\n}\n\nint main() {\n    int x = 2;\n    int y = 5;\n    int p = 13;\n    printf(\"Power is %d\\n\", exponentiation(x, y, p));\n    return 0;\n}\npublic class Exponentiation {\n\n    static int exponentiation(int x, int y, int p) {\n        int answer = 1;\n        for (int i = 0; i < y; i++) {\n            answer = (answer * x) % p;\n        }\n        return answer % p;\n    }\n\n    public static void main(String[] args) {\n        int x = 2;\n        int y = 5;\n        int p = 13;\n        System.out.println(\"Power is \" + exponentiation(x, y, p));\n    }\n}\ndef exponentiation(x, y, p):\n    answer = 1\n    for _ in range(y):\n        answer = (answer * x) % p\n    return answer % p\n\n# Driver Code\nx = 2\ny = 5\np = 13\nprint(\"Power is\", exponentiation(x, y, p))\nusing System;\n\nclass Exponentiation\n{\n    static int ExponentiationMod(int x, int y, int p)\n    {\n        int answer = 1;\n        for (int i = 0; i < y; i++)\n        {\n            answer = (answer * x) % p;\n        }\n        return answer % p;\n    }\n\n    public static void Main()\n    {\n        int x = 2;\n        int y = 5;\n        int p = 13;\n        Console.WriteLine(\"Power is \" + ExponentiationMod(x, y, p));\n    }\n}\nfunction exponentiation(x, y, p) {\n    let answer = 1;\n    for (let i = 0; i < y; i++) {\n        answer = (answer * x) % p;\n    }\n    return answer % p;\n}\n\n// Driver Code\nlet x = 2;\nlet y = 5;\nlet p = 13;\nconsole.log(\"Power is\", exponentiation(x, y, p));\nPower is 6\n// Iterative C++ program to compute modular power \n#include <iostream>\nusing namespace std;\n\n/* Iterative Function to calculate (x^y)%p in O(log y) */\nint power(long long x, unsigned int y, int p) \n{ \n    int res = 1;     // Initialize result \n\n    x = x % p; // Update x if it is more than or \n                // equal to p\n \n    if (x == 0) return 0; // In case x is divisible by p;\n\n    while (y > 0) \n    { \n        // If y is odd, multiply x with result \n        if (y & 1) \n            res = (res*x) % p; \n\n        // y must be even now \n        y = y>>1; // y = y/2 \n        x = (x*x) % p; \n    } \n    return res; \n} \n\n// Driver code \nint main() \n{ \n    int x = 2; \n    int y = 5; \n    int p = 13; \n    cout << \"Power is \" << power(x, y, p); \n    return 0; \n}\n// Iterative Java program to compute modular power \nimport java.io.*;\nclass GFG \n{\n\n  /* Iterative Function to calculate (x^y) in O(log y) */\n  static int power(int x, int y, int p)\n  {\n    int res = 1; // Initialize result\n\n    x = x % p; // Update x if it is more than or\n    // equal to p\n\n    if (x == 0)\n      return 0; // In case x is divisible by p;\n\n    while (y > 0)\n    {\n\n      // If y is odd, multiply x with result\n      if ((y & 1) != 0)\n        res = (res * x) % p;\n\n      // y must be even now\n      y = y >> 1; // y = y/2\n      x = (x * x) % p;\n    }\n    return res;\n  }\n\n  // Driver Code\n  public static void main(String[] args)\n  {\n    int x = 2;\n    int y = 5;\n    int p = 13;\n    System.out.print(\"Power is \" + power(x, y, p));\n  }\n}\n\n// This code is contributed by Dharanendra L V.\n# Iterative Python3 program\n# to compute modular power\n\n# Iterative Function to calculate\n# (x^y)%p in O(log y) \ndef power(x, y, p) :\n    res = 1     # Initialize result\n\n    # Update x if it is more\n    # than or equal to p\n    x = x % p \n    \n    if (x == 0) :\n        return 0\n\n    while (y > 0) :\n        \n        # If y is odd, multiply\n        # x with result\n        if ((y & 1) == 1) :\n            res = (res * x) % p\n\n        # y must be even now\n        y = y >> 1      # y = y/2\n        x = (x * x) % p\n        \n    return res\n    \n\n# Driver Code\n\nx = 2; y = 5; p = 13\nprint(\"Power is \", power(x, y, p))\nusing System;\npublic class GFG\n{\n\n  /* Iterative Function to calculate (x^y) in O(log y) */\n  static int power(int x, int y, int p)\n  {\n    int res = 1; // Initialize result\n\n    x = x % p; // Update x if it is more than or\n    // equal to p\n\n    if (x == 0)\n      return 0; // In case x is divisible by p;\n\n    while (y > 0) \n    {\n\n      // If y is odd, multiply x with result\n      if ((y & 1) != 0)\n        res = (res * x) % p;\n\n      // y must be even now\n      y = y >> 1; // y = y/2\n      x = (x * x) % p;\n    }\n    return res;\n  }\n\n  // Driver Code\n  static public void Main ()\n  {\n    int x = 2;\n    int y = 5;\n    int p = 13;\n    Console.Write(\"Power is \" + power(x, y, p));\n  }\n}\n// Iterative Javascript program to \n// compute modular power\n\n// Iterative Function to \n// calculate (x^y)%p in O(log y) \nfunction power(x, y, p)\n{\n    // Initialize result\n    let res = 1; \n\n    // Update x if it is more \n    // than or equal to p\n    x = x % p; \n\n    if (x == 0)\n        return 0;\n\n    while (y > 0)\n    {\n        // If y is odd, multiply\n        // x with result\n        if (y & 1)\n            res = (res * x) % p;\n\n        // y must be even now\n        \n        // y = $y/2\n        y = y >> 1; \n        x = (x * x) % p; \n    }\n    return res;\n}\n\n// Driver Code\nlet x = 2;\nlet y = 5;\nlet p = 13;\ndocument.write(\"Power is \" + power(x, y, p));\n<?php\n// Iterative PHP program to \n// compute modular power\n\n// Iterative Function to \n// calculate (x^y)%p in O(log y) \nfunction power($x, $y, $p)\n{\n    // Initialize result\n    $res = 1; \n\n    // Update x if it is more \n    // than or equal to p\n    $x = $x % $p; \n\n    if ($x == 0)\n        return 0;\n\n    while ($y > 0)\n    {\n        // If y is odd, multiply\n        // x with result\n        if ($y & 1)\n            $res = ($res * $x) % $p;\n\n        // y must be even now\n        \n        // y = $y/2\n        $y = $y >> 1; \n        $x = ($x * $x) % $p; \n    }\n    return $res;\n}\n\n// Driver Code\n$x = 2;\n$y = 5;\n$p = 13;\necho \"Power is \", power($x, $y, $p);\n\n// This code is contributed by aj_36\n?>\nPower is 6\n",
        "complexity": {
            "time": "Time Complexity – O(Log y)Auxiliary Space – O(1)",
            "space": ""
        },
        "tags": [
            "Mathematical Algorithms"
        ],
        "url": "https://www.geeksforgeeks.org/modular-exponentiation-power-in-modular-arithmetic/"
    },
    {
        "title": "Modular multiplicative inverse",
        "description": "Given two integers A and M, find the modular multiplicative inverse of A under modulo M.The modular multiplicative inverse is an integer X such that: A * X ≡ 1 (mod M) Note: The value of X should be in the range {1, 2, … M-1}, i.e., in the range of integer modulo M. ( Note that X cannot be 0 as A*0 mod M will never be 1). The multiplicative inverse of “A modulo M” exists if and only if A and M are relatively prime (i.e. if gcd(A, M) = 1) Examples: Input: A = 3, M = 11Output: 4Explanation: Since (4*3) mod 11 = 1, 4 is modulo inverse of 3(under 11).One might think, 15 also as a valid output as “(15*3) mod 11” is also 1, but 15 is not in range {1, 2, … 10}, so not valid. Input:  A = 10, M = 17Output: 12Explamation: Since (10*12) mod 17 = 1, 12 is modulo inverse of 10(under 17). Naive Approach:  To solve the problem, follow the below idea: A naive method is to try all numbers from 1 to m. For every number x, check if (A * X) % M is 1 Below is the implementation of the above approach: Time Complexity: O(M)Auxiliary Space: O(1) The idea is to use Extended Euclidean algorithms that take two integers ‘a’ and ‘b’, then find their gcd, and also find ‘x’ and ‘y’ such that ax + by = gcd(a, b) To find the multiplicative inverse of ‘A’ under ‘M’, we put b = M in the above formula. Since we know that A and M are relatively prime, we can put the value of gcd as 1. Ax + My = 1 If we take modulo M on both sides, we get Ax + My ≡ 1 (mod M) We can remove the second term on left side as ‘My (mod M)’ would always be 0 for an integer y. Ax  ≡ 1 (mod M) So the ‘x’ that we can find using Extended Euclid Algorithm is the multiplicative inverse of ‘A’ Below is the implementation of the above approach: Time Complexity: O(log M)Auxiliary Space: O(log M), because of the internal recursion stack. Iterative Implementation of the above approach: Time Complexity: O(log m)Auxiliary Space: O(1) If we know M is prime, then we can also use Fermat’s little theorem to find the inverse. aM-1 ≡ 1 (mod M) If we multiply both sides with a-1, we get a-1 ≡ a M-2 (mod M) Below is the implementation of the above approach: Time Complexity: O(log M)Auxiliary Space: O(log M), because of the internal recursion stack. Applications: Computation of the modular multiplicative inverse is an essential step in RSA public-key encryption method.  A  ",
        "code": "// C++ program to find modular\n// inverse of A under modulo M\n#include <bits/stdc++.h>\nusing namespace std;\n\n// A naive method to find modular\n// multiplicative inverse of 'A'\n// under modulo 'M'\n\nint modInverse(int A, int M) {\n  \n  \tif(__gcd(A, M) > 1){\n      \t\n      \t// modulo inverse does not exist\n      \treturn -1;\n    }\n    for (int X = 1; X < M; X++)\n        if (((A % M) * (X % M)) % M == 1)\n            return X;\n}\n\nint main() {\n    int A = 3, M = 11;\n\n    cout << modInverse(A, M);\n    return 0;\n}\n// Java program to find modular inverse\n// of A under modulo M\nimport java.io.*;\n\nclass GFG {\n\n    // A naive method to find modulor\n    // multiplicative inverse of A\n    // under modulo M\n  \tstatic int gcd(int a, int b) {\n        if (b == 0) {\n            return a;\n        }\n        return gcd(b, a % b);\n    }\n    static int modInverse(int A, int M) {\n\t\tif (gcd(A, M) > 1) {\n          \t\n            // modulo inverse does not exist\n            return -1;\n        }\n        for (int X = 1; X < M; X++)\n            if (((A % M) * (X % M)) % M == 1)\n                return X;\n        return 1;\n    }\n\n    public static void main(String args[])\n    {\n        int A = 3, M = 11;\n\n        System.out.println(modInverse(A, M));\n    }\n}\n# Python3 program to find modular\n# inverse of A under modulo M\n\n# A naive method to find modulor\n# multiplicative inverse of A\n# under modulo M\n\ndef gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\ndef modInverse(A, M):\n    if gcd(A, M) > 1:\n      \n        # modulo inverse does not exist\n        return -1\n    for X in range(1, M):\n        if (((A % M) * (X % M)) % M == 1):\n            return X\n    return -1\n\n\nif __name__ == \"__main__\":\n    A = 3\n    M = 11\n\n    print(modInverse(A, M))\n// C# program to find modular inverse\n// of A under modulo M\nusing System;\n\nclass GFG {\n  \tstatic int gcd(int a, int b) {\n        if (b == 0) {\n            return a;\n        }\n        return gcd(b, a % b);\n    }\n\t\n  \t// A naive method to find modulor\n    // multiplicative inverse of A\n    // under modulo M\n    static int modInverse(int A, int M) {\n        if (gcd(A, M) > 1) {\n          \n            // modulo inverse does not exist\n            return -1;\n        }\n   \t\t\n        for (int X = 1; X < M; X++)\n            if (((A % M) * (X % M)) % M == 1)\n                return X;\n        return 1;\n    }\n\n    static void Main() {\n        int A = 3, M = 11;\n        Console.WriteLine(modInverse(A, M));\n    }\n}\n// Javascript program to find modular \n// inverse of a under modulo m\n\nfunction gcd(a, b) {\n    if (b === 0) {\n        return a;\n    }\n    return gcd(b, a % b);\n}\n\n// A naive method to find modulor\n// multiplicative inverse of\n// 'a' under modulo 'm'\nfunction modInverse(A, M) {\n    if (gcd(A, M) > 1) {\n    \n        // modulo inverse does not exist\n        return -1;\n    }\n    \n    for(let x = 1; x < m; x++)\n        if (((a % m) * (x % m)) % m == 1)\n            return x;\n}\n\n\nlet a = 3; \nlet m = 11;\n\nconsole.log(modInverse(a, m));\n4\n// C++ program to find multiplicative modulo\n// inverse using Extended Euclid algorithm.\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Function for extended Euclidean Algorithm\nint gcdExtended(int a, int b, int* x, int* y);\n\n// Function to find modulo inverse of a\nvoid modInverse(int A, int M) {\n    int x, y;\n    int g = gcdExtended(A, M, &x, &y);\n    if (g != 1)\n        cout << \"Inverse doesn't exist\";\n    else {\n\n        // m is added to handle negative x\n        int res = (x % M + M) % M;\n        cout << \"Modular multiplicative inverse is \" << res;\n    }\n}\n\n// Function for extended Euclidean Algorithm\nint gcdExtended(int a, int b, int* x, int* y)\n{\n\n    // Base Case\n    if (a == 0) {\n        *x = 0, *y = 1;\n        return b;\n    }\n\n    // To store results of recursive call\n    int x1, y1;\n    int gcd = gcdExtended(b % a, a, &x1, &y1);\n\n    // Update x and y using results of recursive\n    // call\n    *x = y1 - (b / a) * x1;\n    *y = x1;\n\n    return gcd;\n}\n\n// Driver Code\nint main()\n{\n    int A = 3, M = 11;\n\n    // Function call\n    modInverse(A, M);\n    return 0;\n}\n\n// This code is contributed by khushboogoyal499\n// C program to find multiplicative modulo inverse using\n// Extended Euclid algorithm.\n#include <stdio.h>\n\n// C function for extended Euclidean Algorithm\nint gcdExtended(int a, int b, int* x, int* y);\n\n// Function to find modulo inverse of a\nvoid modInverse(int A, int M)\n{\n    int x, y;\n    int g = gcdExtended(A, M, &x, &y);\n    if (g != 1)\n        printf(\"Inverse doesn't exist\");\n    else {\n        // m is added to handle negative x\n        int res = (x % M + M) % M;\n        printf(\"Modular multiplicative inverse is %d\", res);\n    }\n}\n\n// C function for extended Euclidean Algorithm\nint gcdExtended(int a, int b, int* x, int* y)\n{\n    // Base Case\n    if (a == 0) {\n        *x = 0, *y = 1;\n        return b;\n    }\n\n    int x1, y1; // To store results of recursive call\n    int gcd = gcdExtended(b % a, a, &x1, &y1);\n\n    // Update x and y using results of recursive\n    // call\n    *x = y1 - (b / a) * x1;\n    *y = x1;\n\n    return gcd;\n}\n\n// Driver Code\nint main()\n{\n    int A = 3, M = 11;\n\n    // Function call\n    modInverse(A, M);\n    return 0;\n}\n// java program to find multiplicative modulo\n// inverse using Extended Euclid algorithm.\npublic class GFG {\n\n    // Global Variables\n    public static int x;\n    public static int y;\n\n    // Function for extended Euclidean Algorithm\n    static int gcdExtended(int a, int b)\n    {\n\n        // Base Case\n        if (a == 0) {\n            x = 0;\n            y = 1;\n            return b;\n        }\n\n        // To store results of recursive call\n        int gcd = gcdExtended(b % a, a);\n        int x1 = x;\n        int y1 = y;\n\n        // Update x and y using results of recursive\n        // call\n        int tmp = b / a;\n        x = y1 - tmp * x1;\n        y = x1;\n\n        return gcd;\n    }\n\n    static void modInverse(int A, int M)\n    {\n        int g = gcdExtended(A, M);\n        if (g != 1) {\n            System.out.println(\"Inverse doesn't exist\");\n        }\n        else {\n\n            // m is added to handle negative x\n            int res = (x % M + M) % M;\n            System.out.println(\n                \"Modular multiplicative inverse is \" + res);\n        }\n    }\n\n    // Driver code\n    public static void main(String[] args)\n    {\n        int A = 3, M = 11;\n\n        // Function Call\n        modInverse(A, M);\n    }\n}\n\n// The code is contributed by Gautam goel (gautamgoel962)\n# Python3 program to find multiplicative modulo\n# inverse using Extended Euclid algorithm.\n\n# Global Variables\nx, y = 0, 1\n\n# Function for extended Euclidean Algorithm\n\n\ndef gcdExtended(a, b):\n    global x, y\n\n    # Base Case\n    if (a == 0):\n        x = 0\n        y = 1\n        return b\n\n    # To store results of recursive call\n    gcd = gcdExtended(b % a, a)\n    x1 = x\n    y1 = y\n\n    # Update x and y using results of recursive\n    # call\n    x = y1 - (b // a) * x1\n    y = x1\n\n    return gcd\n\n\ndef modInverse(A, M):\n\n    g = gcdExtended(A, M)\n    if (g != 1):\n        print(\"Inverse doesn't exist\")\n\n    else:\n\n        # m is added to handle negative x\n        res = (x % M + M) % M\n        print(\"Modular multiplicative inverse is \", res)\n\n\n# Driver Code\nif __name__ == \"__main__\":\n    A = 3\n    M = 11\n\n    # Function call\n    modInverse(A, M)\n\n\n# This code is contributed by phasing17\n// C# program to find multiplicative modulo\n// inverse using Extended Euclid algorithm.\n\nusing System;\n\npublic class GFG {\n    public static int x, y;\n\n    // Function for extended Euclidean Algorithm\n    static int gcdExtended(int a, int b)\n    {\n\n        // Base Case\n        if (a == 0) {\n            x = 0;\n            y = 1;\n            return b;\n        }\n\n        // To store results of recursive call\n        int gcd = gcdExtended(b % a, a);\n        int x1 = x;\n        int y1 = y;\n\n        // Update x and y using results of recursive\n        // call\n        x = y1 - (b / a) * x1;\n        y = x1;\n\n        return gcd;\n    }\n\n    // Function to find modulo inverse of a\n    static void modInverse(int A, int M)\n    {\n        int g = gcdExtended(A, M);\n        if (g != 1)\n            Console.Write(\"Inverse doesn't exist\");\n        else {\n\n            // M is added to handle negative x\n            int res = (x % M + M) % M;\n            Console.Write(\n                \"Modular multiplicative inverse is \" + res);\n        }\n    }\n\n    // Driver Code\n    public static void Main(string[] args)\n    {\n        int A = 3, M = 11;\n\n        // Function call\n        modInverse(A, M);\n    }\n}\n\n// this code is contributed by phasing17\n<script>\n// JavaScript program to find multiplicative modulo\n// inverse using Extended Euclid algorithm.\n\n// Global Variables\nlet x, y;\n\n// Function for extended Euclidean Algorithm\nfunction gcdExtended(a, b){\n     \n    // Base Case\n    if (a == 0)\n    {\n        x = 0;\n        y = 1;\n        return b;\n    }\n     \n    // To store results of recursive call    \n    let gcd = gcdExtended(b % a, a);\n    let x1 = x;\n    let y1 = y;\n\n    // Update x and y using results of recursive\n    // call\n    x = y1 - Math.floor(b / a) * x1;\n    y = x1;\n \n    return gcd;\n}\n\nfunction modInverse(a, m)\n{\n    let g = gcdExtended(a, m);\n    if (g != 1){\n        document.write(\"Inverse doesn't exist\");\n    }\n    else{\n         \n        // m is added to handle negative x\n        let res = (x % m + m) % m;\n        document.write(\"Modular multiplicative inverse is \", res);\n        }\n}\n\n// Driver Code\n{\n    let a = 3, m = 11;\n   \n    // Function call\n    modInverse(a, m);\n}\n \n// This code is contributed by Gautam goel (gautamgoel962)\n</script>\nModular multiplicative inverse is 4\n// Iterative C++ program to find modular\n// inverse using extended Euclid algorithm\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Returns modulo inverse of a with respect\n// to m using extended Euclid Algorithm\n// Assumption: a and m are coprimes, i.e.,\n// gcd(A, M) = 1\nint modInverse(int A, int M) {\n    int m0 = M;\n    int y = 0, x = 1;\n\n    if (M == 1)\n        return 0;\n\n    while (A > 1) {\n        // q is quotient\n        int q = A / M;\n        int t = M;\n\n        // m is remainder now, process same as\n        // Euclid's algo\n        M = A % M, A = t;\n        t = y;\n\n        // Update y and x\n        y = x - q * y;\n        x = t;\n    }\n\n    // Make x positive\n    if (x < 0)\n        x += m0;\n\n    return x;\n}\n\nint main() {\n    int A = 3, M = 11;\n\n    cout << \"Modular multiplicative inverse is \"\n         << modInverse(A, M);\n    return 0;\n}\n// Iterative C program to find modular\n// inverse using extended Euclid algorithm\n\n#include <stdio.h>\n\n// Returns modulo inverse of a with respect\n// to m using extended Euclid Algorithm\n// Assumption: a and m are coprimes, i.e.,\n// gcd(A, M) = 1\nint modInverse(int A, int M)\n{\n    int m0 = M;\n    int y = 0, x = 1;\n\n    if (M == 1)\n        return 0;\n\n    while (A > 1) {\n        // q is quotient\n        int q = A / M;\n        int t = M;\n\n        // m is remainder now, process same as\n        // Euclid's algo\n        M = A % M, A = t;\n        t = y;\n\n        // Update y and x\n        y = x - q * y;\n        x = t;\n    }\n\n    // Make x positive\n    if (x < 0)\n        x += m0;\n\n    return x;\n}\n\n// Driver Code\nint main()\n{\n    int A = 3, M = 11;\n\n    // Function call\n    printf(\"Modular multiplicative inverse is %d\\n\",\n           modInverse(A, M));\n    return 0;\n}\n// Iterative Java program to find modular\n// inverse using extended Euclid algorithm\n\nclass GFG {\n\n    // Returns modulo inverse of a with\n    // respect to m using extended Euclid\n    // Algorithm Assumption: a and m are\n    // coprimes, i.e., gcd(A, M) = 1\n    static int modInverse(int A, int M)\n    {\n        int m0 = M;\n        int y = 0, x = 1;\n\n        if (M == 1)\n            return 0;\n\n        while (A > 1) {\n            // q is quotient\n            int q = A / M;\n\n            int t = M;\n\n            // m is remainder now, process\n            // same as Euclid's algo\n            M = A % M;\n            A = t;\n            t = y;\n\n            // Update x and y\n            y = x - q * y;\n            x = t;\n        }\n\n        // Make x positive\n        if (x < 0)\n            x += m0;\n\n        return x;\n    }\n\n    // Driver code\n    public static void main(String args[])\n    {\n        int A = 3, M = 11;\n\n        // Function call\n        System.out.println(\"Modular multiplicative \"\n                           + \"inverse is \"\n                           + modInverse(A, M));\n    }\n}\n\n/*This code is contributed by Nikita Tiwari.*/\n# Iterative Python 3 program to find\n# modular inverse using extended\n# Euclid algorithm\n\n# Returns modulo inverse of a with\n# respect to m using extended Euclid\n# Algorithm Assumption: a and m are\n# coprimes, i.e., gcd(A, M) = 1\n\n\ndef modInverse(A, M):\n    m0 = M\n    y = 0\n    x = 1\n\n    if (M == 1):\n        return 0\n\n    while (A > 1):\n\n        # q is quotient\n        q = A // M\n\n        t = M\n\n        # m is remainder now, process\n        # same as Euclid's algo\n        M = A % M\n        A = t\n        t = y\n\n        # Update x and y\n        y = x - q * y\n        x = t\n\n    # Make x positive\n    if (x < 0):\n        x = x + m0\n\n    return x\n\n\n# Driver code\nif __name__ == \"__main__\":\n    A = 3\n    M = 11\n\n    # Function call\n    print(\"Modular multiplicative inverse is\",\n          modInverse(A, M))\n\n# This code is contributed by Nikita tiwari.\n// Iterative C# program to find modular\n// inverse using extended Euclid algorithm\nusing System;\nclass GFG {\n\n    // Returns modulo inverse of a with\n    // respect to m using extended Euclid\n    // Algorithm Assumption: a and m are\n    // coprimes, i.e., gcd(A, M) = 1\n    static int modInverse(int A, int M)\n    {\n        int m0 = M;\n        int y = 0, x = 1;\n\n        if (M == 1)\n            return 0;\n\n        while (A > 1) {\n            // q is quotient\n            int q = A / M;\n\n            int t = M;\n\n            // m is remainder now, process\n            // same as Euclid's algo\n            M = A % M;\n            A = t;\n            t = y;\n\n            // Update x and y\n            y = x - q * y;\n            x = t;\n        }\n\n        // Make x positive\n        if (x < 0)\n            x += m0;\n\n        return x;\n    }\n\n    // Driver Code\n    public static void Main()\n    {\n        int A = 3, M = 11;\n\n        // Function call\n        Console.WriteLine(\"Modular multiplicative \"\n                          + \"inverse is \"\n                          + modInverse(A, M));\n    }\n}\n\n// This code is contributed by anuj_67.\n// Iterative Javascript program to find modular\n// inverse using extended Euclid algorithm\n\n// Returns modulo inverse of a with respect\n// to m using extended Euclid Algorithm\n// Assumption: a and m are coprimes, i.e.,\n// gcd(a, m) = 1\nfunction modInverse(a, m)\n{\n    let m0 = m;\n    let y = 0;\n    let x = 1;\n\n    if (m == 1)\n        return 0;\n\n    while (a > 1)\n    {\n        \n        // q is quotient\n        let q = parseInt(a / m);\n        let t = m;\n\n        // m is remainder now,\n        // process same as\n        // Euclid's algo\n        m = a % m;\n        a = t;\n        t = y;\n\n        // Update y and x\n        y = x - q * y;\n        x = t;\n    }\n\n    // Make x positive\n    if (x < 0)\n        x += m0;\n\n    return x;\n}\n\n// Driver Code\nlet a = 3;\nlet m = 11;\n\n// Function call\nconsole.log(`Modular multiplicative inverse is ${modInverse(a, m)}`);\nModular multiplicative inverse is 4\n// C++ program to find modular inverse of A under modulo M\n// This program works only if M is prime.\n#include <bits/stdc++.h>\nusing namespace std;\n\n// To find GCD of a and b\nint gcd(int a, int b);\n\n// To compute x raised to power y under modulo M\nint power(int x, unsigned int y, unsigned int M);\n\n// Function to find modular inverse of a under modulo M\n// Assumption: M is prime\nvoid modInverse(int A, int M)\n{\n    int g = gcd(A, M);\n    if (g != 1)\n        cout << \"Inverse doesn't exist\";\n    else {\n        // If a and m are relatively prime, then modulo\n        // inverse is a^(m-2) mode m\n        cout << \"Modular multiplicative inverse is \"\n             << power(A, M - 2, M);\n    }\n}\n\n// To compute x^y under modulo m\nint power(int x, unsigned int y, unsigned int M)\n{\n    if (y == 0)\n        return 1;\n\n    int p = power(x, y / 2, M) % M;\n    p = (p * p) % M;\n\n    return (y % 2 == 0) ? p : (x * p) % M;\n}\n\n// Function to return gcd of a and b\nint gcd(int a, int b)\n{\n    if (a == 0)\n        return b;\n    return gcd(b % a, a);\n}\n\n// Driver code\nint main()\n{\n    int A = 3, M = 11;\n\n    // Function call\n    modInverse(A, M);\n    return 0;\n}\n// Java program to find modular\n// inverse of A under modulo M\n// This program works only if\n// M is prime.\nimport java.io.*;\n\nclass GFG {\n\n    // Function to find modular inverse of a\n    // under modulo M Assumption: M is prime\n    static void modInverse(int A, int M)\n    {\n        int g = gcd(A, M);\n        if (g != 1)\n            System.out.println(\"Inverse doesn't exist\");\n        else {\n            // If a and m are relatively prime, then modulo\n            // inverse is a^(m-2) mode m\n            System.out.println(\n                \"Modular multiplicative inverse is \"\n                + power(A, M - 2, M));\n        }\n    }\n\n    static int power(int x, int y, int M)\n    {\n        if (y == 0)\n            return 1;\n        int p = power(x, y / 2, M) % M;\n        p = (int)((p * (long)p) % M);\n        if (y % 2 == 0)\n            return p;\n        else\n            return (int)((x * (long)p) % M);\n    }\n\n    // Function to return gcd of a and b\n    static int gcd(int a, int b)\n    {\n        if (a == 0)\n            return b;\n        return gcd(b % a, a);\n    }\n\n    // Driver Code\n    public static void main(String args[])\n    {\n        int A = 3, M = 11;\n\n        // Function call\n        modInverse(A, M);\n    }\n}\n\n// This code is contributed by Nikita Tiwari.\n# Python3 program to find modular\n# inverse of A under modulo M\n\n# This program works only if M is prime.\n\n# Function to find modular\n# inverse of A under modulo M\n# Assumption: M is prime\n\n\ndef modInverse(A, M):\n\n    g = gcd(A, M)\n\n    if (g != 1):\n        print(\"Inverse doesn't exist\")\n\n    else:\n\n        # If A and M are relatively prime,\n        # then modulo inverse is A^(M-2) mod M\n        print(\"Modular multiplicative inverse is \",\n              power(A, M - 2, M))\n\n# To compute x^y under modulo M\n\n\ndef power(x, y, M):\n\n    if (y == 0):\n        return 1\n\n    p = power(x, y // 2, M) % M\n    p = (p * p) % M\n\n    if(y % 2 == 0):\n        return p\n    else:\n        return ((x * p) % M)\n\n# Function to return gcd of a and b\n\n\ndef gcd(a, b):\n    if (a == 0):\n        return b\n\n    return gcd(b % a, a)\n\n\n# Driver Code\nif __name__ == \"__main__\":\n    A = 3\n    M = 11\n\n    # Function call\n    modInverse(A, M)\n\n\n# This code is contributed by Nikita Tiwari.\n// C# program to find modular\n// inverse of a under modulo M\n// This program works only if\n// M is prime.\nusing System;\nclass GFG {\n\n    // Function to find modular\n    // inverse of A under modulo\n    // M Assumption: M is prime\n    static void modInverse(int A, int M)\n    {\n        int g = gcd(A, M);\n        if (g != 1)\n            Console.Write(\"Inverse doesn't exist\");\n        else {\n            // If A and M are relatively\n            // prime, then modulo inverse\n            // is A^(M-2) mod M\n            Console.Write(\n                \"Modular multiplicative inverse is \"\n                + power(A, M - 2, M));\n        }\n    }\n\n    // To compute x^y under\n    // modulo M\n    static int power(int x, int y, int M)\n    {\n        if (y == 0)\n            return 1;\n\n        int p = power(x, y / 2, M) % M;\n        p = (p * p) % M;\n\n        if (y % 2 == 0)\n            return p;\n        else\n            return (x * p) % M;\n    }\n\n    // Function to return\n    // gcd of a and b\n    static int gcd(int a, int b)\n    {\n        if (a == 0)\n            return b;\n        return gcd(b % a, a);\n    }\n\n    // Driver Code\n    public static void Main()\n    {\n        int A = 3, M = 11;\n\n        // Function call\n        modInverse(A, M);\n    }\n}\n\n// This code is contributed by nitin mittal.\n<script>\n// Javascript program to find modular inverse of a under modulo m\n// This program works only if m is prime.\n\n// Function to find modular inverse of a under modulo m\n// Assumption: m is prime\nfunction modInverse(a, m)\n{\n    let g = gcd(a, m);\n    if (g != 1)\n        document.write(\"Inverse doesn't exist\");\n    else \n    {\n        // If a and m are relatively prime, then modulo\n        // inverse is a^(m-2) mode m\n        document.write(\"Modular multiplicative inverse is \"\n             + power(a, m - 2, m));\n    }\n}\n\n// To compute x^y under modulo m\nfunction power(x, y, m)\n{\n    if (y == 0)\n        return 1;\n    let p = power(x, parseInt(y / 2), m) % m;\n    p = (p * p) % m;\n\n    return (y % 2 == 0) ? p : (x * p) % m;\n}\n\n// Function to return gcd of a and b\nfunction gcd(a, b)\n{\n    if (a == 0)\n        return b;\n    return gcd(b % a, a);\n}\n\n// Driver code\nlet a = 3, m = 11;\n\n// Function call\nmodInverse(a, m);\n\n// This code is contributed by subham348.\n</script>\n<?php\n// PHP program to find modular \n// inverse of A under modulo M\n// This program works only if M\n// is prime.\n\n// Function to find modular\n// inverse of A under modulo\n// M Assumption: M is prime\nfunction modInverse( $A, $M)\n{\n    $g = gcd($A, $M);\n    if ($g != 1)\n        echo \"Inverse doesn't exist\";\n    else\n    {\n        \n        // If A and M are relatively \n        // prime, then modulo inverse\n        // is A^(M-2) mod M\n        echo \"Modular multiplicative inverse is \"\n                        , power($A, $M - 2, $M);\n    }\n}\n\n// To compute x^y under modulo m\nfunction power( $x, $y, $M)\n{\n    if ($y == 0)\n        return 1;\n    $p = power($x, $y / 2, $M) % $M;\n    $p = ($p * $p) % $M;\n\n    return ($y % 2 == 0)? $p : ($x * $p) % $M;\n}\n\n// Function to return gcd of a and b\nfunction gcd($a, $b)\n{\n    if ($a == 0)\n        return $b;\n    return gcd($b % $a, $a);\n}\n\n// Driver Code\n$A = 3;\n$M = 11;\n\n// Function call\nmodInverse($A, $M);\n    \n// This code is contributed by anuj_67.\n?>\nModular multiplicative inverse is 4\n",
        "complexity": {
            "time": "Time Complexity: O(log M)Auxiliary Space: O(log M), because of the internal recursion stack.",
            "space": ""
        },
        "tags": [
            "Mathematical Algorithms"
        ],
        "url": "https://www.geeksforgeeks.org/multiplicative-inverse-under-modulo-m/"
    },
    {
        "title": "Stein’s Algorithm for finding GCD",
        "description": "Stein’s algorithm or binary GCD algorithm is an algorithm that computes the greatest common divisor of two non-negative integers. Stein’s algorithm replaces division with arithmetic shifts, comparisons, and subtraction. Examples: Input: a = 17, b = 34 Output : 17Input: a = 50, b = 49Output: 1 Algorithm to find GCD using Stein’s algorithm gcd(a, b) The algorithm is mainly an optimization over standard Euclidean Algorithm for GCD Time Complexity: O(N*N)Auxiliary Space: O(1) Time Complexity: O(N*N) where N is the number of bits in the larger number.Auxiliary Space: O(N*N) where N is the number of bits in the larger number. You may also like – Basic and Extended Euclidean Algorithm Advantages over Euclid’s GCD Algorithm A  ",
        "code": "// Iterative C++ program to\n// implement Stein's Algorithm\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Function to implement\n// Stein's Algorithm\nint gcd(int a, int b)\n{\n    /* GCD(0, b) == b; GCD(a, 0) == a,\n       GCD(0, 0) == 0 */\n    if (a == 0)\n        return b;\n    if (b == 0)\n        return a;\n\n    /*Finding K, where K is the\n      greatest power of 2\n      that divides both a and b. */\n    int k;\n    for (k = 0; ((a | b) & 1) == 0; ++k) \n    {\n        a >>= 1;\n        b >>= 1;\n    }\n\n    /* Dividing a by 2 until a becomes odd */\n    while ((a & 1) == 0)\n        a >>= 1;\n\n    /* From here on, 'a' is always odd. */\n    do\n    {\n        /* If b is even, remove all factor of 2 in b */\n        while ((b & 1) == 0)\n            b >>= 1;\n\n        /* Now a and b are both odd.\n           Swap if necessary so a <= b,\n           then set b = b - a (which is even).*/\n        if (a > b)\n            swap(a, b); // Swap u and v.\n\n        b = (b - a);\n    }while (b != 0);\n\n    /* restore common factors of 2 */\n    return a << k;\n}\n\n// Driver code\nint main()\n{\n    int a = 34, b = 17;\n    printf(\"Gcd of given numbers is %d\\n\", gcd(a, b));\n    return 0;\n}\n// Iterative Java program to\n// implement Stein's Algorithm\nimport java.io.*;\n\nclass GFG {\n\n    // Function to implement Stein's\n    // Algorithm\n    static int gcd(int a, int b)\n    {\n        // GCD(0, b) == b; GCD(a, 0) == a,\n        // GCD(0, 0) == 0\n        if (a == 0)\n            return b;\n        if (b == 0)\n            return a;\n\n        // Finding K, where K is the greatest\n        // power of 2 that divides both a and b\n        int k;\n        for (k = 0; ((a | b) & 1) == 0; ++k) \n        {\n            a >>= 1;\n            b >>= 1;\n        }\n\n        // Dividing a by 2 until a becomes odd\n        while ((a & 1) == 0)\n            a >>= 1;\n\n        // From here on, 'a' is always odd.\n        do \n        {\n            // If b is even, remove\n            // all factor of 2 in b\n            while ((b & 1) == 0)\n                b >>= 1;\n\n            // Now a and b are both odd. Swap\n            // if necessary so a <= b, then set\n            // b = b - a (which is even)\n            if (a > b) \n            {\n                // Swap u and v.\n                int temp = a;\n                a = b;\n                b = temp;\n            }\n\n            b = (b - a);\n        } while (b != 0);\n\n        // restore common factors of 2\n        return a << k;\n    }\n\n    // Driver code\n    public static void main(String args[])\n    {\n        int a = 34, b = 17;\n\n        System.out.println(\"Gcd of given \"\n                           + \"numbers is \" + gcd(a, b));\n    }\n}\n\n// This code is contributed by Nikita Tiwari\n# Iterative Python 3 program to\n# implement Stein's Algorithm\n\n# Function to implement\n# Stein's Algorithm\n\n\ndef gcd(a, b):\n\n    # GCD(0, b) == b; GCD(a, 0) == a,\n    # GCD(0, 0) == 0\n    if (a == 0):\n        return b\n\n    if (b == 0):\n        return a\n\n    # Finding K, where K is the\n    # greatest power of 2 that\n    # divides both a and b.\n    k = 0\n\n    while(((a | b) & 1) == 0):\n        a = a >> 1\n        b = b >> 1\n        k = k + 1\n\n    # Dividing a by 2 until a becomes odd\n    while ((a & 1) == 0):\n        a = a >> 1\n\n    # From here on, 'a' is always odd.\n    while(b != 0):\n\n        # If b is even, remove all\n        # factor of 2 in b\n        while ((b & 1) == 0):\n            b = b >> 1\n\n        # Now a and b are both odd. Swap if\n        # necessary so a <= b, then set\n        # b = b - a (which is even).\n        if (a > b):\n\n            # Swap u and v.\n            temp = a\n            a = b\n            b = temp\n\n        b = (b - a)\n\n    # restore common factors of 2\n    return (a << k)\n\n\n# Driver code\na = 34\nb = 17\n\nprint(\"Gcd of given numbers is \", gcd(a, b))\n\n# This code is contributed by Nikita Tiwari.\n// Iterative C# program to implement\n// Stein's Algorithm\nusing System;\n\nclass GFG {\n\n    // Function to implement Stein's\n    // Algorithm\n    static int gcd(int a, int b)\n    {\n\n        // GCD(0, b) == b; GCD(a, 0) == a,\n        // GCD(0, 0) == 0\n        if (a == 0)\n            return b;\n        if (b == 0)\n            return a;\n\n        // Finding K, where K is the greatest\n        // power of 2 that divides both a and b\n        int k;\n        for (k = 0; ((a | b) & 1) == 0; ++k) \n        {\n            a >>= 1;\n            b >>= 1;\n        }\n\n        // Dividing a by 2 until a becomes odd\n        while ((a & 1) == 0)\n            a >>= 1;\n\n        // From here on, 'a' is always odd\n        do \n        {\n            // If b is even, remove\n            // all factor of 2 in b\n            while ((b & 1) == 0)\n                b >>= 1;\n\n            /* Now a and b are both odd. Swap\n            if necessary so a <= b, then set\n            b = b - a (which is even).*/\n            if (a > b) {\n\n                // Swap u and v.\n                int temp = a;\n                a = b;\n                b = temp;\n            }\n\n            b = (b - a);\n        } while (b != 0);\n\n        /* restore common factors of 2 */\n        return a << k;\n    }\n\n    // Driver code\n    public static void Main()\n    {\n        int a = 34, b = 17;\n\n        Console.Write(\"Gcd of given \"\n                      + \"numbers is \" + gcd(a, b));\n    }\n}\n\n// This code is contributed by nitin mittal\n<script>\n\n// Iterative JavaScript program to\n// implement Stein's Algorithm\n\n// Function to implement\n// Stein's Algorithm\nfunction gcd( a,  b)\n{\n    /* GCD(0, b) == b; GCD(a, 0) == a,\n       GCD(0, 0) == 0 */\n    if (a == 0)\n        return b;\n    if (b == 0)\n        return a;\n\n    /*Finding K, where K is the\n      greatest power of 2\n      that divides both a and b. */\n    let k;\n    for (k = 0; ((a | b) & 1) == 0; ++k) \n    {\n        a >>= 1;\n        b >>= 1;\n    }\n\n    /* Dividing a by 2 until a becomes odd */\n    while ((a & 1) == 0)\n        a >>= 1;\n\n    /* From here on, 'a' is always odd. */\n    do\n    {\n        /* If b is even, remove all factor of 2 in b */\n        while ((b & 1) == 0)\n            b >>= 1;\n\n        /* Now a and b are both odd.\n           Swap if necessary so a <= b,\n           then set b = b - a (which is even).*/\n        if (a > b){\n        let t = a;\n        a = b;\n        b = t;\n        }\n\n        b = (b - a);\n    }while (b != 0);\n\n    /* restore common factors of 2 */\n    return a << k;\n}\n\n// Driver code\n\n    let a = 34, b = 17;\n    document.write(\"Gcd of given numbers is \"+ gcd(a, b));\n\n// This code contributed by gauravrajput1 \n\n</script>\n<?php\n// Iterative php program to \n// implement Stein's Algorithm\n\n// Function to implement \n// Stein's Algorithm\nfunction gcd($a, $b)\n{\n    // GCD(0, b) == b; GCD(a, 0) == a,\n    // GCD(0, 0) == 0\n    if ($a == 0)\n        return $b;\n    if ($b == 0)\n        return $a;\n\n    // Finding K, where K is the greatest\n    // power of 2 that divides both a and b.\n    $k;\n    for ($k = 0; (($a | $b) & 1) == 0; ++$k)\n    {\n        $a >>= 1;\n        $b >>= 1;\n    }\n\n    // Dividing a by 2 until a becomes odd \n    while (($a & 1) == 0)\n        $a >>= 1;\n\n    // From here on, 'a' is always odd.\n    do\n    {\n        \n        // If b is even, remove \n        // all factor of 2 in b \n        while (($b & 1) == 0)\n            $b >>= 1;\n\n        // Now a and b are both odd. Swap\n        // if necessary so a <= b, then set \n        // b = b - a (which is even)\n        if ($a > $b)\n            swap($a, $b); // Swap u and v.\n\n        $b = ($b - $a);\n    } while ($b != 0);\n\n    // restore common factors of 2\n    return $a << $k;\n}\n\n// Driver code\n$a = 34; $b = 17;\necho \"Gcd of given numbers is \" . \n                     gcd($a, $b);\n\n// This code is contributed by ajit\n?>\nGcd of given numbers is 17\n// Recursive C++ program to\n// implement Stein's Algorithm\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Function to implement\n// Stein's Algorithm\nint gcd(int a, int b)\n{\n    if (a == b)\n        return a;\n\n    // GCD(0, b) == b; GCD(a, 0) == a,\n    // GCD(0, 0) == 0\n    if (a == 0)\n        return b;\n    if (b == 0)\n        return a;\n\n    // look for factors of 2\n    if (~a & 1) // a is even\n    {\n        if (b & 1) // b is odd\n            return gcd(a >> 1, b);\n        else // both a and b are even\n            return gcd(a >> 1, b >> 1) << 1;\n    }\n\n    if (~b & 1) // a is odd, b is even\n        return gcd(a, b >> 1);\n\n    // reduce larger number\n    if (a > b)\n        return gcd((a - b) >> 1, b);\n\n    return gcd((b - a) >> 1, a);\n}\n\n// Driver code\nint main()\n{\n    int a = 34, b = 17;\n    printf(\"Gcd of given numbers is %d\\n\", gcd(a, b));\n    return 0;\n}\n// Recursive Java program to\n// implement Stein's Algorithm\nimport java.io.*;\n\nclass GFG {\n\n    // Function to implement\n    // Stein's Algorithm\n    static int gcd(int a, int b)\n    {\n        if (a == b)\n            return a;\n\n        // GCD(0, b) == b; GCD(a, 0) == a,\n        // GCD(0, 0) == 0\n        if (a == 0)\n            return b;\n        if (b == 0)\n            return a;\n\n        // look for factors of 2\n        if ((~a & 1) == 1) // a is even\n        {\n            if ((b & 1) == 1) // b is odd\n                return gcd(a >> 1, b);\n\n            else // both a and b are even\n                return gcd(a >> 1, b >> 1) << 1;\n        }\n\n        // a is odd, b is even\n        if ((~b & 1) == 1)\n            return gcd(a, b >> 1);\n\n        // reduce larger number\n        if (a > b)\n            return gcd((a - b) >> 1, b);\n\n        return gcd((b - a) >> 1, a);\n    }\n\n    // Driver code\n    public static void main(String args[])\n    {\n        int a = 34, b = 17;\n        System.out.println(\"Gcd of given\"\n                           + \"numbers is \" + gcd(a, b));\n    }\n}\n\n// This code is contributed by Nikita Tiwari\n# Recursive Python 3 program to\n# implement Stein's Algorithm\n\n# Function to implement\n# Stein's Algorithm\n\n\ndef gcd(a, b):\n\n    if (a == b):\n        return a\n\n    # GCD(0, b) == b; GCD(a, 0) == a,\n    # GCD(0, 0) == 0\n    if (a == 0):\n        return b\n\n    if (b == 0):\n        return a\n\n    # look for factors of 2\n    # a is even\n    if ((~a & 1) == 1):\n\n        # b is odd\n        if ((b & 1) == 1):\n            return gcd(a >> 1, b)\n        else:\n            # both a and b are even\n            return (gcd(a >> 1, b >> 1) << 1)\n\n    # a is odd, b is even\n    if ((~b & 1) == 1):\n        return gcd(a, b >> 1)\n\n    # reduce larger number\n    if (a > b):\n        return gcd((a - b) >> 1, b)\n\n    return gcd((b - a) >> 1, a)\n\n\n# Driver code\na, b = 34, 17\nprint(\"Gcd of given numbers is \",\n      gcd(a, b))\n\n# This code is contributed\n# by Nikita Tiwari.\n// Recursive C# program to\n// implement Stein's Algorithm\nusing System;\n\nclass GFG {\n\n    // Function to implement\n    // Stein's Algorithm\n    static int gcd(int a, int b)\n    {\n        if (a == b)\n            return a;\n\n        // GCD(0, b) == b;\n        // GCD(a, 0) == a,\n        // GCD(0, 0) == 0\n        if (a == 0)\n            return b;\n        if (b == 0)\n            return a;\n\n        // look for factors of 2\n        // a is even\n        if ((~a & 1) == 1) {\n\n            // b is odd\n            if ((b & 1) == 1)\n                return gcd(a >> 1, b);\n\n            else\n\n                // both a and b are even\n                return gcd(a >> 1, b >> 1) << 1;\n        }\n\n        // a is odd, b is even\n        if ((~b & 1) == 1)\n            return gcd(a, b >> 1);\n\n        // reduce larger number\n        if (a > b)\n            return gcd((a - b) >> 1, b);\n\n        return gcd((b - a) >> 1, a);\n    }\n\n    // Driver code\n    public static void Main()\n    {\n        int a = 34, b = 17;\n        Console.Write(\"Gcd of given\"\n                      + \"numbers is \" + gcd(a, b));\n    }\n}\n\n// This code is contributed by nitin mittal.\n<script>\n\n// JavaScript program to\n// implement Stein's Algorithm\n\n     // Function to implement\n    // Stein's Algorithm\n    function gcd(a, b)\n    {\n        if (a == b)\n            return a;\n \n        // GCD(0, b) == b; GCD(a, 0) == a,\n        // GCD(0, 0) == 0\n        if (a == 0)\n            return b;\n        if (b == 0)\n            return a;\n \n        // look for factors of 2\n        if ((~a & 1) == 1) // a is even\n        {\n            if ((b & 1) == 1) // b is odd\n                return gcd(a >> 1, b);\n \n            else // both a and b are even\n                return gcd(a >> 1, b >> 1) << 1;\n        }\n \n        // a is odd, b is even\n        if ((~b & 1) == 1)\n            return gcd(a, b >> 1);\n \n        // reduce larger number\n        if (a > b)\n            return gcd((a - b) >> 1, b);\n \n        return gcd((b - a) >> 1, a);\n    }\n\n// Driver Code\n\n        let a = 34, b = 17;\n        document.write(\"Gcd of given \"\n                           + \"numbers is \" + gcd(a, b));\n                        \n</script>\n<?php\n// Recursive PHP program to\n// implement Stein's Algorithm\n\n// Function to implement\n// Stein's Algorithm\nfunction gcd($a, $b)\n{\n    if ($a == $b)\n        return $a;\n\n    /* GCD(0, b) == b; GCD(a, 0) == a,\n       GCD(0, 0) == 0 */\n    if ($a == 0)\n        return $b;\n    if ($b == 0)\n        return $a;\n\n    // look for factors of 2\n    if (~$a & 1) // a is even\n    {\n        if ($b & 1) // b is odd\n            return gcd($a >> 1, $b);\n        else // both a and b are even\n            return gcd($a >> 1, $b >> 1) << 1;\n    }\n\n    if (~$b & 1) // a is odd, b is even\n        return gcd($a, $b >> 1);\n\n    // reduce larger number\n    if ($a > $b)\n        return gcd(($a - $b) >> 1, $b);\n\n    return gcd(($b - $a) >> 1, $a);\n}\n\n// Driver code\n$a = 34; $b = 17;\necho \"Gcd of given numbers is: \", \n                     gcd($a, $b);\n\n// This code is contributed by aj_36\n?>\nGcd of given numbers is 17\n",
        "complexity": {
            "time": "Time Complexity: O(N*N) where N is the number of bits in the larger number.Auxiliary Space: O(N*N) where N is the number of bits in the larger number.",
            "space": ""
        },
        "tags": [
            "Mathematical Algorithms"
        ],
        "url": "https://www.geeksforgeeks.org/steins-algorithm-for-finding-gcd/"
    },
    {
        "title": "Juggler Sequence",
        "description": "Juggler Sequence is a series of integer number in which the first term starts with a positive integer number a and the remaining terms are generated from the immediate previous term using the below recurrence relation : Juggler Sequence starting with number 3: 3, 5, 11, 36, 6, 2, 1Juggler Sequence starting with number 9: 9, 27, 140, 11, 36, 6, 2, 1Given a number n we have to print the Juggler Sequence for this number as the first term of the sequence. Examples: Output: Time complexity: O(nlogn) since using a single while loop and finding square root takes logarithmic time. Space complexity: O(1) for constant variables Important Points: Reference: https://en.wikipedia.org/wiki/Juggler_sequence H  ",
        "code": "Input: 9\r\nOutput: 9, 27, 140, 11, 36, 6, 2, 1\r\nWe start with 9 and use above formula to get\r\nnext terms.\r\n\r\nInput: 6\r\nOutput: 6, 2, 1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n3 5 11 36 6 2 1 \r\n9 27 140 11 36 6 2 1\n",
        "complexity": {
            "time": "Time complexity: O(nlogn) since using a single while loop and finding square root takes logarithmic time.",
            "space": "Space complexity: O(1) for constant variables"
        },
        "tags": [
            "Mathematical Algorithms"
        ],
        "url": "https://www.geeksforgeeks.org/juggler-sequence/"
    },
    {
        "title": "Introduction to Chinese Remainder Theorem",
        "description": "We are given two arrays num[0..k-1] and rem[0..k-1]. In num[0..k-1], every pair is coprime (gcd for every pair is 1). We need to find minimum positive number x such that: x % num[0]    =  rem[0], x % num[1]    =  rem[1], …………………..x % num[k-1]  =  rem[k-1] Basically, we are given k numbers which are pairwise coprime, and given remainders of these numbers when an unknown number x is divided by them. We need to find the minimum possible value of x that produces given remainders.Examples: Input:  num[] = {5, 7}, rem[] = {1, 3}Output: 31Explanation: 31 is the smallest number such that: Input:  num[] = {3, 4, 5}, rem[] = {2, 3, 1}Output: 11Explanation: 11 is the smallest number such that: Chinese Remainder Theorem states that there always exists an x that satisfies given congruences. Let num[0], num[1], …num[k-1] be positive integers that are pairwise coprime. Then, for any given sequence of integers rem[0], rem[1], … rem[k-1], there exists an integer x solving the following system of simultaneous congruences.  The first part is clear that there exists an x. The second part basically states that all solutions (including the minimum one) produce the same remainder when divided by-product of num[0], num[1], .. num[k-1]. In the above example, the product is 3*4*5 = 60. And 11 is one solution, other solutions are 71, 131, .. etc. All these solutions produce the same remainder when divided by 60, i.e., they are of form 11 + m*60 where m >= 0. A Naive Approach to find x is to start with 1 and one by one increment it and check if dividing it with given elements in num[] produces corresponding remainders in rem[]. Once we find such an x, we return it. Below is the implementation of the above approach: Output : Time Complexity: O(N * M), where N is the smallest number satisfying all conditions and M is the number of divisors. The worst case occurs when we increment x one by one until we find a valid solution.Space Complexity: O(1), as only a few integer variables are used, with no extra data structures.See below link for an efficient method to find x.Chinese Remainder Theorem | Set 2 (Inverse Modulo based Implementation) R  ",
        "code": "// A C++ program to demonstrate working of Chinese remainder\n// Theorem\n#include<bits/stdc++.h>\nusing namespace std;\n\n// k is size of num[] and rem[].  Returns the smallest\n// number x such that:\n//  x % num[0] = rem[0], \n//  x % num[1] = rem[1], \n//  ..................\n//  x % num[k-2] = rem[k-1]\n// Assumption: Numbers in num[] are pairwise coprime \n// (gcd for every pair is 1)\nint findMinX(int num[], int rem[], int k)\n{\n    int x = 1; // Initialize result\n\n    // As per the Chinese remainder theorem,\n    // this loop will always break.\n    while (true)\n    {\n        // Check if remainder of x % num[j] is \n        // rem[j] or not (for all j from 0 to k-1)\n        int j;\n        for (j=0; j<k; j++ )\n            if (x%num[j] != rem[j])\n               break;\n\n        // If all remainders matched, we found x\n        if (j == k)\n            return x;\n\n        // Else try next number\n        x++;\n    }\n\n    return x;\n}\n\n// Driver method\nint main()\n{\n    int num[] = {3, 4, 5};\n    int rem[] = {2, 3, 1};\n    int k = sizeof(num)/sizeof(num[0]);\n    cout << \"x is \" << findMinX(num, rem, k);\n    return 0;\n}\n// A Java program to demonstrate the working of Chinese remainder\n// Theorem\nimport java.io.*;\n\nclass GfG {\n    \n    // k is size of num[] and rem[].  Returns the smallest\n    // number x such that:\n    //  x % num[0] = rem[0], \n    //  x % num[1] = rem[1], \n    //  ..................\n    //  x % num[k-2] = rem[k-1]\n    // Assumption: Numbers in num[] are pairwise coprime \n    // (gcd for every pair is 1)\n    static int findMinX(int num[], int rem[], int k)\n    {\n        int x = 1; // Initialize result\n     \n        // As per the Chinese remainder theorem,\n        // this loop will always break.\n        while (true)\n        {\n            // Check if remainder of x % num[j] is \n            // rem[j] or not (for all j from 0 to k-1)\n            int j;\n            for (j=0; j<k; j++ )\n                if (x%num[j] != rem[j])\n                   break;\n     \n            // If all remainders matched, we found x\n            if (j == k)\n                return x;\n     \n            // Else try next number\n            x++;\n        }\n     \n    }\n     \n    // Driver method\n    public static void main(String args[])\n    {\n        int num[] = {3, 4, 5};\n        int rem[] = {2, 3, 1};\n        int k = num.length;\n        System.out.println(\"x is \" + findMinX(num, rem, k));\n    }\n}\n# A Python3 program to demonstrate \n# working of Chinise remainder Theorem\n\n# k is size of num[] and rem[]. \n# Returns the smallest number x \n# such that:\n# x % num[0] = rem[0], \n# x % num[1] = rem[1], \n# ..................\n# x % num[k-2] = rem[k-1]\n# Assumption: Numbers in num[] \n# are pairwise coprime (gcd for\n# every pair is 1)\ndef findMinX(num, rem, k):\n    x = 1; # Initialize result\n\n    # As per the Chinise remainder\n    # theorem, this loop will\n    # always break.\n    while(True):\n        \n        # Check if remainder of \n        # x % num[j] is rem[j] \n        # or not (for all j from \n        # 0 to k-1)\n        j = 0;\n        while(j < k):\n            if (x % num[j] != rem[j]):\n                break;\n            j += 1;\n\n        # If all remainders \n        # matched, we found x\n        if (j == k):\n            return x;\n\n        # Else try next number\n        x += 1;\n\n# Driver Code\nif __name__ == \"__main__\":\n    \n    num = [3, 4, 5];\n    rem = [2, 3, 1];\n    k = len(num);\n    print(\"x is\", findMinX(num, rem, k));\n// C# program to demonstrate working\n// of Chinise remainder Theorem\nusing System;\n\nclass GFG\n{\n    \n    // k is size of num[] and rem[]. \n    // Returns the smallest\n    // number x such that:\n    // x % num[0] = rem[0], \n    // x % num[1] = rem[1], \n    // ..................\n    // x % num[k-2] = rem[k-1]\n    // Assumption: Numbers in num[] \n    // are pairwise coprime \n    // (gcd for every pair is 1)\n    static int findMinX(int []num, int []rem,\n                        int k)\n    {\n        \n        // Initialize result\n        int x = 1; \n    \n        // As per the Chinese remainder theorem,\n        // this loop will always break.\n        while (true)\n        {\n            // Check if remainder of x % num[j] is \n            // rem[j] or not (for all j from 0 to k-1)\n            int j;\n            for (j = 0; j < k; j++ )\n                if (x % num[j] != rem[j])\n                break;\n    \n            // If all remainders matched, we found x\n            if (j == k)\n                return x;\n    \n            // Else try next number\n            x++;\n        }\n    \n    }\n    \n    // Driver code\n    public static void Main()\n    {\n        int []num = {3, 4, 5};\n        int []rem = {2, 3, 1};\n        int k = num.Length;\n        Console.WriteLine(\"x is \" + findMinX(num, \n                                        rem, k));\n    }\n}\n// A javascript program to demonstrate the working of Chinese remainder\n// Theorem\n   \n// k is size of num and rem.  Returns the smallest\n// number x such that:\n//  x % num[0] = rem[0], \n//  x % num[1] = rem[1], \n//  ..................\n//  x % num[k-2] = rem[k-1]\n// Assumption: Numbers in num are pairwise coprime \n// (gcd for every pair is 1)\nfunction findMinX(num , rem , k)\n{\n    var x = 1; // Initialize result\n \n    // As per the Chinese remainder theorem,\n    // this loop will always break.\n    while (true)\n    {\n        // Check if remainder of x % num[j] is \n        // rem[j] or not (for all j from 0 to k-1)\n        var j;\n        for (j=0; j<k; j++ )\n            if (x%num[j] != rem[j])\n               break;\n \n        // If all remainders matched, we found x\n        if (j == k)\n            return x;\n \n        // Else try next number\n        x++;\n    }\n \n}\n \n// Driver method\nvar num = [3, 4, 5];\nvar rem = [2, 3, 1];\nvar k = num.length;\nconsole.log(\"x is \" + findMinX(num, rem, k));\nx is 11\n",
        "complexity": {
            "time": "Time Complexity: O(N * M), where N is the smallest number satisfying all conditions and M is the number of divisors. The worst case occurs when we increment x one by one until we find a valid solution.Space Complexity: O(1), as only a few integer variables are used, with no extra data structures.See below link for an efficient method to find x.Chinese Remainder Theorem | Set 2 (Inverse Modulo based Implementation)",
            "space": ""
        },
        "tags": [
            "Mathematical Algorithms"
        ],
        "url": "https://www.geeksforgeeks.org/introduction-to-chinese-remainder-theorem/"
    },
    {
        "title": "Quiz on Fibonacci Numbers",
        "description": "Question 1 What is the Fibonacci sequence? A sequence of odd numbers A sequence of even numbers A sequence of prime numbers A sequence of numbers where each number is the sum of the two preceding ones Question 2 Choose the recursive formula for the Fibonacci series.(n>=1) F(n) = F(n+1) + F(n+2) F(n) = F(n) + F(n+1) F(n) = F(n-1) + F(n-2) F(n) = F(n-1) – F(n-2) Question 3 Guess the next value of the Fibonacci sequence: 21, 34, 55, ___, 144. 89 63 83 43 Question 4 What is the time complexity of calculating the nth Fibonacci number using dynamic programming? O(N) O(logN) O(2^N) O(N^2) Question 5 Which of the following algorithms is efficient for calculating Fibonacci numbers, especially for large values of n? Brute-force recursion Depth-First Search (DFS) Sieve of Eratosthenes Dynamic programming Question 6 What is wrong with the below code? we have not assigned the first and second value of the list we have declared the arry of size n+2 the loop must be run till (i<n). None Question 7 What is the value of F(6) when the value of F(0)= 0 and F(1)=1 in the Fibonacci sequence? 6 5 8 13 Question 8 What is the output of the below recursive code of the Fibonacci algorithm? Linear Constant Exponential None Question 9 What is the space used in the below Fibonacci program? O(1) O(LogN) O(N) O(N^2) Question 10 What should be the base condition for the below recursive code? if(n>=1) return 0; if(n<=1) return 0; if(n< 1 ) return n; if(n<=1) return n; There are 10 questions to complete. ",
        "code": "int fib(int n)\n{\n        \n    int f[n + 2];\n        int i;\n     \n for (i = 2; i <= n; i++)\n    {\n     f[i] = f[i - 1] + f[i - 2];        \n    }\n     \n    return f[n];\n}\nint fib(int n)\n{\n       if (n <= 1) return n;\n\n        return fib(n - 1) + fib(n - 2);\n}\nint fib(int n)\n{\n        int f[n + 2];\n        int i;\n\n        f[0] = 0;\n        f[1] = 1;\n \n        for (i = 2; i <= n; i++) {\n            f[i] = f[i - 1] + f[i - 2];\n        }\n        return f[n];\n}\nint fib(int n)\n{\n        //Base condition\n\n    return fib(n - 1) + fib(n - 2);\n}\n",
        "complexity": {
            "time": "What is the time complexity of calculating the nth Fibonacci number using dynamic programming?",
            "space": ""
        },
        "tags": [
            "Mathematical Algorithms"
        ],
        "url": "https://www.geeksforgeeks.org/quiz-on-fibonacci-numbers/"
    },
    {
        "title": "DSA Tutorial - Learn Data Structures and Algorithms",
        "description": "DSA (Data Structures and Algorithms)  is the study of organizing data efficiently using data structures like arrays, stacks, and trees, paired with step-by-step procedures (or algorithms) to solve problems effectively. Data structures manage how data is stored and accessed, while algorithms focus on processing this data. Hoping you have learned a programming language of your choice, here comes the next stage of the roadmap - Learn about Time and Space Complexities. Once you have learned basics of a programming language, it is recommended that you learn basic logic building To analyze algorithms, we mainly measure order of growth of time or space taken in terms of input size.  We do this in the worst case scenario in most of the cases. Please refer the below links for a clear understanding of these concepts. Array is a linear data structure where elements are allocated contiguous memory, allowing for constant-time access. Searching algorithms are used to locate specific data within a large set of data. It helps find a target value within the data. There are various types of searching algorithms, each with its own approach and efficiency. Sorting algorithms are used to arrange the elements of a list in a specific order, such as numerical or alphabetical. It organizes the items in a systematic way, making it easier to search for and access specific elements. Hashing is a technique that generates a fixed-size output (hash value) from an input of variable size using mathematical formulas called hash functions. Hashing is commonly used in data structures for efficient searching, insertion and deletion. In Two Pointer Technique, we typically use two index variables from two corners of an array. We use the two pointer technique for searching a required point or value in an array. In Window Sliding Technique, we use the result of previous subarray to quickly compute the result of current. In Prefix Sum Technique, we compute prefix sums of an array to quickly find results for a subarray. String is a sequence of characters, typically immutable and have limited set of elements (lower case or all English alphabets). Recursion is a programming technique where a function calls itself within its own definition. It is usually used to solve problems that can be broken down into smaller instances of the same problem. Matrix is a two-dimensional array of elements, arranged in rows and columns. It is represented as a rectangular grid, with each element at the intersection of a row and column. Linked list is a linear data structure that stores data in nodes, which are connected by pointers. Unlike arrays, nodes of linked lists are not stored in contiguous memory locations and can only be accessed sequentially, starting from the head of list. Stack is a linear data structure that follows the Last In, First Out (LIFO) principle. Stacks play an important role in managing function calls, memory, and are widely used in algorithms like stock span problem, next greater element and largest area in a histogram. Queue is a linear data structure that follows the First In, First Out (FIFO) principle. Queues play an important role in managing tasks or data in order, scheduling and message handling systems. A deque (double-ended queue) is a data structure that allows elements to be added or removed from both ends efficiently. Tree is a non-linear, hierarchical data structure consisting of nodes connected by edges, with a top node called the root and nodes having child nodes. It is widely used in file systems, databases, decision-making algorithms, etc. Heap is a complete binary tree data structure that satisfies the heap property. Heaps are usually used to implement priority queues, where the smallest or largest element is always at the root of the tree. Graph is a non-linear data structure consisting of a finite set of vertices(or nodes) and a set of edges(or links)that connect a pair of nodes. Graphs are widely used to represent relationships between entities. Greedy Algorithm builds up the solution one piece at a time and chooses the next piece which gives the most obvious and immediate benefit i.e., which is the most optimal choice at that moment. So the problems where choosing locally optimal also leads to the global solutions are best fit for Greedy. Dynamic Programming is a method used to solve complex problems by breaking them down into simpler subproblems. By solving each subproblem only once and storing the results, it avoids redundant computations, leading to more efficient solutions for a wide range of problems. Bitwise Algorithms: Operate on individual bits of numbers. Backtracking Algorithm : Follow Recursion  with the option to revert and traces back if the solution from current point is not feasible. Divide and conquer:  A strategy to solve problems by dividing them into smaller subproblems, solving those subproblems, and combining the solutions to obtain the final solution. Branch and Bound : Used in combinatorial optimization problems to systematically search for the best solution. It works by dividing the problem into smaller subproblems, or branches, and then eliminating certain branches based on bounds on the optimal solution. This process continues until the best solution is found or all branches have been explored. Geometric algorithms are a set of algorithms that solve problems related to shapes, points, lines and polygons. Randomized algorithms are algorithms that use randomness to solve problems. They make use of random input to achieve their goals, often leading to simpler and more efficient solutions. These algorithms may not product same result but are particularly useful in situations when a probabilistic approach is acceptable. Advanced Data Structures like Trie, Segment Tree, Red-Black Tree and Binary Indexed Tree offer significant performance improvements for specific problem domains. They provide efficient solutions for tasks like fast prefix searches, range queries, dynamic updates, and maintaining balanced data structures, which are crucial for handling large datasets and real-time processing. By optimizing time complexity, they enable better scalability and faster execution in many computational problems. R  ",
        "code": "",
        "complexity": {
            "time": "Advanced Data Structures like Trie, Segment Tree, Red-Black Tree and Binary Indexed Tree offer significant performance improvements for specific problem domains. They provide efficient solutions for tasks like fast prefix searches, range queries, dynamic updates, and maintaining balanced data structures, which are crucial for handling large datasets and real-time processing. By optimizing time complexity, they enable better scalability and faster execution in many computational problems.",
            "space": ""
        },
        "tags": [
            "Pattern Searching"
        ],
        "url": "https://www.geeksforgeeks.org/learn-data-structures-and-algorithms-dsa-tutorial/"
    },
    {
        "title": "No Title",
        "description": "",
        "code": "",
        "complexity": {
            "time": "",
            "space": ""
        },
        "tags": [
            "Pattern Searching"
        ],
        "url": "https://www.geeksforgeeks.org/explore?page=1&category=pattern-printing&sortBy=submissions"
    },
    {
        "title": "Introduction to Pattern Searching – Data Structure and Algorithm Tutorial",
        "description": "Pattern searching is an algorithm that involves searching for patterns such as strings, words, images, etc. We use certain algorithms to do the search process. The complexity of pattern searching varies from algorithm to algorithm. They are very useful when performing a search in a database. The Pattern Searching algorithm is useful for finding patterns in substrings of larger strings. This process can be accomplished using a variety of algorithms that we are going to discuss in this blog. Introduction to Pattern Searching – Data Structure and Algorithm Tutorial Naive pattern searching is the simplest method among other pattern-searching algorithms. It checks for all characters of the main string to the pattern. This algorithm is helpful for smaller texts. It does not need any pre-processing phases. We can find the substring by checking once for the string. It also does not occupy extra space to perform the operation. Compare text characters with pattern characters The time complexity of Naive Pattern Search method is O(m*n). The m is the size of pattern and n is the size of the main string. Time Complexity: O(N*M)Auxiliary Space: O(1) KMP algorithm is used to find a “Pattern” in a “Text”. This algorithm compares character by character from left to right. But whenever a mismatch occurs, it uses a preprocessed table called “Prefix Table” to skip characters comparison while matching. Sometimes prefix table is also known as LPS Table. Here LPS stands for “Longest proper Prefix which is also Suffix”. We use the LPS table to decide how many characters are to be skipped for comparison when a mismatch has occurred.When a mismatch occurs, check the LPS value of the previous character of the mismatched character in the pattern. If it is ‘0’ then start comparing the first character of the pattern with the next character to the mismatched character in the text. If it is not ‘0’ then start comparing the character which is at an index value equal to the LPS value of the previous character to the mismatched character in pattern with the mismatched character in the Text. Example of KMP algorithm Compare first character of pattern with first character of text from left to right Compare first character of pattern with next character of text Compare pattern[0] and pattern[1] values Compare pattern[0] with next characters in text. Compare pattern[2] with mismatched characters in text. Let’s take a look on working example of KMP Algorithm to find a Pattern in a Text. LPS table Define variables Compare A with B Compare A with C Compare A with D Compare A with A Compare B with B Compare C with D Compare A with D Implementation of the KMP algorithm: Time complexity: O(n + m)Auxiliary Space: O(M) Rabin-Karp algorithm is an algorithm used for searching/matching patterns in the text using a hash function. Unlike Naive string-matching algorithm, it does not travel through every character in the initial phase rather it filters the characters that do not match and then perform the comparison. Rabin-Karp compares a string’s hash values, rather than the strings themselves. For efficiency, the hash value of the next position in the text is easily computed from the hash value of the current position. Example of Rabin Karp Below is the implementation of the Rabin-Karp algorithm. Time Complexity: Space Complexity : The space complexity of the Rabin-Karp algorithm is O(1), which means that it is a constant amount of memory that is required, regardless of the size of the input text and pattern. This is because the algorithm only needs to store a few variables that are updated as the algorithm progresses through the text and pattern. Specifically, the algorithm needs to store the hash value of the pattern, the hash value of the current window in the text, and a few loop counters and temporary variables. Since the size of these variables is fixed, the space complexity is constant. This algorithm finds all occurrences of a pattern in a text in linear time. Let length of text be n and of pattern be m, then total time taken is O(m + n) with linear space complexity. Z algorithm works by maintaining an auxiliary array called the Z array. This Z array stores the length of the longest substring, starting from the current index, that also it’s prefix. For a string str[0..n-1], Z array is of same length as string. An element Z[i] of Z array stores length of the longest substring starting from str[i] which is also a prefix of str[0..n-1]. The first entry of Z array is meaning less as complete string is always prefix of itself. Example: Index            0   1   2   3   4   5   6   7   8   9  10  11 Text             a   a   b   c   a   a   b   x   a   a   a   zZ values         X   1   0   0   3   1   0   0   2   2   1   0 A Simple Solution is to run two nested loops, the outer loop goes to every index and the inner loop finds length of the longest prefix that matches the substring starting at current index. The time complexity of this solution is O(n2). We can construct Z array in linear time. The idea is to maintain an interval [L, R] which is the interval with max Rsuch that [L, R] is prefix substring (substring which is also a prefix. Steps for maintaining this interval are as follows – Construction of Z array Below is the implementation of the Z algorithm: Time Complexity: O(m+n), where m is length of pattern and n is length of text.Auxiliary Space: O(m+n) Aho-Corasick Algorithm finds all words in O(n + m + z) time where z is the total number of occurrences of words in text. The Aho–Corasick string matching algorithm formed the basis of the original Unix command “fgrep”. Preprocessing: Build an automaton of all words in arr[] The automaton has mainly three functions: Go To:  This function simply follows edges of Trie of all words in arr[]. It is represented as 2D array g[][] where we store next state for current state and character. Failure: This function stores all edges that are followed when current character doesn’t have edge in Trie.It is represented as1D array f[] where we store next state for current state. Output: Stores indexes of all words that end at current state. It is represented as 1D  array o[] where we store indices of all matching words as a bitmap for current state. Matching: Traverse the given text over built automaton to find all matching words.Preprocessing: Preprocessing: We first Build a Trie (or Keyword Tree) of all words. Build a Trie (or Keyword Tree) of all words. Fills entries in goto g[][] and output o[] Go to:  We build Trie. And for all characters which don’t have an edge at the root, we add an edge back to root.Failure:  For a state s, we find the longest proper suffix which is a proper prefix of some pattern. This is done using Breadth First Traversal of Trie.Output: For a state s, indexes of all words ending at s are stored. These indexes are stored as bitwise map (by doing bitwise OR of values). This is also computing using Breadth First Traversal with Failure. Below is the implementation of the Aho-Corasick Algorithm: Time Complexity: O(n + l + z), where ‘n’ is the length of the text, ‘l’ is the length of keywords, and ‘z’ is the number of matches.Auxiliary Space: O(l * q), where ‘q’ is the length of the alphabet since that is the maximum number of children a node can have. H  ",
        "code": "// C++ program for Naive Pattern\n// Searching algorithm\n#include <bits/stdc++.h>\nusing namespace std;\n\nvoid search(char* pat, char* txt)\n{\n    int M = strlen(pat);\n    int N = strlen(txt);\n\n    /* A loop to slide pat[] one by one */\n    for (int i = 0; i <= N - M; i++) {\n        int j;\n\n        /* For current index i, check for pattern match */\n        for (j = 0; j < M; j++)\n            if (txt[i + j] != pat[j])\n                break;\n\n        if (j\n            == M) // if pat[0...M-1] = txt[i, i+1, ...i+M-1]\n            cout << \"Pattern found at index \" << i << endl;\n    }\n}\n\n// Driver's Code\nint main()\n{\n    char txt[] = \"AABAACAADAABAAABAA\";\n    char pat[] = \"AABA\";\n\n    // Function call\n    search(pat, txt);\n    return 0;\n}\n// Java program for Naive Pattern\n// Searching algorithm\nclass GFG {\n\n  static void search(char[] pat, char[] txt)\n  {\n    int M = pat.length;\n    int N = txt.length;\n\n    /* A loop to slide pat[] one by one */\n    for (int i = 0; i <= N - M; i++) {\n      int j;\n\n      /* For current index i, check for pattern match\n             */\n      for (j = 0; j < M; j++)\n        if (txt[i + j] != pat[j])\n          break;\n\n      // if pat[0...M-1] = txt[i, i+1, ...i+M-1]\n      if (j == M)\n        System.out.println(\"Pattern found at index \"\n                           + i);\n    }\n  }\n\n  // Driver's Code\n\n  public static void main(String[] args)\n  {\n    char txt[] = \"AABAACAADAABAAABAA\".toCharArray();\n\n    char pat[] = \"AABA\".toCharArray();\n\n    // Function call\n    search(pat, txt);\n  }\n}\n\n// This code is contributed by karandeep1234\ndef search(pat, txt):\n    M = len(pat)\n    N = len(txt)\n\n    # A loop to slide pat[] one by one\n    for i in range(N - M + 1):\n        j = 0\n\n        # For current index i, check for pattern match\n        while j < M:\n            if txt[i + j] != pat[j]:\n                break\n            j += 1\n\n        if j == M:  # if pat[0...M-1] = txt[i, i+1, ...i+M-1]\n            print(f\"Pattern found at index {i}\")\n\n\n# Driver's Code\ntxt = \"AABAACAADAABAAABAA\"\npat = \"AABA\"\n\n# Function call\nsearch(pat, txt)\nusing System;\n\npublic class GFG {\n\n  public static void search(char[] pat, char[] txt)\n  {\n    int M = pat.Length;\n    int N = txt.Length;\n\n    /* A loop to slide pat[] one by one */\n    for (int i = 0; i <= N - M; i++) {\n      int j;\n\n      /* For current index i, check for pattern match\n             */\n      for (j = 0; j < M; j++)\n        if (txt[i + j] != pat[j])\n          break;\n\n      if (j == M) // if pat[0...M-1] = txt[i, i+1,\n        // ...i+M-1]\n        Console.WriteLine(\"Pattern found at index \"\n                          + i);\n    }\n  }\n\n  static public void Main()\n  {\n\n    char[] txt = \"AABAACAADAABAAABAA\".ToCharArray();\n    char[] pat = \"AABA\".ToCharArray();\n\n    // Function call\n    search(pat, txt);\n  }\n}\n// This code is contributed by akashish__\n// JS program for Naive Pattern\n// Searching algorithm\nfunction search(pat, txt)\n{\n    let M = pat.length;\n    let N = txt.length;\n    \n    /* A loop to slide pat[] one by one */\n    for (let i = 0; i <= N - M; i++) {\n        let j = 0;\n        \n        /* For current index i, check for pattern match */\n        for (j = 0; j < M; j++)\n            if (txt[i + j] != pat[j])\n                break;\n        if (j == M) // if pat[0...M-1] = txt[i, i+1, ...i+M-1]\n            console.log(\"Pattern found at index\",i);\n    }\n}\n\n// Driver's Code\n    let txt = \"AABAACAADAABAAABAA\";\n    let pat = \"AABA\";\n    \n    // Function call\n    search(pat, txt);\n    \n    // This code is contributed by ishankhandelwals.\nPattern found at index 0\nPattern found at index 9\nPattern found at index 13\n// C++ program for implementation of KMP pattern searching\n// algorithm\n#include <bits/stdc++.h>\n\nvoid computeLPSArray(char* pat, int M, int* lps);\n\n// Prints occurrences of txt[] in pat[]\nvoid KMPSearch(char* pat, char* txt)\n{\n    int M = strlen(pat);\n    int N = strlen(txt);\n\n    // create lps[] that will hold the longest prefix suffix\n    // values for pattern\n    int lps[M];\n\n    // Preprocess the pattern (calculate lps[] array)\n    computeLPSArray(pat, M, lps);\n\n    int i = 0; // index for txt[]\n    int j = 0; // index for pat[]\n    while ((N - i) >= (M - j)) {\n        if (pat[j] == txt[i]) {\n            j++;\n            i++;\n        }\n\n        if (j == M) {\n            printf(\"Found pattern at index %d \", i - j);\n            j = lps[j - 1];\n        }\n\n        // mismatch after j matches\n        else if (i < N && pat[j] != txt[i]) {\n            // Do not match lps[0..lps[j-1]] characters,\n            // they will match anyway\n            if (j != 0)\n                j = lps[j - 1];\n            else\n                i = i + 1;\n        }\n    }\n}\n\n// Fills lps[] for given pattern pat[0..M-1]\nvoid computeLPSArray(char* pat, int M, int* lps)\n{\n    // length of the previous longest prefix suffix\n    int len = 0;\n\n    lps[0] = 0; // lps[0] is always 0\n\n    // the loop calculates lps[i] for i = 1 to M-1\n    int i = 1;\n    while (i < M) {\n        if (pat[i] == pat[len]) {\n            len++;\n            lps[i] = len;\n            i++;\n        }\n        else // (pat[i] != pat[len])\n        {\n            // This is tricky. Consider the example.\n            // AAACAAAA and i = 7. The idea is similar\n            // to search step.\n            if (len != 0) {\n                len = lps[len - 1];\n\n                // Also, note that we do not increment\n                // i here\n            }\n            else // if (len == 0)\n            {\n                lps[i] = 0;\n                i++;\n            }\n        }\n    }\n}\n\n// Driver program to test above function\nint main()\n{\n    char txt[] = \"ABABDABACDABABCABAB\";\n    char pat[] = \"ABABCABAB\";\n    KMPSearch(pat, txt);\n    return 0;\n}\n// Java program for implementation of KMP pattern searching \n// algorithm\npublic class KMP_String_Matching { \n    void KMPSearch(String pat, String txt) \n    { \n        int M = pat.length(); \n        int N = txt.length(); \n\n        // create lps[] that will hold the longest prefix suffix \n        // values for pattern \n        int lps[] = new int[M]; \n        int j = 0; // index for pat[] \n\n        // Preprocess the pattern (calculate lps[] array) \n        computeLPSArray(pat, M, lps); \n\n        int i = 0; // index for txt[] \n        while (i < N) { \n            if (pat.charAt(j) == txt.charAt(i)) { \n                j++; \n                i++; \n            } \n            if (j == M) { \n                System.out.println(\"Found pattern \" + \"at index \" + (i - j)); \n                j = lps[j - 1]; \n            } \n\n            // mismatch after j matches \n            else if (i < N && pat.charAt(j) != txt.charAt(i)) { \n                // Do not match lps[0..lps[j-1]] characters, \n                // they will match anyway \n                if (j != 0) \n                    j = lps[j - 1]; \n                else\n                    i = i + 1; \n            } \n        } \n    } \n\n    void computeLPSArray(String pat, int M, int lps[]) \n    { \n        // length of the previous longest prefix suffix \n        int len = 0; \n        int i = 1; \n        lps[0] = 0; // lps[0] is always 0 \n\n        // the loop calculates lps[i] for i = 1 to M-1 \n        while (i < M) { \n            if (pat.charAt(i) == pat.charAt(len)) { \n                len++; \n                lps[i] = len; \n                i++; \n            } \n            else // (pat[i] != pat[len]) \n            { \n                // This is tricky. Consider the example. \n                // AAACAAAA and i = 7. The idea is similar \n                // to search step. \n                if (len != 0) { \n                    len = lps[len - 1]; \n\n                    // Also, note that we do not increment \n                    // i here \n                } \n                else // if (len == 0) \n                { \n                    lps[i] = len; \n                    i++; \n                } \n            } \n        } \n    } \n\n    // Driver program to test above function \n    public static void main(String[] args) \n    { \n        String txt = \"ABABDABACDABABCABAB\"; \n        String pat = \"ABABCABAB\"; \n        new KMP_String_Matching().KMPSearch(pat, txt); \n    } \n}\n# Python program for implementation of KMP pattern searching\n# algorithm\ndef computeLPSArray(pat, M, lps):\n    len = 0  # length of the previous longest prefix suffix\n\n    lps[0]  # lps[0] is always 0\n    i = 1\n\n    # the loop calculates lps[i] for i = 1 to M-1\n    while i < M:\n        if pat[i] == pat[len]:\n            len += 1\n            lps[i] = len\n            i += 1\n        else:\n            # This is tricky. Consider the example.\n            # AAACAAAA and i = 7. The idea is similar\n            # to search step.\n            if len != 0:\n                len = lps[len-1]\n\n            # Also, note that we do not increment i here\n            else:\n                lps[i] = 0\n                i += 1\n\ndef KMPSearch(pat, txt):\n    M = len(pat)\n    N = len(txt)\n\n    # create lps[] that will hold the longest prefix suffix\n    # values for pattern\n    lps = [0]*M\n    j = 0  # index for pat[]\n\n    # Preprocess the pattern (calculate lps[] array)\n    computeLPSArray(pat, M, lps)\n\n    i = 0  # index for txt[]\n    while (N - i) >= (M - j):\n        if pat[j] == txt[i]:\n            j += 1\n            i += 1\n\n        if j == M:\n            print(\"Found pattern at index:\", i-j)\n            j = lps[j-1]\n\n        # mismatch after j matches\n        elif i < N and pat[j] != txt[i]:\n            # Do not match lps[0..lps[j-1]] characters,\n            # they will match anyway\n            if j != 0:\n                j = lps[j-1]\n            else:\n                i += 1\n\ntxt = \"ABABDABACDABABCABAB\"\npat = \"ABABCABAB\"\nKMPSearch(pat, txt)\n\n# This code is contributed by ishankhandelwals.\nusing System;\nusing System.Collections.Generic;\n\npublic class GFG {\n\n  // Prints occurrences of txt[] in pat[]\n  public static void KMPSearch(char[] pat, char[] txt)\n  {\n    int M = pat.Length;\n    int N = txt.Length;\n\n    // create lps[] that will hold the longest prefix\n    // suffix values for pattern\n    int[] lps = new int[M];\n\n    // Preprocess the pattern (calculate lps[] array)\n    computeLPSArray(pat, M, lps);\n\n    int i = 0; // index for txt[]\n    int j = 0; // index for pat[]\n    while ((N - i) >= (M - j)) {\n      if (pat[j] == txt[i]) {\n        j++;\n        i++;\n      }\n\n      if (j == M) {\n        int temp = i - j;\n        Console.WriteLine(\"Found pattern at index \"\n                          + temp);\n        j = lps[j - 1];\n      }\n\n      // mismatch after j matches\n      else if (i < N && pat[j] != txt[i]) {\n        // Do not match lps[0..lps[j-1]] characters,\n        // they will match anyway\n        if (j != 0)\n          j = lps[j - 1];\n        else\n          i = i + 1;\n      }\n    }\n  }\n\n  // Fills lps[] for given pattern pat[0..M-1]\n  public static void computeLPSArray(char[] pat, int M,\n                                     int[] lps)\n  {\n    // length of the previous longest prefix suffix\n    int len = 0;\n\n    lps[0] = 0; // lps[0] is always 0\n\n    // the loop calculates lps[i] for i = 1 to M-1\n    int i = 1;\n    while (i < M) {\n      if (pat[i] == pat[len]) {\n        len++;\n        lps[i] = len;\n        i++;\n      }\n      else // (pat[i] != pat[len])\n      {\n        // This is tricky. Consider the example.\n        // AAACAAAA and i = 7. The idea is similar\n        // to search step.\n        if (len != 0) {\n          len = lps[len - 1];\n\n          // Also, note that we do not increment\n          // i here\n        }\n        else // if (len == 0)\n        {\n          lps[i] = 0;\n          i++;\n        }\n      }\n    }\n  }\n\n  static public void Main()\n  {\n\n    char[] txt = \"ABABDABACDABABCABAB\".ToCharArray();\n    char[] pat = \"ABABCABAB\".ToCharArray();\n    KMPSearch(pat, txt);\n  }\n}\n\n// This code is contributed by akashish__\n// JS program for implementation of KMP pattern searching\n// algorithm\n// Prlets occurrences of txt[] in pat[]\nfunction computeLPSArray(pat, M, lps)\n{\n\n    // length of the previous longest prefix suffix\n    let len = 0;\n    lps[0] = 0; // lps[0] is always 0\n    // the loop calculates lps[i] for i = 1 to M-1\n    let i = 1;\n    while (i < M) {\n        if (pat[i] == pat[len]) {\n            len++;\n            lps[i] = len;\n            i++;\n        }\n        else // (pat[i] != pat[len])\n        {\n        \n            // This is tricky. Consider the example.\n            // AAACAAAA and i = 7. The idea is similar\n            // to search step.\n            if (len != 0) {\n                len = lps[len - 1];\n                \n                // Also, note that we do not increment\n                // i here\n            }\n            else // if (len == 0)\n            {\n                lps[i] = 0;\n                i++;\n            }\n        }\n    }\n}\nfunction KMPSearch(pat, txt) {\n    let M = pat.length;\n    let N = txt.length\n    \n    // create lps[] that will hold the longest prefix suffix\n    // values for pattern\n    let lps = [];\n    \n    // Preprocess the pattern (calculate lps[] array)\n    computeLPSArray(pat, M, lps);\n    let i = 0; // index for txt[]\n    let j = 0; // index for pat[]\n    while ((N - i) >= (M - j)) {\n        if (pat[j] == txt[i]) {\n            j++;\n            i++;\n        }\n        if (j == M) {\n            console.log(\"Found pattern at index:\", i - j);\n            j = lps[j - 1];\n        }\n        \n        // mismatch after j matches\n        else if (i < N && pat[j] != txt[i])\n        {\n        \n            // Do not match lps[0..lps[j-1]] characters,\n            // they will match anyway\n            if (j != 0)\n                j = lps[j - 1];\n            else\n                i = i + 1;\n        }\n    }\n}\n\n// Fills lps[] for given pattern pat[0..M-1]\n// Driver program to test above function\nlet txt = \"ABABDABACDABABCABAB\";\nlet pat = \"ABABCABAB\";\nKMPSearch(pat, txt);\n\n// This code is contributed by ishankhandelwals.\nFound pattern at index 10\n/* Following program is a C++ implementation of Rabin Karp\nAlgorithm given in the CLRS book */\n#include <bits/stdc++.h>\nusing namespace std;\n\n// d is the number of characters in the input alphabet\n#define d 256\n\n/* pat -> pattern\n    txt -> text\n    q -> A prime number\n*/\nvoid search(char pat[], char txt[], int q)\n{\n    int M = strlen(pat);\n    int N = strlen(txt);\n    int i, j;\n    int p = 0; // hash value for pattern\n    int t = 0; // hash value for txt\n    int h = 1;\n\n    // The value of h would be \"pow(d, M-1)%q\"\n    for (i = 0; i < M - 1; i++)\n        h = (h * d) % q;\n\n    // Calculate the hash value of pattern and first\n    // window of text\n    for (i = 0; i < M; i++) {\n        p = (d * p + pat[i]) % q;\n        t = (d * t + txt[i]) % q;\n    }\n\n    // Slide the pattern over text one by one\n    for (i = 0; i <= N - M; i++) {\n\n        // Check the hash values of current window of text\n        // and pattern. If the hash values match then only\n        // check for characters one by one\n        if (p == t) {\n            /* Check for characters one by one */\n            for (j = 0; j < M; j++) {\n                if (txt[i + j] != pat[j]) {\n                    break;\n                }\n            }\n\n            // if p == t and pat[0...M-1] = txt[i, i+1,\n            // ...i+M-1]\n\n            if (j == M)\n                cout << \"Pattern found at index \" << i\n                     << endl;\n        }\n\n        // Calculate hash value for next window of text:\n        // Remove leading digit, add trailing digit\n        if (i < N - M) {\n            t = (d * (t - txt[i] * h) + txt[i + M]) % q;\n\n            // We might get negative value of t, converting\n            // it to positive\n            if (t < 0)\n                t = (t + q);\n        }\n    }\n}\n\n/* Driver code */\nint main()\n{\n    char txt[] = \"GEEKS FOR GEEKS\";\n    char pat[] = \"GEEK\";\n\n    // we mod to avoid overflowing of value but we should\n    // take as big q as possible to avoid the collison\n    int q = INT_MAX;\n\n    // Function Call\n    search(pat, txt, q);\n    return 0;\n}\n\n// This is code is contributed by rathbhupendra\nimport java.io.*;\nimport java.lang.*;\nimport java.util.*;\n\n/* pat -> pattern\n    txt -> text\n    q -> A prime number\n*/\npublic class GFG {\n  // d is the number of characters in the input alphabet\n  public final static int d = 256;\n  public static void search(String pat, String txt, int q)\n  {\n    int M = pat.length();\n    int N = txt.length();\n    int i, j;\n    int p = 0; // hash value for pattern\n    int t = 0; // hash value for txt\n    int h = 1;\n\n    // The value of h would be \"pow(d, M-1)%q\"\n    for (i = 0; i < M - 1; i++)\n      h = (h * d) % q;\n    // Calculate the hash value of pattern and first\n    // window of text\n    for (i = 0; i < M; i++) {\n      p = (d * p + pat.charAt(i)) % q;\n      t = (d * t + txt.charAt(i)) % q;\n    }\n\n    // Slide the pattern over text one by one\n    for (i = 0; i <= N - M; i++) {\n\n      // Check the hash values of current window of\n      // text and pattern. If the hash values match\n      // then only check for characters one by one\n      if (p == t) {\n        /* Check for characters one by one */\n        for (j = 0; j < M; j++) {\n          if (txt.charAt(i + j)\n              != pat.charAt(j)) {\n            break;\n          }\n        }\n\n        // if p == t and pat[0...M-1] = txt[i, i+1,\n        // ...i+M-1]\n\n        if (j == M) {\n          System.out.println(\n            \"Pattern found at index \" + i);\n        }\n      }\n      // Calculate hash value for next window of text:\n      // Remove leading digit, add trailing digit\n      if (i < N - M) {\n        t = (d * (t - txt.charAt(i) * h)\n             + txt.charAt(i + M))\n          % q;\n\n        // We might get negative value of t,\n        // converting it to positive\n        if (t < 0)\n          t = (t + q);\n      }\n    }\n  }\n\n  /* Driver code */\n  public static void main(String[] args)\n  {\n    String txt = \"GEEKS FOR GEEKS\";\n    String pat = \"GEEK\";\n\n    // A prime number\n    int q = 101;\n\n    // Function Call\n    search(pat, txt, q);\n  }\n}\n\n// This code is contributed by ishankhandelwals.\n# d is the number of characters in the input alphabet\nd = 256\n\n''' pat -> pattern\ntxt -> text\nq -> A prime number '''\ndef search(pat, txt, q):\n    \n    M = len(pat)\n    N = len(txt)\n    p = 0 # hash value for pattern\n    t = 0 # hash value for txt\n    h = 1\n\n    # The value of h would be \"pow(d, M-1)%q\"\n    for i in range(M - 1):\n        h = (h * d) % q\n\n    # Calculate the hash value of pattern and first\n    # window of text\n    for i in range(M):\n        p = (d * p + ord(pat[i])) % q\n        t = (d * t + ord(txt[i])) % q\n\n    # Slide the pattern over text one by one\n    for i in range(N - M + 1):\n        # Check the hash values of current window of text\n        # and pattern. If the hash values match then only\n        # check for characters one by one\n        if p == t:\n            # Check for characters one by one\n            for j in range(M):\n                if txt[i + j] != pat[j]:\n                    break\n            # if p == t and pat[0...M-1] = txt[i, i+1,\n            # ...i+M-1]\n            if j == M - 1:\n                print(\"Pattern found at index \" + str(i))\n\n        # Calculate hash value for next window of text:\n        # Remove leading digit, add trailing digit\n        if i < N - M:\n            t = (d * (t - ord(txt[i]) * h) + ord(txt[i + M])) % q\n            # We might get negative value of t, converting\n            # it to positive\n            if t < 0:\n                t = (t + q)\n\n# Driver code\ntxt = \"GEEKS FOR GEEKS\"\npat = \"GEEK\"\n\n# we mod to avoid overflowing of value but we should\n# take as big q as possible to avoid the collison\nq = float('inf')\n\n# Function Call\nsearch(pat, txt, q)\n\n# This code is contributed by akashish__\n// C# code\nusing System;\n\n/* pat -> pattern\n    txt -> text\n    q -> A prime number\n*/\n\nclass GFG {\n  // d is the number of characters in the input alphabet\n  public static int d = 256;\n  public static void search(string pat, string txt, int q)\n  {\n    int M = pat.Length;\n    int N = txt.Length;\n    int i, j;\n    int p = 0; // hash value for pattern\n    int t = 0; // hash value for txt\n    int h = 1;\n    // The value of h would be \"pow(d, M-1)%q\"\n    for (i = 0; i < M - 1; i++)\n      h = (h * d) % q;\n    // Calculate the hash value of pattern and first\n    // window of text\n    for (i = 0; i < M; i++) {\n      p = (d * p + pat[i]) % q;\n      t = (d * t + txt[i]) % q;\n    }\n\n    // Slide the pattern over text one by one\n    for (i = 0; i <= N - M; i++) {\n\n      // Check the hash values of current window of\n      // text and pattern. If the hash values match\n      // then only check for characters one by one\n      if (p == t) {\n        /* Check for characters one by one */\n        for (j = 0; j < M; j++) {\n          if (txt[i + j] != pat[j]) {\n            break;\n          }\n        }\n\n        // if p == t and pat[0...M-1] = txt[i, i+1,\n        // ...i+M-1]\n\n        if (j == M) {\n          Console.WriteLine(\n            \"Pattern found at index \" + i);\n        }\n      }\n      // Calculate hash value for next window of text:\n      // Remove leading digit, add trailing digit\n      if (i < N - M) {\n        t = (d * (t - txt[i] * h) + txt[i + M]) % q;\n\n        // We might get negative value of t,\n        // converting it to positive\n        if (t < 0)\n          t = (t + q);\n      }\n    }\n  }\n\n  /* Driver code */\n  public static void Main(string[] args)\n  {\n    string txt = \"GEEKS FOR GEEKS\";\n    string pat = \"GEEK\";\n\n    // A prime number\n    int q = 101;\n\n    // Function Call\n    search(pat, txt, q);\n  }\n}\n\n// This code is contributed by akashish__\n// d is the number of characters in the input alphabet\nconst d = 256;\n\n/* pat -> pattern\n    txt -> text\n    q -> A prime number\n*/\nfunction search(pat, txt, q) {\n  const M = pat.length;\n  const N = txt.length;\n  let p = 0; // hash value for pattern\n  let t = 0; // hash value for txt\n  let h = 1;\n\n  // The value of h would be \"pow(d, M-1)%q\"\n  for (let i = 0; i < M - 1; i++) {\n    h = (h * d) % q;\n  }\n\n  // Calculate the hash value of pattern and first\n  // window of text\n  for (let i = 0; i < M; i++) {\n    p = (d * p + pat.charCodeAt(i)) % q;\n    t = (d * t + txt.charCodeAt(i)) % q;\n  }\n\n  // Slide the pattern over text one by one\n  for (let i = 0; i <= N - M; i++) {\n    // Check the hash values of current window of text\n    // and pattern. If the hash values match then only\n    // check for characters one by one\n    if (p === t) {\n    /* Check for characters one by one */\n    for (j = 0; j < M; j++) {\n        if (txt.charAt(i + j) !== pat.charAt(j)) {\n        break;\n        }\n    }\n\n    // if p == t and pat[0...M-1] = txt[i, i+1,\n    // ...i+M-1]\n\n    if (j === M)\n        console.log(\"Pattern found at index \" + i);\n    }\n\n    // Calculate hash value for next window of text:\n    // Remove leading digit, add trailing digit\n    if (i < N - M) {\n    t = (d * (t - txt.charCodeAt(i) * h) + txt.charCodeAt(i + M)) % q;\n\n    // We might get negative value of t, converting\n    // it to positive\n    if (t < 0)\n        t = (t + q);\n    }\n  }\n}\n\n/* Driver code */\nconst txt = \"GEEKS FOR GEEKS\";\nconst pat = \"GEEK\";\n\n// we mod to avoid overflowing of value but we should\n// take as big q as possible to avoid the collison\nconst q = Number.MAX_SAFE_INTEGER;\n\n// Function Call\nsearch(pat, txt, q);\n\n// This code is contributed by ishankhandelwals.\nPattern found at index 0\nPattern found at index 10\n// A C++ program that implements Z algorithm for pattern\n// searching\n#include <iostream>\nusing namespace std;\n\nvoid getZarr(string str, int Z[]);\n\n// prints all occurrences of pattern in text using Z algo\nvoid search(string text, string pattern)\n{\n    // Create concatenated string \"P$T\"\n    string concat = pattern + \"$\" + text;\n    int l = concat.length();\n\n    // Construct Z array\n    int Z[l];\n    getZarr(concat, Z);\n\n    // now looping through Z array for matching condition\n    for (int i = 0; i < l; ++i) {\n        // if Z[i] (matched region) is equal to pattern\n        // length we got the pattern\n        if (Z[i] == pattern.length())\n            cout << \"Pattern found at index \"\n                 << i - pattern.length() - 1 << endl;\n    }\n}\n\n// Fills Z array for given string str[]\nvoid getZarr(string str, int Z[])\n{\n    int n = str.length();\n    int L, R, k;\n\n    // [L, R] make a window which matches with prefix of s\n    L = R = 0;\n    for (int i = 1; i < n; ++i) {\n        // if i>R nothing matches so we will calculate.\n        // Z[i] using naive way.\n        if (i > R) {\n            L = R = i;\n\n            // R-L = 0 in starting, so it will start\n            // checking from 0'th index. For example,\n            // for \"ababab\" and i = 1, the value of R\n            // remains 0 and Z[i] becomes 0. For string\n            // \"aaaaaa\" and i = 1, Z[i] and R become 5\n            while (R < n && str[R - L] == str[R])\n                R++;\n            Z[i] = R - L;\n            R--;\n        }\n        else {\n            // k = i-L so k corresponds to number which\n            // matches in [L, R] interval.\n            k = i - L;\n\n            // if Z[k] is less than remaining interval\n            // then Z[i] will be equal to Z[k].\n            // For example, str = \"ababab\", i = 3, R = 5\n            // and L = 2\n            if (Z[k] < R - i + 1)\n                Z[i] = Z[k];\n\n            // For example str = \"aaaaaa\" and i = 2, R is 5,\n            // L is 0\n            else {\n                // else start from R and check manually\n                L = i;\n                while (R < n && str[R - L] == str[R])\n                    R++;\n                Z[i] = R - L;\n                R--;\n            }\n        }\n    }\n}\n\n// Driver program\nint main()\n{\n    string text = \"GEEKS FOR GEEKS\";\n    string pattern = \"GEEK\";\n    search(text, pattern);\n    return 0;\n}\n// A Java program that implements Z algorithm for pattern\n// searching\nimport java.io.*;\n\nclass GFG \n{\n\n  // prints all occurrences of pattern in text using Z\n  // algo\n  static void search(String text, String pattern)\n  {\n\n    // Create concatenated string \"P$T\"\n    String concat = pattern + \"$\" + text;\n    int l = concat.length();\n\n    // Construct Z array\n    int[] Z = new int[l];\n    getZarr(concat, Z);\n\n    // now looping through Z array for matching\n    // condition\n    for (int i = 0; i < l; i++) {\n      // if Z[i] (matched region) is equal to pattern\n      // length we got the pattern\n      if (Z[i] == pattern.length()) {\n        System.out.println(\n          \"Pattern found at index \"\n          + (i - pattern.length() - 1));\n      }\n    }\n  }\n\n  // Fills Z array for given string str[]\n  static void getZarr(String str, int[] Z)\n  {\n    int n = str.length();\n    // [L, R] make a window which matches with prefix of\n    // s\n    int L = 0, R = 0, k;\n\n    for (int i = 1; i < n; ++i) {\n      // if i>R nothing matches so we will calculate.\n      // Z[i] using naive way.\n      if (i > R) {\n        L = R = i;\n        // R-L = 0 in starting, so it will start\n        // checking from 0'th index. For example,\n        // for \"ababab\" and i = 1, the value of R\n        // remains 0 and Z[i] becomes 0. For string\n        // \"aaaaaa\" and i = 1, Z[i] and R become 5\n        while (R < n\n               && str.charAt(R - L)\n               == str.charAt(R)) {\n          R++;\n        }\n        Z[i] = R - L;\n        R--;\n      }\n      else {\n        // k = i-L so k corresponds to number which\n        // matches in [L, R] interval.\n        k = i - L;\n\n        // if Z[k] is less than remaining interval\n        // then Z[i] will be equal to Z[k].\n        // For example, str = \"ababab\", i = 3, R = 5\n        // and L = 2\n        if (Z[k] < R - i + 1)\n          Z[i] = Z[k];\n\n        // For example str = \"aaaaaa\" and i = 2, R\n        // is 5, L is 0\n        else {\n          // else start from R and check manually\n          L = i;\n          while (R < n\n                 && str.charAt(R - L)\n                 == str.charAt(R)) {\n            R++;\n          }\n          Z[i] = R - L;\n          R--;\n        }\n      }\n    }\n  }\n\n  public static void main(String[] args)\n  {\n    String text = \"GEEKS FOR GEEKS\";\n    String pattern = \"GEEK\";\n    search(text, pattern);\n  }\n}\n\n// This code is contributed by lokeshmvs21.\n# A Python program that implements Z algorithm for pattern\n# searching\n# Fills Z array for given string str[]\ndef getZarr(string, Z):\n    n = len(string)\n    \n    # [L, R] make a window which matches with prefix of s\n    L, R, k = 0, 0, 0\n    Z[0] = n\n\n    for i in range(1, n):\n      \n      # if i>R nothing matches so we will calculate.\n        # Z[i] using naive way.\n        if i > R:\n            L, R = i, i\n            \n            # R-L = 0 in starting, so it will start\n            # checking from 0'th index. For example,\n            # for \"ababab\" and i = 1, the value of R\n            # remains 0 and Z[i] becomes 0. For string\n            # \"aaaaaa\" and i = 1, Z[i] and R become 5\n            while R < n and string[R - L] == string[R]:\n                R += 1\n            Z[i] = R - L\n            R -= 1\n        else:\n          \n          # k = i-L so k corresponds to number which\n            # matches in [L, R] interval.\n            k = i - L\n            \n            # if Z[k] is less than remaining interval\n            # then Z[i] will be equal to Z[k].\n            # For example, str = \"ababab\", i = 3, R = 5\n            # and L = 2\n            if Z[k] < R - i + 1:\n                Z[i] = Z[k]\n                \n            # For example str = \"aaaaaa\" and i = 2, R is 5,\n            # L is 0\n            else:\n              \n              # else start from R and check manually\n                L = i\n                while R < n and string[R - L] == string[R]:\n                    R += 1\n                Z[i] = R - L\n                R -= 1\n                \n# prints all occurrences of pattern in text using Z algo\ndef search(text, pattern):\n  \n  # Create concatenated string \"P$T\"\n    concat = pattern + \"$\" + text\n    l = len(concat)\n\n    # Construct Z array\n    Z = [0] * l\n    getZarr(concat, Z)\n\n    # now looping through Z array for matching condition\n    for i in range(l):\n      \n      # if Z[i] (matched region) is equal to pattern\n        # length we got the pattern\n        if Z[i] == len(pattern):\n            print(\"Pattern found at index\", i - len(pattern) - 1)\n\n# Driver program\nif __name__ == \"__main__\":\n    text = \"GEEKS FOR GEEKS\"\n    pattern = \"GEEK\"\n    search(text, pattern)\n    \n# This code is contributed by akashish__\nusing System;\nusing System.Linq;\n\npublic class GFG {\n\n  // prints all occurrences of pattern in text using Z\n  // algo\n  static void search(string text, string pattern)\n  {\n    // Create concatenated string \"P$T\"\n    string concat = pattern + \"$\" + text;\n    int l = concat.Length;\n\n    // Construct Z array\n    int[] Z = new int[l];\n    GetZarr(concat, Z);\n\n    // now looping through Z array for matching\n    // condition\n    for (int i = 0; i < l; i++) {\n      // if Z[i] (matched region) is equal to\n      // pattern length we got the pattern\n      if (Z[i] == pattern.Length) {\n        Console.WriteLine(\n          \"Pattern found at index \"\n          + (i - pattern.Length - 1));\n      }\n    }\n  }\n\n  // Fills Z array for given string str[]\n  static void GetZarr(string str, int[] Z)\n  {\n    int n = str.Length;\n    // [L, R] make a window which matches with\n    // prefix of\n    // s\n    int L = 0, R = 0, k;\n\n    for (int i = 1; i < n; ++i) {\n      // if i>R nothing matches so we will\n      // calculate. Z[i] using naive way.\n      if (i > R) {\n        L = R = i;\n        // R-L = 0 in starting, so it will start\n        // checking from 0'th index. For\n        // example, for \"ababab\" and i = 1, the\n        // value of R remains 0 and Z[i] becomes\n        // 0. For string \"aaaaaa\" and i = 1,\n        // Z[i] and R become 5\n        while (R < n && str[R - L] == str[R]) {\n          R++;\n        }\n        Z[i] = R - L;\n        R--;\n      }\n      else {\n        // k = i-L so k corresponds to number\n        // which matches in [L, R] interval.\n        k = i - L;\n\n        // if Z[k] is less than remaining\n        // interval then Z[i] will be equal to\n        // Z[k]. For example, str = \"ababab\", i\n        // = 3, R = 5 and L = 2\n        if (Z[k] < R - i + 1)\n          Z[i] = Z[k];\n\n        // For example str = \"aaaaaa\" and i = 2,\n        // R is 5, L is 0\n        else {\n          // else start from R and check\n          // manually\n          L = i;\n          while (R < n && str[R - L] == str[R]) {\n            R++;\n          }\n          Z[i] = R - L;\n          R--;\n        }\n      }\n    }\n  }\n\n  static public void Main()\n  {\n    string text = \"GEEKS FOR GEEKS\";\n    string pattern = \"GEEK\";\n    search(text, pattern);\n  }\n}\n// This code is contributed by akashish__\nfunction search(text, pattern) {\n  // Create concatenated string \"P$T\"\n  let concat = pattern + \"$\" + text;\n  let l = concat.length;\n\n  // Construct Z array\n  let Z = [];\n  getZarr(concat, Z);\n\n  // now looping through Z array for matching condition\n  for (let i = 0; i < l; i++) {\n    // if Z[i] (matched region) is equal to pattern\n    // length we got the pattern\n    if (Z[i] == pattern.length) {\n      console.log(`Pattern found at index ${i - pattern.length - 1}`);\n    }\n  }\n}\n\n// Fills Z array for given string str[]\nfunction getZarr(str, Z) {\n  let n = str.length;\n  let L, R, k;\n\n  // [L, R] make a window which matches with prefix of s\n  L = R = 0;\n  for (let i = 1; i < n; i++) {\n    // if i>R nothing matches so we will calculate.\n    // Z[i] using naive way.\n    if (i > R) {\n      L = R = i;\n\n      // R-L = 0 in starting, so it will start\n      // checking from 0'th index. For example,\n      // for \"ababab\" and i = 1, the value of R\n      // remains 0 and Z[i] becomes 0. For string\n      // \"aaaaaa\" and i = 1, Z[i] and R become 5\n      while (R < n && str[R - L] == str[R]) {\n        R++;\n      }\n      Z[i] = R - L;\n      R--;\n    } else {\n      // k = i-L so k corresponds to number which\n      // matches in [L, R] interval.\n      k = i - L;\n\n      // if Z[k] is less than remaining interval\n      // then Z[i] will be equal to Z[k].\n      // For example, str = \"ababab\", i = 3, R = 5\n      // and L = 2\n      if (Z[k] < R - i + 1) {\n        Z[i] = Z[k];\n      }\n\n      // For example str = \"aaaaaa\" and i = 2, R is 5,\n      // L is 0\n      else {\n        // else start from R and check manually\n        L = i;\n        while (R < n && str[R - L] == str[R]) {\n          R++;\n        }\n        Z[i] = R - L;\n        R--;\n      }\n    }\n  }\n}\n\n// Driver program\nlet text = \"GEEKS FOR GEEKS\";\nlet pattern = \"GEEK\";\nsearch(text, pattern);\n\n// This code is contributed by akashish__\nPattern found at index 0\nPattern found at index 10\n// C++ program for implementation of\n// Aho Corasick algorithm for String\n// matching\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Max number of states in the matching\n// machine. Should be equal to the sum\n// of the length of all keywords.\n\n#define MAXS 500\n\n// Maximum number of characters\n// in input alphabet\n\n#define MAXC 26\n\n// OUTPUT FUNCTION IS IMPLEMENTED USING out[]\n// Bit i in this mask is one if the word with\n// index i appears when the machine enters\n// this state.\nint out[MAXS];\n\n// FAILURE FUNCTION IS IMPLEMENTED USING f[]\nint f[MAXS];\n\n// GOTO FUNCTION (OR TRIE) IS\n// IMPLEMENTED USING g[][]\nint g[MAXS][MAXC];\n\n// Builds the String matching machine.\n// arr - array of words. The index of each keyword is\n// important:\n//\"out[state] & (1 << i)\" is > 0 if we just found\n// word[i] in the text.\n// Returns the number of states that the built machine\n// has. States are numbered 0 up to the return value -\n// 1, inclusive.\n\nint buildMatchingMachine(string arr[], int k)\n{\n    // Initialize all values in output function as 0.\n    memset(out, 0, sizeof out);\n\n    // Initialize all values in goto function as -1.\n    memset(g, -1, sizeof g);\n\n    // Initially, we just have the 0 state\n    int states = 1;\n\n    // Convalues for goto function, i.e., fill g[][]\n    // This is same as building a Trie for arr[]\n    for (int i = 0; i < k; i++) {\n        string word = arr[i];\n        int currentState = 0;\n\n        // Insert all characters of current\n        // word in arr[]\n        for (int j = 0; j < word.length(); j++) {\n            int ch = word[j] - 'a';\n\n            // Allocate a new node (create a new state)\n            // if a node for ch doesn't exist.\n            if (g[currentState][ch] == -1)\n                g[currentState][ch] = states++;\n\n            currentState = g[currentState][ch];\n        }\n\n        // Add current word in output function\n        out[currentState] |= (1 << i);\n    }\n\n    // For all characters which don't have\n    // an edge from root (or state 0) in Trie,\n    // add a goto edge to state 0 itself\n    for (int ch = 0; ch < MAXC; ch++)\n        if (g[0][ch] == -1)\n            g[0][ch] = 0;\n\n    // Now, let's build the failure function\n    // Initialize values in fail function\n    memset(f, -1, sizeof f);\n\n    // Failure function is computed in\n    // breadth first order\n    // using a queue\n    queue<int> q;\n\n    // Iterate over every possible input\n    for (int ch = 0; ch < MAXC; ch++) {\n\n        // All nodes of depth 1 have failure\n        // function value as 0. For example,\n        // in above diagram we move to 0\n        // from states 1 and 3.\n        if (g[0][ch] != 0) {\n            f[g[0][ch]] = 0;\n            q.push(g[0][ch]);\n        }\n    }\n\n    // Now queue has states 1 and 3\n    while (!q.empty()) {\n\n        // Remove the front state from queue\n        int state = q.front();\n        q.pop();\n\n        // For the removed state, find failure\n        // function for all those characters\n        // for which goto function is\n        // not defined.\n        for (int ch = 0; ch < MAXC; ch++) {\n\n            // If goto function is defined for\n            // character 'ch' and 'state'\n            if (g[state][ch] != -1) {\n\n                // Find failure state of removed state\n                int failure = f[state];\n\n                // Find the deepest node labeled by\n                // proper suffix of String from root to\n                // current state.\n                while (g[failure][ch] == -1)\n                    failure = f[failure];\n                failure = g[failure][ch];\n                f[g[state][ch]] = failure;\n\n                // Merge output values\n                out[g[state][ch]] |= out[failure];\n\n                // Insert the next level node\n                // (of Trie) in Queue\n                q.push(g[state][ch]);\n            }\n        }\n    }\n    return states;\n}\n\n// Returns the next state the machine will transition to\n// using goto and failure functions. currentState - The\n// current state of the machine. Must be between\n// 0 and the number of states - 1,\n// inclusive.\n// nextInput - The next character that enters into the\n// machine.\n\n// This function finds all occurrences of\n// all array words in text.\nvoid searchWords(string arr[], int k, string text)\n{\n\n    // Preprocess patterns.\n    // Build machine with goto, failure\n    // and output functions\n    buildMatchingMachine(arr, k);\n\n    // Initialize current state\n    int currentState = 0;\n\n    // Traverse the text through the\n    // built machine to find all\n    // occurrences of words in arr[]\n    for (int i = 0; i < text.length(); i++) {\n        int ch = text[i] - 'a';\n\n        // If goto is not defined, use\n        // failure function\n        while (g[currentState][ch] == -1)\n            currentState = f[currentState];\n        currentState = g[currentState][ch];\n\n        // If match not found, move to next state\n        if (out[currentState] == 0)\n            continue;\n\n        // Match found, print all matching\n        // words of arr[]\n        // using output function.\n        for (int j = 0; j < k; j++) {\n            if (out[currentState] & (1 << j))\n                cout << \"Word \" << arr[j]\n                     << \" appears from \"\n                     << i - arr[j].length() + 1 << \" to \"\n                     << i << endl;\n        }\n    }\n}\n// Driver code\n\nint main()\n{\n    string arr[] = { \"he\", \"she\", \"hers\", \"his\" };\n    int k = sizeof(arr) / sizeof(arr[0]);\n    string text = \"ahishers\";\n    searchWords(arr, k, text);\n    return 0;\n}\n// Java program for implementation of\n// Aho Corasick algorithm for String\n// matching\nimport java.util.*;\n\nclass GFG {\n\n    // Max number of states in the matching\n    // machine. Should be equal to the sum\n    // of the length of all keywords.\n    static int MAXS = 500;\n\n    // Maximum number of characters\n    // in input alphabet\n    static int MAXC = 26;\n\n    // OUTPUT FUNCTION IS IMPLEMENTED USING out[]\n    // Bit i in this mask is one if the word with\n    // index i appears when the machine enters\n    // this state.\n    static int[] out = new int[MAXS];\n\n    // FAILURE FUNCTION IS IMPLEMENTED USING f[]\n    static int[] f = new int[MAXS];\n\n    // GOTO FUNCTION (OR TRIE) IS\n    // IMPLEMENTED USING g[][]\n    static int[][] g = new int[MAXS][MAXC];\n\n    // Builds the String matching machine.\n    // arr - array of words. The index of each keyword is\n    // important:\n    //         \"out[state] & (1 << i)\" is > 0 if we just\n    //         found\n    // word[i]          in the text.\n    // Returns the number of states that the built machine\n    // has. States are numbered 0 up to the return value -\n    // 1, inclusive.\n    static int buildMatchingMachine(String arr[], int k)\n    {\n\n        // Initialize all values in output function as 0.\n        Arrays.fill(out, 0);\n\n        // Initialize all values in goto function as -1.\n        for (int i = 0; i < MAXS; i++)\n            Arrays.fill(g[i], -1);\n\n        // Initially, we just have the 0 state\n        int states = 1;\n\n        // Convalues for goto function, i.e., fill g[][]\n        // This is same as building a Trie for arr[]\n        for (int i = 0; i < k; ++i) {\n            String word = arr[i];\n            int currentState = 0;\n\n            // Insert all characters of current\n            // word in arr[]\n            for (int j = 0; j < word.length(); ++j) {\n                int ch = word.charAt(j) - 'a';\n\n                // Allocate a new node (create a new state)\n                // if a node for ch doesn't exist.\n                if (g[currentState][ch] == -1)\n                    g[currentState][ch] = states++;\n\n                currentState = g[currentState][ch];\n            }\n\n            // Add current word in output function\n            out[currentState] |= (1 << i);\n        }\n\n        // For all characters which don't have\n        // an edge from root (or state 0) in Trie,\n        // add a goto edge to state 0 itself\n        for (int ch = 0; ch < MAXC; ++ch)\n            if (g[0][ch] == -1)\n                g[0][ch] = 0;\n\n        // Now, let's build the failure function\n        // Initialize values in fail function\n        Arrays.fill(f, -1);\n\n        // Failure function is computed in\n        // breadth first order\n        // using a queue\n        Queue<Integer> q = new LinkedList<>();\n\n        // Iterate over every possible input\n        for (int ch = 0; ch < MAXC; ++ch) {\n\n            // All nodes of depth 1 have failure\n            // function value as 0. For example,\n            // in above diagram we move to 0\n            // from states 1 and 3.\n            if (g[0][ch] != 0) {\n                f[g[0][ch]] = 0;\n                q.add(g[0][ch]);\n            }\n        }\n\n        // Now queue has states 1 and 3\n        while (!q.isEmpty()) {\n\n            // Remove the front state from queue\n            int state = q.peek();\n            q.remove();\n\n            // For the removed state, find failure\n            // function for all those characters\n            // for which goto function is\n            // not defined.\n            for (int ch = 0; ch < MAXC; ++ch) {\n\n                // If goto function is defined for\n                // character 'ch' and 'state'\n                if (g[state][ch] != -1) {\n\n                    // Find failure state of removed state\n                    int failure = f[state];\n\n                    // Find the deepest node labeled by\n                    // proper suffix of String from root to\n                    // current state.\n                    while (g[failure][ch] == -1)\n                        failure = f[failure];\n\n                    failure = g[failure][ch];\n                    f[g[state][ch]] = failure;\n\n                    // Merge output values\n                    out[g[state][ch]] |= out[failure];\n\n                    // Insert the next level node\n                    // (of Trie) in Queue\n                    q.add(g[state][ch]);\n                }\n            }\n        }\n        return states;\n    }\n\n    // Returns the next state the machine will transition to\n    // using goto and failure functions. currentState - The\n    // current state of the machine. Must be between\n    // 0 and the number of states - 1,\n    // inclusive.\n    // nextInput - The next character that enters into the\n    // machine.\n    static int findNextState(int currentState,\n                             char nextInput)\n    {\n        int answer = currentState;\n        int ch = nextInput - 'a';\n\n        // If goto is not defined, use\n        // failure function\n        while (g[answer][ch] == -1)\n            answer = f[answer];\n\n        return g[answer][ch];\n    }\n\n    // This function finds all occurrences of\n    // all array words in text.\n    static void searchWords(String arr[], int k,\n                            String text)\n    {\n\n        // Preprocess patterns.\n        // Build machine with goto, failure\n        // and output functions\n        buildMatchingMachine(arr, k);\n\n        // Initialize current state\n        int currentState = 0;\n\n        // Traverse the text through the\n        // built machine to find all\n        // occurrences of words in arr[]\n        for (int i = 0; i < text.length(); ++i) {\n            currentState = findNextState(currentState,\n                                         text.charAt(i));\n\n            // If match not found, move to next state\n            if (out[currentState] == 0)\n                continue;\n\n            // Match found, print all matching\n            // words of arr[]\n            // using output function.\n            for (int j = 0; j < k; ++j) {\n                if ((out[currentState] & (1 << j)) > 0) {\n                    System.out.print(\n                        \"Word \" + arr[j] + \" appears from \"\n                        + (i - arr[j].length() + 1) + \" to \"\n                        + i + \"\\n\");\n                }\n            }\n        }\n    }\n\n    // Driver code\n    public static void main(String[] args)\n    {\n        String arr[] = { \"he\", \"she\", \"hers\", \"his\" };\n        String text = \"ahishers\";\n        int k = arr.length;\n\n        searchWords(arr, k, text);\n    }\n}\n// This code is wriiten by Sundaram.\n# Python program for implementation of\n# Aho-Corasick algorithm for string matching\n\n# defaultdict is used only for storing the final output\n# We will return a dictionary where key is the matched word\n# and value is the list of indexes of matched word\nfrom collections import defaultdict\n\n# For simplicity, Arrays and Queues have been implemented using lists.\n# If you want to improve performance try using them instead\n\n\nclass AhoCorasick:\n    def __init__(self, words):\n\n        # Max number of states in the matching machine.\n        # Should be equal to the sum of the length of all keywords.\n        self.max_states = sum([len(word) for word in words])\n\n        # Maximum number of characters.\n        # Currently supports only alphabets [a, z]\n        self.max_characters = 26\n\n        # OUTPUT FUNCTION IS IMPLEMENTED USING out []\n        # Bit i in this mask is 1 if the word with\n        # index i appears when the machine enters this state.\n        # Lets say, a state outputs two words \"he\" and \"she\" and\n        # in our provided words list, he has index 0 and she has index 3\n        # so value of out[state] for this state will be 1001\n        # It has been initialized to all 0.\n        # We have taken one extra state for the root.\n        self.out = [0]*(self.max_states + 1)\n\n        # FAILURE FUNCTION IS IMPLEMENTED USING fail []\n        # There is one value for each state + 1 for the root\n        # It has been initialized to all -1\n        # This will contain the fail state value for each state\n        self.fail = [-1]*(self.max_states + 1)\n\n        # GOTO FUNCTION (OR TRIE) IS IMPLEMENTED USING goto [[]]\n        # Number of rows = max_states + 1\n        # Number of columns = max_characters i.e 26 in our case\n        # It has been initialized to all -1.\n        self.goto = [\n            [-1]*self.max_characters for _ in range(self.max_states + 1)]\n\n        # Convert all words to lowercase\n        # so that our search is case insensitive\n        for i in range(len(words)):\n            words[i] = words[i].lower()\n\n        # All the words in dictionary which will be used to create Trie\n        # The index of each keyword is important:\n        # \"out[state] & (1 << i)\" is > 0 if we just found word[i]\n        # in the text.\n        self.words = words\n\n        # Once the Trie has been built, it will contain the number\n        # of nodes in Trie which is total number of states required <= max_states\n        self.states_count = self.__build_matching_machine()\n\n    # Builds the String matching machine.\n    # Returns the number of states that the built machine has.\n    # States are numbered 0 up to the return value - 1, inclusive.\n\n    def __build_matching_machine(self):\n        k = len(self.words)\n\n        # Initially, we just have the 0 state\n        states = 1\n\n        # Convalues for goto function, i.e., fill goto\n        # This is same as building a Trie for words[]\n        for i in range(k):\n            word = self.words[i]\n            current_state = 0\n\n            # Process all the characters of the current word\n            for character in word:\n                ch = ord(character) - 97  # Ascii value of 'a' = 97\n\n                # Allocate a new node (create a new state)\n                # if a node for ch doesn't exist.\n                if self.goto[current_state][ch] == -1:\n                    self.goto[current_state][ch] = states\n                    states += 1\n\n                current_state = self.goto[current_state][ch]\n\n            # Add current word in output function\n            self.out[current_state] |= (1 << i)\n\n        # For all characters which don't have\n        # an edge from root (or state 0) in Trie,\n        # add a goto edge to state 0 itself\n        for ch in range(self.max_characters):\n            if self.goto[0][ch] == -1:\n                self.goto[0][ch] = 0\n\n        # Failure function is computed in\n        # breadth first order using a queue\n        queue = []\n\n        # Iterate over every possible input\n        for ch in range(self.max_characters):\n\n            # All nodes of depth 1 have failure\n            # function value as 0. For example,\n            # in above diagram we move to 0\n            # from states 1 and 3.\n            if self.goto[0][ch] != 0:\n                self.fail[self.goto[0][ch]] = 0\n                queue.append(self.goto[0][ch])\n\n        # Now queue has states 1 and 3\n        while queue:\n\n            # Remove the front state from queue\n            state = queue.pop(0)\n\n            # For the removed state, find failure\n            # function for all those characters\n            # for which goto function is not defined.\n            for ch in range(self.max_characters):\n\n                # If goto function is defined for\n                # character 'ch' and 'state'\n                if self.goto[state][ch] != -1:\n\n                    # Find failure state of removed state\n                    failure = self.fail[state]\n\n                    # Find the deepest node labeled by proper\n                    # suffix of String from root to current state.\n                    while self.goto[failure][ch] == -1:\n                        failure = self.fail[failure]\n\n                    failure = self.goto[failure][ch]\n                    self.fail[self.goto[state][ch]] = failure\n\n                    # Merge output values\n                    self.out[self.goto[state][ch]] |= self.out[failure]\n\n                    # Insert the next level node (of Trie) in Queue\n                    queue.append(self.goto[state][ch])\n\n        return states\n\n    # Returns the next state the machine will transition to using goto\n    # and failure functions.\n    # current_state - The current state of the machine. Must be between\n    # 0 and the number of states - 1, inclusive.\n    # next_input - The next character that enters into the machine.\n\n    def __find_next_state(self, current_state, next_input):\n        answer = current_state\n        ch = ord(next_input) - 97  # Ascii value of 'a' is 97\n\n        # If goto is not defined, use\n        # failure function\n        while self.goto[answer][ch] == -1:\n            answer = self.fail[answer]\n\n        return self.goto[answer][ch]\n\n    # This function finds all occurrences of all words in text.\n\n    def search_words(self, text):\n        # Convert the text to lowercase to make search case insensitive\n        text = text.lower()\n\n        # Initialize current_state to 0\n        current_state = 0\n\n        # A dictionary to store the result.\n        # Key here is the found word\n        # Value is a list of all occurrences start index\n        result = defaultdict(list)\n\n        # Traverse the text through the built machine\n        # to find all occurrences of words\n        for i in range(len(text)):\n            current_state = self.__find_next_state(current_state, text[i])\n\n            # If match not found, move to next state\n            if self.out[current_state] == 0:\n                continue\n\n            # Match found, store the word in result dictionary\n            for j in range(len(self.words)):\n                if (self.out[current_state] & (1 << j)) > 0:\n                    word = self.words[j]\n\n                    # Start index of word is (i-len(word)+1)\n                    result[word].append(i-len(word)+1)\n\n        # Return the final result dictionary\n        return result\n\n\n# Driver code\nif __name__ == \"__main__\":\n    words = [\"he\", \"she\", \"hers\", \"his\"]\n    text = \"ahishers\"\n\n    # Create an Object to initialize the Trie\n    aho_chorasick = AhoCorasick(words)\n\n    # Get the result\n    result = aho_chorasick.search_words(text)\n\n    # Print the result\n    for word in result:\n        for i in result[word]:\n            print(\"Word\", word, \"appears from\", i, \"to\", i + len(word)-1)\nconst MAXS = 500;\nconst MAXC = 26;\n\nlet out = new Array(MAXS).fill(0);\nlet f = new Array(MAXS).fill(-1);\nlet g = Array.from(Array(MAXS), () => new Array(MAXC).fill(-1));\n\nfunction buildMatchingMachine(arr, k) {\n  out.fill(0);\n  g.forEach(row => row.fill(-1));\n  let states = 1;\n  for (let i = 0; i < k; i++) {\n    const word = arr[i];\n    let currentState = 0;\n    for (let j = 0; j < word.length; j++) {\n      const ch = word.charCodeAt(j) - 'a'.charCodeAt(0);\n      if (g[currentState][ch] === -1) g[currentState][ch] = states++;\n      currentState = g[currentState][ch];\n    }\n    out[currentState] |= 1 << i;\n  }\n  for (let ch = 0; ch < MAXC; ch++) {\n    if (g[0][ch] === -1) g[0][ch] = 0;\n  }\n  f.fill(-1);\n  const q = [];\n  for (let ch = 0; ch < MAXC; ch++) {\n    if (g[0][ch] !== 0) {\n      f[g[0][ch]] = 0;\n      q.push(g[0][ch]);\n    }\n  }\n  while (q.length) {\n    const state = q.shift();\n    for (let ch = 0; ch < MAXC; ch++) {\n      if (g[state][ch] !== -1) {\n        let failure = f[state];\n        while (g[failure][ch] === -1) failure = f[failure];\n        failure = g[failure][ch];\n        f[g[state][ch]] = failure;\n        out[g[state][ch]] |= out[failure];\n        q.push(g[state][ch]);\n      }\n    }\n  }\n  return states;\n}\n\nfunction searchWords(arr, k, text) {\n  buildMatchingMachine(arr, k);\n  let currentState = 0;\n  for (let i = 0; i < text.length; i++) {\n    const ch = text.charCodeAt(i) - 'a'.charCodeAt(0);\n    while (g[currentState][ch] === -1) currentState = f[currentState];\n    currentState = g[currentState][ch];\n    if (out[currentState] === 0) continue;\n    for (let j = 0; j < k; j++) {\n      if (out[currentState] & (1 << j)) {\n        console.log(`Word ${arr[j]} appears from ${i - arr[j].length + 1} to ${i}`);\n      }\n    }\n  }\n}\n\n// Driver code\nconst arr = [\"he\", \"she\", \"hers\", \"his\"];\nconst k = arr.length;\nconst text = \"ahishers\";\nsearchWords(arr, k, text);\nWord his appears from 1 to 3\nWord he appears from 4 to 5\nWord she appears from 3 to 5\nWord hers appears from 4 to 7\n",
        "complexity": {
            "time": "Time Complexity: O(n + l + z), where ‘n’ is the length of the text, ‘l’ is the length of keywords, and ‘z’ is the number of matches.Auxiliary Space: O(l * q), where ‘q’ is the length of the alphabet since that is the maximum number of children a node can have.",
            "space": "This algorithm finds all occurrences of a pattern in a text in linear time. Let length of text be n and of pattern be m, then total time taken is O(m + n) with linear space complexity. Z algorithm works by maintaining an auxiliary array called the Z array. This Z array stores the length of the longest substring, starting from the current index, that also it’s prefix."
        },
        "tags": [
            "Pattern Searching"
        ],
        "url": "https://www.geeksforgeeks.org/introduction-to-pattern-searching/"
    },
    {
        "title": "Naive algorithm for Pattern Searching",
        "description": "Given text string with length n and a pattern with length m, the task is to prints all occurrences of pattern in text. Note: You may assume that n > m. Examples: Input:  text = “THIS IS A TEST TEXT”, pattern = “TEST”Output: Pattern found at index 10 Input:  text =  “AABAACAADAABAABA”, pattern = “AABA”Output: Pattern found at index 0, Pattern found at index 9, Pattern found at index 12 Pattern searching Slide the pattern over text one by one and check for a match. If a match is found, then slide by 1 again to check for subsequent matches. Time Complexity: O(N2)Auxiliary Space: O(1)   ",
        "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\nvoid search(string& pat, string& txt) {\n    int M = pat.size();\n    int N = txt.size();\n\n    // A loop to slide pat[] one by one\n    for (int i = 0; i <= N - M; i++) {\n        int j;\n\n        // For current index i, check for pattern match\n        for (j = 0; j < M; j++) {\n            if (txt[i + j] != pat[j]) {\n                break;\n            }\n        }\n\n        // If pattern matches at index i\n        if (j == M) {\n            cout << \"Pattern found at index \" << i << endl;\n        }\n    }\n}\n\n// Driver's Code\nint main() {\n    // Example 1\n    string txt1 = \"AABAACAADAABAABA\";\n    string pat1 = \"AABA\";\n    cout << \"Example 1: \" << endl;\n    search(pat1, txt1);\n    \n    // Example 2\n    string txt2 = \"agd\";\n    string pat2 = \"g\";\n    cout << \"\\nExample 2: \" << endl;\n    search(pat2, txt2);\n\n    return 0;\n}\n#include <stdio.h>\n#include <string.h>\n\nvoid search(char* pat, char* txt) {\n    int M = strlen(pat);\n    int N = strlen(txt);\n\n    // A loop to slide pat[] one by one\n    for (int i = 0; i <= N - M; i++) {\n        int j;\n\n        // For current index i, check for pattern match\n        for (j = 0; j < M; j++) {\n            if (txt[i + j] != pat[j]) {\n                break;\n            }\n        }\n\n        // If pattern matches at index i\n        if (j == M) {\n            printf(\"Pattern found at index %d\\n\", i);\n        }\n    }\n}\n\nint main() {\n    // Example 1\n    char txt1[] = \"AABAACAADAABAABA\";\n    char pat1[] = \"AABA\";\n    printf(\"Example 1:\\n\");\n    search(pat1, txt1);\n    \n    // Example 2\n    char txt2[] = \"agd\";\n    char pat2[] = \"g\";\n    printf(\"\\nExample 2:\\n\");\n    search(pat2, txt2);\n\n    return 0;\n}\npublic class PatternSearch {\n\n    public static void search(String pat, String txt) {\n        int M = pat.length();\n        int N = txt.length();\n\n        // A loop to slide pat[] one by one\n        for (int i = 0; i <= N - M; i++) {\n            int j;\n\n            // For current index i, check for pattern match\n            for (j = 0; j < M; j++) {\n                if (txt.charAt(i + j) != pat.charAt(j)) {\n                    break;\n                }\n            }\n\n            // If pattern matches at index i\n            if (j == M) {\n                System.out.println(\"Pattern found at index \" + i);\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        // Example 1\n        String txt1 = \"AABAACAADAABAABA\";\n        String pat1 = \"AABA\";\n        System.out.println(\"Example 1:\");\n        search(pat1, txt1);\n\n        // Example 2\n        String txt2 = \"agd\";\n        String pat2 = \"g\";\n        System.out.println(\"\\nExample 2:\");\n        search(pat2, txt2);\n    }\n}\ndef search_pattern(pattern, text):\n    # Get the lengths of the pattern and the text\n    m = len(pattern)\n    n = len(text)\n\n    # A loop to slide pattern over text one by one\n    for i in range(n - m + 1):\n        # For current index i, check for pattern match\n        j = 0\n        while j < m and text[i + j] == pattern[j]:\n            j += 1\n        \n        # If the entire pattern matches the text starting at index i\n        if j == m:\n            print(f\"Pattern found at index {i}\")\n\n# Example usage\nif __name__ == \"__main__\":\n    # Example 1\n    text1 = \"AABAACAADAABAABA\"\n    pattern1 = \"AABA\"\n    print(\"Example 1:\")\n    search_pattern(pattern1, text1)\n    \n    # Example 2\n    text2 = \"agd\"\n    pattern2 = \"g\"\n    print(\"\\nExample 2:\")\n    search_pattern(pattern2, text2)\nusing System;\n\nclass PatternSearch\n{\n    static void Search(string pat, string txt)\n    {\n        int M = pat.Length;\n        int N = txt.Length;\n\n        // A loop to slide pat[] one by one\n        for (int i = 0; i <= N - M; i++)\n        {\n            int j;\n\n            // For current index i, check for pattern match\n            for (j = 0; j < M; j++)\n            {\n                if (txt[i + j] != pat[j])\n                {\n                    break;\n                }\n            }\n\n            // If pattern matches at index i\n            if (j == M)\n            {\n                Console.WriteLine($\"Pattern found at index {i}\");\n            }\n        }\n    }\n\n    static void Main()\n    {\n        // Example 1\n        string txt1 = \"AABAACAADAABAABA\";\n        string pat1 = \"AABA\";\n        Console.WriteLine(\"Example 1:\");\n        Search(pat1, txt1);\n        \n        // Example 2\n        string txt2 = \"agd\";\n        string pat2 = \"g\";\n        Console.WriteLine(\"\\nExample 2:\");\n        Search(pat2, txt2);\n    }\n}\nfunction search(pat, txt) {\n    const M = pat.length;\n    const N = txt.length;\n\n    // A loop to slide pat[] one by one\n    for (let i = 0; i <= N - M; i++) {\n        let j = 0;\n\n        // For current index i, check for pattern match\n        while (j < M && txt[i + j] === pat[j]) {\n            j++;\n        }\n\n        // If pattern matches at index i\n        if (j === M) {\n            console.log(`Pattern found at index ${i}`);\n        }\n    }\n}\n\n// Example 1\nconst txt1 = \"AABAACAADAABAABA\";\nconst pat1 = \"AABA\";\nconsole.log(\"Example 1:\");\nsearch(pat1, txt1);\n\n// Example 2\nconst txt2 = \"agd\";\nconst pat2 = \"g\";\nconsole.log(\"\\nExample 2:\");\nsearch(pat2, txt2);\nfunction search($pat, $txt) {\n    $M = strlen($pat);\n    $N = strlen($txt);\n\n    // A loop to slide pat[] one by one\n    for ($i = 0; $i <= $N - $M; $i++) {\n        $j = 0;\n\n        // For current index i, check for pattern match\n        while ($j < $M && $txt[$i + $j] === $pat[$j]) {\n            $j++;\n        }\n\n        // If pattern matches at index i\n        if ($j == $M) {\n            echo \"Pattern found at index $i\\n\";\n        }\n    }\n}\n\n// Example 1\n$txt1 = \"AABAACAADAABAABA\";\n$pat1 = \"AABA\";\necho \"Example 1:\\n\";\nsearch($pat1, $txt1);\n\n// Example 2\n$txt2 = \"agd\";\n$pat2 = \"g\";\necho \"\\nExample 2:\\n\";\nsearch($pat2, $txt2);\nPattern found at index 0 \nPattern found at index 9 \nPattern found at index 13\n",
        "complexity": {
            "time": "Time Complexity: O(N2)Auxiliary Space: O(1)",
            "space": ""
        },
        "tags": [
            "Pattern Searching"
        ],
        "url": "https://www.geeksforgeeks.org/naive-algorithm-for-pattern-searching/"
    },
    {
        "title": "Rabin-Karp Algorithm for Pattern Searching",
        "description": "Given a text T[0. . .n-1] and a pattern P[0. . .m-1], write a function search(char P[], char T[]) that prints all occurrences of P[] present in T[] using Rabin Karp algorithm. You may assume that n > m. Examples: Input:  T[] = “THIS IS A TEST TEXT”, P[] = “TEST”Output: Pattern found at index 10 Input:  T[] =  “AABAACAADAABAABA”, P[] =  “AABA”Output: Pattern found at index 0              Pattern found at index 9              Pattern found at index 12 In the Naive String Matching algorithm, we check whether every substring of the text of the pattern’s size is equal to the pattern or not one by one. Like the Naive Algorithm, the Rabin-Karp algorithm also check every substring. But unlike the Naive algorithm, the Rabin Karp algorithm matches the hash value of the pattern with the hash value of the current substring of text, and if the hash values match then only it starts matching individual characters. So Rabin Karp algorithm needs to calculate hash values for the following strings. Hash value is used to efficiently check for potential matches between a pattern and substrings of a larger text. The hash value is calculated using a rolling hash function, which allows you to update the hash value for a new substring by efficiently removing the contribution of the old character and adding the contribution of the new character. This makes it possible to slide the pattern over the text and calculate the hash value for each substring without recalculating the entire hash from scratch. Here’s how the hash value is typically calculated in Rabin-Karp: Step 1: Choose a suitable base and a modulus: Step 2: Initialize the hash value: Step 3: Calculate the initial hash value for the pattern: Step 4: Slide the pattern over the text: Step 5: Update the hash value for each subsequent substring: hash = (hash – (text[i – pattern_length] * (bpattern_length – 1)) % p) * b + text[i] Step 6: Compare hash values: Below is the Illustration of above algorithm:  Step-by-step approach: Time Complexity: Auxiliary Space: O(1) Spurious Hit: When the hash value of the pattern matches with the hash value of a window of the text but the window is not the actual pattern then it is called a spurious hit. Spurious hit increases the time complexity of the algorithm. In order to minimize spurious hit, we use good hash function. It greatly reduces the spurious hit. Related Posts: Searching for Patterns | Set 1 (Naive Pattern Searching) Searching for Patterns | Set 2 (KMP Algorithm)   ",
        "code": "/* Following program is a C++ implementation of Rabin Karp\nAlgorithm given in the CLRS book */\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Search the pat string in the txt string \nvoid search(string pat, string txt, int q)\n{\n    int M = pat.size();\n    int N = txt.size();\n    int i, j;\n    int p = 0; // hash value for pattern\n    int t = 0; // hash value for txt\n    int h = 1;\n    int d = 256; // d is the number of characters in the input alphabet \n    // The value of h would be \"pow(d, M-1)%q\"\n    for (i = 0; i < M - 1; i++)\n        h = (h * d) % q;\n\n    // Calculate the hash value of pattern and first\n    // window of text\n    for (i = 0; i < M; i++) {\n        p = (d * p + pat[i]) % q;\n        t = (d * t + txt[i]) % q;\n    }\n\n    // Slide the pattern over text one by one\n    for (i = 0; i <= N - M; i++) {\n\n        // Check the hash values of current window of text\n        // and pattern. If the hash values match then only\n        // check for characters one by one\n        if (p == t) {\n            /* Check for characters one by one */\n            for (j = 0; j < M; j++) {\n                if (txt[i + j] != pat[j]) {\n                    break;\n                }\n            }\n\n            // if p == t and pat[0...M-1] = txt[i, i+1,\n            // ...i+M-1]\n\n            if (j == M)\n                cout << \"Pattern found at index \" << i\n                     << endl;\n        }\n\n        // Calculate hash value for next window of text:\n        // Remove leading digit, add trailing digit\n        if (i < N - M) {\n            t = (d * (t - txt[i] * h) + txt[i + M]) % q;\n\n            // We might get negative value of t, converting\n            // it to positive\n            if (t < 0)\n                t = (t + q);\n        }\n    }\n}\n\n/* Driver code */\nint main()\n{\n    string txt = \"GEEKS FOR GEEKS\";\n    string pat = \"GEEK\";\n\n    // we mod to avoid overflowing of value but we should\n    // take as big q as possible to avoid the collison\n    int q = INT_MAX;\n    // Function Call\n    search(pat, txt, q);\n    return 0;\n}\n\n// This is code is contributed by rathbhupendra\n/* Following program is a C implementation of Rabin Karp\nAlgorithm given in the CLRS book */\n#include <stdio.h>\n#include <string.h>\n\n// Search the pat string in the txt string\nvoid search(char pat[], char txt[], int q)\n{\n    int M = strlen(pat);\n    int N = strlen(txt);\n    int i, j;\n    int p = 0; // hash value for pattern\n    int t = 0; // hash value for txt\n    int h = 1;\n    int d = 256; // d is the number of characters in the input alphabet\n\n    // The value of h would be \"pow(d, M-1)%q\"\n    for (i = 0; i < M - 1; i++)\n        h = (h * d) % q;\n\n    // Calculate the hash value of pattern and first\n    // window of text\n    for (i = 0; i < M; i++) {\n        p = (d * p + pat[i]) % q;\n        t = (d * t + txt[i]) % q;\n    }\n\n    // Slide the pattern over text one by one\n    for (i = 0; i <= N - M; i++) {\n\n        // Check the hash values of current window of text\n        // and pattern. If the hash values match then only\n        // check for characters one by one\n        if (p == t) {\n            /* Check for characters one by one */\n            for (j = 0; j < M; j++) {\n                if (txt[i + j] != pat[j])\n                    break;\n            }\n\n            // if p == t and pat[0...M-1] = txt[i, i+1,\n            // ...i+M-1]\n            if (j == M)\n                printf(\"Pattern found at index %d \\n\", i);\n        }\n\n        // Calculate hash value for next window of text:\n        // Remove leading digit, add trailing digit\n        if (i < N - M) {\n            t = (d * (t - txt[i] * h) + txt[i + M]) % q;\n\n            // We might get negative value of t, converting\n            // it to positive\n            if (t < 0)\n                t = (t + q);\n        }\n    }\n}\n\n/* Driver Code */\nint main()\n{\n    char txt[] = \"GEEKS FOR GEEKS\";\n    char pat[] = \"GEEK\";\n\n    // A prime number\n    int q = 101;\n\n    // function call\n    search(pat, txt, q);\n    return 0;\n}\n// Following program is a Java implementation\n// of Rabin Karp Algorithm given in the CLRS book\n\npublic class Main {\n    // d is the number of characters in the input alphabet\n    public final static int d = 256;\n\n    // Search the pat string in the txt string\n    static void search(String pat, String txt, int q)\n    {\n        int M = pat.length();\n        int N = txt.length();\n        int i, j;\n        int p = 0; // hash value for pattern\n        int t = 0; // hash value for txt\n        int h = 1;\n\n        // The value of h would be \"pow(d, M-1)%q\"\n        for (i = 0; i < M - 1; i++)\n            h = (h * d) % q;\n\n        // Calculate the hash value of pattern and first\n        // window of text\n        for (i = 0; i < M; i++) {\n            p = (d * p + pat.charAt(i)) % q;\n            t = (d * t + txt.charAt(i)) % q;\n        }\n\n        // Slide the pattern over text one by one\n        for (i = 0; i <= N - M; i++) {\n\n            // Check the hash values of current window of\n            // text and pattern. If the hash values match\n            // then only check for characters one by one\n            if (p == t) {\n                /* Check for characters one by one */\n                for (j = 0; j < M; j++) {\n                    if (txt.charAt(i + j) != pat.charAt(j))\n                        break;\n                }\n\n                // if p == t and pat[0...M-1] = txt[i, i+1,\n                // ...i+M-1]\n                if (j == M)\n                    System.out.println(\n                        \"Pattern found at index \" + i);\n            }\n\n            // Calculate hash value for next window of text:\n            // Remove leading digit, add trailing digit\n            if (i < N - M) {\n                t = (d * (t - txt.charAt(i) * h)\n                     + txt.charAt(i + M))\n                    % q;\n\n                // We might get negative value of t,\n                // converting it to positive\n                if (t < 0)\n                    t = (t + q);\n            }\n        }\n    }\n\n    /* Driver Code */\n    public static void main(String[] args)\n    {\n        String txt = \"GEEKS FOR GEEKS\";\n        String pat = \"GEEK\";\n\n        // A prime number\n        int q = 101;\n\n        // Function Call\n        search(pat, txt, q);\n    }\n}\n\n// This code is contributed by nuclode\n# Following program is the python implementation of\n# Rabin Karp Algorithm given in CLRS book\n\n# d is the number of characters in the input alphabet\nd = 256\n\n# Search the pat string in the txt string\ndef search(pat, txt, q):\n    M = len(pat)\n    N = len(txt)\n    i = 0\n    j = 0\n    p = 0    # hash value for pattern\n    t = 0    # hash value for txt\n    h = 1\n\n    # The value of h would be \"pow(d, M-1)%q\"\n    for i in range(M-1):\n        h = (h*d) % q\n\n    # Calculate the hash value of pattern and first window\n    # of text\n    for i in range(M):\n        p = (d*p + ord(pat[i])) % q\n        t = (d*t + ord(txt[i])) % q\n\n    # Slide the pattern over text one by one\n    for i in range(N-M+1):\n        # Check the hash values of current window of text and\n        # pattern if the hash values match then only check\n        # for characters one by one\n        if p == t:\n            # Check for characters one by one\n            for j in range(M):\n                if txt[i+j] != pat[j]:\n                    break\n                else:\n                    j += 1\n\n            # if p == t and pat[0...M-1] = txt[i, i+1, ...i+M-1]\n            if j == M:\n                print(\"Pattern found at index \" + str(i))\n\n        # Calculate hash value for next window of text: Remove\n        # leading digit, add trailing digit\n        if i < N-M:\n            t = (d*(t-ord(txt[i])*h) + ord(txt[i+M])) % q\n\n            # We might get negative values of t, converting it to\n            # positive\n            if t < 0:\n                t = t+q\n\n\n# Driver Code\nif __name__ == '__main__':\n    txt = \"GEEKS FOR GEEKS\"\n    pat = \"GEEK\"\n\n    # A prime number\n    q = 101\n\n    # Function Call\n    search(pat, txt, q)\n\n# This code is contributed by Bhavya Jain\n// Following program is a C# implementation\n// of Rabin Karp Algorithm given in the CLRS book\nusing System;\npublic class GFG {\n    // d is the number of characters in the input alphabet\n    public readonly static int d = 256;\n\n    // Search the pat string in the txt string\n    static void search(String pat, String txt, int q)\n    {\n        int M = pat.Length;\n        int N = txt.Length;\n        int i, j;\n        int p = 0; // hash value for pattern\n        int t = 0; // hash value for txt\n        int h = 1;\n\n        // The value of h would be \"pow(d, M-1)%q\"\n        for (i = 0; i < M - 1; i++)\n            h = (h * d) % q;\n\n        // Calculate the hash value of pattern and first\n        // window of text\n        for (i = 0; i < M; i++) {\n            p = (d * p + pat[i]) % q;\n            t = (d * t + txt[i]) % q;\n        }\n\n        // Slide the pattern over text one by one\n        for (i = 0; i <= N - M; i++) {\n\n            // Check the hash values of current window of\n            // text and pattern. If the hash values match\n            // then only check for characters one by one\n            if (p == t) {\n                /* Check for characters one by one */\n                for (j = 0; j < M; j++) {\n                    if (txt[i + j] != pat[j])\n                        break;\n                }\n\n                // if p == t and pat[0...M-1] = txt[i, i+1,\n                // ...i+M-1]\n                if (j == M)\n                    Console.WriteLine(\n                        \"Pattern found at index \" + i);\n            }\n\n            // Calculate hash value for next window of text:\n            // Remove leading digit, add trailing digit\n            if (i < N - M) {\n                t = (d * (t - txt[i] * h) + txt[i + M]) % q;\n\n                // We might get negative value of t,\n                // converting it to positive\n                if (t < 0)\n                    t = (t + q);\n            }\n        }\n    }\n\n    /* Driver Code */\n    public static void Main()\n    {\n        String txt = \"GEEKS FOR GEEKS\";\n        String pat = \"GEEK\";\n\n        // A prime number\n        int q = 101;\n\n        // Function Call\n        search(pat, txt, q);\n    }\n}\n\n// This code is contributed by PrinciRaj19992\n// Following program is a JavaScript implementation \n// of Rabin Karp Algorithm given in the CLRS book \n\n// d is the number of characters in the input alphabet \nlet d = 256; \n\n// Search the pat string in the txt string\nfunction search(pat, txt, q) { \n    let M = pat.length; \n    let N = txt.length; \n    let i, j; \n    \n    // Hash value for pattern \n    let p = 0; \n    \n    // Hash value for txt \n    let t = 0; \n    let h = 1; \n\n    // The value of h would be \"pow(d, M-1) % q\" \n    for (i = 0; i < M - 1; i++) \n        h = (h * d) % q; \n\n    // Calculate the hash value of pattern and first window of text \n    for (i = 0; i < M; i++) { \n        p = (d * p + pat[i].charCodeAt()) % q; \n        t = (d * t + txt[i].charCodeAt()) % q; \n    } \n\n    // Slide the pattern over text one by one \n    for (i = 0; i <= N - M; i++) { \n        // Check the hash values of current window of text and pattern\n        if (p == t) { \n            /* Check for characters one by one */\n            for (j = 0; j < M; j++) { \n                if (txt[i + j] != pat[j]) \n                    break; \n            } \n\n            // If p == t and pat[0...M-1] = txt[i, i+1, ...i+M-1] \n            if (j == M) \n                console.log(\"Pattern found at index \" + i);\n        } \n\n        // Calculate hash value for next window of text:\n        // Remove leading digit, add trailing digit \n        if (i < N - M) { \n            t = (d * (t - txt[i].charCodeAt() * h) + txt[i + M].charCodeAt()) % q; \n\n            // We might get negative value of t, converting it to positive \n            if (t < 0) \n                t = (t + q); \n        } \n    } \n} \n\n// Driver code\nlet txt = \"GEEKS FOR GEEKS\";\nlet pat = \"GEEK\";\n\n// A prime number\nlet q = 101; \n\n// Function Call\nsearch(pat, txt, q);\n\n// This code is contributed by target_2\nPattern found at index 0\nPattern found at index 10\n",
        "complexity": {
            "time": "Spurious Hit: When the hash value of the pattern matches with the hash value of a window of the text but the window is not the actual pattern then it is called a spurious hit. Spurious hit increases the time complexity of the algorithm. In order to minimize spurious hit, we use good hash function. It greatly reduces the spurious hit.",
            "space": ""
        },
        "tags": [
            "Pattern Searching"
        ],
        "url": "https://www.geeksforgeeks.org/rabin-karp-algorithm-for-pattern-searching/"
    },
    {
        "title": "KMP Algorithm for Pattern Searching",
        "description": "Given two strings txt and pat, the task is to return all indices of occurrences of pat within txt. Examples: Input: txt = “abcab”,  pat = “ab”Output: [0, 3]Explanation: The string “ab” occurs twice in txt, first occurrence starts from index 0 and second from index 3. Input: txt=  “aabaacaadaabaaba”, pat =  “aaba”Output: [0, 9, 12]Explanation: Please refer Naive algorithm for pattern searching for implementation. The Naive Algorithm can work in linear time if we know for sure that all characters are distinct.  Please refer  Naive Pattern Searching for Distinct Characters in Pattern. The Naive algorithm can not be made better than linear when we have repeating characters. Examples: 1) txt[] = “AAAAAAAAAAAAAAAAAB”, pat[] = “AAAAB”2) txt[] = “ABABABCABABABCABABABC”, pat[] =  “ABABAC” (not a worst case, but a bad case for Naive) The KMP matching algorithm uses degenerating property (pattern having the same sub-patterns appearing more than once in the pattern) of the pattern and improves the worst-case complexity to O(n+m). The basic idea behind KMP’s algorithm is: whenever we detect a mismatch (after some matches), we already know some of the characters in the text of the next window. We take advantage of this information to avoid matching the characters that we know will anyway match. Matching Overview txt = “AAAAABAAABA” pat = “AAAA”We compare first window of txt with pat txt = “AAAAABAAABA” pat = “AAAA”  [Initial position]We find a match. This is same as Naive String Matching. In the next step, we compare next window of txt with pat. txt = “AAAAABAAABA” pat =  “AAAA” [Pattern shifted one position] This is where KMP does optimization over Naive. In this second window, we only compare fourth A of patternwith fourth character of current window of text to decide whether current window matches or not. Since we know first three characters will anyway match, we skipped matching first three characters. Need of Preprocessing? An important question arises from the above explanation, how to know how many characters to be skipped. To know this, we pre-process pattern and prepare an integer array lps[] that tells us the count of characters to be skipped lps[i] = the longest proper prefix of pat[0..i] which is also a suffix of pat[0..i]. Note: lps[i] could also be defined as the longest prefix which is also a proper suffix. We need to use it properly in one place to make sure that the whole substring is not considered. Examples of lps[] construction: For the pattern “AAAA”, lps[] is [0, 1, 2, 3] For the pattern “ABCDE”, lps[] is [0, 0, 0, 0, 0] For the pattern “AABAACAABAA”, lps[] is [0, 1, 0, 1, 2, 0, 1, 2, 3, 4, 5] For the pattern “AAACAAAAAC”, lps[] is [0, 1, 2, 0, 1, 2, 3, 3, 3, 4] For the pattern “AAABAAA”, lps[] is [0, 1, 2, 0, 1, 2, 3] lps[0] is always 0 since a string of length one has no non-empty proper prefix. We store the value of the previous LPS in a variable len, initialized to 0. As we traverse the pattern, we compare the current character at index i, with the character at index len. Case 1 – pat[i] = pat[len]: this means that we can simply extend the LPS at the previous index, so increment len by 1 and store its value at lps[i]. Case 2 – pat[i] != pat[len] and len = 0: it means that there were no matching characters earlier and the current characters are also not matching, so lps[i] = 0. Case 3 – pat[i] != pat[len] and len > 0: it means that we can’t extend the LPS at index i-1. However, there may be a smaller prefix that matches the suffix ending at i. To find this, we look for a smaller suffix of pat[i-len…i-1] that is also a proper prefix of pat. We then attempt to match pat[i] with the next character of this prefix. If there is a match, pat[i] = length of that matching prefix. Since lps[i-1] equals len, we know that pat[0…len-1] is the same as pat[i-len…i-1]. Thus, rather than searching through pat[i-len…i-1], we can use lps[len – 1] to update len, since that part of the pattern has already been matched. Refer the below illustration for better explanation of all the cases:   We initialize two pointers, one for the text string and another for the pattern. When the characters at both pointers match, we increment both pointers and continue the comparison. If they do not match, we reset the pattern pointer to the last value from the LPS array, because that portion of the pattern has already been matched with the text string. Similarly, if we have traversed the entire pattern string, we add the starting index of occurrence of pattern in text, to the result and continue the search from the lps value of last element of the pattern. Let’s say we are at position i in the text string and position j in the pattern string when a mismatch occurs:   Time Complexity: O(n + m), where n is the length of the text and m is the length of the pattern. This is because creating the LPS (Longest Prefix Suffix) array takes O(m) time, and the search through the text takes O(n) time. Auxiliary Space: O(m), as we need to store the LPS array of size m.  ",
        "code": "// C++ program to search the pattern in given text using\n// KMP Algorithm\n\n#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nvoid constructLps(string &pat, vector<int> &lps) {\n\n    // len stores the length of longest prefix which\n    // is also a suffix for the previous index\n    int len = 0;\n\n    // lps[0] is always 0\n    lps[0] = 0;\n\n    int i = 1;\n    while (i < pat.length()) {\n\n        // If characters match, increment the size of lps\n        if (pat[i] == pat[len]) {\n            len++;\n            lps[i] = len;\n            i++;\n        }\n\n        // If there is a mismatch\n        else {\n            if (len != 0) {\n\n                // Update len to the previous lps value\n                // to avoid reduntant comparisons\n                len = lps[len - 1];\n            }\n            else {\n\n                // If no matching prefix found, set lps[i] to 0\n                lps[i] = 0;\n                i++;\n            }\n        }\n    }\n}\n\nvector<int> search(string &pat, string &txt) {\n    int n = txt.length();\n    int m = pat.length();\n\n    vector<int> lps(m);\n    vector<int> res;\n\n    constructLps(pat, lps);\n\n    // Pointers i and j, for traversing\n    // the text and pattern\n    int i = 0;\n    int j = 0;\n\n    while (i < n) {\n\n        // If characters match, move both pointers forward\n        if (txt[i] == pat[j]) {\n            i++;\n            j++;\n\n            // If the entire pattern is matched\n            // store the start index in result\n            if (j == m) {\n                res.push_back(i - j);\n\n                // Use LPS of previous index to\n                // skip unnecessary comparisons\n                j = lps[j - 1];\n            }\n        }\n\n        // If there is a mismatch\n        else {\n\n            // Use lps value of previous index\n            // to avoid redundant comparisons\n            if (j != 0)\n                j = lps[j - 1];\n            else\n                i++;\n        }\n    }\n    return res;\n}\n\nint main() {\n    string txt = \"aabaacaadaabaaba\";\n    string pat = \"aaba\";\n\n    vector<int> res = search(pat, txt);\n    for (int i = 0; i < res.size(); i++)\n        cout << res[i] << \" \";\n\n    return 0;\n}\n// Java program to search the pattern in given text using\n// KMP Algorithm\n\nimport java.util.ArrayList;\n\nclass GfG {\n    \n    static void constructLps(String pat, int[] lps) {\n        \n        // len stores the length of longest prefix which \n        // is also a suffix for the previous index\n        int len = 0;\n\n        // lps[0] is always 0\n        lps[0] = 0;\n\n        int i = 1;\n        while (i < pat.length()) {\n            \n            // If characters match, increment the size of lps\n            if (pat.charAt(i) == pat.charAt(len)) {\n                len++;\n                lps[i] = len;\n                i++;\n            }\n            \n            // If there is a mismatch\n            else {\n                if (len != 0) {\n                    \n                    // Update len to the previous lps value \n                    // to avoid redundant comparisons\n                    len = lps[len - 1];\n                } \n                else {\n                    \n                    // If no matching prefix found, set lps[i] to 0\n                    lps[i] = 0;\n                    i++;\n                }\n            }\n        }\n    }\n\n    static ArrayList<Integer> search(String pat, String txt) {\n        int n = txt.length();\n        int m = pat.length();\n\n        int[] lps = new int[m];\n        ArrayList<Integer> res = new ArrayList<>();\n\n        constructLps(pat, lps);\n\n        // Pointers i and j, for traversing \n        // the text and pattern\n        int i = 0;\n        int j = 0;\n\n        while (i < n) {\n            // If characters match, move both pointers forward\n            if (txt.charAt(i) == pat.charAt(j)) {\n                i++;\n                j++;\n\n                // If the entire pattern is matched \n                // store the start index in result\n                if (j == m) {\n                    res.add(i - j);\n                    \n                    // Use LPS of previous index to \n                    // skip unnecessary comparisons\n                    j = lps[j - 1];\n                }\n            }\n            \n            // If there is a mismatch\n            else {\n                \n                // Use lps value of previous index\n                // to avoid redundant comparisons\n                if (j != 0)\n                    j = lps[j - 1];\n                else\n                    i++;\n            }\n        }\n        return res; \n    }\n\n    public static void main(String[] args) {\n        String txt = \"aabaacaadaabaaba\"; \n        String pat = \"aaba\"; \n\n        ArrayList<Integer> res = search(pat, txt);\n        for (int i = 0; i < res.size(); i++) \n            System.out.print(res.get(i) + \" \");\n    }\n}\n# Python program to search the pattern in given text \n# using KMP Algorithm\n\ndef constructLps(pat, lps):\n    \n    # len stores the length of longest prefix which \n    # is also a suffix for the previous index\n    len_ = 0\n    m = len(pat)\n    \n    # lps[0] is always 0\n    lps[0] = 0\n\n    i = 1\n    while i < m:\n        \n        # If characters match, increment the size of lps\n        if pat[i] == pat[len_]:\n            len_ += 1\n            lps[i] = len_\n            i += 1\n        \n        # If there is a mismatch\n        else:\n            if len_ != 0:\n                \n                # Update len to the previous lps value \n                # to avoid redundant comparisons\n                len_ = lps[len_ - 1]\n            else:\n                \n                # If no matching prefix found, set lps[i] to 0\n                lps[i] = 0\n                i += 1\n\ndef search(pat, txt):\n    n = len(txt)\n    m = len(pat)\n\n    lps = [0] * m\n    res = []\n\n    constructLps(pat, lps)\n\n    # Pointers i and j, for traversing \n    # the text and pattern\n    i = 0\n    j = 0\n\n    while i < n:\n        \n        # If characters match, move both pointers forward\n        if txt[i] == pat[j]:\n            i += 1\n            j += 1\n\n            # If the entire pattern is matched \n            # store the start index in result\n            if j == m:\n                res.append(i - j)\n                \n                # Use LPS of previous index to \n                # skip unnecessary comparisons\n                j = lps[j - 1]\n        \n        # If there is a mismatch\n        else:\n            \n            # Use lps value of previous index\n            # to avoid redundant comparisons\n            if j != 0:\n                j = lps[j - 1]\n            else:\n                i += 1\n    return res \n\nif __name__ == \"__main__\":\n    txt = \"aabaacaadaabaaba\"\n    pat = \"aaba\"\n\n    res = search(pat, txt)\n    for i in range(len(res)):\n        print(res[i], end=\" \")\n// C# program to search the pattern in given text using\n// KMP Algorithm\n\nusing System;\nusing System.Collections.Generic;\n\nclass GfG {\n    static void ConstructLps(string pat, int[] lps) {\n        // len stores the length of longest prefix which \n        // is also a suffix for the previous index\n        int len = 0;\n\n        // lps[0] is always 0\n        lps[0] = 0;\n\n        int i = 1;\n        while (i < pat.Length) {\n          \n            // If characters match, increment the size of lps\n            if (pat[i] == pat[len]) {\n                len++;\n                lps[i] = len;\n                i++;\n            }\n          \n            // If there is a mismatch\n            else {\n                if (len != 0) {\n                  \n                    // Update len to the previous lps value \n                    // to avoid redundant comparisons\n                    len = lps[len - 1];\n                }\n                else {\n                  \n                    // If no matching prefix found, set lps[i] to 0\n                    lps[i] = 0;\n                    i++;\n                }\n            }\n        }\n    }\n\n    static List<int> search(string pat, string txt) {\n        int n = txt.Length;\n        int m = pat.Length;\n\n        int[] lps = new int[m];\n        List<int> res = new List<int>();\n\n        ConstructLps(pat, lps);\n\n        // Pointers i and j, for traversing \n        // the text and pattern\n        int i = 0;\n        int j = 0;\n\n        while (i < n) {\n          \n            // If characters match, move both pointers forward\n            if (txt[i] == pat[j]) {\n                i++;\n                j++;\n\n                // If the entire pattern is matched \n                // store the start index in result\n                if (j == m) {\n                    res.Add(i - j);\n                    \n                    // Use LPS of previous index to \n                    // skip unnecessary comparisons\n                    j = lps[j - 1];\n                }\n            }\n            \n            // If there is a mismatch\n            else {\n            \n                // Use lps value of previous index\n                // to avoid redundant comparisons\n                if (j != 0)\n                    j = lps[j - 1];\n                else\n                    i++;\n            }\n        }\n        return res;\n    }\n\n    static void Main(string[] args) {\n        string txt = \"aabaacaadaabaaba\";\n        string pat = \"aaba\";\n\n        List<int> res = search(pat, txt);\n        for (int i = 0; i < res.Count; i++)\n            Console.Write(res[i] + \" \");\n    }\n}\n// JavaScript program to search the pattern in given text \n// using KMP Algorithm\n\nfunction constructLps(pat, lps) {\n    \n    // len stores the length of longest prefix which \n    // is also a suffix for the previous index\n    let len = 0;\n\n    // lps[0] is always 0\n    lps[0] = 0;\n\n    let i = 1;\n    while (i < pat.length) {\n        \n        // If characters match, increment the size of lps\n        if (pat[i] === pat[len]) {\n            len++;\n            lps[i] = len;\n            i++;\n        }\n        \n        // If there is a mismatch\n        else {\n            if (len !== 0) {\n                \n                // Update len to the previous lps value \n                // to avoid redundant comparisons\n                len = lps[len - 1];\n            } else {\n                \n                // If no matching prefix found, set lps[i] to 0\n                lps[i] = 0;\n                i++;\n            }\n        }\n    }\n}\n\nfunction search(pat, txt) {\n    const n = txt.length;\n    const m = pat.length;\n\n    const lps = new Array(m);\n    const res = [];\n\n    constructLps(pat, lps);\n\n    // Pointers i and j, for traversing \n    // the text and pattern\n    let i = 0;\n    let j = 0;\n\n    while (i < n) {\n        \n        // If characters match, move both pointers forward\n        if (txt[i] === pat[j]) {\n            i++;\n            j++;\n\n            // If the entire pattern is matched \n            // store the start index in result\n            if (j === m) {\n                res.push(i - j);\n                \n                // Use LPS of previous index to \n                // skip unnecessary comparisons\n                j = lps[j - 1];\n            }\n        }\n        \n        // If there is a mismatch\n        else {\n            \n            // Use lps value of previous index\n            // to avoid redundant comparisons\n            if (j !== 0)\n                j = lps[j - 1];\n            else\n                i++;\n        }\n    }\n    return res; \n}\n\nconst txt = \"aabaacaadaabaaba\";\nconst pat = \"aaba\";\n\nconst res = search(pat, txt);\nconsole.log(res.join(\" \"));\n0 9 12\n",
        "complexity": {
            "time": "Time Complexity: O(n + m), where n is the length of the text and m is the length of the pattern. This is because creating the LPS (Longest Prefix Suffix) array takes O(m) time, and the search through the text takes O(n) time.",
            "space": ""
        },
        "tags": [
            "Pattern Searching"
        ],
        "url": "https://www.geeksforgeeks.org/kmp-algorithm-for-pattern-searching"
    },
    {
        "title": "Z algorithm (Linear time pattern searching Algorithm)",
        "description": "This algorithm efficiently locates all instances of a specific pattern within a text in linear time. If the length of the text is “n” and the length of the pattern is “m,” then the total time taken is O(m + n), with a linear auxiliary space. It is worth noting that the time and auxiliary space of this algorithm is the same as the KMP algorithm, but this particular algorithm is simpler to comprehend. In this approach, we create a Z array as part of the process. For a string str[0..n-1], Z array is of same length as string. An element Z[i] of Z array stores length of the longest substring starting from str[i] which is also a prefix of str[0..n-1]. The first entry of Z array is meaning less as complete string is always prefix of itself. Example:Index           0   1   2   3   4   5   6   7   8   9  10  11 Text             a   a   b   c   a   a   b   x   a   a   a   zZ values      X   1   0   0   3   1   0   0   2   2   1   0 More Examples:str  = “aaaaaa”Z[]  = {x, 5, 4, 3, 2, 1}str = “aabaacd”Z[] = {x, 1, 0, 2, 1, 0, 0}str = “abababab”Z[] = {x, 0, 6, 0, 4, 0, 2, 0} How is Z array helpful in Searching Pattern in Linear time? The idea is to concatenate pattern and text, and create a string “P$T” where P is pattern, $ is a special character should not be present in pattern and text, and T is text. Build the Z array for concatenated string. In Z array, if Z value at any point is equal to pattern length, then pattern is present at that point. Example:Pattern P = “aab”,  Text T = “baabaa”The concatenated string is = “aab$baabaa”Z array for above concatenated string is {x, 1, 0, 0, 0, 3, 1, 0, 2, 1}.Since length of pattern is 3, the value 3 in Z array indicates presence of pattern. How to construct Z array?      A Simple Solution is to run two nested loops, the outer loop goes to every index and the inner loop finds length of the longest prefix that matches the substring starting at the current index. The time complexity of this solution is O(n2).      We can construct Z array in linear time. The idea is to maintain an interval [L, R] which is the interval with max R such that [L,R] is prefix substring (substring which is also prefix). Steps for maintaining this interval are as follows – 1) If i > R then there is no prefix substring that starts before i and  ends after i, so we reset L and R and compute new [L,R] by comparing str[0..] to str[i..] and get Z[i] (= R-L+1).2) If i <= R then let K = i-L,  now Z[i] >= min(Z[K], R-i+1)  because  str[i..] matches with str[K..] for atleast R-i+1 characters (they are in  [L,R] interval which we know is a prefix substring). Now two sub cases arise –  a) If Z[K] < R-i+1  then there is no prefix substring starting at str[i] (otherwise Z[K] would be larger)  so  Z[i] = Z[K]  and interval [L,R] remains same. b) If Z[K] >= R-i+1 then it is possible to extend the [L,R] interval thus we will set L as i and start matching from str[R]  onwards and get new R then we will update interval [L,R] and calculate Z[i] (=R-L+1). The algorithm runs in linear time because we never compare character less than R and with matching we increase R by one so there are at most T comparisons. In mismatch case, mismatch happen only once for each i (because of which R stops), that’s another at most T comparison making overall linear complexity. Below is the implementation of Z algorithm for pattern searching.  Time Complexity: O(m+n), where m is length of pattern and n is length of text.Auxiliary Space: O(n) U  ",
        "code": "// A C++ program that implements Z algorithm for pattern searching\n#include<iostream>\nusing namespace std;\n\nvoid getZarr(string str, int Z[]);\n\n// prints all occurrences of pattern in text using Z algo\nvoid search(string &text, string &pattern)\n{\n    // Create concatenated string \"P$T\"\n    string concat = pattern + \"$\" + text;\n    int l = concat.length();\n\n    // Construct Z array\n    int Z[l];\n    getZarr(concat, Z);\n\n    // now looping through Z array for matching condition\n    for (int i = 0; i < l; ++i)\n    {\n        // if Z[i] (matched region) is equal to pattern\n        // length we got the pattern\n        if (Z[i] == pattern.length())\n            cout << \"Pattern found at index \"\n                << i - pattern.length() -1 << endl;\n    }\n}\n\n// Fills Z array for given string str[]\nvoid getZarr(string str, int Z[])\n{\n    int n = str.length();\n    int L, R, k;\n\n    // [L,R] make a window which matches with prefix of s\n    L = R = 0;\n    for (int i = 1; i < n; ++i)\n    {\n        // if i>R nothing matches so we will calculate.\n        // Z[i] using naive way.\n        if (i > R)\n        {\n            L = R = i;\n\n            // R-L = 0 in starting, so it will start\n            // checking from 0'th index. For example,\n            // for \"ababab\" and i = 1, the value of R\n            // remains 0 and Z[i] becomes 0. For string\n            // \"aaaaaa\" and i = 1, Z[i] and R become 5\n            while (R<n && str[R-L] == str[R])\n                R++;\n            Z[i] = R-L;\n            R--;\n        }\n        else\n        {\n            // k = i-L so k corresponds to number which\n            // matches in [L,R] interval.\n            k = i-L;\n\n            // if Z[k] is less than remaining interval\n            // then Z[i] will be equal to Z[k].\n            // For example, str = \"ababab\", i = 3, R = 5\n            // and L = 2\n            if (Z[k] < R-i+1)\n                Z[i] = Z[k];\n\n            // For example str = \"aaaaaa\" and i = 2, R is 5,\n            // L is 0\n            else\n            {\n                // else start from R and check manually\n                L = i;\n                while (R<n && str[R-L] == str[R])\n                    R++;\n                Z[i] = R-L;\n                R--;\n            }\n        }\n    }\n}\n\n// Driver program\nint main()\n{\n    string text = \"GEEKS FOR GEEKS\";\n    string pattern = \"GEEK\";\n    search(text, pattern);\n    return 0;\n}\n// A Java program that implements Z algorithm for pattern\n// searching\nclass GFG { \n\n    //  prints all occurrences of pattern in text using\n    // Z algo\n    public static void search(String text, String pattern)\n    {\n\n        // Create concatenated string \"P$T\"\n        String concat = pattern + \"$\" + text;\n\n        int l = concat.length();\n\n        int Z[] = new int[l];\n\n        // Construct Z array\n        getZarr(concat, Z);\n\n        // now looping through Z array for matching condition\n        for(int i = 0; i < l; ++i){\n\n            // if Z[i] (matched region) is equal to pattern\n            // length we got the pattern\n\n            if(Z[i] == pattern.length()){\n                System.out.println(\"Pattern found at index \"\n                              + (i - pattern.length() - 1));\n            }\n        }\n    }\n\n    // Fills Z array for given string str[]\n    private static void getZarr(String str, int[] Z) {\n\n        int n = str.length();\n        \n        // [L,R] make a window which matches with \n        // prefix of s\n        int L = 0, R = 0;\n\n        for(int i = 1; i < n; ++i) {\n\n            // if i>R nothing matches so we will calculate.\n            // Z[i] using naive way.\n            if(i > R){\n\n                L = R = i;\n\n                // R-L = 0 in starting, so it will start\n                // checking from 0'th index. For example,\n                // for \"ababab\" and i = 1, the value of R\n                // remains 0 and Z[i] becomes 0. For string\n                // \"aaaaaa\" and i = 1, Z[i] and R become 5\n\n                while(R < n && str.charAt(R - L) == str.charAt(R))\n                    R++;\n                \n                Z[i] = R - L;\n                R--;\n\n            }\n            else{\n\n                // k = i-L so k corresponds to number which\n                // matches in [L,R] interval.\n                int k = i - L;\n\n                // if Z[k] is less than remaining interval\n                // then Z[i] will be equal to Z[k].\n                // For example, str = \"ababab\", i = 3, R = 5\n                // and L = 2\n                if(Z[k] < R - i + 1)\n                    Z[i] = Z[k];\n\n                // For example str = \"aaaaaa\" and i = 2, R is 5,\n                // L is 0\n                else{\n\n\n                // else start from R and check manually\n                    L = i;\n                    while(R < n && str.charAt(R - L) == str.charAt(R))\n                        R++;\n                    \n                    Z[i] = R - L;\n                    R--;\n                }\n            }\n        }\n    }\n    \n    // Driver program\n    public static void main(String[] args) \n    {\n        String text = \"GEEKS FOR GEEKS\";\n        String pattern = \"GEEK\";\n\n        search(text, pattern);\n    }\n}\n\n// This code is contributed by PavanKoli.\n# Python3 program that implements Z algorithm\n# for pattern searching\n\n# Fills Z array for given string str[]\ndef getZarr(string, z):\n    n = len(string)\n\n    # [L,R] make a window which matches\n    # with prefix of s\n    l, r, k = 0, 0, 0\n    for i in range(1, n):\n\n        # if i>R nothing matches so we will calculate.\n        # Z[i] using naive way.\n        if i > r:\n            l, r = i, i\n\n            # R-L = 0 in starting, so it will start\n            # checking from 0'th index. For example,\n            # for \"ababab\" and i = 1, the value of R\n            # remains 0 and Z[i] becomes 0. For string\n            # \"aaaaaa\" and i = 1, Z[i] and R become 5\n            while r < n and string[r - l] == string[r]:\n                r += 1\n            z[i] = r - l\n            r -= 1\n        else:\n\n            # k = i-L so k corresponds to number which\n            # matches in [L,R] interval.\n            k = i - l\n\n            # if Z[k] is less than remaining interval\n            # then Z[i] will be equal to Z[k].\n            # For example, str = \"ababab\", i = 3, R = 5\n            # and L = 2\n            if z[k] < r - i + 1:\n                z[i] = z[k]\n\n            # For example str = \"aaaaaa\" and i = 2, \n            # R is 5, L is 0\n            else:\n\n                # else start from R and check manually\n                l = i\n                while r < n and string[r - l] == string[r]:\n                    r += 1\n                z[i] = r - l\n                r -= 1\n\n# prints all occurrences of pattern \n# in text using Z algo\ndef search(text, pattern):\n\n    # Create concatenated string \"P$T\"\n    concat = pattern + \"$\" + text\n    l = len(concat)\n\n    # Construct Z array\n    z = [0] * l\n    getZarr(concat, z)\n\n    # now looping through Z array for matching condition\n    for i in range(l):\n\n        # if Z[i] (matched region) is equal to pattern\n        # length we got the pattern\n        if z[i] == len(pattern):\n            print(\"Pattern found at index\", \n                      i - len(pattern) - 1)\n\n# Driver Code\nif __name__ == \"__main__\":\n    text = \"GEEKS FOR GEEKS\"\n    pattern = \"GEEK\"\n    search(text, pattern)\n\n# This code is contributed by\n# sanjeev2552\n// A C# program that implements Z \n// algorithm for pattern searching \nusing System;\n\nclass GFG\n{\n\n// prints all occurrences of \n// pattern in text using Z algo \npublic static void search(string text,\n                          string pattern)\n{\n\n    // Create concatenated string \"P$T\" \n    string concat = pattern + \"$\" + text;\n\n    int l = concat.Length;\n\n    int[] Z = new int[l];\n\n    // Construct Z array \n    getZarr(concat, Z);\n\n    // now looping through Z array\n    // for matching condition \n    for (int i = 0; i < l; ++i)\n    {\n\n        // if Z[i] (matched region) is equal \n        // to pattern length we got the pattern \n\n        if (Z[i] == pattern.Length)\n        {\n            Console.WriteLine(\"Pattern found at index \" + \n                             (i - pattern.Length - 1));\n        }\n    }\n}\n\n// Fills Z array for given string str[] \nprivate static void getZarr(string str,\n                            int[] Z)\n{\n\n    int n = str.Length;\n\n    // [L,R] make a window which \n    // matches with prefix of s \n    int L = 0, R = 0;\n\n    for (int i = 1; i < n; ++i)\n    {\n\n        // if i>R nothing matches so we will \n        // calculate. Z[i] using naive way. \n        if (i > R)\n        {\n            L = R = i;\n\n            // R-L = 0 in starting, so it will start \n            // checking from 0'th index. For example, \n            // for \"ababab\" and i = 1, the value of R \n            // remains 0 and Z[i] becomes 0. For string \n            // \"aaaaaa\" and i = 1, Z[i] and R become 5 \n            while (R < n && str[R - L] == str[R])\n            {\n                R++;\n            }\n\n            Z[i] = R - L;\n            R--;\n\n        }\n        else\n        {\n\n            // k = i-L so k corresponds to number \n            // which matches in [L,R] interval. \n            int k = i - L;\n\n            // if Z[k] is less than remaining interval \n            // then Z[i] will be equal to Z[k]. \n            // For example, str = \"ababab\", i = 3, \n            // R = 5 and L = 2 \n            if (Z[k] < R - i + 1)\n            {\n                Z[i] = Z[k];\n            }\n\n            // For example str = \"aaaaaa\" and \n            // i = 2, R is 5, L is 0 \n            else\n            {\n\n\n                // else start from R and \n                // check manually \n                L = i;\n                while (R < n && str[R - L] == str[R])\n                {\n                    R++;\n                }\n\n                Z[i] = R - L;\n                R--;\n            }\n        }\n    }\n}\n\n// Driver Code \npublic static void Main(string[] args)\n{\n    string text = \"GEEKS FOR GEEKS\";\n    string pattern = \"GEEK\";\n\n    search(text, pattern);\n}\n}\n\n// This code is contributed by Shrikant13\n// A JavaScript program that implements Z algorithm for\n// pattern searching\n\n//  prints all occurrences of pattern in text using algo\nfunction search(text, pattern)\n{\n    // Create concatenated string \"P$T\"\n    let concat = pattern + \"$\" + text;\n\n    let l = concat.length;\n\n    let Z = new Array(l);\n\n    // Construct Z array\n    getZarr(concat, Z);\n\n    // now looping through Z array for matching condition\n    for (let i = 0; i < l; ++i) {\n\n        // if Z[i] (matched region) is equal to pattern\n        // length we got the pattern\n\n        if (Z[i] == pattern.length) {\n            console.log(\"Pattern found at index \"\n                        + (i - pattern.length - 1));\n        }\n    }\n}\n\n// Fills Z array for given string str[]\nfunction getZarr(str, Z)\n{\n    let n = str.length;\n\n    // [L,R] make a window which matches with\n    // prefix of s\n    let L = 0, R = 0;\n\n    for (let i = 1; i < n; ++i) {\n\n        // if i>R nothing matches so we will calculate.\n        // Z[i] using naive way.\n        if (i > R) {\n\n            L = R = i;\n\n            // R-L = 0 in starting, so it will start\n            // checking from 0'th index. For example,\n            // for \"ababab\" and i = 1, the value of R\n            // remains 0 and Z[i] becomes 0. For string\n            // \"aaaaaa\" and i = 1, Z[i] and R become 5\n\n            while (R < n && str[R - L] == str[R])\n                R++;\n\n            Z[i] = R - L;\n            R--;\n        }\n        else {\n\n            // k = i-L so k corresponds to number which\n            // matches in [L,R] interval.\n            let k = i - L;\n\n            // if Z[k] is less than remaining interval\n            // then Z[i] will be equal to Z[k].\n            // For example, str = \"ababab\", i = 3, R = 5\n            // and L = 2\n            if (Z[k] < R - i + 1)\n                Z[i] = Z[k];\n\n            // For example str = \"aaaaaa\" and i = 2, R is 5,\n            // L is 0\n            else {\n\n                // else start from R and check manually\n                L = i;\n                while (R < n && str[R - L] == str[R])\n                    R++;\n\n                Z[i] = R - L;\n                R--;\n            }\n        }\n    }\n}\n\n// Driver program\nlet text = \"GEEKS FOR GEEKS\";\nlet pattern = \"GEEK\";\n\nsearch(text, pattern);\nPattern found at index 0\nPattern found at index 10\n",
        "complexity": {
            "time": "Time Complexity: O(m+n), where m is length of pattern and n is length of text.Auxiliary Space: O(n)",
            "space": ""
        },
        "tags": [
            "Pattern Searching"
        ],
        "url": "https://www.geeksforgeeks.org/z-algorithm-linear-time-pattern-searching-algorithm/"
    },
    {
        "title": "Trie Data Structure Tutorial",
        "description": "The trie data structure, also known as a prefix tree, is a tree-like data structure used for efficient retrieval of key-value pairs. It is commonly used for implementing dictionaries and autocomplete features, making it a fundamental component in many search algorithms. In this article, we will explore all about Trie data structures in detail.  Trie Data Structure  Table of Content Trie data structure is defined as a Tree based data structure that is used for storing a collection of strings and performing efficient search, insert, delete, prefix search and sorted-traversal-of-all operations on them. The word Trie is derived from reTRIEval, which means finding something or obtaining it. Trie data structure follows a property that If two strings have a common prefix then they will have the same ancestor in the trie. This particular property allows to find all words with a given prefix. A Trie data structure is used for storing and retrieval of data and the same operations could be done using another data structure which is Hash Table but Trie data structure can perform these operations more efficiently than a Hash Table. Moreover, Trie has its own advantage over the Hash table. A Trie data structure can be used for prefix-based searching and a sorted traversal of all words. So a Trie has advantages of both hash table and self balancing binary search trees. However the main issue with Trie is extra memory space required to store words and the space may become huge for long list of words and/or for long words. The A trie data structure has the following advantages over a hash table: Below are some important properties of the Trie data structure: Below is a simple example of Trie data structure. Trie Data Structure Trie data structure can contain any number of characters including alphabets, numbers, and special characters. But for this article, we will discuss strings with characters a-z. Therefore, only 26 pointers need for every node, where the 0th index represents ‘a’ and the 25th index represents ‘z’ characters. Any lowercase English word can start with a-z, then the next letter of the word could be a-z, the third letter of the word again could be a-z, and so on. So for storing a word, we need to take an array (container) of size 26 and initially, all the characters are empty as there are no words and it will look as shown below. An array of pointers inside every Trie node Let’s see how a word “and” and “ant” is stored in the Trie data structure: After storing the word “and” and “ant” the Trie will look like this: Every Trie node consists of a character pointer array or hashmap and a flag to represent if the word is ending at that node or not. But if the words contain only lower-case letters (i.e. a-z), then we can define Trie Node with an array instead of a hashmap. This operation is used to insert new strings into the Trie data structure. Let us see how this works: Let us try to Insert “and” & “ant” in this Trie: Insert “and” & “ant” From the above representation of insertion, we can see that the word “and” & “ant” have shared some common node (i.e “an”) this is because of the property of the Trie data structure that If two strings have a common prefix then they will have the same ancestor in the trie. Now let us try to Insert “dad” & “do”: Insertion in Trie Data Structure Algorithm: Below is the implementation of the above algorithm: Search operation in Trie is performed in a similar way as the insertion operation but the only difference is that whenever we find that the array of pointers in curr node does not point to the current character of the word then return false instead of creating a new node for that current character of the word. This operation is used to search whether a string is present in the Trie data structure or not. There are two search approaches in the Trie data structure. There is a similar search pattern in both approaches. The first step in searching a given word in Trie is to convert the word to characters and then compare every character with the trie node from the root node. If the current character is present in the node, move forward to its children. Repeat this process until all characters are found. Search for the prefix “an” in the Trie Data Structure. Search for the prefix “an” in Trie It is similar to prefix search but additionally, we have to check if the word is ending at the last character of the word or not. Search “dad” in the Trie data structure This operation is used to delete strings from the Trie data structure. There are three cases when deleting a word from Trie. As shown in the following figure, the deleted word “an” share a complete prefix with another word “and” and “ant“. Deletion of word which is a prefix of other words in Trie An easy solution to perform a delete operation for this case is to just decrement the wordCount by 1 at the ending node of the word. As shown in the following figure, the deleted word “and” has some common prefixes with other words ‘ant’. They share the prefix ‘an’. Deletion of word which shares a common prefix with other words in Trie The solution for this case is to delete all the nodes starting from the end of the prefix to the last character of the given word. As shown in the following figure, the word “geek” does not share any common prefix with any other words.  The solution for this case is just to delete all the nodes. Below is the implementation that handles all the above cases: Algorithm: Note: In the above complexity table ‘n’, ‘m’ represents the size of the string and the number of strings that are stored in the trie. 1. Autocomplete Feature: Autocomplete provides suggestions based on what you type in the search box. Trie data structure is used to implement autocomplete functionality. Autocomplete feature of Trie Data Structure 2. Spell Checkers: If the word typed does not appear in the dictionary, then it shows suggestions based on what you typed.It is a 3-step process that includes : Trie stores the data dictionary and makes it easier to build an algorithm for searching the word from the dictionary and provides the list of valid words for the suggestion. 3. Longest Prefix Matching Algorithm(Maximum Prefix Length Match): This algorithm is used in networking by the routing devices in IP networking. Optimization of network routes requires contiguous masking that bound the complexity of lookup a time to O(n), where n is the length of the URL address in bits. To speed up the lookup process, Multiple Bit trie schemes were developed that perform the lookups of multiple bits faster. Our discussion so far has led us to the conclusion that the Trie data structure is a Tree based data structure that is used for storing some collection of strings and performing efficient search operations on them and we have also discussed the various advantage and applications of trie data structure. Related articles:  ",
        "code": "struct TrieNode {\n    struct TrieNode* children[ALPHABET_SIZE];\n\n    // This will keep track of number of strings that are\n    // stored in the Trie from root node to any Trie node.\n    int wordCount = 0;\n};\npublic class TrieNode {\n    public TrieNode[] children;\n    public int wordCount;\n\n    public TrieNode()\n    {\n        children = new TrieNode[26];\n        // This will keep track of number of strings that\n        // are stored in the Trie from root node to any Trie\n        // node.\n        wordCount = 0;\n    }\n}\n# Python code\nclass TrieNode:\n\n    # Trie node class\n    def _init_(self):\n        self.children = [None for _ in range(26)]\n\n        # This will keep track of number of strings that are\n        # stored in the Trie from root node to any Trie node.\n        self.wordCount = 0\n        \n        # This code is contributed by ishankhandelwals.\n// Include namespace system\nusing System;\n\n\npublic class TrieNode\n{\n    public TrieNode[] children;\n    public int wordCount;\n    public TrieNode()\n    {\n        this.children = new TrieNode[26];\n        // This will keep track of number of strings that\n        // are stored in the Trie from root node to any Trie\n        // node.\n        this.wordCount = 0;\n    }\n}\n// JS code\nclass TrieNode {\n\n    constructor() \n    {\n        this.children = new Array(26);\n        // This will keep track of number of strings that are\n        // stored in the Trie from root node to any Trie node.\n        this.wordCount = 0;\n    }\n}\n\n// This code is contributed by ishankhandelwals.\nvoid insert_key(TrieNode* root, string& key)\n{\n    // Initialize the currentNode pointer\n    // with the root node\n    TrieNode* currentNode = root;\n\n    // Iterate across the length of the string\n    for (auto c : key) {\n\n        // Check if the node exist for the current\n        // character in the Trie.\n        if (currentNode->childNode[c - 'a'] == NULL) {\n\n            // If node for current character does not exist\n            // then make a new node\n            TrieNode* newNode = new TrieNode();\n\n            // Keep the reference for the newly created\n            // node.\n            currentNode->childNode[c - 'a'] = newNode;\n        }\n\n        // Now, move the current node pointer to the newly\n        // created node.\n        currentNode = currentNode->childNode[c - 'a'];\n    }\n\n    // Increment the wordEndCount for the last currentNode\n    // pointer this implies that there is a string ending at\n    // currentNode.\n    currentNode->wordCount++;\n}\nstatic void insert(TrieNode root, String key)\n{\n    // Initialize the currentNode pointer with the root node\n    TrieNode currentNode = root;\n\n    for (int i = 0; i < key.length(); i++) {\n        int index = key.charAt(i) - 'a';\n\n        // Check if the node exist for the current\n        // character in the Trie.\n        if (currentNode.childNode[index] == null) {\n\n            // Keep the reference for the newly created\n            // node.\n            currentNode.childNode[index] = new TrieNode();\n        }\n\n        // Now, move the current node pointer to the newly\n        // created node.\n        currentNode = currentNode.childNode[index];\n    }\n\n    // Increment the wordEndCount for the last currentNode\n    // pointer this implies that there is a string ending at\n    // currentNode.\n    currentNode.wordCount++;\n}\ndef insert_key(root, key):\n    # Initialize the currentNode pointer\n    # with the root node\n    currentNode = root\n\n    # Iterate across the length of the string\n    for c in key:\n        # Check if the node exist for the current\n        # character in the Trie.\n        if currentNode.childNode[ord(c) - ord('a')] == None:\n            # If node for current character does not exist\n            # then make a new node\n            newNode = TrieNode()\n\n            # Keep the reference for the newly created\n            # node.\n            currentNode.childNode[ord(c) - ord('a')] = newNode\n\n        # Now, move the current node pointer to the newly\n        # created node.\n        currentNode = currentNode.childNode[ord(c) - ord('a')]\n\n    # Increment the wordEndCount for the last currentNode\n    # pointer this implies that there is a string ending at\n    # currentNode.\n    currentNode.wordCount += 1\nstatic void insert(TrieNode root, string key)\n{\n    // Initialize the currentNode pointer with the root node\n    TrieNode currentNode = root;\n\n    for (int i = 0; i < key.Length; i++) {\n        int index = key[i] - 'a';\n\n        // Check if the node exist for the current\n        // character in the Trie.\n        if (currentNode.childNode[index] == null) {\n\n            // Keep the reference for the newly created\n            // node.\n            currentNode.childNode[index] = new TrieNode();\n        }\n\n        // Now, move the current node pointer to the newly\n        // created node.\n        currentNode = currentNode.childNode[index];\n    }\n\n    // Increment the wordEndCount for the last currentNode\n    // pointer this implies that there is a string ending at\n    // currentNode.\n    currentNode.wordCount++;\n}\n// JS code for above approach\nfunction insert_key(root, key)\n{\n    // Initialize the currentNode pointer\n    // with the root node\n    let currentNode = root;\n    // Iterate across the length of the string\n    for (let i=0;i<key.length;i++) {\n        // Check if the node exist for the current\n        // character in the Trie.\n        if (currentNode.childNode[key[i]- 'a'] == NULL) {\n            // If node for current character does not exist\n            // then make a new node\n            let newNode = new TrieNode();\n            // Keep the reference for the newly created\n            // node.\n            currentNode.childNode[key[i] - 'a'] = newNode;\n        }\n        // Now, move the current node pointer to the newly\n        // created node.\n        currentNode = currentNode.childNode[key[i] - 'a'];\n    }\n    // Increment the wordEndCount for the last currentNode\n    // pointer this implies that there is a string ending at\n    // currentNode.\n    currentNode.wordCount++;\n}\nbool isPrefixExist(TrieNode* root, string& key)\n{\n    // Initialize the currentNode pointer\n    // with the root node\n    TrieNode* currentNode = root;\n\n    // Iterate across the length of the string\n    for (auto c : key) {\n\n        // Check if the node exist for the current\n        // character in the Trie.\n        if (currentNode->childNode[c - 'a'] == NULL) {\n          \n            // Given word as a prefix does not exist in Trie\n            return false;\n        }\n\n        // Move the currentNode pointer to the already \n        // existing node for current character.\n        currentNode = currentNode->childNode[c - 'a'];\n    }\n \n      // Prefix exist in the Trie\n    return true;\n}\npublic boolean isPrefixExist(TrieNode root, String key) {\n    // Initialize the currentNode pointer\n    // with the root node\n    TrieNode currentNode = root;\n\n    // Iterate across the length of the string\n    for (char c : key.toCharArray()) {\n\n        // Check if the node exist for the current\n        // character in the Trie.\n        if (currentNode.childNode[c - 'a'] == null) {\n          \n            // Given word as a prefix does not exist in Trie\n            return false;\n        }\n\n        // Move the currentNode pointer to the already \n        // existing node for current character.\n        currentNode = currentNode.childNode[c - 'a'];\n    }\n \n      // Prefix exist in the Trie\n    return true;\n}\ndef is_prefix_exist(root, key):\n    # Initialize the currentNode pointer\n    # with the root node\n    current_node = root\n\n    # Iterate across the length of the string\n    for c in key:\n        # Check if the node exist for the current\n        # character in the Trie.\n        if current_node.child_node[ord(c) - ord('a')] is None:\n            # Given word as a prefix does not exist in Trie\n            return False\n\n        # Move the currentNode pointer to the already \n        # existing node for current character.\n        current_node = current_node.child_node[ord(c) - ord('a')]\n\n    # Prefix exist in the Trie\n    return True\npublic bool isPrefixExist(TrieNode root, string key)\n{\n    // Initialize the currentNode pointer\n    // with the root node\n    TrieNode currentNode = root;\n\n    // Iterate across the length of the string\n    foreach (char c in key)\n    {\n\n        // Check if the node exist for the current\n        // character in the Trie.\n        if (currentNode.childNode[c - 'a'] == null)\n        {\n\n            // Given word as a prefix does not exist in Trie\n            return false;\n        }\n\n        // Move the currentNode pointer to the already \n        // existing node for current character.\n        currentNode = currentNode.childNode[c - 'a'];\n    }\n\n    // Prefix exist in the Trie\n    return true;\n}\nfunction isPrefixExist(root, key) {\n    // Initialize the currentNode pointer with the root node\n    let currentNode = root;\n\n    // Iterate across the length of the string\n    for (let c of key) {\n\n        // Check if the node exist for the current character in the Trie.\n        if (currentNode.childNode[c.charCodeAt(0) - 'a'.charCodeAt(0)] === null) {\n          \n            // Given word as a prefix does not exist in Trie\n            return false;\n        }\n\n        // Move the currentNode pointer to the already existing node for current character.\n        currentNode = currentNode.childNode[c.charCodeAt(0) - 'a'.charCodeAt(0)];\n    }\n\n    // Prefix exist in the Trie\n    return true;\n}\nbool search_key(TrieNode* root, string& key)\n{\n    // Initialize the currentNode pointer\n    // with the root node\n    TrieNode* currentNode = root;\n\n    // Iterate across the length of the string\n    for (auto c : key) {\n\n        // Check if the node exist for the current\n        // character in the Trie.\n        if (currentNode->childNode[c - 'a'] == NULL) {\n          \n            // Given word does not exist in Trie\n            return false;\n        }\n\n        // Move the currentNode pointer to the already \n        // existing node for current character.\n        currentNode = currentNode->childNode[c - 'a'];\n    }\n \n    return (currentNode->wordCount > 0);\n}\n// Returns true if key presents in trie, else false\nstatic boolean search(TrieNode root, String key)\n{\n    // Initialize the currentNode\n    // with the root node\n    TrieNode currentNode = root;\n\n    for (int i = 0; i < key.length(); i++) {\n        int index = key.charAt(i) - 'a';\n\n        // Check if the node exist for the current\n        // character in the Trie.\n        if (currentNode.childNode[index] == null)\n            return false;\n\n        // Move the currentNode to the already\n        // existing node for current character.\n        currentNode = currentNode.childNode[index];\n    }\n\n    return (currentNode.isEndOfWord);\n}\ndef search_key(root, key):\n    # Initialize the currentNode pointer with the root node\n    currentNode = root\n\n    # Iterate across the length of the string\n    for c in key:\n        # Check if the node exist for the current character in the Trie\n        if currentNode.childNode[ord(c) - ord('a')] is None:\n            # Given word does not exist in Trie\n            return False\n\n        # Move the currentNode pointer to the already existing node for current character\n        currentNode = currentNode.childNode[ord(c) - ord('a')]\n \n    # Return if the wordCount is greater than 0\n    return currentNode.wordCount > 0\npublic bool SearchKey(TrieNode root, string key)\n{\n// Initialize the currentNode pointer with the root node\nTrieNode currentNode = root;\n  // Iterate across the length of the string\nforeach (char c in key)\n{\n    // Check if the node exist for the current character in the Trie\n    if (currentNode.childNode[c - 'a'] == null)\n    {\n        // Given word does not exist in Trie\n        return false;\n    }\n\n    // Move the currentNode pointer to the already existing node for current character\n    currentNode = currentNode.childNode[c - 'a'];\n}\n\n// Return if the wordCount is greater than 0\nreturn currentNode.wordCount > 0;\n}\n\n//This code is contributed by shivamsharma215\nfunction searchKey(root, key) {\n  let currentNode = root;\n\n  for (let c of key) {\n    if (!currentNode.childNode[c.charCodeAt(0) - 'a'.charCodeAt(0)]) {\n      return false;\n    }\n    currentNode = currentNode.childNode[c.charCodeAt(0) - 'a'.charCodeAt(0)];\n  }\n\n  return currentNode.wordCount > 0;\n}\nbool delete_key(TrieNode* root, string& word)\n{\n    TrieNode* currentNode = root;\n    TrieNode* lastBranchNode = NULL;\n    char lastBranchChar = 'a';\n\n    for (auto c : word) {\n        if (currentNode->childNode[c - 'a'] == NULL) {\n            return false;\n        }\n        else {\n            int count = 0;\n            for (int i = 0; i < 26; i++) {\n                if (currentNode->childNode[i] != NULL)\n                    count++;\n            }\n\n            if (count > 1) {\n                lastBranchNode = currentNode;\n                lastBranchChar = c;\n            }\n            currentNode = currentNode->childNode[c - 'a'];\n        }\n    }\n\n    int count = 0;\n    for (int i = 0; i < 26; i++) {\n        if (currentNode->childNode[i] != NULL)\n            count++;\n    }\n\n    // Case 1: The deleted word is a prefix of other words\n    // in Trie.\n    if (count > 0) {\n        currentNode->wordCount--;\n        return true;\n    }\n\n    // Case 2: The deleted word shares a common prefix with\n    // other words in Trie.\n    if (lastBranchNode != NULL) {\n        lastBranchNode->childNode[lastBranchChar] = NULL;\n        return true;\n    }\n    // Case 3: The deleted word does not share any common\n    // prefix with other words in Trie.\n    else {\n        root->childNode[word[0]] = NULL;\n        return true;\n    }\n}\npublic class TrieNode {\n    TrieNode[] childNode;\n    int wordCount;\n\n    public TrieNode() {\n        this.childNode = new TrieNode[26];\n        this.wordCount = 0;\n    }\n}\n\npublic class Trie {\n    TrieNode root;\n\n    public Trie() {\n        this.root = new TrieNode();\n    }\n\n    public boolean deleteKey(String word) {\n        TrieNode currentNode = root;\n        TrieNode lastBranchNode = null;\n        char lastBranchChar = 'a';\n\n        for (char c : word.toCharArray()) {\n            if (currentNode.childNode[c - 'a'] == null) {\n                // If the current node has no child, the word is not present\n                return false;\n            } else {\n                int count = 0;\n                // Count the number of non-null child nodes\n                for (int i = 0; i < 26; i++) {\n                    if (currentNode.childNode[i] != null)\n                        count++;\n                }\n\n                if (count > 1) {\n                    // If there are more than one child, store the last branch information\n                    lastBranchNode = currentNode;\n                    lastBranchChar = c;\n                }\n                currentNode = currentNode.childNode[c - 'a'];\n            }\n        }\n\n        int count = 0;\n        // Count the number of non-null child nodes at the last character\n        for (int i = 0; i < 26; i++) {\n            if (currentNode.childNode[i] != null)\n                count++;\n        }\n\n        // Case 1: The deleted word is a prefix of other words in Trie.\n        if (count > 0) {\n            // Decrement the word count and indicate successful deletion\n            currentNode.wordCount--;\n            return true;\n        }\n\n        // Case 2: The deleted word shares a common prefix with other words in Trie.\n        if (lastBranchNode != null) {\n            // Remove the link to the deleted word\n            lastBranchNode.childNode[lastBranchChar - 'a'] = null;\n            return true;\n        }\n        // Case 3: The deleted word does not share any common prefix with other words in Trie.\n        else {\n            // Remove the link to the deleted word from the root\n            root.childNode[word.charAt(0) - 'a'] = null;\n            return true;\n        }\n    }\n}\ndef delete_key(root, word):\n    current_node = root\n    last_branch_node = None\n    last_branch_char = 'a'\n\n    # loop through each character in the word\n    for c in word:\n        # if the current node doesn't have a child with the current character,\n        # return False as the word is not present in Trie\n        if current_node.childNode[ord(c) - ord('a')] is None:\n            return False\n        else:\n            count = 0\n            # count the number of children nodes of the current node\n            for i in range(26):\n                if current_node.childNode[i] is not None:\n                    count += 1\n\n            # if the count of children is more than 1,\n            # store the node and the current character\n            if count > 1:\n                last_branch_node = current_node\n                last_branch_char = c\n\n            current_node = current_node.childNode[ord(c) - ord('a')]\n\n    count = 0\n    # count the number of children nodes of the current node\n    for i in range(26):\n        if current_node.childNode[i] is not None:\n            count += 1\n\n    # Case 1: The deleted word is a prefix of other words in Trie\n    if count > 0:\n        current_node.wordCount -= 1\n        return True\n\n    # Case 2: The deleted word shares a common prefix with other words in Trie\n    if last_branch_node is not None:\n        last_branch_node.childNode[ord(last_branch_char) - ord('a')] = None\n        return True\n\n    # Case 3: The deleted word does not share any common prefix with other words in Trie\n    else:\n        root.childNode[ord(word[0]) - ord('a')] = None\n        return True\npublic bool delete_key(TrieNode root, string word)\n{\n    TrieNode current_node = root;\n    TrieNode last_branch_node = null;\n    char last_branch_char = 'a';\n\n    // loop through each character in the word\n    foreach (char c in word)\n    {\n        // if the current node doesn't have a child with the current character,\n        // return False as the word is not present in Trie\n        if (current_node.childNode[c - 'a'] == null)\n        {\n            return false;\n        }\n        else\n        {\n            int count = 0;\n            // count the number of children nodes of the current node\n            for (int i = 0; i < 26; i++)\n            {\n                if (current_node.childNode[i] != null)\n                {\n                    count++;\n                }\n            }\n\n            // if the count of children is more than 1,\n            // store the node and the current character\n            if (count > 1)\n            {\n                last_branch_node = current_node;\n                last_branch_char = c;\n            }\n\n            current_node = current_node.childNode[c - 'a'];\n        }\n    }\n\n    int wordCount = 0;\n    // count the number of children nodes of the current node\n    for (int i = 0; i < 26; i++)\n    {\n        if (current_node.childNode[i] != null)\n        {\n            wordCount++;\n        }\n    }\n\n    // Case 1: The deleted word is a prefix of other words in Trie\n    if (wordCount > 0)\n    {\n        current_node.wordCount--;\n        return true;\n    }\n\n    // Case 2: The deleted word shares a common prefix with other words in Trie\n    if (last_branch_node != null)\n    {\n        last_branch_node.childNode[last_branch_char - 'a'] = null;\n        return true;\n    }\n\n    // Case 3: The deleted word does not share any common prefix with other words in Trie\n    else\n    {\n        root.childNode[word[0] - 'a'] = null;\n        return true;\n    }\n}\n\n//This code is contributed by shivamsharma215\nfunction delete_key(root, word) {\n    let currentNode = root;\n    let lastBranchNode = null;\n    let lastBrachChar = 'a';\n\n    for (let c of word) {\n        if (currentNode.childNode[c.charCodeAt(0) - 'a'.charCodeAt(0)] === null) {\n            return false;\n        } else {\n            let count = 0;\n            for (let i = 0; i < 26; i++) {\n                if (currentNode.childNode[i] !== null) {\n                    count++;\n                }\n            }\n\n            if (count > 1) {\n                lastBranchNode = currentNode;\n                lastBrachChar = c;\n            }\n            currentNode = currentNode.childNode[c.charCodeAt(0) - 'a'.charCodeAt(0)];\n        }\n    }\n\n    let count = 0;\n    for (let i = 0; i < 26; i++) {\n        if (currentNode.childNode[i] !== null) {\n            count++;\n        }\n    }\n\n    // Case 1: The deleted word is a prefix of other words\n    // in Trie.\n    if (count > 0) {\n        currentNode.wordCount--;\n        return true;\n    }\n\n    // Case 2: The deleted word shares a common prefix with\n    // other words in Trie.\n    if (lastBranchNode !== null) {\n        lastBranchNode.childNode[lastBrachChar] = null;\n        return true;\n    }\n    // Case 3: The deleted word does not share any common\n    // prefix with other words in Trie.\n    else {\n        root.childNode[word[0].charCodeAt(0) - 'a'.charCodeAt(0)] = null;\n        return true;\n    }\n}\n\n//This code is contributed by shivamsharma215\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TrieNode {\n\n    // pointer array for child nodes of each node\n    TrieNode* childNode[26];\n    int wordCount;\n\n    TrieNode()\n    {\n        // constructor\n        // initialize the wordCnt variable with 0\n        // initialize every index of childNode array with\n        // NULL\n        wordCount = 0;\n        for (int i = 0; i < 26; i++) {\n            childNode[i] = NULL;\n        }\n    }\n};\n\nvoid insert_key(TrieNode* root, string& key)\n{\n    // Initialize the currentNode pointer\n    // with the root node\n    TrieNode* currentNode = root;\n\n    // Iterate across the length of the string\n    for (auto c : key) {\n\n        // Check if the node exist for the current\n        // character in the Trie.\n        if (currentNode->childNode[c - 'a'] == NULL) {\n\n            // If node for current character does not exist\n            // then make a new node\n            TrieNode* newNode = new TrieNode();\n\n            // Keep the reference for the newly created\n            // node.\n            currentNode->childNode[c - 'a'] = newNode;\n        }\n\n        // Now, move the current node pointer to the newly\n        // created node.\n        currentNode = currentNode->childNode[c - 'a'];\n    }\n\n    // Increment the wordEndCount for the last currentNode\n    // pointer this implies that there is a string ending at\n    // currentNode.\n    currentNode->wordCount++;\n}\n\nbool search_key(TrieNode* root, string& key)\n{\n    // Initialize the currentNode pointer\n    // with the root node\n    TrieNode* currentNode = root;\n\n    // Iterate across the length of the string\n    for (auto c : key) {\n\n        // Check if the node exist for the current\n        // character in the Trie.\n        if (currentNode->childNode[c - 'a'] == NULL) {\n\n            // Given word does not exist in Trie\n            return false;\n        }\n\n        // Move the currentNode pointer to the already\n        // existing node for current character.\n        currentNode = currentNode->childNode[c - 'a'];\n    }\n\n    return (currentNode->wordCount > 0);\n}\n\nbool delete_key(TrieNode* root, string& word)\n{\n    TrieNode* currentNode = root;\n    TrieNode* lastBranchNode = NULL;\n    char lastBrachChar = 'a';\n\n    for (auto c : word) {\n        if (currentNode->childNode[c - 'a'] == NULL) {\n            return false;\n        }\n        else {\n            int count = 0;\n            for (int i = 0; i < 26; i++) {\n                if (currentNode->childNode[i] != NULL)\n                    count++;\n            }\n\n            if (count > 1) {\n                lastBranchNode = currentNode;\n                lastBrachChar = c;\n            }\n            currentNode = currentNode->childNode[c - 'a'];\n        }\n    }\n\n    int count = 0;\n    for (int i = 0; i < 26; i++) {\n        if (currentNode->childNode[i] != NULL)\n            count++;\n    }\n\n    // Case 1: The deleted word is a prefix of other words\n    // in Trie.\n    if (count > 0) {\n        currentNode->wordCount--;\n        return true;\n    }\n\n    // Case 2: The deleted word shares a common prefix with\n    // other words in Trie.\n    if (lastBranchNode != NULL) {\n        lastBranchNode->childNode[lastBrachChar] = NULL;\n        return true;\n    }\n    // Case 3: The deleted word does not share any common\n    // prefix with other words in Trie.\n    else {\n        root->childNode[word[0]] = NULL;\n        return true;\n    }\n}\n\n// Driver code\nint main()\n{\n    // Make a root node for the Trie\n    TrieNode* root = new TrieNode();\n\n    // Stores the strings that we want to insert in the\n    // Trie\n    vector<string> inputStrings\n        = { \"and\", \"ant\", \"do\", \"geek\", \"dad\", \"ball\" };\n\n    // number of insert operations in the Trie\n    int n = inputStrings.size();\n\n    for (int i = 0; i < n; i++) {\n        insert_key(root, inputStrings[i]);\n    }\n\n    // Stores the strings that we want to search in the Trie\n    vector<string> searchQueryStrings\n        = { \"do\", \"geek\", \"bat\" };\n\n    // number of search operations in the Trie\n    int searchQueries = searchQueryStrings.size();\n\n    for (int i = 0; i < searchQueries; i++) {\n        cout << \"Query String: \" << searchQueryStrings[i]\n             << \"\\n\";\n        if (search_key(root, searchQueryStrings[i])) {\n            // the queryString is present in the Trie\n            cout << \"The query string is present in the \"\n                    \"Trie\\n\";\n        }\n        else {\n            // the queryString is not present in the Trie\n            cout << \"The query string is not present in \"\n                    \"the Trie\\n\";\n        }\n    }\n\n    // stores the strings that we want to delete from the\n    // Trie\n    vector<string> deleteQueryStrings = { \"geek\", \"tea\" };\n\n    // number of delete operations from the Trie\n    int deleteQueries = deleteQueryStrings.size();\n\n    for (int i = 0; i < deleteQueries; i++) {\n        cout << \"Query String: \" << deleteQueryStrings[i]\n             << \"\\n\";\n        if (delete_key(root, deleteQueryStrings[i])) {\n            // The queryString is successfully deleted from\n            // the Trie\n            cout << \"The query string is successfully \"\n                    \"deleted\\n\";\n        }\n        else {\n            // The query string is not present in the Trie\n            cout << \"The query string is not present in \"\n                    \"the Trie\\n\";\n        }\n    }\n\n    return 0;\n}\n# Trie implementation in Python \n\nclass TrieNode:\n    def __init__(self):\n        # pointer array for child nodes of each node\n        self.childNode = [None] * 26\n        self.wordCount = 0\n        \ndef insert_key(root, key):\n    # Initialize the currentNode pointer with the root node\n    currentNode = root\n\n    # Iterate across the length of the string\n    for c in key:\n        # Check if the node exist for the current character in the Trie.\n        if not currentNode.childNode[ord(c) - ord('a')]:\n            # If node for current character does not exist\n            # then make a new node\n            newNode = TrieNode()\n            # Keep the reference for the newly created node.\n            currentNode.childNode[ord(c) - ord('a')] = newNode\n        # Now, move the current node pointer to the newly created node.\n        currentNode = currentNode.childNode[ord(c) - ord('a')]\n    # Increment the wordEndCount for the last currentNode\n    # pointer this implies that there is a string ending at currentNode.\n    currentNode.wordCount += 1\n    \ndef search_key(root, key):\n    # Initialize the currentNode pointer with the root node\n    currentNode = root\n\n    # Iterate across the length of the string\n    for c in key:\n        # Check if the node exist for the current character in the Trie.\n        if not currentNode.childNode[ord(c) - ord('a')]:\n            # Given word does not exist in Trie\n            return False\n        # Move the currentNode pointer to the already existing node for current character.\n        currentNode = currentNode.childNode[ord(c) - ord('a')]\n\n    return currentNode.wordCount > 0\n\ndef delete_key(root, word):\n    currentNode = root\n    lastBranchNode = None\n    lastBrachChar = 'a'\n\n    for c in word:\n        if not currentNode.childNode[ord(c) - ord('a')]:\n            return False\n        else:\n            count = 0\n            for i in range(26):\n                if currentNode.childNode[i]:\n                    count += 1\n            if count > 1:\n                lastBranchNode = currentNode\n                lastBrachChar = c\n            currentNode = currentNode.childNode[ord(c) - ord('a')]\n\n    count = 0\n    for i in range(26):\n        if currentNode.childNode[i]:\n            count += 1\n\n    # Case 1: The deleted word is a prefix of other words in Trie.\n    if count > 0:\n        currentNode.wordCount -= 1\n        return True\n\n    # Case 2: The deleted word shares a common prefix with other words in Trie.\n    if lastBranchNode:\n        lastBranchNode.childNode[ord(lastBrachChar) - ord('a')] = None\n        return True\n    # Case 3: The deleted word does not share any common prefix with other words in Trie.\n    else:\n        root.childNode[ord(word[0]) - ord('a')] = None\n        return True\n# Driver Code\nif __name__ == '__main__':\n    # Make a root node for the Trie\n    root = TrieNode()\n\n    # Stores the strings that we want to insert in the Trie\n    input_strings = [\"and\", \"ant\", \"do\", \"geek\", \"dad\", \"ball\"]\n\n    # number of insert operations in the Trie\n    n = len(input_strings)\n\n    for i in range(n):\n        insert_key(root, input_strings[i])\n\n    # Stores the strings that we want to search in the Trie\n    search_query_strings = [\"do\", \"geek\", \"bat\"]\n\n    # number of search operations in the Trie\n    search_queries = len(search_query_strings)\n\n    for i in range(search_queries):\n        print(\"Query String:\", search_query_strings[i])\n        if search_key(root, search_query_strings[i]):\n            # the queryString is present in the Trie\n            print(\"The query string is present in the Trie\")\n        else:\n            # the queryString is not present in the Trie\n            print(\"The query string is not present in the Trie\")\n\n    # stores the strings that we want to delete from the Trie\n    delete_query_strings = [\"geek\", \"tea\"]\n\n    # number of delete operations from the Trie\n    delete_queries = len(delete_query_strings)\n\n    for i in range(delete_queries):\n        print(\"Query String:\", delete_query_strings[i])\n        if delete_key(root, delete_query_strings[i]):\n            # The queryString is successfully deleted from the Trie\n            print(\"The query string is successfully deleted\")\n        else:\n            # The query string is not present in the Trie\n            print(\"The query string is not present in the Trie\")\n\n# This code is contributed by Vikram_Shirsat\n// C# code addition \nusing System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Linq;\n\nclass TrieNode\n{\n    public TrieNode[] ChildNode = new TrieNode[26];\n    public int WordCount;\n\n    public TrieNode()\n    {\n        WordCount = 0;\n        for (int i = 0; i < 26; i++)\n        {\n            ChildNode[i] = null;\n        }\n    }\n}\n\nclass Program\n{\n    static void InsertKey(TrieNode root, string key)\n    {\n        TrieNode currentNode = root;\n\n        foreach (char c in key)\n        {\n            if (currentNode.ChildNode[c - 'a'] == null)\n            {\n                TrieNode newNode = new TrieNode();\n                currentNode.ChildNode[c - 'a'] = newNode;\n            }\n\n            currentNode = currentNode.ChildNode[c - 'a'];\n        }\n\n        currentNode.WordCount++;\n    }\n\n    static bool SearchKey(TrieNode root, string key)\n    {\n        TrieNode currentNode = root;\n\n        foreach (char c in key)\n        {\n            if (currentNode.ChildNode[c - 'a'] == null)\n            {\n                return false;\n            }\n\n            currentNode = currentNode.ChildNode[c - 'a'];\n        }\n\n        return (currentNode.WordCount > 0);\n    }\n\n    static bool DeleteKey(TrieNode root, string word)\n    {\n        TrieNode currentNode = root;\n        TrieNode lastBranchNode = null;\n        char lastBranchChar = 'a';\n\n        foreach (char c in word)\n        {\n            if (currentNode.ChildNode[c - 'a'] == null)\n            {\n                return false;\n            }\n            else\n            {\n                int count = 0;\n                for (int i = 0; i < 26; i++)\n                {\n                    if (currentNode.ChildNode[i] != null)\n                        count++;\n                }\n\n                if (count > 1)\n                {\n                    lastBranchNode = currentNode;\n                    lastBranchChar = c;\n                }\n                currentNode = currentNode.ChildNode[c - 'a'];\n            }\n        }\n\n        int leafCount = 0;\n        for (int i = 0; i < 26; i++)\n        {\n            if (currentNode.ChildNode[i] != null)\n                leafCount++;\n        }\n\n        if (leafCount > 0)\n        {\n            currentNode.WordCount--;\n            return true;\n        }\n\n        if (lastBranchNode != null)\n        {\n            lastBranchNode.ChildNode[lastBranchChar - 'a'] = null;\n            return true;\n        }\n        else\n        {\n            root.ChildNode[word[0] - 'a'] = null;\n            return true;\n        }\n    }\n\n    static void Main()\n    {\n        TrieNode root = new TrieNode();\n\n        string[] inputStrings = { \"and\", \"ant\", \"do\", \"geek\", \"dad\", \"ball\" };\n\n        foreach (string str in inputStrings)\n        {\n            InsertKey(root, str);\n        }\n\n        string[] searchQueryStrings = { \"do\", \"geek\", \"bat\" };\n\n        foreach (string str in searchQueryStrings)\n        {\n            Console.WriteLine(\"Query String: \" + str);\n            if (SearchKey(root, str))\n            {\n                Console.WriteLine(\"The query string is present in the Trie\");\n            }\n            else\n            {\n                Console.WriteLine(\"The query string is not present in the Trie\");\n            }\n        }\n\n        string[] deleteQueryStrings = { \"geek\", \"tea\" };\n\n        foreach (string str in deleteQueryStrings)\n        {\n            Console.WriteLine(\"Query String: \" + str);\n            if (DeleteKey(root, str))\n            {\n                Console.WriteLine(\"The query string is successfully deleted\");\n            }\n              else{\n            // The query string is not present in the Trie\n                Console.WriteLine(\"The query string is not present in the Trie\");\n            }\n        }\n        \n    }\n}\n\n// The code  is contributed by Nidhi goel.\nclass TrieNode{\n    constructor(){\n        //pointer array for child nodes of each node\n        this.childNode = new Array(26).fill(null);\n        this.wordCount = 0;\n    }\n}\n\n// function to insert key in Trie\nfunction insertKey(root, key){\n    // initializing currentNode with root node\n    let currentNode = root;\n\n    // iterating over length of string\n    for(let i = 0; i < key.length; i++){\n        // check if node exist for current character in Trie\n        if(!currentNode.childNode[key.charCodeAt(i) - 97]){\n            // if node doesn't exist then create new node\n            let newNode = new TrieNode();\n            // keeping reference for newly created node\n            currentNode.childNode[key.charCodeAt(i) - 97] = newNode;\n        }\n        // now moving currentNode pointer to newly created node\n        currentNode = currentNode.childNode[key.charCodeAt(i) - 97];\n    }\n    // incrementing wordCount for last currentNode pointer\n    // implies that there is a string ending at currentNode\n    currentNode.wordCount++;\n}\n\n// function to search key in Trie\nfunction searchKey(root, key){\n    // initializing currentNode with root node\n    let currentNode = root;\n\n    // iterating over length of string\n    for(let i = 0; i < key.length; i++){\n        // check if node exist for current character in Trie\n        if(!currentNode.childNode[key.charCodeAt(i) - 97]){\n            // given word does not exist in Trie\n            return false;\n        }\n        // move currentNode pointer to already existing node for current character\n        currentNode = currentNode.childNode[key.charCodeAt(i) - 97];\n    }\n    return currentNode.wordCount > 0;\n}\n\n// function to delete key from Trie\nfunction deleteKey(root, word){\n    let currentNode = root;\n    let lastBranchNode = null;\n    let lastBranchChar = 'a';\n\n    for(let i = 0; i < word.length; i++){\n        // check if node exist for current character in Trie\n        if(!currentNode.childNode[word.charCodeAt(i) - 97]){\n            return false;\n        }\n        // check if there is more than one branch at current node\n        else{\n            let count = 0;\n            for(let j = 0; j < 26; j++){\n                if(currentNode.childNode[j]){\n                    count++;\n                }\n            }\n            // if there is more than one branch then store the node and character\n            if(count > 1){\n                lastBranchNode = currentNode;\n                lastBranchChar = word[i];\n            }\n            // move currentNode pointer to already existing node for current character\n            currentNode = currentNode.childNode[word.charCodeAt(i) - 97];\n        }\n    }\n    // checking if there is more than one branch at current node\n    let count = 0;\n    for(let i = 0; i < 26; i++){\n        if(currentNode.childNode[i]){\n            count++\n        }\n    }\n\n    // Case 1: The deleted word is a prefix of other words in Trie\n    if(count > 0){\n        currentNode.wordCount--;\n        return true;\n    }\n    // Case 2: The deleted word shares a common prefix with other words in Trie\n    else if(lastBranchNode){\n        lastBranchNode.childNode[lastBranchChar.charCodeAt(0) - 97] = null;\n        return true;\n    }\n    // Case 3: The deleted word does not share any common prefix with other words in Trie\n    else{\n        root.childNode[word.charCodeAt(0) - 97] = null;\n        return true;\n    }\n}\n\n// driver code\nfunction main(){\n    // making a root node for Trie\n    let root = new TrieNode();\n\n    // stores the strings that we want to insert in Trie\n    let inputStrings = [\"and\", \"ant\", \"do\", \"geek\", \"dad\", \"ball\"];\n\n    // number of insert operations in Trie\n    let n = inputStrings.length;\n    for(let i = 0; i < n; i++){\n        insertKey(root, inputStrings[i]);\n    }\n\n    // stores the strings that we want to search in Trie\n    let searchQueryStrings = [\"do\", \"geek\", \"bat\"];\n\n    // number of search operations in Trie\n    let searchQueries = searchQueryStrings.length;\n    for(let i = 0; i < searchQueries; i++){\n        console.log(\"Query String:\", searchQueryStrings[i]);\n        if(searchKey(root, searchQueryStrings[i])){\n            // the queryString is present in the Trie\n            console.log(\"The query string is present in the Trie\");\n        }\n        else{\n            // the queryString is not present in the Trie\n            console.log(\"The query string is not present in the Trie\");\n        }\n    }\n\n    // stores the strings that we want to delete from the Trie\n    let deleteQueryStrings = [\"geek\", \"tea\"];\n\n    // number of delete operations from the Trie\n    let deleteQueries = deleteQueryStrings.length;\n    for(let i = 0; i < deleteQueries; i++){\n        console.log(\"Query String:\", deleteQueryStrings[i]);\n        if(deleteKey(root, deleteQueryStrings[i])){\n            // the queryString is successfully deleted from the Trie\n            console.log(\"The query string is successfully deleted\");\n        }\n        else{\n            // the queryString is not present in the Trie\n            console.log(\"The query string is not present in the Trie\");\n        }\n    }\n}\n\nmain();\nQuery String: do\nThe query string is present in the Trie\nQuery String: geek\nThe query string is present in the Trie\nQuery String: bat\nThe query string is not present in the Trie\nQuery String: geek\nThe query string is successfully deleted\nQuery String: tea\nThe query string is not present in the Trie\n",
        "complexity": {
            "time": "",
            "space": ""
        },
        "tags": [
            "Pattern Searching"
        ],
        "url": "https://www.geeksforgeeks.org/introduction-to-trie-data-structure-and-algorithm-tutorials/"
    },
    {
        "title": "Manacher’s Algorithm – Linear Time Longest Palindromic Substring – Part 4",
        "description": "In Manacher’s Algorithm Part 1 and Part 2, we gone through some of the basics, understood LPS length array and how to calculate it efficiently based on four cases. In Part 3, we implemented the same. Here we will review the four cases again and try to see it differently and implement the same. All four cases depends on LPS length value at currentLeftPosition (L[iMirror]) and value of (centerRightPosition – currentRightPosition), i.e. (R – i). These two information are known before which helps us to reuse previous available information and avoid unnecessary character comparison.  If we look at all four cases, we will see that we 1st set minimum of L[iMirror] and R-i to L[i] and then we try to expand the palindrome in whichever case it can expand.Above observation may look more intuitive, easier to understand and implement, given that one understands LPS length array, position, index, symmetry property etc. Implementation: Time Complexity: O(n)Auxiliary Space: O(n) Other Approaches:We have discussed two approaches here. One in Part 3 and other in current article. In both approaches, we worked on given string. Here we had to handle even and odd positions differently while comparing characters for expansion (because even positions do not represent any character in string).To avoid this different handling of even and odd positions, we need to make even positions also to represent some character (actually all even positions should represent SAME character because they MUST match while character comparison). One way to do this is to set some character at all even positions by modifying given string or create a new copy of given string. For example, if input string is “abcb”, new string should be “#a#b#c#b#” if we add # as unique character at even positions.The two approaches discussed already can be modified a bit to work on modified string where different handling of even and odd positions will not be needed. We may also add two DIFFERENT characters (not yet used anywhere in string at even and odd positions) at start and end of string as sentinels to avoid bound check. With these changes string “abcb” will look like “^#a#b#c#b#$” where ^ and $ are sentinels. This implementation may look cleaner with the cost of more memory.We are not implementing these here as it’s a simple change in given implementations.  ",
        "code": "// A C program to implement Manacher’s Algorithm \n#include <stdio.h> \n#include <string.h> \n\nchar text[100]; \nint min(int a, int b) \n{ \n    int res = a; \n    if(b < a) \n        res = b; \n    return res; \n} \n\nvoid findLongestPalindromicString() \n{ \n    int N = strlen(text); \n    if(N == 0) \n        return; \n    N = 2*N + 1; //Position count \n    int L[N]; //LPS Length Array \n    L[0] = 0; \n    L[1] = 1; \n    int C = 1; //centerPosition \n    int R = 2; //centerRightPosition \n    int i = 0; //currentRightPosition \n    int iMirror; //currentLeftPosition \n    int maxLPSLength = 0; \n    int maxLPSCenterPosition = 0; \n    int start = -1; \n    int end = -1; \n    int diff = -1; \n    \n    //Uncomment it to print LPS Length array \n    //printf(\"%d %d \", L[0], L[1]); \n    for (i = 2; i < N; i++) \n    { \n        //get currentLeftPosition iMirror for currentRightPosition i \n        iMirror = 2*C-i; \n        L[i] = 0; \n        diff = R - i; \n        //If currentRightPosition i is within centerRightPosition R \n        if(diff > 0) \n            L[i] = min(L[iMirror], diff); \n\n        //Attempt to expand palindrome centered at currentRightPosition i \n        //Here for odd positions, we compare characters and \n        //if match then increment LPS Length by ONE \n        //If even position, we just increment LPS by ONE without \n        //any character comparison \n        while ( ((i + L[i]) < N && (i - L[i]) > 0) && \n            ( ((i + L[i] + 1) % 2 == 0) || \n            (text[(i + L[i] + 1)/2] == text[(i - L[i] - 1)/2] ))) \n        { \n            L[i]++; \n        } \n\n        if(L[i] > maxLPSLength) // Track maxLPSLength \n        { \n            maxLPSLength = L[i]; \n            maxLPSCenterPosition = i; \n        } \n\n        //If palindrome centered at currentRightPosition i \n        //expand beyond centerRightPosition R, \n        //adjust centerPosition C based on expanded palindrome. \n        if (i + L[i] > R) \n        { \n            C = i; \n            R = i + L[i]; \n        } \n        //Uncomment it to print LPS Length array \n        //printf(\"%d \", L[i]); \n    } \n    //printf(\"\\n\"); \n    start = (maxLPSCenterPosition - maxLPSLength)/2; \n    end = start + maxLPSLength - 1; \n    printf(\"LPS of string is %s : \", text); \n    for(i=start; i<=end; i++) \n        printf(\"%c\", text[i]); \n    printf(\"\\n\"); \n} \n\nint main(int argc, char *argv[]) \n{ \n\n    strcpy(text, \"babcbabcbaccba\"); \n    findLongestPalindromicString(); \n\n    strcpy(text, \"abaaba\"); \n    findLongestPalindromicString(); \n\n    strcpy(text, \"abababa\"); \n    findLongestPalindromicString(); \n\n    strcpy(text, \"abcbabcbabcba\"); \n    findLongestPalindromicString(); \n\n    strcpy(text, \"forgeeksskeegfor\"); \n    findLongestPalindromicString(); \n\n    strcpy(text, \"caba\"); \n    findLongestPalindromicString(); \n\n    strcpy(text, \"abacdfgdcaba\"); \n    findLongestPalindromicString(); \n\n    strcpy(text, \"abacdfgdcabba\"); \n    findLongestPalindromicString(); \n\n    strcpy(text, \"abacdedcaba\"); \n    findLongestPalindromicString(); \n\n    return 0; \n}\n// Java program to implement Manacher's Algorithm \nimport java.util.*;\n\nclass GFG \n{\n    static void findLongestPalindromicString(String text) \n    {\n        int N = text.length();\n        if (N == 0)\n            return;\n        N = 2 * N + 1; // Position count\n        int[] L = new int[N + 1]; // LPS Length Array\n        L[0] = 0;\n        L[1] = 1;\n        int C = 1; // centerPosition\n        int R = 2; // centerRightPosition\n        int i = 0; // currentRightPosition\n        int iMirror; // currentLeftPosition\n        int maxLPSLength = 0;\n        int maxLPSCenterPosition = 0;\n        int start = -1;\n        int end = -1;\n        int diff = -1;\n\n        // Uncomment it to print LPS Length array\n        // printf(\"%d %d \", L[0], L[1]);\n        for (i = 2; i < N; i++) \n        {\n\n            // get currentLeftPosition iMirror \n            // for currentRightPosition i\n            iMirror = 2 * C - i;\n            L[i] = 0;\n            diff = R - i;\n\n            // If currentRightPosition i is within \n            // centerRightPosition R\n            if (diff > 0)\n                L[i] = Math.min(L[iMirror], diff);\n\n            // Attempt to expand palindrome centered at \n            // currentRightPosition i. Here for odd positions, \n            // we compare characters and if match then \n            // increment LPS Length by ONE. If even position, \n            // we just increment LPS by ONE without \n            // any character comparison\n            while (((i + L[i]) + 1 < N && (i - L[i]) > 0) && \n                               (((i + L[i] + 1) % 2 == 0) || \n                         (text.charAt((i + L[i] + 1) / 2) == \n                          text.charAt((i - L[i] - 1) / 2))))\n            {\n                L[i]++;\n            }\n\n            if (L[i] > maxLPSLength) // Track maxLPSLength\n            {\n                maxLPSLength = L[i];\n                maxLPSCenterPosition = i;\n            }\n\n            // If palindrome centered at currentRightPosition i\n            // expand beyond centerRightPosition R,\n            // adjust centerPosition C based on expanded palindrome.\n            if (i + L[i] > R) \n            {\n                C = i;\n                R = i + L[i];\n            }\n\n            // Uncomment it to print LPS Length array\n            // printf(\"%d \", L[i]);\n        }\n\n        start = (maxLPSCenterPosition - maxLPSLength) / 2;\n        end = start + maxLPSLength - 1;\n        System.out.printf(\"LPS of string is %s : \", text);\n        for (i = start; i <= end; i++)\n            System.out.print(text.charAt(i));\n        System.out.println();\n    }\n\n    // Driver Code\n    public static void main(String[] args)\n    {\n        String text = \"babcbabcbaccba\";\n        findLongestPalindromicString(text);\n\n        text = \"abaaba\";\n        findLongestPalindromicString(text);\n\n        text = \"abababa\";\n        findLongestPalindromicString(text);\n\n        text = \"abcbabcbabcba\";\n        findLongestPalindromicString(text);\n\n        text = \"forgeeksskeegfor\";\n        findLongestPalindromicString(text);\n\n        text = \"caba\";\n        findLongestPalindromicString(text);\n\n        text = \"abacdfgdcaba\";\n        findLongestPalindromicString(text);\n\n        text = \"abacdfgdcabba\";\n        findLongestPalindromicString(text);\n\n        text = \"abacdedcaba\";\n        findLongestPalindromicString(text);\n    }\n}\n\n// This code is contributed by\n// sanjeev2552\n# Python program to implement Manacher's Algorithm\n \ndef findLongestPalindromicString(text):\n    N = len(text)\n    if N == 0:\n        return\n    N = 2*N+1    # Position count\n    L = [0] * N\n    L[0] = 0\n    L[1] = 1\n    C = 1     # centerPosition\n    R = 2     # centerRightPosition\n    i = 0    # currentRightPosition\n    iMirror = 0     # currentLeftPosition\n    maxLPSLength = 0\n    maxLPSCenterPosition = 0\n    start = -1\n    end = -1\n    diff = -1\n \n    # Uncomment it to print LPS Length array\n    # printf(\"%d %d \", L[0], L[1]);\n    for i in range(2,N):\n     \n        # get currentLeftPosition iMirror for currentRightPosition i\n        iMirror = 2*C-i\n        L[i] = 0\n        diff = R - i\n        # If currentRightPosition i is within centerRightPosition R\n        if diff > 0:\n            L[i] = min(L[iMirror], diff)\n \n        # Attempt to expand palindrome centered at currentRightPosition i\n        # Here for odd positions, we compare characters and\n        # if match then increment LPS Length by ONE\n        # If even position, we just increment LPS by ONE without\n        # any character comparison\n        try:\n            while ((i + L[i]) < N and (i - L[i]) > 0) and \\\n                    (((i + L[i] + 1) % 2 == 0) or \\\n                    (text[(i + L[i] + 1) // 2] == text[(i - L[i] - 1) // 2])):\n                L[i]+=1\n        except Exception as e:\n            pass\n \n        if L[i] > maxLPSLength:        # Track maxLPSLength\n            maxLPSLength = L[i]\n            maxLPSCenterPosition = i\n \n        # If palindrome centered at currentRightPosition i\n        # expand beyond centerRightPosition R,\n        # adjust centerPosition C based on expanded palindrome.\n        if i + L[i] > R:\n            C = i\n            R = i + L[i]\n \n    # Uncomment it to print LPS Length array\n    # printf(\"%d \", L[i]);\n    start = (maxLPSCenterPosition - maxLPSLength) // 2\n    end = start + maxLPSLength - 1\n    print (\"LPS of string is \" + text + \" : \",text[start:end+1])\n \n# Driver program\ntext1 = \"babcbabcbaccba\"\nfindLongestPalindromicString(text1)\n \ntext2 = \"abaaba\"\nfindLongestPalindromicString(text2)\n \ntext3 = \"abababa\"\nfindLongestPalindromicString(text3)\n \ntext4 = \"abcbabcbabcba\"\nfindLongestPalindromicString(text4)\n \ntext5 = \"forgeeksskeegfor\"\nfindLongestPalindromicString(text5)\n \ntext6 = \"caba\"\nfindLongestPalindromicString(text6)\n \ntext7 = \"abacdfgdcaba\"\nfindLongestPalindromicString(text7)\n \ntext8 = \"abacdfgdcabba\"\nfindLongestPalindromicString(text8)\n \ntext9 = \"abacdedcaba\"\nfindLongestPalindromicString(text9)\n \n# This code is contributed by BHAVYA JAIN\n// C# program to implement Manacher's Algorithm\nusing System;\n\nclass GFG \n{\n    static void findLongestPalindromicString(String text) \n    {\n        int N = text.Length;\n        if (N == 0)\n            return;\n        N = 2 * N + 1; // Position count\n        int[] L = new int[N + 1]; // LPS Length Array\n        L[0] = 0;\n        L[1] = 1;\n        int C = 1; // centerPosition\n        int R = 2; // centerRightPosition\n        int i = 0; // currentRightPosition\n        int iMirror; // currentLeftPosition\n        int maxLPSLength = 0;\n        int maxLPSCenterPosition = 0;\n        int start = -1;\n        int end = -1;\n        int diff = -1;\n\n        // Uncomment it to print LPS Length array\n        // printf(\"%d %d \", L[0], L[1]);\n        for (i = 2; i < N; i++) \n        {\n\n            // get currentLeftPosition iMirror \n            // for currentRightPosition i\n            iMirror = 2 * C - i;\n            L[i] = 0;\n            diff = R - i;\n\n            // If currentRightPosition i is within \n            // centerRightPosition R\n            if (diff > 0)\n                L[i] = Math.Min(L[iMirror], diff);\n\n            // Attempt to expand palindrome centered at \n            // currentRightPosition i. Here for odd positions, \n            // we compare characters and if match then \n            // increment LPS Length by ONE. If even position, \n            // we just increment LPS by ONE without \n            // any character comparison\n            while (((i + L[i]) + 1 < N && (i - L[i]) > 0) && \n                               (((i + L[i] + 1) % 2 == 0) || \n                           (text[(i + L[i] + 1) / 2] == \n                            text[(i - L[i] - 1) / 2])))\n            {\n                L[i]++;\n            }\n\n            if (L[i] > maxLPSLength) // Track maxLPSLength\n            {\n                maxLPSLength = L[i];\n                maxLPSCenterPosition = i;\n            }\n\n            // If palindrome centered at currentRightPosition i\n            // expand beyond centerRightPosition R,\n            // adjust centerPosition C based on expanded palindrome.\n            if (i + L[i] > R) \n            {\n                C = i;\n                R = i + L[i];\n            }\n\n            // Uncomment it to print LPS Length array\n            // printf(\"%d \", L[i]);\n        }\n\n        start = (maxLPSCenterPosition - maxLPSLength) / 2;\n        end = start + maxLPSLength - 1;\n        Console.Write(\"LPS of string is {0} : \", text);\n        for (i = start; i <= end; i++)\n            Console.Write(text[i]);\n        Console.WriteLine();\n    }\n\n    // Driver Code\n    public static void Main(String[] args)\n    {\n        String text = \"babcbabcbaccba\";\n        findLongestPalindromicString(text);\n\n        text = \"abaaba\";\n        findLongestPalindromicString(text);\n\n        text = \"abababa\";\n        findLongestPalindromicString(text);\n\n        text = \"abcbabcbabcba\";\n        findLongestPalindromicString(text);\n\n        text = \"forgeeksskeegfor\";\n        findLongestPalindromicString(text);\n\n        text = \"caba\";\n        findLongestPalindromicString(text);\n\n        text = \"abacdfgdcaba\";\n        findLongestPalindromicString(text);\n\n        text = \"abacdfgdcabba\";\n        findLongestPalindromicString(text);\n\n        text = \"abacdedcaba\";\n        findLongestPalindromicString(text);\n    }\n}\n\n// This code is contributed by PrinciRaj1992\n<script>\n// Javascript program to implement Manacher's Algorithm \n\nfunction findLongestPalindromicString(text)\n{\n    let N = text.length;\n        if (N == 0)\n            return;\n        N = 2 * N + 1; // Position count\n        let L = new Array(N + 1); // LPS Length Array\n        L[0] = 0;\n        L[1] = 1;\n        let C = 1; // centerPosition\n        let R = 2; // centerRightPosition\n        let i = 0; // currentRightPosition\n        let iMirror; // currentLeftPosition\n        let maxLPSLength = 0;\n        let maxLPSCenterPosition = 0;\n        let start = -1;\n        let end = -1;\n        let diff = -1;\n  \n        // Uncomment it to print LPS Length array\n        // printf(\"%d %d \", L[0], L[1]);\n        for (i = 2; i < N; i++) \n        {\n  \n            // get currentLeftPosition iMirror \n            // for currentRightPosition i\n            iMirror = 2 * C - i;\n            L[i] = 0;\n            diff = R - i;\n  \n            // If currentRightPosition i is within \n            // centerRightPosition R\n            if (diff > 0)\n                L[i] = Math.min(L[iMirror], diff);\n  \n            // Attempt to expand palindrome centered at \n            // currentRightPosition i. Here for odd positions, \n            // we compare characters and if match then \n            // increment LPS Length by ONE. If even position, \n            // we just increment LPS by ONE without \n            // any character comparison\n            let flr1 = Math.floor((i + L[i] + 1) / 2));    \n            let flr2 = Math.floor((i + L[i] - 1) / 2));    \n            while (((i + L[i]) + 1 < N && (i - L[i]) > 0) && \n                               (((i + L[i] + 1) % 2 == 0) || \n                         (text[flr1] == \n                          text[flr2])))\n            {\n                L[i]++;\n            }\n  \n            if (L[i] > maxLPSLength) // Track maxLPSLength\n            {\n                maxLPSLength = L[i];\n                maxLPSCenterPosition = i;\n            }\n  \n            // If palindrome centered at currentRightPosition i\n            // expand beyond centerRightPosition R,\n            // adjust centerPosition C based on expanded palindrome.\n            if (i + L[i] > R) \n            {\n                C = i;\n                R = i + L[i];\n            }\n  \n            // Uncomment it to print LPS Length array\n            // printf(\"%d \", L[i]);\n        }\n  \n        start = (maxLPSCenterPosition - maxLPSLength) / 2;\n        end = start + maxLPSLength - 1;\n        document.write(\"LPS of string is \"+text+\" : \");\n        for (i = start; i <= end; i++)\n            document.write(text[i]);\n        document.write(\"<br>\");\n}\n\n// Driver Code\n\nlet text = \"babcbabcbaccba\";\nfindLongestPalindromicString(text);\n\ntext = \"abaaba\";\nfindLongestPalindromicString(text);\n\ntext = \"abababa\";\nfindLongestPalindromicString(text);\n\ntext = \"abcbabcbabcba\";\nfindLongestPalindromicString(text);\n\ntext = \"forgeeksskeegfor\";\nfindLongestPalindromicString(text);\n\ntext = \"caba\";\nfindLongestPalindromicString(text);\n\ntext = \"abacdfgdcaba\";\nfindLongestPalindromicString(text);\n\ntext = \"abacdfgdcabba\";\nfindLongestPalindromicString(text);\n\ntext = \"abacdedcaba\";\nfindLongestPalindromicString(text);\n\n\n// This code is contributed by unknown2108\n</script>\nLPS of string is babcbabcbaccba : abcbabcba\nLPS of string is abaaba : abaaba\nLPS of string is abababa : abababa\nLPS of string is abcbabcbabcba : abcbabcbabcba\nLPS of string is forgeeksskeegfor : geeksskeeg\nLPS of string is caba : aba\nLPS of string is abacdfgdcaba : aba\nLPS of string is abacdfgdcabba : abba\nLPS of string is abacdedcaba : abacdedcaba\n",
        "complexity": {
            "time": "Time Complexity: O(n)Auxiliary Space: O(n)",
            "space": ""
        },
        "tags": [
            "Pattern Searching"
        ],
        "url": "https://www.geeksforgeeks.org/manachers-algorithm-linear-time-longest-palindromic-substring-part-4/"
    },
    {
        "title": "Generalized Suffix Tree",
        "description": "In earlier suffix tree articles, we created suffix tree for one string and then we queried that tree for substring check, searching all patterns, longest repeated substring and built suffix array (All linear time operations).There are lots of other problems where multiple strings are involved. e.g. pattern searching in a text file or dictionary, spell checker, phone book, Autocomplete, Longest common substring problem, Longest palindromic substring and More.For such operations, all the involved strings need to be indexed for faster search and retrieval. One way to do this is using suffix trie or suffix tree. We will discuss suffix tree here. A suffix tree made of a set of strings is known as Generalized Suffix Tree. We will discuss a simple way to build Generalized Suffix Tree here for two strings only. Later, we will discuss another approach to build Generalized Suffix Tree for two or more strings.Here we will use the suffix tree implementation for one string discussed already and modify that a bit to build generalized suffix tree.Lets consider two strings X and Y for which we want to build generalized suffix tree. For this we will make a new string X#Y$ where # and $ both are terminal symbols (must be unique). Then we will build suffix tree for X#Y$ which will be the generalized suffix tree for X and Y. Same logic will apply for more than two strings (i.e. concatenate all strings using unique terminal symbols and then build suffix tree for concatenated string).Lets say X = xabxa, and Y = babxba, then X#Y$ = xabxa#babxba$ If we run the code implemented at Ukkonen’s Suffix Tree Construction – Part 6 for string xabxa#babxba$, we get following output: Output:  Pictorial View:  We can use this tree to solve some of the problems, but we can refine it a bit by removing unwanted substrings on a path label. A path label should have substring from only one input string, so if there are path labels having substrings from multiple input strings, we can keep only the initial portion corresponding to one string and remove all the later portion. For example, for path labels #babxba$, a#babxba$ and bxa#babxba$, we can remove babxba$ (belongs to 2nd input string) and then new path labels will be #, a# and bxa# repectively. With this change, above diagram will look like below:  Below implementation is built on top of original implementation. Here we are removing unwanted characters on path labels. If a path label has “#” character in it, then we are trimming all characters after the “#” in that path label. Note: This implementation builds generalized suffix tree for only two strings X and Y which are concatenated as X#Y$ If two strings are of size M and N, this implementation will take O(M+N) time and space. If input strings are not concatenated already, then it will take 2(M+N) space in total, M+N space to store the generalized suffix tree and another M+N space to store concatenated string. Followup: Extend above implementation for more than two strings (i.e. concatenate all strings using unique terminal symbols and then build suffix tree for concatenated string)One problem with this approach is the need of unique terminal symbol for each input string. This will work for few strings but if there is too many input strings, we may not be able to find that many unique terminal symbols. We will discuss another approach to build generalized suffix tree soon where we will need only one unique terminal symbol and that will resolve the above problem and can be used to build generalized suffix tree for any number of input strings. We have published following more articles on suffix tree applications:  A  ",
        "code": "// A C++ program to implement Ukkonen's Suffix Tree Construction\n// And then build generalized suffix tree\n#include<bits/stdc++.h>\nusing namespace std;\n#define MAX_CHAR 256\n \nstruct SuffixTreeNode {\n    struct SuffixTreeNode *children[MAX_CHAR];\n \n    //pointer to other node via suffix link\n    struct SuffixTreeNode *suffixLink;\n \n    /*(start, end) interval specifies the edge, by which the\n     node is connected to its parent node. Each edge will\n     connect two nodes,  one parent and one child, and\n     (start, end) interval of a given edge  will be stored\n     in the child node. Lets say there are two nods A and B\n     connected by an edge with indices (5, 8) then this\n     indices (5, 8) will be stored in node B. */\n    int start;\n    int *end;\n \n    /*for leaf nodes, it stores the index of suffix for\n      the path  from root to leaf*/\n    int suffixIndex;\n};\n \ntypedef struct SuffixTreeNode Node;\n \nchar text[100]; //Input string\nNode *root = NULL; //Pointer to root node\n \n/*lastNewNode will point to newly created internal node,\n  waiting for it's suffix link to be set, which might get\n  a new suffix link (other than root) in next extension of\n  same phase. lastNewNode will be set to NULL when last\n  newly created internal node (if there is any) got it's\n  suffix link reset to new internal node created in next\n  extension of same phase. */\nNode *lastNewNode = NULL;\nNode *activeNode = NULL;\n \n/*activeEdge is represented as input string character\n  index (not the character itself)*/\nint activeEdge = -1;\nint activeLength = 0;\n \n// remainingSuffixCount tells how many suffixes yet to\n// be added in tree\nint remainingSuffixCount = 0;\nint leafEnd = -1;\nint *rootEnd = NULL;\nint *splitEnd = NULL;\nint sizee = -1; //Length of input string\n \nNode *newNode(int start, int *end)\n{\n    Node* node = new Node();\n    int i;\n    for (i = 0; i < MAX_CHAR; i++)\n          node->children[i] = NULL;\n \n    /*For root node, suffixLink will be set to NULL\n    For internal nodes, suffixLink will be set to root\n    by default in  current extension and may change in\n    next extension*/\n    node->suffixLink = root;\n    node->start = start;\n    node->end = end;\n \n    /*suffixIndex will be set to -1 by default and\n      actual suffix index will be set later for leaves\n      at the end of all phases*/\n    node->suffixIndex = -1;\n    return node;\n}\n \nint edgeLength(Node *n) {\n    if(n == root)\n        return 0;\n    return *(n->end) - (n->start) + 1;\n}\n \nint walkDown(Node *currNode)\n{\n    /*activePoint change for walk down (APCFWD) using\n     Skip/Count Trick  (Trick 1). If activeLength is greater\n     than current edge length, set next  internal node as\n     activeNode and adjust activeEdge and activeLength\n     accordingly to represent same activePoint*/\n    if (activeLength >= edgeLength(currNode))\n    {\n        activeEdge += edgeLength(currNode);\n        activeLength -= edgeLength(currNode);\n        activeNode = currNode;\n        return 1;\n    }\n    return 0;\n}\n \nvoid extendSuffixTree(int pos)\n{\n    /*Extension Rule 1, this takes care of extending all\n    leaves created so far in tree*/\n    leafEnd = pos;\n \n    /*Increment remainingSuffixCount indicating that a\n    new suffix added to the list of suffixes yet to be\n    added in tree*/\n    remainingSuffixCount++;\n \n    /*set lastNewNode to NULL while starting a new phase,\n     indicating there is no internal node waiting for\n     it's suffix link reset in current phase*/\n    lastNewNode = NULL;\n \n    //Add all suffixes (yet to be added) one by one in tree\n    while(remainingSuffixCount > 0) {\n \n        if (activeLength == 0)\n            activeEdge = pos; //APCFALZ\n \n        // There is no outgoing edge starting with\n        // activeEdge from activeNode\n        if (activeNode->children[text[activeEdge]] == NULL)\n        {\n            //Extension Rule 2 (A new leaf edge gets created)\n            activeNode->children[text[activeEdge]] = newNode(pos, &leafEnd);\n \n            /*A new leaf edge is created in above line starting\n             from  an existing node (the current activeNode), and\n             if there is any internal node waiting for it's suffix\n             link get reset, point the suffix link from that last\n             internal node to current activeNode. Then set lastNewNode\n             to NULL indicating no more node waiting for suffix link\n             reset.*/\n            if (lastNewNode != NULL)\n            {\n                lastNewNode->suffixLink = activeNode;\n                lastNewNode = NULL;\n            }\n        }\n        // There is an outgoing edge starting with activeEdge\n        // from activeNode\n        else\n        {\n            // Get the next node at the end of edge starting\n            // with activeEdge\n            Node *next = activeNode->children[text[activeEdge]];\n            if (walkDown(next))//Do walkdown\n            {\n                //Start from next node (the new activeNode)\n                continue;\n            }\n            /*Extension Rule 3 (current character being processed\n              is already on the edge)*/\n            if (text[next->start + activeLength] == text[pos])\n            {\n                //If a newly created node waiting for it's \n                //suffix link to be set, then set suffix link \n                //of that waiting node to current active node\n                if(lastNewNode != NULL && activeNode != root)\n                {\n                    lastNewNode->suffixLink = activeNode;\n                    lastNewNode = NULL;\n                }\n\n                //APCFER3\n                activeLength++;\n                /*STOP all further processing in this phase\n                and move on to next phase*/\n                break;\n            }\n \n            /*We will be here when activePoint is in middle of\n              the edge being traversed and current character\n              being processed is not  on the edge (we fall off\n              the tree). In this case, we add a new internal node\n              and a new leaf edge going out of that new node. This\n              is Extension Rule 2, where a new leaf edge and a new\n            internal node get created*/\n            \n            splitEnd = new int;\n            *splitEnd = next->start + activeLength - 1;\n \n            //New internal node\n            Node *split = newNode(next->start, splitEnd);\n            activeNode->children[text[activeEdge]] = split;\n \n            //New leaf coming out of new internal node\n            split->children[text[pos]] = newNode(pos, &leafEnd);\n            next->start += activeLength;\n            split->children[text[next->start]] = next;\n \n            /*We got a new internal node here. If there is any\n              internal node created in last extensions of same\n              phase which is still waiting for it's suffix link\n              reset, do it now.*/\n            if (lastNewNode != NULL)\n            {\n            /*suffixLink of lastNewNode points to current newly\n              created internal node*/\n                lastNewNode->suffixLink = split;\n            }\n \n            /*Make the current newly created internal node waiting\n              for it's suffix link reset (which is pointing to root\n              at present). If we come across any other internal node\n              (existing or newly created) in next extension of same\n              phase, when a new leaf edge gets added (i.e. when\n              Extension Rule 2 applies is any of the next extension\n              of same phase) at that point, suffixLink of this node\n              will point to that internal node.*/\n            lastNewNode = split;\n        }\n \n        /* One suffix got added in tree, decrement the count of\n          suffixes yet to be added.*/\n        remainingSuffixCount--;\n        if (activeNode == root && activeLength > 0) //APCFER2C1\n        {\n            activeLength--;\n            activeEdge = pos - remainingSuffixCount + 1;\n        }\n        else if (activeNode != root) //APCFER2C2\n        {\n            activeNode = activeNode->suffixLink;\n        }\n    }\n}\n \nvoid print(int i, int j)\n{\n    int k;\n    for (k=i; k<=j && text[k] != '#'; k++){\n        cout << text[k];\n    }\n        \n    if(k<=j)\n        cout << \"#\";\n}\n \n//Print the suffix tree as well along with setting suffix index\n//So tree will be printed in DFS manner\n//Each edge along with it's suffix index will be printed\nvoid setSuffixIndexByDFS(Node *n, int labelHeight)\n{\n    if (n == NULL)  return;\n \n    if (n->start != -1) //A non-root node\n    {\n        //Print the label on edge from parent to current node\n        print(n->start, *(n->end));\n    }\n    int leaf = 1;\n    int i;\n    for (i = 0; i < MAX_CHAR; i++)\n    {\n        if (n->children[i] != NULL)\n        {\n            if (leaf == 1 && n->start != -1){\n                cout << \" [\" << n->suffixIndex << \"]\" << endl;\n            }\n                 \n            //Current node is not a leaf as it has outgoing\n            //edges from it.\n            leaf = 0;\n            setSuffixIndexByDFS(n->children[i], labelHeight +\n                                  edgeLength(n->children[i]));\n        }\n    }\n    if (leaf == 1)\n    {\n        for(i= n->start; i<= *(n->end); i++)\n        {\n            if(text[i] == '#') //Trim unwanted characters\n            {\n                \n                n->end = new int;\n                *(n->end) = i;\n            }\n        }\n        n->suffixIndex = sizee - labelHeight;\n        cout << \" [\" << n->suffixIndex << \"]\" << endl;\n    }\n}\n \nvoid freeSuffixTreeByPostOrder(Node *n)\n{\n    if (n == NULL)\n        return;\n    int i;\n    for (i = 0; i < MAX_CHAR; i++)\n    {\n        if (n->children[i] != NULL)\n        {\n            freeSuffixTreeByPostOrder(n->children[i]);\n        }\n    }\n    if (n->suffixIndex == -1)\n        delete n->end;\n    delete n;\n}\n \n/*Build the suffix tree and print the edge labels along with\nsuffixIndex. suffixIndex for leaf edges will be >= 0 and\nfor non-leaf edges will be -1*/\nvoid buildSuffixTree()\n{\n    sizee = strlen(text);\n    int i;\n    rootEnd = new int;\n    *rootEnd = - 1;\n \n    /*Root is a special node with start and end indices as -1,\n    as it has no parent from where an edge comes to root*/\n    root = newNode(-1, rootEnd);\n \n    activeNode = root; //First activeNode will be root\n    for (i=0; i<sizee; i++)\n        extendSuffixTree(i);\n    int labelHeight = 0;\n    setSuffixIndexByDFS(root, labelHeight);\n \n    //Free the dynamically allocated memory\n    freeSuffixTreeByPostOrder(root);\n}\n \n// driver program to test above functions\nint main()\n{\n    strcpy(text, \"xabxa#babxba$\");\n    buildSuffixTree();\n    return 0;\n}\n\n// The code is contributed by Nidhi goel.\n// A C program to implement Ukkonen's Suffix Tree Construction\n// And then build generalized suffix tree\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#define MAX_CHAR 256\n \nstruct SuffixTreeNode {\n    struct SuffixTreeNode *children[MAX_CHAR];\n \n    //pointer to other node via suffix link\n    struct SuffixTreeNode *suffixLink;\n \n    /*(start, end) interval specifies the edge, by which the\n     node is connected to its parent node. Each edge will\n     connect two nodes,  one parent and one child, and\n     (start, end) interval of a given edge  will be stored\n     in the child node. Lets say there are two nods A and B\n     connected by an edge with indices (5, 8) then this\n     indices (5, 8) will be stored in node B. */\n    int start;\n    int *end;\n \n    /*for leaf nodes, it stores the index of suffix for\n      the path  from root to leaf*/\n    int suffixIndex;\n};\n \ntypedef struct SuffixTreeNode Node;\n \nchar text[100]; //Input string\nNode *root = NULL; //Pointer to root node\n \n/*lastNewNode will point to newly created internal node,\n  waiting for it's suffix link to be set, which might get\n  a new suffix link (other than root) in next extension of\n  same phase. lastNewNode will be set to NULL when last\n  newly created internal node (if there is any) got it's\n  suffix link reset to new internal node created in next\n  extension of same phase. */\nNode *lastNewNode = NULL;\nNode *activeNode = NULL;\n \n/*activeEdge is represented as input string character\n  index (not the character itself)*/\nint activeEdge = -1;\nint activeLength = 0;\n \n// remainingSuffixCount tells how many suffixes yet to\n// be added in tree\nint remainingSuffixCount = 0;\nint leafEnd = -1;\nint *rootEnd = NULL;\nint *splitEnd = NULL;\nint size = -1; //Length of input string\n \nNode *newNode(int start, int *end)\n{\n    Node *node =(Node*) malloc(sizeof(Node));\n    int i;\n    for (i = 0; i < MAX_CHAR; i++)\n          node->children[i] = NULL;\n \n    /*For root node, suffixLink will be set to NULL\n    For internal nodes, suffixLink will be set to root\n    by default in  current extension and may change in\n    next extension*/\n    node->suffixLink = root;\n    node->start = start;\n    node->end = end;\n \n    /*suffixIndex will be set to -1 by default and\n      actual suffix index will be set later for leaves\n      at the end of all phases*/\n    node->suffixIndex = -1;\n    return node;\n}\n \nint edgeLength(Node *n) {\n    if(n == root)\n        return 0;\n    return *(n->end) - (n->start) + 1;\n}\n \nint walkDown(Node *currNode)\n{\n    /*activePoint change for walk down (APCFWD) using\n     Skip/Count Trick  (Trick 1). If activeLength is greater\n     than current edge length, set next  internal node as\n     activeNode and adjust activeEdge and activeLength\n     accordingly to represent same activePoint*/\n    if (activeLength >= edgeLength(currNode))\n    {\n        activeEdge += edgeLength(currNode);\n        activeLength -= edgeLength(currNode);\n        activeNode = currNode;\n        return 1;\n    }\n    return 0;\n}\n \nvoid extendSuffixTree(int pos)\n{\n    /*Extension Rule 1, this takes care of extending all\n    leaves created so far in tree*/\n    leafEnd = pos;\n \n    /*Increment remainingSuffixCount indicating that a\n    new suffix added to the list of suffixes yet to be\n    added in tree*/\n    remainingSuffixCount++;\n \n    /*set lastNewNode to NULL while starting a new phase,\n     indicating there is no internal node waiting for\n     it's suffix link reset in current phase*/\n    lastNewNode = NULL;\n \n    //Add all suffixes (yet to be added) one by one in tree\n    while(remainingSuffixCount > 0) {\n \n        if (activeLength == 0)\n            activeEdge = pos; //APCFALZ\n \n        // There is no outgoing edge starting with\n        // activeEdge from activeNode\n        if (activeNode->children[text[activeEdge]] == NULL)\n        {\n            //Extension Rule 2 (A new leaf edge gets created)\n            activeNode->children[text[activeEdge]] =\n                                          newNode(pos, &leafEnd);\n \n            /*A new leaf edge is created in above line starting\n             from  an existing node (the current activeNode), and\n             if there is any internal node waiting for it's suffix\n             link get reset, point the suffix link from that last\n             internal node to current activeNode. Then set lastNewNode\n             to NULL indicating no more node waiting for suffix link\n             reset.*/\n            if (lastNewNode != NULL)\n            {\n                lastNewNode->suffixLink = activeNode;\n                lastNewNode = NULL;\n            }\n        }\n        // There is an outgoing edge starting with activeEdge\n        // from activeNode\n        else\n        {\n            // Get the next node at the end of edge starting\n            // with activeEdge\n            Node *next = activeNode->children[text[activeEdge]];\n            if (walkDown(next))//Do walkdown\n            {\n                //Start from next node (the new activeNode)\n                continue;\n            }\n            /*Extension Rule 3 (current character being processed\n              is already on the edge)*/\n            if (text[next->start + activeLength] == text[pos])\n            {\n                //If a newly created node waiting for it's \n                //suffix link to be set, then set suffix link \n                //of that waiting node to current active node\n                if(lastNewNode != NULL && activeNode != root)\n                {\n                    lastNewNode->suffixLink = activeNode;\n                    lastNewNode = NULL;\n                }\n\n                //APCFER3\n                activeLength++;\n                /*STOP all further processing in this phase\n                and move on to next phase*/\n                break;\n            }\n \n            /*We will be here when activePoint is in middle of\n              the edge being traversed and current character\n              being processed is not  on the edge (we fall off\n              the tree). In this case, we add a new internal node\n              and a new leaf edge going out of that new node. This\n              is Extension Rule 2, where a new leaf edge and a new\n            internal node get created*/\n            splitEnd = (int*) malloc(sizeof(int));\n            *splitEnd = next->start + activeLength - 1;\n \n            //New internal node\n            Node *split = newNode(next->start, splitEnd);\n            activeNode->children[text[activeEdge]] = split;\n \n            //New leaf coming out of new internal node\n            split->children[text[pos]] = newNode(pos, &leafEnd);\n            next->start += activeLength;\n            split->children[text[next->start]] = next;\n \n            /*We got a new internal node here. If there is any\n              internal node created in last extensions of same\n              phase which is still waiting for it's suffix link\n              reset, do it now.*/\n            if (lastNewNode != NULL)\n            {\n            /*suffixLink of lastNewNode points to current newly\n              created internal node*/\n                lastNewNode->suffixLink = split;\n            }\n \n            /*Make the current newly created internal node waiting\n              for it's suffix link reset (which is pointing to root\n              at present). If we come across any other internal node\n              (existing or newly created) in next extension of same\n              phase, when a new leaf edge gets added (i.e. when\n              Extension Rule 2 applies is any of the next extension\n              of same phase) at that point, suffixLink of this node\n              will point to that internal node.*/\n            lastNewNode = split;\n        }\n \n        /* One suffix got added in tree, decrement the count of\n          suffixes yet to be added.*/\n        remainingSuffixCount--;\n        if (activeNode == root && activeLength > 0) //APCFER2C1\n        {\n            activeLength--;\n            activeEdge = pos - remainingSuffixCount + 1;\n        }\n        else if (activeNode != root) //APCFER2C2\n        {\n            activeNode = activeNode->suffixLink;\n        }\n    }\n}\n \nvoid print(int i, int j)\n{\n    int k;\n    for (k=i; k<=j && text[k] != '#'; k++)\n        printf(\"%c\", text[k]);\n    if(k<=j)\n        printf(\"#\");\n}\n \n//Print the suffix tree as well along with setting suffix index\n//So tree will be printed in DFS manner\n//Each edge along with it's suffix index will be printed\nvoid setSuffixIndexByDFS(Node *n, int labelHeight)\n{\n    if (n == NULL)  return;\n \n    if (n->start != -1) //A non-root node\n    {\n        //Print the label on edge from parent to current node\n        print(n->start, *(n->end));\n    }\n    int leaf = 1;\n    int i;\n    for (i = 0; i < MAX_CHAR; i++)\n    {\n        if (n->children[i] != NULL)\n        {\n            if (leaf == 1 && n->start != -1)\n                printf(\" [%d]\\n\", n->suffixIndex);\n \n            //Current node is not a leaf as it has outgoing\n            //edges from it.\n            leaf = 0;\n            setSuffixIndexByDFS(n->children[i], labelHeight +\n                                  edgeLength(n->children[i]));\n        }\n    }\n    if (leaf == 1)\n    {\n        for(i= n->start; i<= *(n->end); i++)\n        {\n            if(text[i] == '#') //Trim unwanted characters\n            {\n                n->end = (int*) malloc(sizeof(int));\n                *(n->end) = i;\n            }\n        }\n        n->suffixIndex = size - labelHeight;\n        printf(\" [%d]\\n\", n->suffixIndex);\n    }\n}\n \nvoid freeSuffixTreeByPostOrder(Node *n)\n{\n    if (n == NULL)\n        return;\n    int i;\n    for (i = 0; i < MAX_CHAR; i++)\n    {\n        if (n->children[i] != NULL)\n        {\n            freeSuffixTreeByPostOrder(n->children[i]);\n        }\n    }\n    if (n->suffixIndex == -1)\n        free(n->end);\n    free(n);\n}\n \n/*Build the suffix tree and print the edge labels along with\nsuffixIndex. suffixIndex for leaf edges will be >= 0 and\nfor non-leaf edges will be -1*/\nvoid buildSuffixTree()\n{\n    size = strlen(text);\n    int i;\n    rootEnd = (int*) malloc(sizeof(int));\n    *rootEnd = - 1;\n \n    /*Root is a special node with start and end indices as -1,\n    as it has no parent from where an edge comes to root*/\n    root = newNode(-1, rootEnd);\n \n    activeNode = root; //First activeNode will be root\n    for (i=0; i<size; i++)\n        extendSuffixTree(i);\n    int labelHeight = 0;\n    setSuffixIndexByDFS(root, labelHeight);\n \n    //Free the dynamically allocated memory\n    freeSuffixTreeByPostOrder(root);\n}\n \n// driver program to test above functions\nint main(int argc, char *argv[])\n{\n//  strcpy(text, \"xabxac#abcabxabcd$\"); buildSuffixTree();\n    strcpy(text, \"xabxa#babxba$\"); buildSuffixTree();\n    return 0;\n}\n# [5]\n$ [12]\na [-1]\n# [4]\n$ [11]\nbx [-1]\na# [1]\nba$ [7]\nb [-1]\na [-1]\n$ [10]\nbxba$ [6]\nx [-1]\na# [2]\nba$ [8]\nx [-1]\na [-1]\n# [3]\nbxa# [0]\nba$ [9]\n",
        "complexity": {
            "time": "",
            "space": ""
        },
        "tags": [
            "Pattern Searching"
        ],
        "url": "https://www.geeksforgeeks.org/generalized-suffix-tree/"
    },
    {
        "title": "Ukkonen’s Suffix Tree Construction – Part 1",
        "description": "Suffix Tree is very useful in numerous string processing and computational biology problems. Many books and e-resources talk about it theoretically and in few places, code implementation is discussed. But still, I felt something is missing and it’s not easy to implement code to construct suffix tree and it’s usage in many applications. This is an attempt to bridge the gap between theory and complete working code implementation. Here we will discuss Ukkonen’s Suffix Tree Construction Algorithm. We will discuss it in step by step detailed way and in multiple parts from theory to implementation. We will start with brute force way and try to understand different concepts, tricks involved in Ukkonen’s algorithm and in the last part, code implementation will be discussed. Note: You may find some portion of the algorithm difficult to understand while 1st or 2nd reading and it’s perfectly fine. With few more attempts and thought, you should be able to understand such portions. Book Algorithms on Strings, Trees and Sequences: Computer Science and Computational Biology by Dan Gusfield explains the concepts very well. A suffix tree T for a m-character string S is a rooted directed tree with exactly m leaves numbered 1 to m. (Given that last string character is unique in string) Concatenation of the edge-labels on the path from the root to leaf i gives the suffix of S that starts at position i, i.e. S[i…m]. Note: Position starts with 1 (it’s not zero indexed, but later, while code implementation, we will used zero indexed position) For string S = xabxac with m = 6, suffix tree will look like following:  It has one root node and two internal nodes and 6 leaf nodes. String Depth of red path is 1 and it represents suffix c starting at position 6 String Depth of blue path is 4 and it represents suffix bxca starting at position 3 String Depth of green path is 2 and it represents suffix ac starting at position 5 String Depth of orange path is 6 and it represents suffix xabxac starting at position 1 Edges with labels a (green) and xa (orange) are non-leaf edge (which ends at an internal node). All other edges are leaf edge (ends at a leaf) If one suffix of S matches a prefix of another suffix of S (when last character in not unique in string), then path for the first suffix would not end at a leaf. For String S = xabxa, with m = 5, following is the suffix tree:  Here we will have 5 suffixes: xabxa, abxa, bxa, xa and a. Path for suffixes ‘xa’ and ‘a’ do not end at a leaf. A tree like above (Figure 2) is called implicit suffix tree as some suffixes (‘xa’ and ‘a’) are not seen explicitly in tree. To avoid this problem, we add a character which is not present in string already. We normally use $, # etc as termination characters. Following is the suffix tree for string S = xabxa$ with m = 6 and now all 6 suffixes end at leaf.  A naive algorithm to build a suffix tree Given a string S of length m, enter a single edge for suffix S[1 ..m]$ (the entire string) into the tree, then successively enter suffix S[i..m]$ into the growing tree, for i increasing from 2 to m. Let Ni denote the intermediate tree that encodes all the suffixes from 1 to i. So Ni+1 is constructed from Ni as follows: This takes O(m2) to build the suffix tree for the string S of length m. Following are few steps to build suffix tree based for string “xabxa$” based on above algorithm:        Implicit suffix tree While generating suffix tree using Ukkonen’s algorithm, we will see implicit suffix tree in intermediate steps few times depending on characters in string S. In implicit suffix trees, there will be no edge with $ (or # or any other termination character) label and no internal node with only one edge going out of it. To get implicit suffix tree from a suffix tree S$,   High Level Description of Ukkonen’s algorithm Ukkonen’s algorithm constructs an implicit suffix tree Ti for each prefix S[l ..i] of S (of length m). It first builds T1 using 1st character, then T2 using 2nd character, then T3 using 3rd character, …, Tm using mth character. Implicit suffix tree Ti+1 is built on top of implicit suffix tree Ti. The true suffix tree for S is built from Tm by adding $. At any time, Ukkonen’s algorithm builds the suffix tree for the characters seen so far and so it has on-line property that may be useful in some situations. Time taken is O(m). Ukkonen’s algorithm is divided into m phases (one phase for each character in the string with length m) In phase i+1, tree Ti+1 is built from tree Ti. Each phase i+1 is further divided into i+1 extensions, one for each of the i+1 suffixes of S[1..i+1] In extension j of phase i+1, the algorithm first finds the end of the path from the root labelled with substring S[j..i]. It then extends the substring by adding the character S(i+1) to its end (if it is not there already). In extension 1 of phase i+1, we put string S[1..i+1] in the tree. Here S[1..i] will already be present in tree due to previous phase i. We just need to add S[i+1]th character in tree (if not there already). In extension 2 of phase i+1, we put string S[2..i+1] in the tree. Here S[2..i] will already be present in tree due to previous phase i. We just need to add S[i+1]th character in tree (if not there already) In extension 3 of phase i+1, we put string S[3..i+1] in the tree. Here S[3..i] will already be present in tree due to previous phase i. We just need to add S[i+1]th character in tree (if not there already) . . In extension i+1 of phase i+1, we put string S[i+1..i+1] in the tree. This is just one character which may not be in tree (if character is seen first time so far). If so, we just add a new leaf edge with label S[i+1]. High Level Ukkonen’s algorithm Construct tree T1 For i from 1 to m-1 do begin {phase i+1}           For j from 1 to i+1                     begin {extension j}                     Find the end of the path from the root labelled S[j..i] in the current tree.                     Extend that path by adding character S[i+l] if it is not there already           end; end; Suffix extension is all about adding the next character into the suffix tree built so far. In extension j of phase i+1, algorithm finds the end of S[j..i] (which is already in the tree due to previous phase i) and then it extends S[j..i] to be sure the suffix S[j..i+1] is in the tree. There are 3 extension rules: Rule 1: If the path from the root labelled S[j..i] ends at leaf edge (i.e. S[i] is last character on leaf edge) then character S[i+1] is just added to the end of the label on that leaf edge. Rule 2: If the path from the root labelled S[j..i] ends at non-leaf edge (i.e. there are more characters after S[i] on path) and next character is not s[i+1], then a new leaf edge with label s{i+1] and number j is created starting from character S[i+1]. A new internal node will also be created if s[1..i] ends inside (in-between) a non-leaf edge. Rule 3: If the path from the root labelled S[j..i] ends at non-leaf edge (i.e. there are more characters after S[i] on path) and next character is s[i+1] (already in tree), do nothing. One important point to note here is that from a given node (root or internal), there will be one and only one edge starting from one character. There will not be more than one edges going out of any node, starting with same character. Following is a step by step suffix tree construction of string xabxac using Ukkonen’s algorithm:            In next parts (Part 2, Part 3, Part 4 and Part 5), we will discuss suffix links, active points, few tricks and finally code implementations (Part 6).  A  ",
        "code": "",
        "complexity": {
            "time": "",
            "space": ""
        },
        "tags": [
            "Pattern Searching"
        ],
        "url": "https://www.geeksforgeeks.org/ukkonens-suffix-tree-construction-part-1/"
    },
    {
        "title": "Boyer Moore Algorithm for Pattern Searching",
        "description": "Pattern searching is an important problem in computer science. When we do search for a string in a notepad/word file, browser, or database, pattern searching algorithms are used to show the search results. A typical problem statement would be- ” Given a text txt[0..n-1] and a pattern pat[0..m-1] where n is the length of the text and m is the length of the pattern, write a function search(char pat[], char txt[]) that prints all occurrences of pat[] in txt[]. You may assume that n > m. “Examples: Input:  txt[] = “THIS IS A TEST TEXT”           pat[] = “TEST”Output: Pattern found at index 10 Input:  txt[] =  “AABAACAADAABAABA”           pat[] =  “AABA”Output: Pattern found at index 0              Pattern found at index 9             Pattern found at index 12  In this post, we will discuss the Boyer Moore pattern searching algorithm. Like KMP and Finite Automata algorithms, Boyer Moore algorithm also preprocesses the pattern. Boyer Moore is a combination of the following two approaches. Both of the above heuristics can also be used independently to search a pattern in a text. Let us first understand how two independent approaches work together in the Boyer Moore algorithm. If we take a look at the Naive algorithm, it slides the pattern over the text one by one. KMP algorithm does preprocessing over the pattern so that the pattern can be shifted by more than one. The Boyer Moore algorithm does preprocessing for the same reason. It processes the pattern and creates different arrays for each of the two heuristics. At every step, it slides the pattern by the max of the slides suggested by each of the two heuristics. So, it uses greatest offset suggested by the two heuristics at every step. Unlike the previous pattern searching algorithms, the Boyer Moore algorithm starts matching from the last character of the pattern.In this post, we will discuss the bad character heuristic and the Good Suffix heuristic in the next post. The idea of bad character heuristic is simple. The character of the text which doesn’t match with the current character of the pattern is called the Bad Character. Upon mismatch, we shift the pattern until – We will lookup the position of the last occurrence of the mismatched character in the pattern, and if the mismatched character exists in the pattern, then we’ll shift the pattern such that it becomes aligned to the mismatched character in the text T.  In the above example, we got a mismatch at position 3. Here our mismatching character is “A”. Now we will search for last occurrence of “A” in pattern. We got “A” at position 1 in pattern (displayed in Blue) and this is the last occurrence of it. Now we will shift pattern 2 times so that “A” in pattern get aligned with “A” in text. We’ll lookup the position of last occurrence of mismatching character in pattern and if character does not exist we will shift pattern past the mismatching character.  Here we have a mismatch at position 7. The mismatching character “C” does not exist in pattern before position 7 so we’ll shift pattern past to the position 7 and eventually in above example we have got a perfect match of pattern (displayed in Green). We are doing this because “C” does not exist in the pattern so at every shift before position 7 we will get mismatch and our search will be fruitless. In the following implementation, we pre-process the pattern and store the last occurrence of every possible character in an array of size equal to alphabet size. If the character is not present at all, then it may result in a shift by m (length of pattern). Therefore, the bad character heuristic takes O(n/m) time in the best case. Below is the implementation of the above idea: Time Complexity : O(m*n) Auxiliary Space: O(1) The Bad Character Heuristic may take O(m*n) time in worst case. The worst case occurs when all characters of the text and pattern are same. For example, txt[] = “AAAAAAAAAAAAAAAAAA” and pat[] = “AAAAA”. The Bad Character Heuristic may take O(n/m) in the best case. The best case occurs when all the characters of the text and pattern are different. Boyer Moore Algorithm | Good Suffix heuristic A  ",
        "code": "/* C++ Program for Bad Character Heuristic of Boyer\nMoore String Matching Algorithm */\n#include <bits/stdc++.h>\nusing namespace std;\n#define NO_OF_CHARS 256\n\n// The preprocessing function for Boyer Moore's\n// bad character heuristic\nvoid badCharHeuristic(string str, int size,\n                      int badchar[NO_OF_CHARS])\n{\n    int i;\n\n    // Initialize all occurrences as -1\n    for (i = 0; i < NO_OF_CHARS; i++)\n        badchar[i] = -1;\n\n    // Fill the actual value of last occurrence\n    // of a character\n    for (i = 0; i < size; i++)\n        badchar[(int)str[i]] = i;\n}\n\n/* A pattern searching function that uses Bad\nCharacter Heuristic of Boyer Moore Algorithm */\nvoid search(string txt, string pat)\n{\n    int m = pat.size();\n    int n = txt.size();\n\n    int badchar[NO_OF_CHARS];\n\n    /* Fill the bad character array by calling\n    the preprocessing function badCharHeuristic()\n    for given pattern */\n    badCharHeuristic(pat, m, badchar);\n\n    int s = 0; // s is shift of the pattern with\n               // respect to text\n    while (s <= (n - m)) {\n        int j = m - 1;\n\n        /* Keep reducing index j of pattern while\n        characters of pattern and text are\n        matching at this shift s */\n        while (j >= 0 && pat[j] == txt[s + j])\n            j--;\n\n        /* If the pattern is present at current\n        shift, then index j will become -1 after\n        the above loop */\n        if (j < 0) {\n            cout << \"pattern occurs at shift = \" << s\n                 << endl;\n\n            /* Shift the pattern so that the next\n            character in text aligns with the last\n            occurrence of it in pattern.\n            The condition s+m < n is necessary for\n            the case when pattern occurs at the end\n            of text */\n            s += (s + m < n) ? m - badchar[txt[s + m]] : 1;\n        }\n\n        else\n            /* Shift the pattern so that the bad character\n            in text aligns with the last occurrence of\n            it in pattern. The max function is used to\n            make sure that we get a positive shift.\n            We may get a negative shift if the last\n            occurrence of bad character in pattern\n            is on the right side of the current\n            character. */\n            s += max(1, j - badchar[txt[s + j]]);\n    }\n}\n\n/* Driver code */\nint main()\n{\n    string txt = \"ABAAABCD\";\n    string pat = \"ABC\";\n    search(txt, pat);\n    return 0;\n}\n\n// This code is contributed by rathbhupendra\n/* C Program for Bad Character Heuristic of Boyer\n   Moore String Matching Algorithm */\n#include <limits.h>\n#include <stdio.h>\n#include <string.h>\n\n#define NO_OF_CHARS 256\n\n// A utility function to get maximum of two integers\nint max(int a, int b) { return (a > b) ? a : b; }\n\n// The preprocessing function for Boyer Moore's\n// bad character heuristic\nvoid badCharHeuristic(char* str, int size,\n                      int badchar[NO_OF_CHARS])\n{\n    int i;\n\n    // Initialize all occurrences as -1\n    for (i = 0; i < NO_OF_CHARS; i++)\n        badchar[i] = -1;\n\n    // Fill the actual value of last occurrence\n    // of a character\n    for (i = 0; i < size; i++)\n        badchar[(int)str[i]] = i;\n}\n\n/* A pattern searching function that uses Bad\n   Character Heuristic of Boyer Moore Algorithm */\nvoid search(char* txt, char* pat)\n{\n    int m = strlen(pat);\n    int n = strlen(txt);\n\n    int badchar[NO_OF_CHARS];\n\n    /* Fill the bad character array by calling\n       the preprocessing function badCharHeuristic()\n       for given pattern */\n    badCharHeuristic(pat, m, badchar);\n\n    int s = 0; // s is shift of the pattern with\n               // respect to text\n    while (s <= (n - m)) {\n        int j = m - 1;\n\n        /* Keep reducing index j of pattern while\n           characters of pattern and text are\n           matching at this shift s */\n        while (j >= 0 && pat[j] == txt[s + j])\n            j--;\n\n        /* If the pattern is present at current\n           shift, then index j will become -1 after\n           the above loop */\n        if (j < 0) {\n            printf(\"\\n pattern occurs at shift = %d\", s);\n\n            /* Shift the pattern so that the next\n               character in text aligns with the last\n               occurrence of it in pattern.\n               The condition s+m < n is necessary for\n               the case when pattern occurs at the end\n               of text */\n            s += (s + m < n) ? m - badchar[txt[s + m]] : 1;\n        }\n\n        else\n            /* Shift the pattern so that the bad character\n               in text aligns with the last occurrence of\n               it in pattern. The max function is used to\n               make sure that we get a positive shift.\n               We may get a negative shift if the last\n               occurrence  of bad character in pattern\n               is on the right side of the current\n               character. */\n            s += max(1, j - badchar[txt[s + j]]);\n    }\n}\n\n/* Driver program to test above function */\nint main()\n{\n    char txt[] = \"ABAAABCD\";\n    char pat[] = \"ABC\";\n    search(txt, pat);\n    return 0;\n}\n/* Java Program for Bad Character Heuristic of Boyer\nMoore String Matching Algorithm */\n\nclass AWQ {\n\n    static int NO_OF_CHARS = 256;\n\n    // A utility function to get maximum of two integers\n    static int max(int a, int b) { return (a > b) ? a : b; }\n\n    // The preprocessing function for Boyer Moore's\n    // bad character heuristic\n    static void badCharHeuristic(char[] str, int size,\n                                 int badchar[])\n    {\n\n        // Initialize all occurrences as -1\n        for (int i = 0; i < NO_OF_CHARS; i++)\n            badchar[i] = -1;\n\n        // Fill the actual value of last occurrence\n        // of a character (indices of table are ascii and\n        // values are index of occurrence)\n        for (int i = 0; i < size; i++)\n            badchar[(int)str[i]] = i;\n    }\n\n    /* A pattern searching function that uses Bad\n    Character Heuristic of Boyer Moore Algorithm */\n    static void search(char txt[], char pat[])\n    {\n        int m = pat.length;\n        int n = txt.length;\n\n        int badchar[] = new int[NO_OF_CHARS];\n\n        /* Fill the bad character array by calling\n           the preprocessing function badCharHeuristic()\n           for given pattern */\n        badCharHeuristic(pat, m, badchar);\n\n        int s = 0; // s is shift of the pattern with\n                   // respect to text\n        // there are n-m+1 potential alignments\n        while (s <= (n - m)) {\n            int j = m - 1;\n\n            /* Keep reducing index j of pattern while\n               characters of pattern and text are\n               matching at this shift s */\n            while (j >= 0 && pat[j] == txt[s + j])\n                j--;\n\n            /* If the pattern is present at current\n               shift, then index j will become -1 after\n               the above loop */\n            if (j < 0) {\n                System.out.println(\n                    \"Patterns occur at shift = \" + s);\n\n                /* Shift the pattern so that the next\n                   character in text aligns with the last\n                   occurrence of it in pattern.\n                   The condition s+m < n is necessary for\n                   the case when pattern occurs at the end\n                   of text */\n                // txt[s+m] is character after the pattern\n                // in text\n                s += (s + m < n) ? m - badchar[txt[s + m]]\n                                 : 1;\n            }\n\n            else\n                /* Shift the pattern so that the bad\n                   character in text aligns with the last\n                   occurrence of it in pattern. The max\n                   function is used to make sure that we get\n                   a positive shift. We may get a negative\n                   shift if the last occurrence  of bad\n                   character in pattern is on the right side\n                   of the current character. */\n                s += max(1, j - badchar[txt[s + j]]);\n        }\n    }\n\n    /* Driver program to test above function */\n    public static void main(String[] args)\n    {\n\n        char txt[] = \"ABAAABCD\".toCharArray();\n        char pat[] = \"ABC\".toCharArray();\n        search(txt, pat);\n    }\n}\n# Python3 Program for Bad Character Heuristic\n# of Boyer Moore String Matching Algorithm\n\nNO_OF_CHARS = 256\n\n\ndef badCharHeuristic(string, size):\n    '''\n    The preprocessing function for\n    Boyer Moore's bad character heuristic\n    '''\n\n    # Initialize all occurrence as -1\n    badChar = [-1]*NO_OF_CHARS\n\n    # Fill the actual value of last occurrence\n    for i in range(size):\n        badChar[ord(string[i])] = i\n\n    # return initialized list\n    return badChar\n\n\ndef search(txt, pat):\n    '''\n    A pattern searching function that uses Bad Character\n    Heuristic of Boyer Moore Algorithm\n    '''\n    m = len(pat)\n    n = len(txt)\n\n    # create the bad character list by calling\n    # the preprocessing function badCharHeuristic()\n    # for given pattern\n    badChar = badCharHeuristic(pat, m)\n\n    # s is shift of the pattern with respect to text\n    s = 0\n    while(s <= n-m):\n        j = m-1\n\n        # Keep reducing index j of pattern while\n        # characters of pattern and text are matching\n        # at this shift s\n        while j >= 0 and pat[j] == txt[s+j]:\n            j -= 1\n\n        # If the pattern is present at current shift,\n        # then index j will become -1 after the above loop\n        if j < 0:\n            print(\"Pattern occur at shift = {}\".format(s))\n\n            '''    \n                Shift the pattern so that the next character in text\n                      aligns with the last occurrence of it in pattern.\n                The condition s+m < n is necessary for the case when\n                   pattern occurs at the end of text\n               '''\n            s += (m-badChar[ord(txt[s+m])] if s+m < n else 1)\n        else:\n            '''\n               Shift the pattern so that the bad character in text\n               aligns with the last occurrence of it in pattern. The\n               max function is used to make sure that we get a positive\n               shift. We may get a negative shift if the last occurrence\n               of bad character in pattern is on the right side of the\n               current character.\n            '''\n            s += max(1, j-badChar[ord(txt[s+j])])\n\n\n# Driver program to test above function\ndef main():\n    txt = \"ABAAABCD\"\n    pat = \"ABC\"\n    search(txt, pat)\n\n\nif __name__ == '__main__':\n    main()\n\n# This code is contributed by Atul Kumar\n# (www.facebook.com/atul.kr.007)\n/* C# Program for Bad Character Heuristic of Boyer\nMoore String Matching Algorithm */\n\nusing System;\npublic class AWQ {\n\n    static int NO_OF_CHARS = 256;\n\n    // A utility function to get maximum of two integers\n    static int max(int a, int b) { return (a > b) ? a : b; }\n\n    // The preprocessing function for Boyer Moore's\n    // bad character heuristic\n    static void badCharHeuristic(char[] str, int size,\n                                 int[] badchar)\n    {\n        int i;\n\n        // Initialize all occurrences as -1\n        for (i = 0; i < NO_OF_CHARS; i++)\n            badchar[i] = -1;\n\n        // Fill the actual value of last occurrence\n        // of a character\n        for (i = 0; i < size; i++)\n            badchar[(int)str[i]] = i;\n    }\n\n    /* A pattern searching function that uses Bad\n    Character Heuristic of Boyer Moore Algorithm */\n    static void search(char[] txt, char[] pat)\n    {\n        int m = pat.Length;\n        int n = txt.Length;\n\n        int[] badchar = new int[NO_OF_CHARS];\n\n        /* Fill the bad character array by calling\n            the preprocessing function badCharHeuristic()\n            for given pattern */\n        badCharHeuristic(pat, m, badchar);\n\n        int s = 0; // s is shift of the pattern with\n                   // respect to text\n        while (s <= (n - m)) {\n            int j = m - 1;\n\n            /* Keep reducing index j of pattern while\n                characters of pattern and text are\n                matching at this shift s */\n            while (j >= 0 && pat[j] == txt[s + j])\n                j--;\n\n            /* If the pattern is present at current\n                shift, then index j will become -1 after\n                the above loop */\n            if (j < 0) {\n                Console.WriteLine(\n                    \"Patterns occur at shift = \" + s);\n\n                /* Shift the pattern so that the next\n                    character in text aligns with the last\n                    occurrence of it in pattern.\n                    The condition s+m < n is necessary for\n                    the case when pattern occurs at the end\n                    of text */\n                s += (s + m < n) ? m - badchar[txt[s + m]]\n                                 : 1;\n            }\n\n            else\n                /* Shift the pattern so that the bad\n                   character in text aligns with the last\n                   occurrence of it in pattern. The max\n                   function is used to make sure that we get\n                   a positive shift. We may get a negative\n                   shift if the last occurrence of bad\n                   character in pattern is on the right side\n                   of the current character. */\n                s += max(1, j - badchar[txt[s + j]]);\n        }\n    }\n\n    /* Driver program to test above function */\n    public static void Main()\n    {\n\n        char[] txt = \"ABAAABCD\".ToCharArray();\n        char[] pat = \"ABC\".ToCharArray();\n        search(txt, pat);\n    }\n}\n\n// This code is contributed by PrinciRaj19992\n<script>\n/* Javascript Program for Bad Character Heuristic of Boyer\nMoore String Matching Algorithm */\nlet NO_OF_CHARS = 256;\n\n// A utility function to get maximum of two integers\nfunction max (a,b)\n{\n    return (a > b)? a: b;\n}\n\n// The preprocessing function for Boyer Moore's\n// bad character heuristic\nfunction badCharHeuristic(str,size,badchar)\n{\n    // Initialize all occurrences as -1\n      for (let i = 0; i < NO_OF_CHARS; i++)\n           badchar[i] = -1;\n \n      // Fill the actual value of last occurrence\n      // of a character (indices of table are ascii and values are index of occurrence)\n      for (i = 0; i < size; i++)\n           badchar[ str[i].charCodeAt(0)] = i;\n}\n\n/* A pattern searching function that uses Bad\n     Character Heuristic of Boyer Moore Algorithm */\nfunction search(txt,pat)\n{\n    let m = pat.length;\n      let n = txt.length;\n \n      let badchar = new Array(NO_OF_CHARS);\n \n      /* Fill the bad character array by calling\n         the preprocessing function badCharHeuristic()\n         for given pattern */\n      badCharHeuristic(pat, m, badchar);\n \n      let s = 0;  // s is shift of the pattern with\n                  // respect to text\n       // there are n-m+1 potential alignments\n      while(s <= (n - m))\n      {\n          let j = m-1;\n \n          /* Keep reducing index j of pattern while\n             characters of pattern and text are\n             matching at this shift s */\n          while(j >= 0 && pat[j] == txt[s+j])\n              j--;\n \n          /* If the pattern is present at current\n             shift, then index j will become -1 after\n             the above loop */\n          if (j < 0)\n          {\n              document.write(\"Patterns occur at shift = \" + s);\n \n              /* Shift the pattern so that the next\n                 character in text aligns with the last\n                 occurrence of it in pattern.\n                 The condition s+m < n is necessary for\n                 the case when pattern occurs at the end\n                 of text */\n              //txt[s+m] is character after the pattern in text\n              s += (s+m < n)? m-badchar[txt[s+m].charCodeAt(0)] : 1;\n \n          }\n \n          else\n              /* Shift the pattern so that the bad character\n                 in text aligns with the last occurrence of\n                 it in pattern. The max function is used to\n                 make sure that we get a positive shift.\n                 We may get a negative shift if the last\n                 occurrence  of bad character in pattern\n                 is on the right side of the current\n                 character. */\n              s += max(1, j - badchar[txt[s+j].charCodeAt(0)]);\n      }\n}\n\n/* Driver program to test above function */\nlet txt=\"ABAAABCD\".split(\"\");\nlet pat = \"ABC\".split(\"\");\nsearch(txt, pat);\n\n// This code is contributed by unknown2108\n</script>\npattern occurs at shift = 4\n",
        "complexity": {
            "time": "Time Complexity : O(m*n)",
            "space": ""
        },
        "tags": [
            "Pattern Searching"
        ],
        "url": "https://www.geeksforgeeks.org/boyer-moore-algorithm-for-pattern-searching/"
    },
    {
        "title": "Aho-Corasick Algorithm for Pattern Searching",
        "description": "Given an input text and an array of k words, arr[], find all occurrences of all words in the input text. Let n be the length of text and m be the total number of characters in all words, i.e. m = length(arr[0]) + length(arr[1]) + … + length(arr[k-1]). Here k is total numbers of input words. Example: If we use a linear time searching algorithm like KMP, then we need to one by one search all words in text[]. This gives us total time complexity as O(n + length(word[0]) + O(n + length(word[1]) + O(n + length(word[2]) + … O(n + length(word[k-1]). This time complexity can be written as O(n*k + m). Aho-Corasick Algorithm finds all words in O(n + m + z) time where z is total number of occurrences of words in text. The Aho–Corasick string matching algorithm formed the basis of the original Unix command fgrep. Preprocessing: Trie  Go to : We build Trie. And for all characters which don’t have an edge at root, we add an edge back to root.Failure : For a state s, we find the longest proper suffix which is a proper prefix of some pattern. This is done using Breadth First Traversal of Trie.Output : For a state s, indexes of all words ending at s are stored. These indexes are stored as bitwise map (by doing bitwise OR of values). This is also computing using Breadth First Traversal with Failure. Below is the implementation of Aho-Corasick Algorithm                Time Complexity: O(n + l + z), where ‘n’ is the length of the text, ‘l’ is the length of keywords, and ‘z’ is the number of matches. Auxiliary Space: O(l * q), where ‘q’ is the length of the alphabet since that is the maximum number of children a node can have. Applications: ? Detecting plagiarism ? Text mining ? Bioinformatics ? Intrusion Detection A  ",
        "code": "Input: text = \"ahishers\"    \r\n       arr[] = {\"he\", \"she\", \"hers\", \"his\"}\r\n\r\nOutput:\r\n   Word his appears from 1 to 3\r\n   Word he appears from 4 to 5\r\n   Word she appears from 3 to 5\r\n   Word hers appears from 4 to 7\nGo To :   This function simply follows edges\r\n          of Trie of all words in arr[]. It is\r\n          represented as 2D array g[][] where\r\n          we store next state for current state \r\n          and character.\r\n\r\nFailure : This function stores all edges that are\r\n          followed when current character doesn't\r\n          have edge in Trie.  It is represented as\r\n          1D array f[] where we store next state for\r\n          current state. \r\n\r\nOutput :  Stores indexes of all words that end at \r\n          current state. It is represented as 1D \r\n          array o[] where we store indexes\r\n          of all matching words as a bitmap for \r\n          current state.\n\n\n\n\n\n\n\n\n\n\nWord his appears from 1 to 3\r\nWord he appears from 4 to 5\r\nWord she appears from 3 to 5\r\nWord hers appears from 4 to 7\n",
        "complexity": {
            "time": "Time Complexity: O(n + l + z), where ‘n’ is the length of the text, ‘l’ is the length of keywords, and ‘z’ is the number of matches.",
            "space": ""
        },
        "tags": [
            "Pattern Searching"
        ],
        "url": "https://www.geeksforgeeks.org/aho-corasick-algorithm-pattern-searching/"
    },
    {
        "title": "Wildcard Pattern Matching",
        "description": "Given a text txt and a wildcard pattern pat, implement a wildcard pattern matching algorithm that finds if the wildcard pattern is matched with the text. The matching should cover the entire text. The wildcard pattern can include the characters ‘?’ and ‘*’ which denote: Input: txt = “abcde”, pat = “a?c*” Output: trueExplanation: ? matches with b and * matches with “de”.Input: txt = “baaabab”, pat = “a*ab” Output: falseExplanation: Because in string pattern character ‘a’ at first position, pattern and text can’t be matched. Input: txt = “abc”, pat = “*” Output: trueExplanation: * matches with whole text “abc”. Table of Content We start matching the last characters of the both pattern and text. There are three possible cases: Case 1: The character is ‘*’ . Here two cases arises as follows: Case 2: The character is ‘?’ :As ‘?’ matches with any single character, we move to the next character in both pattern and text. Case 3: The character in the pattern is not a wildcard: If current character in Text matches with current character in Pattern, we move to next character in the Pattern and Text. If they do not match, we return false. In this problem, we can observe that the recursive solution holds the following two properties of Dynamic Programming: 1. Optimal Substructure: The result of matching a pattern pat of length m with a text txt of length n, i.e., wildCardRec(txt, pat, n, m), depends on the optimal solutions of its subproblems. If the current characters of pat and txt match (or if the character in pat is a ‘?’), then the solution depends on wildCardRec(txt, pat, n-1, m-1). If the current character in pat is an *, the solution of the problem will depend on the optimal result of wildCardRec(txt, pat, n, m-1) and wildCardRec(txt, pat, n-1, m). 2. Overlapping Subproblems: When using a recursive approach for the wildcard matching problem, we notice that certain subproblems are solved multiple times. For example, when solving wildCardRec(txt, pat, n, m), we may repeatedly compute results for subproblems like wildCardRec(txt, pat, n-1, m-1) or wildCardRec(txt, pat, n, m-1) in different recursive paths. The approach is similar to the previous one; however, instead of solving the problem recursively, we iteratively build the solution using a bottom-up manner. We maintain a dp[][] table such that dp[i][j] stores whether the pattern pat[0…j-1] matches with the text txt[0…i-1]. If we take a closer look at the above solution, we can notice that we use only row entries, previous and current one. Therefore we can optimize the space by storing only rows. At first, we initialize two pointers i and j to the beginning of the text and the pattern, respectively. We also initialize two variables startIndex and match to -1 and 0, respectively. startIndex will keep track of the position of the last ‘*’ character in the pattern, and match will keep track of the position in the text where the last proper match started. We then loop through the text until we reach the end or find a character in the pattern that doesn’t match the corresponding character in the text. If the current characters match, we simply move to the next characters in both the pattern and the text. Ifnd if the pattern has a ‘?‘ , we simply move to the next characters in both the pattern and the text. If the pattern has a ‘*’ character, then we mark the current position in the pattern and the text as a proper match by setting startIndex to the current position in the pattern and its match to the current position in the text. If there was no match and no ‘*’ character, then we understand we need to go through a different route henceforth, we backtrack to the last  ‘*’ character position and try a different match by setting j to startIndex + 1, match to match + 1, and i to match. Once we have looped over the text, we consume any remaining ‘*’ characters in the pattern, and if we have reached the end of both the pattern and the text, the pattern matches the text. A  ",
        "code": "// C++ program for wildcard pattern matching using     \n// recursion\n\n#include <iostream>\n#include <string>\nusing namespace std;\n\nbool wildCardRec(string& txt, string& pat, int n, int m) {\n    \n    // Empty pattern can match with a empty text only\n    if (m == 0)\n        return (n == 0);\n\n    // Empty text can match with a pattern consisting \n    // of '*' only.\n    if (n == 0) {\n        for (int i = 0; i < m; i++)\n            if (pat[i] != '*')\n                return false;\n        return true;\n    }\n\n    // Either the characters match or pattern has '?'\n    // move to the next in both text and pattern\n    if (txt[n - 1] == pat[m - 1] || pat[m - 1] == '?')\n        return wildCardRec(txt, pat, n - 1, m - 1);\n\n    // if the current character of pattern is '*'\n    // first case: It matches with zero character\n    // second case: It matches with one or more characters\n    if (pat[m - 1] == '*')\n        return wildCardRec(txt, pat, n, m - 1) || \n               wildCardRec(txt, pat, n - 1, m);\n    \n    return false;\n}\n\nbool wildCard(string txt, string pat) {\n    int n = txt.size();\n    int m = pat.size();\n    return wildCardRec(txt, pat, n, m);\n}\n\nint main() {\n    string txt= \"abcde\";\n    string pat = \"a*de\";\n    cout << (wildCard(txt, pat) ? \"true\" : \"false\"); \n    return 0;\n}\n// Java program for wildcard pattern matching using recursion\n\nclass GfG {\n    static boolean wildCardRec(String txt, \n                         String pat, int n, int m) {\n        \n        // Empty pattern can match with an empty text only\n        if (m == 0)\n            return (n == 0);\n\n        // Empty text can match with a pattern consisting\n        // of '*' only.\n        if (n == 0) {\n            for (int i = 0; i < m; i++)\n                if (pat.charAt(i) != '*')\n                    return false;\n            return true;\n        }\n\n        // Either the characters match or pattern has '?'\n        // move to the next in both text and pattern\n        if (txt.charAt(n - 1) == pat.charAt(m - 1) || \n            \t\t\t\t\tpat.charAt(m - 1) == '?')\n            return wildCardRec(txt, pat, n - 1, m - 1);\n\n        // if the current character of pattern is '*'\n        // first case: It matches with zero character\n        // second case: It matches with one or more characters\n        if (pat.charAt(m - 1) == '*')\n            return wildCardRec(txt, pat, n, m - 1) || \n                   wildCardRec(txt, pat, n - 1, m);\n\n        return false;\n    }\n\n    static boolean wildCard(String txt, String pat) {\n        int n = txt.length();\n        int m = pat.length();\n        return wildCardRec(txt, pat, n, m);\n    }\n\n    public static void main(String[] args) {\n        String txt = \"abcde\";\n        String pat = \"a*de\";\n        System.out.println(wildCard(txt, pat) ? \"true\" : \"false\");\n    }\n}\n# Python program for wildcard pattern matching using\n# recursion\n\ndef wildCardRec(txt, pat, n, m):\n    \n    # Empty pattern can match with an empty text only\n    if m == 0:\n        return n == 0\n\n    # Empty text can match with a pattern consisting\n    # of '*' only.\n    if n == 0:\n        for i in range(m):\n            if pat[i] != '*':\n                return False\n        return True\n\n    # Either the characters match or pattern has '?'\n    # move to the next in both text and pattern\n    if txt[n - 1] == pat[m - 1] or pat[m - 1] == '?':\n        return wildCardRec(txt, pat, n - 1, m - 1)\n\n    # if the current character of pattern is '*'\n    # first case: It matches with zero character\n    # second case: It matches with one or more characters\n    if pat[m - 1] == '*':\n        return wildCardRec(txt, pat, n, m - 1) or \\\n               wildCardRec(txt, pat, n - 1, m)\n\n    return False\n\ndef wildCard(txt, pat):\n    n = len(txt)\n    m = len(pat)\n    return wildCardRec(txt, pat, n, m)\n\nif __name__ == \"__main__\":\n    txt = \"abcde\"\n    pat = \"a*de\"\n    print(\"true\" if wildCard(txt, pat) else \"false\")\n// C# program for wildcard pattern \n// matching using recursion\n\nusing System;\n\nclass GfG {\n    static bool wildCardRec(string txt, \n                            string pat, int n, int m) {\n        \n        // Empty pattern can match with an empty text only\n        if (m == 0)\n            return (n == 0);\n\n        // Empty text can match with a pattern consisting\n        // of '*' only.\n        if (n == 0) {\n            for (int i = 0; i < m; i++)\n                if (pat[i] != '*')\n                    return false;\n            return true;\n        }\n\n        // Either the characters match or pattern has '?'\n        // move to the next in both text and pattern\n        if (txt[n - 1] == pat[m - 1] || pat[m - 1] == '?')\n            return wildCardRec(txt, pat, n - 1, m - 1);\n\n        // if the current character of pattern is '*'\n        // first case: It matches with zero character\n        // second case: It matches with one or more characters\n        if (pat[m - 1] == '*')\n            return wildCardRec(txt, pat, n, m - 1) || \n                   wildCardRec(txt, pat, n - 1, m);\n\n        return false;\n    }\n\n    static bool wildCard(string txt, string pat) {\n        int n = txt.Length;\n        int m = pat.Length;\n        return wildCardRec(txt, pat, n, m);\n    }\n\n    static void Main(string[] args) {\n        string txt = \"abcde\";\n        string pat = \"a*de\";\n        Console.WriteLine(wildCard(txt, pat) ? \"true\" : \"false\");\n    }\n}\n// JavaScript program for wildcard pattern matching using\n// recursion\n\nfunction wildCardRec(txt, pat, n, m) {\n\n    // Empty pattern can match with an empty text only\n    if (m === 0)\n        return (n === 0);\n\n    // Empty text can match with a pattern consisting\n    // of '*' only.\n    if (n === 0) {\n        for (let i = 0; i < m; i++)\n            if (pat[i] !== '*')\n                return false;\n        return true;\n    }\n\n    // Either the characters match or pattern has '?'\n    // move to the next in both text and pattern\n    if (txt[n - 1] === pat[m - 1] || pat[m - 1] === '?')\n        return wildCardRec(txt, pat, n - 1, m - 1);\n\n    // if the current character of pattern is '*'\n    // first case: It matches with zero character\n    // second case: It matches with one or more characters\n    if (pat[m - 1] === '*')\n        return wildCardRec(txt, pat, n, m - 1) || \n               wildCardRec(txt, pat, n - 1, m);\n\n    return false;\n}\n\nfunction wildCard(txt, pat) {\n    let n = txt.length;\n    let m = pat.length;\n    return wildCardRec(txt, pat, n, m);\n}\n\nlet txt = \"abcde\";\nlet pat = \"a*de\";\nconsole.log(wildCard(txt, pat) ? \"true\" : \"false\");\ntrue\n// C++ program for wildcard pattern \n// matching using memoization   \n\n#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nbool wildCardRec(string& txt, string& pat, \n                    int n, int m, vector<vector<int>> &memo) {\n    \n    // Empty pattern can match with a empty text only\n    if (m == 0)\n        return (n == 0);\n    \n    // If result for this sub problem has been \n    // already computed, return it\n    if(memo[n][m] != -1)\n        return memo[n][m];\n        \n    // Empty text can match with a pattern consisting \n    // of '*' only.\n    if (n == 0) {\n        for (int i = 0; i < m; i++)\n            if (pat[i] != '*')\n                return memo[n][m] = false;\n        return memo[n][m] = true;\n    }\n\n    // Either the characters match or pattern has '?'\n    // move to the next in both text and pattern\n    if (txt[n - 1] == pat[m - 1] || pat[m - 1] == '?')\n        return memo[n][m] = \n                    wildCardRec(txt, pat, n - 1, m - 1, memo);\n\n    // if the current character of pattern is '*'\n    // first case: It matches with zero character\n    // second case: It matches with one or more characters\n    if (pat[m - 1] == '*')\n        return memo[n][m] = \n                        wildCardRec(txt, pat, n, m - 1, memo) || \n                        wildCardRec(txt, pat, n - 1, m, memo);\n    \n    return memo[n][m] = false;\n}\n\nbool wildCard(string txt, string pat) {\n    int n = txt.size();\n    int m = pat.size();\n    \n    vector<vector<int>> memo(n+1, vector<int>(m+1, -1));\n    return wildCardRec(txt, pat, n, m, memo);\n}\n\nint main() {\n    string txt= \"abcde\";\n    string pat = \"a*de\";\n    cout << (wildCard(txt, pat) ? \"true\" : \"false\"); \n    return 0;\n}\n// Java program for wildcard pattern matching \n// using memoization\n\nimport java.util.Arrays;\n\nclass GfG {\n    static boolean wildCardRec(String txt, \n                       String pat, int n, int m, int[][] memo) {\n        \n        // Empty pattern can match with an empty text only\n        if (m == 0)\n            return (n == 0);\n        \n        // If result for this subproblem has been \n      \t// already computed, return it\n        if (memo[n][m] != -1)\n            return memo[n][m] == 1;\n        \n        // Empty text can match with a \n        // pattern consisting of '*' only.\n        if (n == 0) {\n            for (int i = 0; i < m; i++) {\n                if (pat.charAt(i) != '*') {\n                    memo[n][m] = 0;\n                  \treturn false;\n                }\n            }\n            memo[n][m] = 1;\n          \treturn true;\n        }\n\n        // Either the characters match or pattern has '?'\n        // Move to the next in both text and pattern\n        if (txt.charAt(n - 1) == pat.charAt(m - 1) || pat.charAt(m - 1) == '?') {\n            memo[n][m] = wildCardRec(txt, pat, n - 1, m - 1, memo) ? 1 : 0;\n            return memo[n][m] == 1;\n        }\n        \n        // If the current character of pattern is '*'\n        // First case: It matches with zero character\n        // Second case: It matches with one or more characters\n        if (pat.charAt(m - 1) == '*') {\n            memo[n][m] = (wildCardRec(txt, pat, n, m - 1, memo) \n                        || wildCardRec(txt, pat, n - 1, m, memo)) ? 1 : 0;\n            return memo[n][m] == 1;\n        }\n\n        memo[n][m] = 0; \n      \treturn false;\n    }\n\n    static boolean wildCard(String txt, String pat) {\n        int n = txt.length();\n        int m = pat.length();\n        int[][] memo = new int[n + 1][m + 1];\n        for (int[] row : memo)\n            Arrays.fill(row, -1);\n        return wildCardRec(txt, pat, n, m, memo);\n    }\n\n    public static void main(String[] args) {\n        String txt = \"abcde\";\n        String pat = \"a*de\";\n        System.out.println(wildCard(txt, pat) ? \"true\" : \"false\");\n    }\n}\n# Python program for wildcard pattern\n# matching using memoization\n\ndef wildCardRec(txt, pat, n, m, memo):\n    \n    # Empty pattern can match with an empty text only\n    if m == 0:\n        return n == 0\n    \n    # If result for this subproblem has been \n    # already computed, return it\n    if memo[n][m] != -1:\n        return memo[n][m]\n        \n    # Empty text can match with a pattern consisting \n    # of '*' only.\n    if n == 0:\n        for i in range(m):\n            if pat[i] != '*':\n                memo[n][m] = False\n                return False\n        memo[n][m] = True\n        return True\n\n    # Either the characters match or pattern has '?'\n    # move to the next in both text and pattern\n    if txt[n - 1] == pat[m - 1] or pat[m - 1] == '?':\n        memo[n][m] = wildCardRec(txt, pat, n - 1, m - 1, memo)\n        return memo[n][m]\n\n    # if the current character of pattern is '*'\n    # first case: It matches with zero character\n    # second case: It matches with one or more characters\n    if pat[m - 1] == '*':\n        memo[n][m] = wildCardRec(txt, pat, n, m - 1, memo) \\\n        or wildCardRec(txt, pat, n - 1, m, memo)\n        return memo[n][m]\n    \n    memo[n][m] = False\n    return False\n\ndef wildCard(txt, pat):\n    n = len(txt)\n    m = len(pat)\n    memo = [[-1 for _ in range(m + 1)] for _ in range(n + 1)]\n    return wildCardRec(txt, pat, n, m, memo)\n\nif __name__ == \"__main__\":\n    txt = \"abcde\"\n    pat = \"a*de\"\n    print(\"true\" if wildCard(txt, pat) else \"false\")\n// C# program for wildcard pattern matching\n// using memoization\n\nusing System;\n\nclass GfG {\n    static bool WildCardRec(string txt, string pat, \n                            \tint n, int m, int[,] memo) {\n      \n        // Empty pattern can match with an empty\n      \t// text only\n        if (m == 0)\n            return (n == 0);\n\n        // If result for this subproblem has been \n      \t// already computed, return it\n        if (memo[n, m] != -1)\n            return memo[n, m] == 1;\n\n        // Empty text can match with a pattern \n      \t// consisting of '*' only.\n        if (n == 0) {\n            for (int i = 0; i < m; i++) {\n                if (pat[i] != '*') {\n                    memo[n, m] = 0;\n                    return false;\n                }\n            }\n            memo[n, m] = 1;\n            return true;\n        }\n\n        // Either the characters match or pattern has '?'\n        // Move to the next in both text and pattern\n        if (txt[n - 1] == pat[m - 1] || pat[m - 1] == '?') {\n            memo[n, m] = WildCardRec(txt, pat, n - 1, m - 1, memo) ? 1 : 0;\n            return memo[n, m] == 1;\n        }\n\n        // If the current character of pattern is '*'\n        // First case: It matches with zero character\n        // Second case: It matches with one or more characters\n        if (pat[m - 1] == '*') {\n            memo[n, m] = (WildCardRec(txt, pat, n, m - 1, memo) \n                          \t|| WildCardRec(txt, pat, n - 1, m, memo)) ? 1 : 0;\n            return memo[n, m] == 1;\n        }\n\n        memo[n, m] = 0;\n        return false;\n    }\n\n    static bool WildCard(string txt, string pat) {\n        int n = txt.Length;\n        int m = pat.Length;\n        int[,] memo = new int[n + 1, m + 1];\n\n        // Initialize memo array with -1\n        for (int i = 0; i <= n; i++) {\n            for (int j = 0; j <= m; j++)\n                memo[i, j] = -1;\n        }\n\n        return WildCardRec(txt, pat, n, m, memo);\n    }\n\n    static void Main(string[] args) {\n        string txt = \"abcde\";\n        string pat = \"a*de\";\n        Console.WriteLine(WildCard(txt, pat) ? \"true\" : \"false\");\n    }\n}\n// JavaScript program for wildcard pattern \n// matching using memoization\n\nfunction wildCardRec(txt, pat, n, m, memo) {\n    \n    // Empty pattern can match with an empty text only\n    if (m === 0)\n        return n === 0;\n    \n    // If result for this subproblem has been \n    // already computed, return it\n    if (memo[n][m] !== -1)\n        return memo[n][m];\n        \n    // Empty text can match with a pattern consisting \n    // of '*' only.\n    if (n === 0) {\n        for (let i = 0; i < m; i++)\n            if (pat[i] !== '*')\n                return memo[n][m] = false;\n        return memo[n][m] = true;\n    }\n\n    // Either the characters match or pattern has '?'\n    // move to the next in both text and pattern\n    if (txt[n - 1] === pat[m - 1] || pat[m - 1] === '?')\n        return memo[n][m] = wildCardRec(txt, pat, n - 1, m - 1, memo);\n\n    // if the current character of pattern is '*'\n    // first case: It matches with zero character\n    // second case: It matches with one or more characters\n    if (pat[m - 1] === '*')\n        return memo[n][m] = wildCardRec(txt, pat, n, m - 1, memo) \n        \t\t\t\t\t\t|| wildCardRec(txt, pat, n - 1, m, memo);\n    \n    return memo[n][m] = false;\n}\n\nfunction wildCard(txt, pat) {\n    let n = txt.length;\n    let m = pat.length;\n    let memo = Array.from(Array(n + 1), () => Array(m + 1).fill(-1));\n    return wildCardRec(txt, pat, n, m, memo);\n}\n\nconst txt = \"abcde\";\nconst pat = \"a*de\";\nconsole.log(wildCard(txt, pat) ? \"true\" : \"false\");\ntrue\n// C++ program for wild card matching \n// using tabulation\n\n#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nbool wildCard(string& txt, string& pat) {\n    int n = txt.size();\n    int m = pat.size();\n\n    // dp[i][j] will be true if txt[0..i-1] matches pat[0..j-1]\n    vector<vector<bool>> dp(n + 1, vector<bool>(m + 1, false));\n\n    // Empty pattern matches with empty string\n    dp[0][0] = true;\n\n    // Handle patterns with '*' at the beginning\n    for (int j = 1; j <= m; j++)\n        if (pat[j - 1] == '*')\n            dp[0][j] = dp[0][j - 1];\n\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= m; j++) {\n            if (pat[j - 1] == txt[i - 1] || pat[j - 1] == '?') {\n                \n                // Either the characters match or pattern has '?'\n                // result will be same as previous state\n                dp[i][j] = dp[i - 1][j - 1];\n            }\n            \n            else if (pat[j - 1] == '*') {\n              \n                // if the current character of pattern is '*'\n                // first case: It matches with zero character\n                // second case: It matches with one or more \n                dp[i][j] = dp[i][j - 1] || dp[i - 1][j];\n            }\n        }\n    }\n\n    return dp[n][m];\n}\n\nint main() {\n    string txt = \"abcde\";\n    string pat = \"a*de\";\n    cout << (wildCard(txt, pat) ? \"true\" : \"false\") << endl;\n    return 0;\n}\n// Java program for wild card matching using tabulation\n\nimport java.util.Arrays;\n\nclass GfG {\n    static boolean wildCard(String txt, String pat) {\n        int n = txt.length();\n        int m = pat.length();\n\n        // dp[i][j] will be true if txt[0..i-1] matches pat[0..j-1]\n        boolean[][] dp = new boolean[n + 1][m + 1];\n\n        // Empty pattern matches with empty string\n        dp[0][0] = true;\n\n        // Handle patterns with '*' at the beginning\n        for (int j = 1; j <= m; j++)\n            if (pat.charAt(j - 1) == '*')\n                dp[0][j] = dp[0][j - 1];\n\n        for (int i = 1; i <= n; i++) {\n            for (int j = 1; j <= m; j++) {\n                if (pat.charAt(j - 1) == txt.charAt(i - 1) \n                    \t\t\t|| pat.charAt(j - 1) == '?') {\n                    \n                    // Either the characters match or pattern has '?'\n                    // result will be same as previous state\n                    dp[i][j] = dp[i - 1][j - 1];\n                }\n                \n                else if (pat.charAt(j - 1) == '*') {\n                  \n                    // if the current character of pattern is '*'\n                    // first case: It matches with zero character\n                    // second case: It matches with one or more \n                    dp[i][j] = dp[i][j - 1] || dp[i - 1][j];\n                }\n            }\n        }\n\n        return dp[n][m];\n    }\n\n    public static void main(String[] args) {\n        String txt = \"abcde\";\n        String pat = \"a*de\";\n        System.out.println(wildCard(txt, pat) ? \"true\" : \"false\");\n    }\n}\n# Python program for wild card matching using tabulation\n\ndef wildCard(txt, pat):\n    n = len(txt)\n    m = len(pat)\n    \n    # dp[i][j] will be True if txt[0..i-1] matches pat[0..j-1]\n    dp = [[False] * (m + 1) for _ in range(n + 1)]\n\n    # Empty pattern matches with empty string\n    dp[0][0] = True\n\n    # Handle patterns with '*' at the beginning\n    for j in range(1, m + 1):\n        if pat[j - 1] == '*':\n            dp[0][j] = dp[0][j - 1]\n\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if pat[j - 1] == txt[i - 1] or pat[j - 1] == '?':\n                \n                # Either the characters match or pattern has '?'\n                # result will be same as previous state\n                dp[i][j] = dp[i - 1][j - 1]\n                \n            elif pat[j - 1] == '*':\n                \n                # if the current character of pattern is '*'\n                # first case: It matches with zero character\n                # second case: It matches with one or more\n                dp[i][j] = dp[i][j - 1] or dp[i - 1][j]\n\n    return dp[n][m]\n\nif __name__ == \"__main__\":\n    txt = \"abcde\"\n    pat = \"a*de\"\n    print(\"true\" if wildCard(txt, pat) else \"false\")\n// C# program for wild card matching using tabulation\n\nusing System;\n\nclass GfG {\n    static bool WildCard(string txt, string pat) {\n        int n = txt.Length;\n        int m = pat.Length;\n\n        // dp[i, j] will be true if txt[0..i-1] matches pat[0..j-1]\n        bool[,] dp = new bool[n + 1, m + 1];\n\n        // Empty pattern matches with empty string\n        dp[0, 0] = true;\n\n        // Handle patterns with '*' at the beginning\n        for (int j = 1; j <= m; j++)\n            if (pat[j - 1] == '*')\n                dp[0, j] = dp[0, j - 1];\n\n        for (int i = 1; i <= n; i++) {\n            for (int j = 1; j <= m; j++) {\n                if (pat[j - 1] == txt[i - 1] || pat[j - 1] == '?') {\n                    \n                    // Either the characters match or pattern has '?'\n                    // result will be same as previous state\n                    dp[i, j] = dp[i - 1, j - 1];\n                }\n                \n                else if (pat[j - 1] == '*') {\n                  \n                    // if the current character of pattern is '*'\n                    // first case: It matches with zero character\n                    // second case: It matches with one or more \n                    dp[i, j] = dp[i, j - 1] || dp[i - 1, j];\n                }\n            }\n        }\n\n        return dp[n, m];\n    }\n\n    static void Main(string[] args) {\n        string txt = \"abcde\";\n        string pat = \"a*de\";\n        Console.WriteLine(WildCard(txt, pat) ? \"true\" : \"false\");\n    }\n}\n// JavaScript program for wild card matching using tabulation\n\nfunction wildCard(txt, pat) {\n    const n = txt.length;\n    const m = pat.length;\n\n    // dp[i][j] will be true if txt[0..i-1] matches pat[0..j-1]\n    const dp = Array.from({ length: n + 1 }, () => Array(m + 1).fill(false));\n\n    // Empty pattern matches with empty string\n    dp[0][0] = true;\n\n    // Handle patterns with '*' at the beginning\n    for (let j = 1; j <= m; j++)\n        if (pat[j - 1] === '*')\n            dp[0][j] = dp[0][j - 1];\n\n    for (let i = 1; i <= n; i++) {\n        for (let j = 1; j <= m; j++) {\n            if (pat[j - 1] === txt[i - 1] || pat[j - 1] === '?') {\n                \n                // Either the characters match or pattern has '?'\n                // result will be same as previous state\n                dp[i][j] = dp[i - 1][j - 1];\n            } \n            \n            else if (pat[j - 1] === '*') {\n              \n                // if the current character of pattern is '*'\n                // first case: It matches with zero character\n                // second case: It matches with one or more\n                dp[i][j] = dp[i][j - 1] || dp[i - 1][j];\n            }\n        }\n    }\n\n    return dp[n][m];\n}\n\nconst txt = \"abcde\";\nconst pat = \"a*de\";\nconsole.log(wildCard(txt, pat) ? \"true\" : \"false\");\ntrue\n// C++ program for wild card matching using \n// space optimized dp\n\n#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nbool wildCard(string txt, string pat) {\n    int n = txt.size();\n    int m = pat.size();\n\n    vector<bool> prev(m+1, false);\n    vector<bool> curr(m+1, false);\n\n    // Empty pattern matches with empty string\n    prev[0] = true;\n\n    // Handle patterns with '*' at the beginning\n    for (int j = 1; j <= m; j++)\n        if (pat[j - 1] == '*')\n            prev[j] = prev[j-1];\n\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= m; j++) {\n            if (pat[j - 1] == txt[i - 1] || pat[j - 1] == '?') {\n                \n                // Either the characters match or pattern has '?'\n                // result will be same as previous state\n                curr[j] = prev[j - 1];\n            }\n            \n            else if (pat[j - 1] == '*') {\n              \n                // if the current character of pattern is '*'\n                // first case: It matches with zero character\n                // second case: It matches with one or more \n                curr[j] = curr[j - 1] || prev[j];\n            }\n        }\n        \n        prev = curr;\n    }\n\n    return prev[m];\n}\n\nint main() {\n    string txt = \"abcde\";\n    string pat = \"a*de\";\n    cout << (wildCard(txt, pat) ? \"true\" : \"false\") << endl;\n    return 0;\n}\n// Java program for wild card matching using space optimized \n// dp\n\nclass GfG {\n    static boolean wildCard(String txt, String pat) {\n        int n = txt.length();\n        int m = pat.length();\n\n        boolean[] prev = new boolean[m + 1];\n        boolean[] curr = new boolean[m + 1];\n\n        // Empty pattern matches with empty string\n        prev[0] = true;\n\n        // Handle patterns with '*' at the beginning\n        for (int j = 1; j <= m; j++)\n            if (pat.charAt(j - 1) == '*')\n                prev[j] = prev[j - 1];\n\n        for (int i = 1; i <= n; i++) {\n            for (int j = 1; j <= m; j++) {\n                if (pat.charAt(j - 1) == txt.charAt(i - 1) \n                    \t\t\t\t|| pat.charAt(j - 1) == '?') {\n                    \n                    // Either the characters match or pattern has '?'\n                    // result will be same as previous state\n                    curr[j] = prev[j - 1];\n                } \n                \n                else if (pat.charAt(j - 1) == '*') {\n                  \n                    // if the current character of pattern is '*'\n                    // first case: It matches with zero character\n                    // second case: It matches with one or more \n                    curr[j] = curr[j - 1] || prev[j];\n                } else {\n                    curr[j] = false;\n                }\n            }\n            \n            // Copy current row to previous row\n            System.arraycopy(curr, 0, prev, 0, m + 1);\n        }\n\n        return prev[m];\n    }\n\n    public static void main(String[] args) {\n        String txt = \"abcde\";\n        String pat = \"a*de\";\n        System.out.println(wildCard(txt, pat) ? \"true\" : \"false\");\n    }\n}\n# Python program for wild card matching using space optimized \n# DP\n\ndef wildCard(txt, pat):\n    n = len(txt)\n    m = len(pat)\n    \n    prev = [False] * (m + 1)\n    curr = [False] * (m + 1)\n\n    # Empty pattern matches with empty string\n    prev[0] = True\n\n    # Handle patterns with '*' at the beginning\n    for j in range(1, m + 1):\n        if pat[j - 1] == '*':\n            prev[j] = prev[j - 1]\n\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if pat[j - 1] == txt[i - 1] or pat[j - 1] == '?':\n                \n                # Either the characters match or pattern has '?'\n                # result will be same as previous state\n                curr[j] = prev[j - 1]\n            \n            elif pat[j - 1] == '*':\n                \n                # if the current character of pattern is '*'\n                # first case: It matches with zero character\n                # second case: It matches with one or more\n                curr[j] = curr[j - 1] or prev[j]\n            else:\n                curr[j] = False\n        \n        # Copy current row to previous row\n        prev = curr[:]\n\n    return prev[m]\n\ntxt = \"abcde\"\npat = \"a*de\"\nprint(\"true\" if wildCard(txt, pat) else \"false\")\n// C# program for wild card matching using Space optimized DP\n\nusing System;\n\nclass GfG {\n    static bool WildCard(string txt, string pat) {\n        int n = txt.Length;\n        int m = pat.Length;\n\n        bool[] prev = new bool[m + 1];\n        bool[] curr = new bool[m + 1];\n\n        // Empty pattern matches with empty string\n        prev[0] = true;\n\n        // Handle patterns with '*' at the beginning\n        for (int j = 1; j <= m; j++)\n            if (pat[j - 1] == '*')\n                prev[j] = prev[j - 1];\n\n        for (int i = 1; i <= n; i++) {\n            for (int j = 1; j <= m; j++) {\n                if (pat[j - 1] == txt[i - 1] || pat[j - 1] == '?') {\n                    \n                    // Either the characters match or pattern has '?'\n                    // result will be same as previous state\n                    curr[j] = prev[j - 1];\n                } \n                \n                else if (pat[j - 1] == '*') {\n                  \n                    // if the current character of pattern is '*'\n                    // first case: It matches with zero character\n                    // second case: It matches with one or more \n                    curr[j] = curr[j - 1] || prev[j];\n                } else {\n                    curr[j] = false;\n                }\n            }\n            \n            // Copy current row to previous row\n            Array.Copy(curr, prev, m + 1);\n        }\n\n        return prev[m];\n    }\n\n    static void Main(string[] args) {\n        string txt = \"abcde\";\n        string pat = \"a*de\";\n        Console.WriteLine(WildCard(txt, pat) ? \"true\" : \"false\");\n    }\n}\n// JavaScript program for wild card matching using space optimized\n// DP\n\nfunction wildCard(txt, pat) {\n    const n = txt.length;\n    const m = pat.length;\n\n    let prev = new Array(m + 1).fill(false);\n    let curr = new Array(m + 1).fill(false);\n\n    // Empty pattern matches with empty string\n    prev[0] = true;\n\n    // Handle patterns with '*' at the beginning\n    for (let j = 1; j <= m; j++) {\n        if (pat[j - 1] === '*')\n            prev[j] = prev[j - 1];\n    }\n\n    for (let i = 1; i <= n; i++) {\n        for (let j = 1; j <= m; j++) {\n            if (pat[j - 1] === txt[i - 1] || pat[j - 1] === '?') {\n                \n                // Either the characters match or pattern has '?'\n                // result will be same as previous state\n                curr[j] = prev[j - 1];\n            } \n            \n            else if (pat[j - 1] === '*') {\n              \n                // if the current character of pattern is '*'\n                // first case: It matches with zero character\n                // second case: It matches with one or more \n                curr[j] = curr[j - 1] || prev[j];\n            } else {\n                curr[j] = false;\n            }\n        }\n        \n        // Copy current row to previous row\n        prev = [...curr];\n    }\n\n    return prev[m];\n}\n\nconst txt = \"abcde\";\nconst pat = \"a*de\";\nconsole.log(wildCard(txt, pat) ? \"true\" : \"false\");\ntrue\n// C++ program for wild card matching using single\n// traversal     \n\n#include <iostream>\nusing namespace std;\n\nbool wildCard(string txt, string pat) {\n    int n = txt.length();\n    int m = pat.length();\n    int i = 0, j = 0, startIndex = -1, match = 0;\n\n    while (i < n) {\n        \n        // Characters match or '?' in pattern matches\n        // any character.\n        if (j < m && (pat[j] == '?' || pat[j] == txt[i])) {          \n            i++;\n            j++;\n        }\n        \n        else if (j < m && pat[j] == '*') {\n          \n            // Wildcard character '*', mark the current\n            // position in the pattern and the text as a\n            // proper match.\n            startIndex = j;\n            match = i;\n            j++;\n        }\n      \n        else if (startIndex != -1) {\n          \n            // No match, but a previous wildcard was found.\n            // Backtrack to the last '*' character position\n            // and try for a different match.\n            j = startIndex + 1;\n            match++;\n            i = match;\n        }\n        \n        else {\n            \n            // If none of the above cases comply, the\n            // pattern does not match.\n            return false;\n        }\n    }\n\n    // Consume any remaining '*' characters in the given\n    // pattern.\n    while (j < m && pat[j] == '*') {\n        j++;\n    }\n\n    // If we have reached the end of both the pattern and\n    // the text, the pattern matches the text.\n    return j == m;\n}\n\nint main() {\n    string txt = \"baaabab\";\n    string pat = \"*****ba*****ab\";\n    \n    cout << (wildCard(txt, pat) ? \"true\" : \"false\");\n}\n// Java program for wild card matching using single\n// traversal\n\nclass GfG {\n    static boolean wildCard(String txt, String pat) {\n        int n = txt.length();\n        int m = pat.length();\n        int i = 0, j = 0, startIndex = -1, match = 0;\n\n        while (i < n) {\n\n            // Characters match or '?' in pattern matches\n            // any character.\n            if (j < m && (pat.charAt(j) == '?' \n                          \t|| pat.charAt(j) == txt.charAt(i))) {\n                i++;\n                j++;\n            }\n\n            else if (j < m && pat.charAt(j) == '*') {\n\n                // Wildcard character '*', mark the current\n                // position in the pattern and the text as a\n                // proper match.\n                startIndex = j;\n                match = i;\n                j++;\n            }\n\n            else if (startIndex != -1) {\n\n                // No match, but a previous wildcard was found.\n                // Backtrack to the last '*' character position\n                // and try for a different match.\n                j = startIndex + 1;\n                match++;\n                i = match;\n            }\n\n            else {\n\n                // If none of the above cases comply, the\n                // pattern does not match.\n                return false;\n            }\n        }\n\n        // Consume any remaining '*' characters in the given\n        // pattern.\n        while (j < m && pat.charAt(j) == '*') {\n            j++;\n        }\n\n        // If we have reached the end of both the pattern and\n        // the text, the pattern matches the text.\n        return j == m;\n    }\n\n    public static void main(String[] args) {\n        String txt = \"baaabab\";\n        String pat = \"*****ba*****ab\";\n\n        System.out.println(wildCard(txt, pat) ? \"true\" : \"false\");\n    }\n}\n# Python program for wild card matching using single\n# traversal\n\ndef wildCard(txt, pat):\n    n = len(txt)\n    m = len(pat)\n    i = 0\n    j = 0\n    startIndex = -1\n    match = 0\n\n    while i < n:\n\n        # Characters match or '?' in pattern matches\n        # any character.\n        if j < m and (pat[j] == '?' or pat[j] == txt[i]):\n            i += 1\n            j += 1\n\n        elif j < m and pat[j] == '*':\n\n            # Wildcard character '*', mark the current\n            # position in the pattern and the text as a\n            # proper match.\n            startIndex = j\n            match = i\n            j += 1\n\n        elif startIndex != -1:\n\n            # No match, but a previous wildcard was found.\n            # Backtrack to the last '*' character position\n            # and try for a different match.\n            j = startIndex + 1\n            match += 1\n            i = match\n\n        else:\n\n            # If none of the above cases comply, the\n            # pattern does not match.\n            return False\n\n    # Consume any remaining '*' characters in the given\n    # pattern.\n    while j < m and pat[j] == '*':\n        j += 1\n\n    # If we have reached the end of both the pattern and\n    # the text, the pattern matches the text.\n    return j == m\n\n\nif __name__ == \"__main__\":\n    txt = \"baaabab\"\n    pat = \"*****ba*****ab\"\n    print(\"true\" if wildCard(txt, pat) else \"false\")\n// C# program for wild card matching using single\n// traversal\n\nusing System;\n\nclass GfG {\n    static bool WildCard(string txt, string pat) {\n        int n = txt.Length;\n        int m = pat.Length;\n        int i = 0, j = 0, startIndex = -1, match = 0;\n\n        while (i < n) {\n\n            // Characters match or '?' in pattern matches\n            // any character.\n            if (j < m && (pat[j] == '?' || pat[j] == txt[i])) {\n                i++;\n                j++;\n            }\n\n            else if (j < m && pat[j] == '*') {\n\n                // Wildcard character '*', mark the current\n                // position in the pattern and the text as a\n                // proper match.\n                startIndex = j;\n                match = i;\n                j++;\n            }\n\n            else if (startIndex != -1) {\n\n                // No match, but a previous wildcard was found.\n                // Backtrack to the last '*' character position\n                // and try for a different match.\n                j = startIndex + 1;\n                match++;\n                i = match;\n            }\n\n            else {\n\n                // If none of the above cases comply, the\n                // pattern does not match.\n                return false;\n            }\n        }\n\n        // Consume any remaining '*' characters in the given\n        // pattern.\n        while (j < m && pat[j] == '*') {\n            j++;\n        }\n\n        // If we have reached the end of both the pattern and\n        // the text, the pattern matches the text.\n        return j == m;\n    }\n\n    static void Main(string[] args) {\n        string txt = \"baaabab\";\n        string pat = \"*****ba*****ab\";\n\n        Console.WriteLine(WildCard(txt, pat) ? \"true\" : \"false\");\n    }\n}\n// JavaScript program for wild card matching using single\n// traversal\n\nfunction wildCard(txt, pat) {\n    let n = txt.length;\n    let m = pat.length;\n    let i = 0, j = 0, startIndex = -1, match = 0;\n\n    while (i < n) {\n\n        // Characters match or '?' in pattern matches\n        // any character.\n        if (j < m && (pat[j] === '?' || pat[j] === txt[i])) {\n            i++;\n            j++;\n        }\n\n        else if (j < m && pat[j] === '*') {\n\n            // Wildcard character '*', mark the current\n            // position in the pattern and the text as a\n            // proper match.\n            startIndex = j;\n            match = i;\n            j++;\n        }\n\n        else if (startIndex !== -1) {\n\n            // No match, but a previous wildcard was found.\n            // Backtrack to the last '*' character position\n            // and try for a different match.\n            j = startIndex + 1;\n            match++;\n            i = match;\n        }\n\n        else {\n\n            // If none of the above cases comply, the\n            // pattern does not match.\n            return false;\n        }\n    }\n\n    // Consume any remaining '*' characters in the given\n    // pattern.\n    while (j < m && pat[j] === '*') {\n        j++;\n    }\n\n    // If we have reached the end of both the pattern and\n    // the text, the pattern matches the text.\n    return j === m;\n}\n\nlet txt = \"baaabab\";\nlet pat = \"*****ba*****ab\";\nconsole.log(wildCard(txt, pat) ? \"true\" : \"false\");\ntrue\n",
        "complexity": {
            "time": "",
            "space": ""
        },
        "tags": [
            "Pattern Searching"
        ],
        "url": "https://www.geeksforgeeks.org/wildcard-pattern-matching/"
    },
    {
        "title": "DSA Tutorial - Learn Data Structures and Algorithms",
        "description": "DSA (Data Structures and Algorithms)  is the study of organizing data efficiently using data structures like arrays, stacks, and trees, paired with step-by-step procedures (or algorithms) to solve problems effectively. Data structures manage how data is stored and accessed, while algorithms focus on processing this data. Hoping you have learned a programming language of your choice, here comes the next stage of the roadmap - Learn about Time and Space Complexities. Once you have learned basics of a programming language, it is recommended that you learn basic logic building To analyze algorithms, we mainly measure order of growth of time or space taken in terms of input size.  We do this in the worst case scenario in most of the cases. Please refer the below links for a clear understanding of these concepts. Array is a linear data structure where elements are allocated contiguous memory, allowing for constant-time access. Searching algorithms are used to locate specific data within a large set of data. It helps find a target value within the data. There are various types of searching algorithms, each with its own approach and efficiency. Sorting algorithms are used to arrange the elements of a list in a specific order, such as numerical or alphabetical. It organizes the items in a systematic way, making it easier to search for and access specific elements. Hashing is a technique that generates a fixed-size output (hash value) from an input of variable size using mathematical formulas called hash functions. Hashing is commonly used in data structures for efficient searching, insertion and deletion. In Two Pointer Technique, we typically use two index variables from two corners of an array. We use the two pointer technique for searching a required point or value in an array. In Window Sliding Technique, we use the result of previous subarray to quickly compute the result of current. In Prefix Sum Technique, we compute prefix sums of an array to quickly find results for a subarray. String is a sequence of characters, typically immutable and have limited set of elements (lower case or all English alphabets). Recursion is a programming technique where a function calls itself within its own definition. It is usually used to solve problems that can be broken down into smaller instances of the same problem. Matrix is a two-dimensional array of elements, arranged in rows and columns. It is represented as a rectangular grid, with each element at the intersection of a row and column. Linked list is a linear data structure that stores data in nodes, which are connected by pointers. Unlike arrays, nodes of linked lists are not stored in contiguous memory locations and can only be accessed sequentially, starting from the head of list. Stack is a linear data structure that follows the Last In, First Out (LIFO) principle. Stacks play an important role in managing function calls, memory, and are widely used in algorithms like stock span problem, next greater element and largest area in a histogram. Queue is a linear data structure that follows the First In, First Out (FIFO) principle. Queues play an important role in managing tasks or data in order, scheduling and message handling systems. A deque (double-ended queue) is a data structure that allows elements to be added or removed from both ends efficiently. Tree is a non-linear, hierarchical data structure consisting of nodes connected by edges, with a top node called the root and nodes having child nodes. It is widely used in file systems, databases, decision-making algorithms, etc. Heap is a complete binary tree data structure that satisfies the heap property. Heaps are usually used to implement priority queues, where the smallest or largest element is always at the root of the tree. Graph is a non-linear data structure consisting of a finite set of vertices(or nodes) and a set of edges(or links)that connect a pair of nodes. Graphs are widely used to represent relationships between entities. Greedy Algorithm builds up the solution one piece at a time and chooses the next piece which gives the most obvious and immediate benefit i.e., which is the most optimal choice at that moment. So the problems where choosing locally optimal also leads to the global solutions are best fit for Greedy. Dynamic Programming is a method used to solve complex problems by breaking them down into simpler subproblems. By solving each subproblem only once and storing the results, it avoids redundant computations, leading to more efficient solutions for a wide range of problems. Bitwise Algorithms: Operate on individual bits of numbers. Backtracking Algorithm : Follow Recursion  with the option to revert and traces back if the solution from current point is not feasible. Divide and conquer:  A strategy to solve problems by dividing them into smaller subproblems, solving those subproblems, and combining the solutions to obtain the final solution. Branch and Bound : Used in combinatorial optimization problems to systematically search for the best solution. It works by dividing the problem into smaller subproblems, or branches, and then eliminating certain branches based on bounds on the optimal solution. This process continues until the best solution is found or all branches have been explored. Geometric algorithms are a set of algorithms that solve problems related to shapes, points, lines and polygons. Randomized algorithms are algorithms that use randomness to solve problems. They make use of random input to achieve their goals, often leading to simpler and more efficient solutions. These algorithms may not product same result but are particularly useful in situations when a probabilistic approach is acceptable. Advanced Data Structures like Trie, Segment Tree, Red-Black Tree and Binary Indexed Tree offer significant performance improvements for specific problem domains. They provide efficient solutions for tasks like fast prefix searches, range queries, dynamic updates, and maintaining balanced data structures, which are crucial for handling large datasets and real-time processing. By optimizing time complexity, they enable better scalability and faster execution in many computational problems. R  ",
        "code": "",
        "complexity": {
            "time": "Advanced Data Structures like Trie, Segment Tree, Red-Black Tree and Binary Indexed Tree offer significant performance improvements for specific problem domains. They provide efficient solutions for tasks like fast prefix searches, range queries, dynamic updates, and maintaining balanced data structures, which are crucial for handling large datasets and real-time processing. By optimizing time complexity, they enable better scalability and faster execution in many computational problems.",
            "space": ""
        },
        "tags": [
            "Bitwise Algorithms"
        ],
        "url": "https://www.geeksforgeeks.org/learn-data-structures-and-algorithms-dsa-tutorial/"
    },
    {
        "title": "No Title",
        "description": "",
        "code": "",
        "complexity": {
            "time": "",
            "space": ""
        },
        "tags": [
            "Bitwise Algorithms"
        ],
        "url": "https://www.geeksforgeeks.org/explore?page=1&category=Bit+Magic&sortBy=submissions"
    },
    {
        "title": "Top | MCQs on Bitwise Algorithms and Bit Manipulations with Answers | Question 16",
        "description": "Which bitwise operator is used to swap two numbers? Left Shift(<<) Right shift(>>) Bitwise OR | Bitwise XOR ^ This question is part of this quiz : ",
        "code": "",
        "complexity": {
            "time": "",
            "space": ""
        },
        "tags": [
            "Bitwise Algorithms"
        ],
        "url": "https://www.geeksforgeeks.org/top-mcqs-on-bitwise-algorithms-and-bit-manipulations-with-answers-question-16/"
    },
    {
        "title": "Introduction to Bitwise Algorithms – Data Structures and Algorithms Tutorial",
        "description": "Bit stands for binary digit. A bit is the basic unit of information and can only have one of two possible values that is 0 or 1. In our world, we usually with numbers using the decimal base. In other words. we use the digit 0 to 9 However, there are other number representations that can be quite useful such as the binary number systems. Introduction to Bitwise Algorithms – Data Structures and Algorithms Tutorial Unlike humans, computers have no concepts of words and numbers. They receive data encoded at the lowest level as a series of zeros and ones (0 and 1). These are called bits, and they are the basis for all the commands they receive. We’ll begin by learning about bits and then explore a few algorithms for manipulating bits. We’ll then explore a few algorithms for manipulating bits. The tutorial is meant to be an introduction to bit algorithms for programmers. Table of Content Bitwise algorithms refer to algorithms that perform operations on individual bits or bit patterns within computer data. These algorithms uses the binary representation of data and use the fundamental bitwise operations such as AND, OR, XOR, NOT, and bit shifting to manipulate and extract information from the data. Bitwise algorithms are usually faster and use less memory than regular arithmetic operations because they work directly with the binary representation of data. This often leads to faster execution times and reduced memory usage. An algorithmic operation known as bit manipulation involves the manipulation of bits at the bit level (bitwise). Bit manipulation is all about these bitwise operations. They improve the efficiency of programs by being primitive, fast actions. The computer uses this bit manipulation to perform operations like addition, subtraction, multiplication, and division are all done at the bit level. This operation is performed in the arithmetic logic unit (ALU) which is a part of a computer’s CPU. Inside the ALU, all such mathematical operations are performed. There are different bitwise operations used in bit manipulation. These bit operations operate on the individual bits of the bit patterns. Bit operations are fast and can be used in optimizing time complexity. The main bitwise operators are: Bitwise Operator Truth Table The bitwise AND operator is denoted using a single ampersand symbol, i.e. &. The & operator takes two equal-length bit patterns as parameters. The two-bit integers are compared. If the bits in the compared positions of the bit patterns are 1, then the resulting bit is 1. If not, it is 0. Truth table of AND operator Example: Take two bit values X and Y, where X = 7= (111)2 and Y = 4 = (100)2 . Take Bitwise and of both X & y Bitwise ANDof (7 & 4) The | Operator takes two equivalent length bit designs as boundaries; if the two bits in the looked-at position are 0, the next bit is zero. If not, it is 1.  Example: Take two bit values X and Y, where X = 7= (111)2 and Y = 4 = (100)2 . Take Bitwise OR of both X, y Bitwise OR of (7 | 4) Explanation: On the basis of truth table of bitwise OR operator we can conclude that the result of 1 | 1  = 11 | 0 = 10 | 1 = 10 | 0 = 0 We used the similar concept of bitwise operator that are show in the image. The ^ operator (also known as the XOR operator) stands for Exclusive Or. Here, if bits in the compared position do not match their resulting bit is 1. i.e, The result of the bitwise XOR operator is 1 if the corresponding bits of two operands are opposite, otherwise 0.  Example: Take two bit values X and Y, where X = 7= (111)2 and Y = 4 = (100)2 . Take Bitwise and of both X & y Bitwise OR of (7 ^ 4) Explanation: On the basis of truth table of bitwise XOR operator we can conclude that the result of 1 ^ 1  = 01 ^ 0 = 10 ^ 1 = 10 ^ 0 = 0 We used the similar concept of bitwise operator that are show in the image. All the above three bitwise operators are binary operators (i.e, requiring two operands in order to operate). Unlike other bitwise operators, this one requires only one operand to operate. The bitwise Not Operator takes a single value and returns its one’s complement. The one’s complement of a binary number is obtained by toggling all bits in it, i.e, transforming the 0 bit to 1 and the 1 bit to 0. Truth Table of Bitwise Operator NOT Example: Take two bit values X and Y, where X = 5= (101)2 . Take Bitwise NOT of X. Explanation: On the basis of truth table of bitwise NOT operator we can conclude that the result of ~1  = 0~0 = 1 We used the similar concept of bitwise operator that are show in the image. The left shift operator is denoted by the double left arrow key (<<). The general syntax for left shift is shift-expression << k. The left-shift operator causes the bits in shift expression to be shifted to the left by the number of positions specified by k. The bit positions that the shift operation has vacated are zero-filled. Note: Every time we shift a number towards the left by 1 bit it multiply that number by 2. Logical left Shift Example: Input: Left shift of 5 by 1.Binary representation of 5 = 00101 and Left shift of 001012 by 1 (i.e, 00101 << 1) Left shift of 5 by 1 Output: 10Explanation: All bit of 5 will be shifted by 1 to left side and this result in 010102, Which is equivalent to 10 Input: Left shift of 5 by 2.Binary representation of 5 = 00101 and Left shift of 001012 by 1 (i.e, 00101 << 2) Left shift of 5 by 2 Output: 20Explanation: All bit of 5 will be shifted by 1 to left side and this result in 101002, Which is equivalent to 20 Input: Left shift of 5 by 3.Binary representation of 5 = 00101 and Left shift of 001012 by 1 (i.e, 00101 << 3) Left shift of 5 by 3 Output: 40Explanation: All bit of 5 will be shifted by 1 to left side and this result in 010002, Which is equivalent to 40 The right shift operator is denoted by the double right arrow key (>>). The general syntax for the right shift is “shift-expression >> k”. The right-shift operator causes the bits in shift expression to be shifted to the right by the number of positions specified by k. For unsigned numbers, the bit positions that the shift operation has vacated are zero-filled. For signed numbers, the sign bit is used to fill the vacated bit positions. In other words, if the number is positive, 0 is used, and if the number is negative, 1 is used. Note: Every time we shift a number towards the right by 1 bit it divides that number by 2. Logical Right Shift Example: Input: Right shift of 5 by 1.Binary representation of 5 = 00101 and Right shift of 00101 by 1 (i.e, 00101 >> 1) Right shift of 5 by 1 Output: 2Explanation: All bit of 5 will be shifted by 1 to Rightside and this result in 00010 Which is equivalent to 2 Input: Right shift of 5 by 2.Binary representation of 5 = 00101 and Right shift of 00101 by 2 (i.e, 00101 >> 2) Right shift of 5 by 2 Output: 1Explanation: All bit of 5 will be shifted by 2 to Right side and this result in 00001, Which is equivalent to 1 Input: Right shift of 5 by 3.Binary representation of 5 = 00101 and Right shift of 00101 by 3 (i.e, 00101 >> 3) Right shift of 5 by 3 Output: 0Explanation: All bit of 5 will be shifted by 3 to Right side and this result in 00000, Which is equivalent to 0 If we want to set a bit at nth position in the number ‘num’, it can be done using the ‘OR’ operator( | ). Note: If the bit would be already set then it would remain unchanged. Below is the implementation: Suppose we want to unset a bit at nth position in number ‘num’ then we have to do this with the help of “AND” (&) operator. Below is the implementation: Toggling means to turn bit ‘on'(1) if it was ‘off'(0) and to turn ‘off'(0) if it was ‘on'(1) previously. We will be using the ‘XOR’ operator here which is this ‘^’. The reason behind the ‘XOR’ operator is because of its properties. Below is the implementation: Time Complexity: O(1) Auxiliary Space: O(1) We used the left shift (<<) operation on 1 to shift the bits to nth position and then use the & operation with number given number, and check if it is not-equals to 0. Below is the implementation: Below is the implementation: Below is the implementation: The  problem can be solved based on the following observations: Say x = n % 4. The XOR value depends on the value if x. If, x = 0, then the answer is n.   x = 1, then answer is 1.   x = 2, then answer is n+1.   x = 3, then answer is 0. Below is the implementation of the above approach. Time Complexity: O(1) Auxiliary Space: O(1) This can be solved based on the following fact: If a number N is a power of 2, then the bitwise AND of N and N-1 will be 0. But this will not work if N is 0. So just check these two conditions, if any of these two conditions is true. Below is the implementation of the above approach. Time Complexity: O(1) Auxiliary Space: O(1) Counting set bits means, counting total number of 1’s in the binary representation of an integer. For this problem we go through all the bits of given number and check whether it is set or not by performing AND operation (with 1). Below is the implementation: The idea is to unset the rightmost bit of number n and XOR the result with n. Then the rightmost set bit in n will be the position of the only set bit in the result. Note that if n is odd, we can directly return 1 as the first bit is always set for odd numbers. Example: The number 20 in binary is 00010100, and the position of the rightmost set bit is 3. 00010100    &               (n = 20)00010011                     (n-1 = 19)——————-00010000    ^                (XOR result number with n)00010100——————-00000100 ——->  rightmost set bit will tell us the position Below is the implementation:  ",
        "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n\n    int a = 7, b = 4;\n    int result = a & b;\n    cout << result << endl;\n\n    return 0;\n}\n/*package whatever //do not write package name here */\n\nimport java.io.*;\n\nclass GFG {\n    public static void main (String[] args) {\n        int a = 7, b = 4;\n          int result = a & b;\n          System.out.println(result);\n    }\n}\n\n// This code is contributed by lokeshmvs21.\na = 7\nb = 4\nresult = a & b\nprint(result)\n# This code is contributed by akashish__\nusing System;\n\npublic class GFG{\n\n    static public void Main (){\n      int a = 7, b = 4;\n      int result = a & b;\n      Console.WriteLine(result);\n    }\n}\n\n// This code is contributed by akashish__\nlet a = 7, b = 4;\nlet result = a & b;\nconsole.log(result);\n// This code is contributed by akashish__\n4\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n\n    int a = 12, b = 25;\n    int result = a | b;\n    cout << result;\n\n    return 0;\n}\nimport java.io.*;\n\nclass GFG {\n    public static void main(String[] args)\n    {\n        int a = 12, b = 25;\n        int result = a | b;\n        System.out.println(result);\n    }\n}\na = 12\nb = 25\nresult = a | b\nprint(result)\n\n# This code is contributed by garg28harsh.\nusing System;\n\npublic class GFG{\n\n    static public void Main (){\n        int a = 12, b = 25;\n        int result = a | b;\n        Console.WriteLine(result);\n    }\n}\n// This code is contributed by akashish__\nlet a = 12, b = 25;\n    let result = a | b;\n    document.write(result);\n      \n// This code is contributed by garg28harsh.\n29\n#include <iostream>\nusing namespace std;\n\nint main()\n{\n\n    int a = 12, b = 25;\n    cout << (a ^ b);\n    return 0;\n}\nimport java.io.*;\n\nclass GFG {\n    public static void main(String[] args)\n    {\n        int a = 12, b = 25;\n        int result = a ^ b;\n        System.out.println(result);\n    }\n}\n\n// This code is contributed by garg28harsh.\na = 12\nb = 25\nresult = a ^ b\nprint(result)\n\n# This code is contributed by garg28harsh.\n// C# Code\n\nusing System;\n\npublic class GFG {\n\n    static public void Main()\n    {\n\n        // Code\n        int a = 12, b = 25;\n        int result = a ^ b;\n        Console.WriteLine(result);\n    }\n}\n\n// This code is contributed by lokesh\nlet a = 12;\nlet b = 25;\nconsole.log((a ^ b));\n// This code is contributed by akashish__\n21\n#include <iostream>\nusing namespace std;\n\nint main()\n{\n\n    int a = 0;\n    cout << \"Value of a without using NOT operator: \" << a;\n    cout << \"\\nInverting using NOT operator (with sign bit): \" << (~a);\n    cout << \"\\nInverting using NOT operator (without sign bit): \" << (!a);\n\n    return 0;\n}\n/*package whatever //do not write package name here */\n\nimport java.io.*;\n\nclass GFG {\n  public static void main(String[] args)\n  {\n    int a = 0;\n    System.out.println(\n      \"Value of a without using NOT operator: \" + a);\n    System.out.println(\n      \"Inverting using NOT operator (with sign bit): \"\n      + (~a));\n    if (a != 1)\n      System.out.println(\n      \"Inverting using NOT operator (without sign bit): 1\");\n    else\n      System.out.println(\n      \"Inverting using NOT operator (without sign bit): 0\");\n  }\n}\n\n// This code is contributed by lokesh.\na = 0\nprint(\"Value of a without using NOT operator: \" , a)\nprint(\"Inverting using NOT operator (with sign bit): \" , (~a))\nprint(\"Inverting using NOT operator (without sign bit): \" , int(not(a)))\n#  This code is contributed by akashish__\nusing System;\n\npublic class GFG {\n\n  static public void Main()\n  {\n\n    int a = 0;\n    Console.WriteLine(\n      \"Value of a without using NOT operator: \" + a);\n    Console.WriteLine(\n      \"Inverting using NOT operator (with sign bit): \"\n      + (~a));\n    if (a != 1)\n      Console.WriteLine(\n      \"Inverting using NOT operator (without sign bit): 1\");\n    else\n      Console.WriteLine(\n      \"Inverting using NOT operator (without sign bit): 0\");\n  }\n}\n\n// This code is contributed by akashish__\nlet a =0;\n    document.write(\"Value of a without using NOT operator: \" + a);\n    document.write( \"Inverting using NOT operator (with sign bit): \" + (~a));\n    if(!a)\n    document.write( \"Inverting using NOT operator (without sign bit): 1\" );\n    else\n    document.write( \"Inverting using NOT operator (without sign bit): 0\" );\nValue of a without using NOT operator: 0\nInverting using NOT operator (with sign bit): -1\nInverting using NOT operator (without sign bit): 1\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n    unsigned int num1 = 1024;\n\n    bitset<32> bt1(num1);\n    cout << bt1 << endl;\n\n    unsigned int num2 = num1 << 1;\n    bitset<32> bt2(num2);\n    cout << bt2 << endl;\n\n    unsigned int num3 = num1 << 2;\n    bitset<16> bitset13{ num3 };\n    cout << bitset13 << endl;\n}\n/*package whatever //do not write package name here */\n\nimport java.io.*;\n\nclass GFG {\n  public static void main(String[] args)\n  {\n    int num1 = 1024;\n\n    String bt1 = Integer.toBinaryString(num1);\n    bt1 = String.format(\"%32s\", bt1).replace(' ', '0');\n    System.out.println(bt1);\n\n    int num2 = num1 << 1;\n    String bt2 = Integer.toBinaryString(num2);\n    bt2 = String.format(\"%32s\", bt2).replace(' ', '0');\n    System.out.println(bt2);\n\n    int num3 = num1 << 2;\n    String bitset13 = Integer.toBinaryString(num3);\n    bitset13 = String.format(\"%16s\", bitset13)\n      .replace(' ', '0');\n    System.out.println(bitset13);\n  }\n}\n\n// This code is contributed by akashish__\n# Python code for the above approach\n\nnum1 = 1024\n\nbt1 = bin(num1)[2:].zfill(32)\nprint(bt1)\n\nnum2 = num1 << 1\nbt2 = bin(num2)[2:].zfill(32)\nprint(bt2)\n\nnum3 = num1 << 2\nbitset13 = bin(num3)[2:].zfill(16)\nprint(bitset13)\n\n# This code is contributed by Prince Kumar\nusing System;\n\nclass GFG {\n  public static void Main(string[] args)\n  {\n    int num1 = 1024;\n\n    string bt1 = Convert.ToString(num1, 2);\n    bt1 = bt1.PadLeft(32, '0');\n    Console.WriteLine(bt1);\n\n    int num2 = num1 << 1;\n    string bt2 = Convert.ToString(num2, 2);\n    bt2 = bt2.PadLeft(32, '0');\n    Console.WriteLine(bt2);\n\n    int num3 = num1 << 2;\n    string bitset13 = Convert.ToString(num3, 2);\n    bitset13 = bitset13.PadLeft(16, '0');\n    Console.WriteLine(bitset13);\n  }\n}\n\n// This code is contributed by akashish__\n// JavaScript code for the above approach\n\nlet num1 = 1024;\n\nlet bt1 = num1.toString(2).padStart(32, '0');\nconsole.log(bt1);\n\nlet num2 = num1 << 1;\nlet bt2 = num2.toString(2).padStart(32, '0');\nconsole.log(bt2);\n\nlet num3 = num1 << 2;\nlet bitset13 = num3.toString(2).padStart(16, '0');\nconsole.log(bitset13);\n00000000000000000000010000000000\n00000000000000000000100000000000\n0001000000000000\n#include <bitset>\n#include <iostream>\n\nusing namespace std;\n\nint main()\n{\n    unsigned int num1 = 1024;\n\n    bitset<32> bt1(num1);\n    cout << bt1 << endl;\n\n    unsigned int num2 = num1 >> 1;\n    bitset<32> bt2(num2);\n    cout << bt2 << endl;\n\n    unsigned int num3 = num1 >> 2;\n    bitset<16> bitset13{ num3 };\n    cout << bitset13 << endl;\n}\n// JavaScript code for the above approach\n\nlet num1 = 1024;\n\nlet bt1 = num1.toString(2).padStart(32, '0');\nconsole.log(bt1);\n\nlet num2 = num1 >> 1;\nlet bt2 = num2.toString(2).padStart(32, '0');\nconsole.log(bt2);\n\nlet num3 = num1 >> 2;\nlet bitset13 = num3.toString(2).padStart(16, '0');\nconsole.log(bitset13);\n// akashish__\n00000000000000000000010000000000\n00000000000000000000001000000000\n0000000100000000\n#include <iostream>\nusing namespace std;\n// num is the number and pos is the position\n// at which we want to set the bit.\nvoid set(int& num, int pos)\n{\n    // First step is shift '1', second\n    // step is bitwise OR\n    num |= (1 << pos);\n}\nint main()\n{\n    int num = 4, pos = 1;\n    set(num, pos);\n    cout << (int)(num) << endl;\n    return 0;\n}\n/*package whatever //do not write package name here */\n\nimport java.io.*;\n\nclass GFG {\n    public static void main(String[] args)\n    {\n        int num = 4, pos = 1;\n        num = set(num, pos);\n        System.out.println(num);\n    }\n    public static int set(int num, int pos)\n    {\n        // First step is shift '1', second\n        // step is bitwise OR\n        num |= (1 << pos);\n        return num;\n    }\n}\n\n// This code is contributed by geeky01adash.\n# num = number, pos = position at which we want to set the bit\ndef set(num, pos):\n    # First step = Shift '1'\n    # Second step = Bitwise OR\n    num |= (1 << pos)\n    print(num)\n\n\nnum, pos = 4, 1\n\nset(num, pos)\n\n# This code is contributed by sarajadhav12052009\nusing System;\n\npublic class GFG {\n\n    static public void Main()\n    {\n        int num = 4, pos = 1;\n        set(num, pos);\n    }\n\n    // num = number, pos = position at which we want to set\n    // the bit\n    static public void set(int num, int pos)\n    {\n        // First Step: Shift '1'\n        // Second Step: Bitwise OR\n        num |= (1 << pos);\n        Console.WriteLine(num);\n    }\n}\n\n// This code is contributed by sarajadhav12052009\n<script>\n// num is the number and pos is the position \n// at which we want to set the bit.\nfunction set(num,pos)\n{\n     // First step is shift '1', second\n     // step is bitwise OR\n     num |= (1 << pos);\n     console.log(parseInt(num));\n}\n\nlet num = 4;\nlet pos = 1;\nset(num, pos);\n\n// This code is contributed by akashish__\n\n</script>\n6\n#include <iostream>\nusing namespace std;\n// First step is to get a number that  has all 1's except\n// the given position.\nvoid unset(int& num, int pos)\n{\n    // Second step is to bitwise and this  number with given\n    // number\n    num &= (~(1 << pos));\n}\nint main()\n{\n    int num = 7;\n    int pos = 1;\n    unset(num, pos);\n    cout << num << endl;\n    return 0;\n}\n/*package whatever //do not write package name here */\n\nimport java.io.*;\n\nclass GFG {\n    public static void main(String[] args)\n    {\n        int num = 7, pos = 1;\n        num = unset(num, pos);\n        System.out.println(num);\n    }\n    public static int unset(int num, int pos)\n    {\n        // Second step is to bitwise and this  number with\n        // given number\n        num = num & (~(1 << pos));\n        return num;\n    }\n}\n# First Step: Getting which have all '1's except the\n# given position\n\n\ndef unset(num, pos):\n    # Second Step: Bitwise AND this number with the given number\n    num &= (~(1 << pos))\n    print(num)\n\n\nnum, pos = 7, 1\n\nunset(num, pos)\nusing System;\n\npublic class GFG {\n\n    static public void Main()\n    {\n        // First Step: Getting a number which have all '1's\n        // except the given position\n        int num = 7, pos = 1;\n        unset(num, pos);\n    }\n    static public void unset(int num, int pos)\n    {\n        // Second Step: Bitwise AND this number with the\n        // given number\n        num &= (~(1 << pos));\n        Console.WriteLine(num);\n    }\n}\n// First step is to get a number that  has all 1's except\n// the given position.\nfunction unset(num, pos)\n{\n    // Second step is to bitwise and this  number with given\n    // number\n    return num &= (~(1 << pos));\n}\n\nlet num = 7;\nlet pos = 1;\nconsole.log(unset(num, pos));\n\n// contributed by akashish__\n5\n#include <iostream>\nusing namespace std;\n// First step is to shift 1,Second step is to XOR with given\n// number\nvoid toggle(int& num, int pos) { num ^= (1 << pos); }\nint main()\n{\n    int num = 4;\n    int pos = 1;\n    toggle(num, pos);\n    cout << num << endl;\n    return 0;\n}\n/*package whatever //do not write package name here */\n\nimport java.io.*;\n\nclass GFG {\n    public static void main(String[] args)\n    {\n        int num = 4, pos = 1;\n        num = toggle(num, pos);\n        System.out.println(num);\n    }\n    public static int toggle(int num, int pos)\n    {\n        // First step is to shift 1,Second step is to XOR\n        // with given number\n        num ^= (1 << pos);\n        return num;\n    }\n}\n\n// This code is contributed by geeky01adash.\ndef toggle(num, pos):\n    # First Step: Shifts '1'\n    # Second Step: XOR num\n    num ^= (1 << pos)\n    print(num)\n\n\nnum, pos = 4, 1\n\ntoggle(num, pos)\n\n# This code is contributed by sarajadhav12052009\nusing System;\n\npublic class GFG {\n\n    static public void Main()\n    {\n        int num = 4, pos = 1;\n        toggle(num, pos);\n    }\n    static public void toggle(int num, int pos)\n    {\n        // First Step: Shift '1'\n        // Second Step: XOR num\n        num ^= (1 << pos);\n        Console.WriteLine(num);\n    }\n}\n\n// This code is contributed by sarajadhav12052009\n// First step is to shift 1,Second step is to XOR with given\n// number\nfunction toggle(num, pos){\n    // First Step: Shifts '1'\n    // Second Step: XOR num\n    num ^= (1 << pos)\n    console.log(num)\n}\n\nlet num = 4;\nlet pos = 1;\ntoggle(num, pos);\n// contributed by akashish__\n6\n#include <iostream>\nusing namespace std;\n\nbool at_position(int num, int pos)\n{\n    bool bit = num & (1 << pos);\n    return bit;\n}\n\nint main()\n{\n    int num = 5;\n    int pos = 2;\n    bool bit = at_position(num, pos);\n    cout << bit << endl;\n    return 0;\n}\n/*package whatever //do not write package name here */\n\nimport java.io.*;\n\nclass GFG {\n    public static void main(String[] args)\n    {\n        int num = 5;\n        int pos = 0;\n        int bit = at_position(num, pos);\n        System.out.println(bit);\n    }\n    public static int at_position(int num, int pos)\n    {\n        int bit = num & (1 << pos);\n        return bit;\n    }\n}\n# code\ndef at_position(num, pos):\n    bit = num & (1 << pos)\n    return bit\n\n\nnum = 5\npos = 0\nbit = at_position(num, pos)\nprint(bit)\nusing System;\n\npublic class GFG {\n\n  public static bool at_position(int num, int pos)\n  {\n    int bit = num & (1 << pos);\n    if (bit == 0)\n      return false;\n    return true;\n  }\n\n  static public void Main()\n  {\n    int num = 5;\n    int pos = 2;\n    bool bit = at_position(num, pos);\n    Console.WriteLine(bit);\n  }\n}\n\n// This code is contributed by akashish__\n<script>\nfunction at_position(num,pos)\n{\n return num & (1<<pos);\n}\nlet num = 5;\nlet pos = 0;\nconsole.log(at_position(num, pos));\n// contributed by akashish__\n</script>\n1\n#include <iostream>\nusing namespace std;\nint main()\n{\n    int num = 12;\n    int ans = num << 1;\n    cout << ans << endl;\n    return 0;\n}\n/*package whatever //do not write package name here */\n\nimport java.io.*;\n\nclass GFG {\n    public static void main(String[] args)\n    {\n        int num = 12;\n        int ans = num << 1;\n        System.out.println(ans);\n    }\n}\n\n// This code is contributed by geeky01adash.\n# Python program for the above approach\n\nnum = 12\nans = num << 1\nprint(ans)\n\n# This code is contributed by Shubham Singh\nusing System;\n\npublic class GFG {\n\n    static public void Main()\n    {\n        int num = 12;\n        Console.WriteLine(num << 1);\n    }\n}\n\n// This code is contributed by sarajadhav12052009\n<script>\n// Javascript program for the above approach\n\nvar num = 12;\nvar ans = num<<1;\ndocument.write(ans);\n\n//This code is contributed by Shubham Singh\n</script>\n24\n#include <iostream>\nusing namespace std;\nint main()\n{\n    int num = 12;\n    int ans = num >> 1;\n    cout << ans << endl;\n    return 0;\n}\n/*package whatever //do not write package name here */\n\nimport java.io.*;\n\nclass GFG {\n    public static void main(String[] args)\n    {\n        int num = 12;\n        int ans = num >> 1;\n        System.out.println(ans);\n    }\n}\n\n// This code is contributed by geeky01adash.\n# Python program for the above approach\n\nnum = 12\nans = num >> 1\nprint(ans)\n\n# This code is contributed by Shubham Singh\nusing System;\n\npublic class GFG {\n\n    static public void Main()\n    {\n        int num = 12;\n        Console.WriteLine(num >> 1);\n    }\n}\n\n// This code is contributed by sarajadhav12052009\n<script>\n// Javascript program for the above approach\n\nvar num = 12;\nvar ans = num>>1;\ndocument.write(ans);\n\n//This code is contributed by Shubham Singh\n</script>\n6\n// Direct XOR of all numbers from 1 to n\nint computeXOR(int n)\n{\n    if (n % 4 == 0)\n        return n;\n    if (n % 4 == 1)\n        return 1;\n    if (n % 4 == 2)\n        return n + 1;\n    else\n        return 0;\n}\n/*package whatever //do not write package name here */\nimport java.io.*;\n\nclass GFG {\n\n    // Direct XOR of all numbers from 1 to n\n    public static int computeXOR(int n)\n    {\n        if (n % 4 == 0)\n            return n;\n        if (n % 4 == 1)\n            return 1;\n        if (n % 4 == 2)\n            return n + 1;\n        else\n            return 0;\n    }\n\n    public static void main(String[] args) {}\n}\n\n// This code is contributed by akashish__\n# num = number, pos = position at which we want to set the bit\ndef set(num, pos):\n\n    # First step = Shift '1'\n    # Second step = Bitwise OR\nnum |= (1 << pos)\nprint(num)\n\nnum, pos = 4, 1\n\nset(num, pos)\n\n# This code is contributed by sarajadhav12052009\nusing System;\npublic class GFG {\n\n    // Direct XOR of all numbers from 1 to n\n    public static int computeXOR(int n)\n    {\n\n        if (n % 4 == 0)\n\n            return n;\n\n        if (n % 4 == 1)\n\n            return 1;\n\n        if (n % 4 == 2)\n\n            return n + 1;\n\n        else\n\n            return 0;\n    }\n    public static void Main() {}\n}\n\n// This code is contributed by akashish__\n<script>\n\n// Direct XOR of all numbers from 1 to n\nfunction computeXOR(n)\n{\n    if (n % 4 == 0)\n        return n;\n    if (n % 4 == 1)\n        return 1;\n    if (n % 4 == 2)\n        return n + 1;\n    else\n        return 0;\n}\n\n// This code is contributed by Shubham Singh\n\n</script>\n// Function to check if x is power of 2\nbool isPowerOfTwo(int x)\n{\n    // First x in the below expression is\n    // for the case when x is 0\n    return x && (!(x & (x - 1)));\n}\n// Function to check if x is power of 2\npublic static boolean isPowerOfTwo(int x)\n{\n    // First x in the below expression is\n    // for the case when x is 0\n    return x != 0 && ((x & (x - 1)) == 0);\n}\n# Function to check if x is power of 2\ndef isPowerOfTwo(x):\n\n\n    # First x in the below expression is\n    # for the case when x is 0\nreturn x and (not(x & (x - 1)))\n\n# This code is contributed by akashish__\nusing System;\n\npublic class GFG {\n\n    // Function to check if x is power of 2\n    static public bool isPowerOfTwo(int x)\n    {\n        // First x in the below expression is\n        // for the case when x is 0\n        return (x != 0) && ((x & (x - 1)) == 0);\n    }\n\n    static public void Main() {}\n}\n\n// This code is contributed by akashish__\n// Function to check if x is power of 2\nfunction isPowerOfTwo(x)\n{\n    // First x in the below expression is\n    // for the case when x is 0\n    return x && (!(x & (x - 1)));\n}\n// contributed by akashish__\n// Function to calculate the number of set bits.\nint countBits(int n)\n{\n    // Initialising a variable count to 0.\n    int count = 0;\n    while (n) {\n        // If the last bit is 1, count will be incremented\n        // by 1 in this step.\n        count += n & 1;\n\n        // Using the right shift operator.\n        // The bits will be shifted one position to the\n        // right.\n        n >>= 1;\n    }\n    return count;\n}\n// Function to calculate the number of set bits.\npublic static int countBits(int n)\n{\n    // Initialising a variable count to 0.\n    int count = 0;\n    while (n > 0) {\n        // If the last bit is 1, count will be incremented\n        // by 1 in this step.\n        count += n & 1;\n\n        // Using the right shift operator.\n        // The bits will be shifted one position to the\n        // right.\n        n >>= 1;\n    }\n    return count;\n}\ndef countBits(n):\n    # Initializing a variable count to 0\n    count = 0\n    while n:\n        # If the last bit is 1, count will be incremented by 1 in this step.\n        count += n & 1\n        # Using the right shift operator. The bits will be shifted one position to the right.\n        n >>= 1\n    return count\nusing System;\n\npublic class GFG {\n\n  // Function to calculate the number of set bits.\n  public static int countBits(int n)\n  {\n\n    // Initialising a variable count to 0.\n    int count = 0;\n    while (n > 0)\n    {\n\n      // If the last bit is 1, count will be\n      // incremented by 1 in this step.\n      count += n & 1;\n\n      // Using the right shift operator.\n      // The bits will be shifted one position to the\n      // right.\n      n >>= 1;\n    }\n    return count;\n  }\n\n  static public void Main() {}\n}\n\n// This code is contributed by akashish__\n// Function to calculate the number of set bits.\nfunction countBits(n)\n{\n    // Initialising a variable count to 0.\n    let count = 0;\n    while (n) {\n        // If the last bit is 1, count will be incremented\n        // by 1 in this step.\n        count += n & 1;\n\n        // Using the right shift operator.\n        // The bits will be shifted one position to the\n        // right.\n        n >>= 1;\n    }\n    return count;\n}\n// Returns the position of the rightmost set bit of `n`\nint positionOfRightmostSetBit(int n)\n{\n    // if the number is odd, return 1\n    if (n & 1) {\n        return 1;\n    }\n\n    // unset rightmost bit and xor with the number itself\n    n = n ^ (n & (n - 1));\n\n    // find the position of the only set bit in the result;\n    // we can directly return `log2(n) + 1` from the\n    // function\n    int pos = 0;\n    while (n) {\n        n = n >> 1;\n        pos++;\n    }\n    return pos;\n}\n// Returns the position of the rightmost set bit of `n`\npublic static int positionOfRightmostSetBit(int n)\n{\n    // if the number is odd, return 1\n    if ((n & 1) != 0) {\n        return 1;\n    }\n\n    // unset rightmost bit and xor with the number itself\n    n = n ^ (n & (n - 1));\n\n    // find the position of the only set bit in the result;\n    // we can directly return `log2(n) + 1` from the\n    // function\n    int pos = 0;\n    while (n != 0) {\n        n = n >> 1;\n        pos++;\n    }\n\n    return pos;\n}\n# Returns the position of the rightmost set bit of `n`\n\n\ndef positionOfRightmostSetBit(n):\n  # if the number is odd, return 1\n    if n & 1:\n        return 1\n\n    # unset rightmost bit and xor with the number itself\n    n = n ^ (n & (n - 1))\n\n    # find the position of the only set bit in the result;\n    # we can directly return `log2(n) + 1` from the function\n    pos = 0\n    while n:\n        n = n >> 1\n        pos = pos + 1\n\n    return pos\n// Returns the position of the rightmost set bit of `n`\npublic static int positionOfRightmostSetBit(int n)\n{\n    // if the number is odd, return 1\n    if ((n & 1) != 0) {\n        return 1;\n    }\n\n    // unset rightmost bit and xor with the number itself\n    n = n ^ (n & (n - 1));\n\n    // find the position of the only set bit in the result;\n    // we can directly return `log2(n) + 1` from the\n    // function\n    int pos = 0;\n    while (n != 0) {\n        n = n >> 1;\n        pos++;\n    }\n\n    return pos;\n}\n// Returns the position of the rightmost set bit of `n`\nfunction positionOfRightmostSetBit( n)\n{\n    // if the number is odd, return 1\n    if (n & 1) {\n        return 1;\n    }\n\n    // unset rightmost bit and xor with the number itself\n    n = n ^ (n & (n - 1));\n\n    // find the position of the only set bit in the result;\n    // we can directly return `log2(n) + 1` from the\n    // function\n    let pos = 0;\n    while (n) {\n        n = n >> 1;\n        pos++;\n    }\n    return pos;\n}\n",
        "complexity": {
            "time": "Time Complexity: O(1) Auxiliary Space: O(1)",
            "space": ""
        },
        "tags": [
            "Bitwise Algorithms"
        ],
        "url": "https://www.geeksforgeeks.org/introduction-to-bitwise-algorithms-data-structures-and-algorithms-tutorial/"
    },
    {
        "title": "Binary representation of a given number",
        "description": "Given an integer n, the task is to print the binary representation of the number. Note: The given number will be maximum of 32 bits, so append 0’s to the left if the result string is smaller than 30 length. Examples: Input: n = 2Output: 00000000000000000000000000000010 Input: n = 0Output: 00000000000000000000000000000000 The idea is to check each bit position of the number from left to right (most significant bit to least significant bit). For each bit position, we use the bitwise AND operation with a mask created by left-shifting 1 to that position (1<<i). If the result is non-zero, it means that bit is set to 1 in the original number, so we append ‘1’ to our answer string; otherwise, we append ‘0’. The idea is to build a 32-bit binary representation by examining each bit of the number from right to left. We start by creating a string of 32 zeros, then iterate through all 32 bit positions. For each position, we check if the current rightmost bit is set (using n%2), and if so, we place a ‘1’ at the appropriate position in our string. After checking each bit, we right-shift the number (using integer division by 2) to examine the next bit in the subsequent iteration. The expression n%2 (n modulo 2) reveals the rightmost bit because any binary number ends with either 0 or 1. If the number is odd, it ends with 1 and n%2 equals 1; if it’s even, it ends with 0 and n%2 equals 0. Meanwhile, the integer division n/2 effectively performs a right shift operation in binary. When we divide by 2, we’re removing the rightmost bit and shifting all other bits one position to the right. For example, 10 (binary 1010) divided by 2 gives 5 (binary 101), effectively shifting all bits right by one position.  ",
        "code": "// C++ program to find binary \n// representation of a given number\n#include <iostream>\nusing namespace std;\n\nstring getBinaryRep(int n) {\n\n    string ans = \"\";\n    \n    // Check for each bit.\n    for (int i=31; i>=0; i--) {\n        \n        // If i'th bit is set \n        if (n&(1<<i)) ans += '1';\n        else ans += '0';\n    }\n    \n    return ans;\n}\n\nint main() {\n    int n = 2;\n    cout << getBinaryRep(n);\n\n    return 0;\n}\n// Java program to find binary \n// representation of a given number\n\nclass GfG {\n    \n    static String getBinaryRep(int n) {\n\n        String ans = \"\";\n        \n        // Check for each bit.\n        for (int i = 31; i >= 0; i--) {\n            \n            // If i'th bit is set \n            if ((n & (1 << i)) != 0) ans += '1';\n            else ans += '0';\n        }\n        \n        return ans;\n    }\n    \n    public static void main(String[] args) {\n        int n = 2;\n        System.out.println(getBinaryRep(n));\n    }\n}\n# Python program to find binary \n# representation of a given number\n\ndef getBinaryRep(n):\n    ans = \"\"\n    \n    # Check for each bit.\n    for i in range(31, -1, -1):\n        \n        # If i'th bit is set \n        if (n & (1 << i)):\n            ans += '1'\n        else:\n            ans += '0'\n    \n    return ans\n\nif __name__ == \"__main__\":\n    n = 2\n    print(getBinaryRep(n))\n// C# program to find binary \n// representation of a given number\n\nusing System;\n\nclass GfG {\n    \n    static string getBinaryRep(int n) {\n\n        string ans = \"\";\n        \n        // Check for each bit.\n        for (int i = 31; i >= 0; i--) {\n            \n            // If i'th bit is set \n            if ((n & (1 << i)) != 0) ans += '1';\n            else ans += '0';\n        }\n        \n        return ans;\n    }\n    \n    static void Main() {\n        int n = 2;\n        Console.WriteLine(getBinaryRep(n));\n    }\n}\n// JavaScript program to find binary \n// representation of a given number\n\nfunction getBinaryRep(n) {\n\n    let ans = \"\";\n    \n    // Check for each bit.\n    for (let i = 31; i >= 0; i--) {\n        \n        // If i'th bit is set \n        if ((n & (1 << i)) !== 0) ans += '1';\n        else ans += '0';\n    }\n    \n    return ans;\n}\n\nlet n = 2;\nconsole.log(getBinaryRep(n));\n00000000000000000000000000000010\n// C++ program to find binary \n// representation of a given number\n#include <iostream>\nusing namespace std;\n\nstring getBinaryRep(int n) {\n\n    // Create a 32 length string \n    // of 0's \n    string ans = \"\";\n    for (int i=0; i<32; i++) ans += '0';\n    \n    for (int i=0; i<32; i++) {\n        \n        // Set 1 f rightmost bit is set \n        if (n%2 == 1) ans[31 - i] = '1';\n        \n        // Right shift bits using divison \n        // operator \n        n = n / 2;\n    }\n    \n    return ans;\n}\n\nint main() {\n    int n = 2;\n    cout << getBinaryRep(n);\n\n    return 0;\n}\n// Java program to find binary \n// representation of a given number\nclass GfG {\n\n    static String getBinaryRep(int n) {\n\n        // Create a 32 length char array \n        // of '0's \n        char[] ans = new char[32];\n        for (int i = 0; i < 32; i++) ans[i] = '0';\n\n        for (int i = 0; i < 32; i++) {\n            \n            // Set 1 if rightmost bit is set \n            if (n % 2 == 1) ans[31 - i] = '1';\n            \n            // Right shift bits using division \n            // operator \n            n = n / 2;\n        }\n\n        return new String(ans);\n    }\n\n    public static void main(String[] args) {\n        int n = 2;\n        System.out.println(getBinaryRep(n));\n    }\n}\n# Python program to find binary \n# representation of a given number\n\ndef getBinaryRep(n):\n\n    # Create a 32 length string \n    # of 0's \n    ans = ['0'] * 32\n    \n    for i in range(32):\n        \n        # Set 1 if rightmost bit is set \n        if n % 2 == 1:\n            ans[31 - i] = '1'\n        \n        # Right shift bits using division \n        # operator \n        n = n // 2\n    \n    return \"\".join(ans)\n\nif __name__ == \"__main__\":\n    n = 2\n    print(getBinaryRep(n))\n// C# program to find binary \n// representation of a given number\n\nusing System;\n\nclass GfG {\n    \n    static string getBinaryRep(int n) {\n\n        // Create a 32 length string \n        // of 0's \n        char[] ans = new char[32];\n        for (int i = 0; i < 32; i++) ans[i] = '0';\n        \n        for (int i = 0; i < 32; i++) {\n            \n            // Set 1 if rightmost bit is set \n            if (n % 2 == 1) ans[31 - i] = '1';\n            \n            // Right shift bits using division \n            // operator \n            n = n / 2;\n        }\n        \n        return new string(ans);\n    }\n    \n    static void Main() {\n        int n = 2;\n        Console.WriteLine(getBinaryRep(n));\n    }\n}\n// JavaScript program to find binary \n// representation of a given number\n\nfunction getBinaryRep(n) {\n\n    // Create a 32 length string \n    // of 0's \n    let ans = Array(32).fill('0');\n    \n    for (let i = 0; i < 32; i++) {\n        \n        // Set 1 if rightmost bit is set \n        if (n % 2 === 1) ans[31 - i] = '1';\n        \n        // Right shift bits using division \n        // operator \n        n = Math.floor(n / 2);\n    }\n    \n    return ans.join('');\n}\n\nlet n = 2;\nconsole.log(getBinaryRep(n));\n00000000000000000000000000000010\n",
        "complexity": {
            "time": "",
            "space": ""
        },
        "tags": [
            "Bitwise Algorithms"
        ],
        "url": "https://www.geeksforgeeks.org/binary-representation-of-a-given-number/"
    },
    {
        "title": "Complete Reference for Bitwise Operators in Programming/Coding",
        "description": "There exists no programming language that doesn't use Bit Manipulations. Bit manipulation is all about these bitwise operations. They improve the efficiency of programs by being primitive, fast actions. There are different bitwise operations used in bit manipulation. These Bitwise Operators operate on the individual bits of the bit patterns. Bit operations are fast and can be used in optimizing time complexity. Table of Content  Some common bit operators are: The bitwise AND operator is denoted using a single ampersand symbol, i.e. &. The & operator takes two equal-length bit patterns as parameters. The two-bit integers are compared. If the bits in the compared positions of the bit patterns are 1, then the resulting bit is 1. If not, it is 0. Example: Take two bit values X and Y, where X = 7= (111)2 and Y = 4 = (100)2 . Take Bitwise and of both X & y Time Complexity: O(1) Auxiliary Space: O(1) The | Operator takes two equivalent length bit designs as boundaries; if the two bits in the looked-at position are 0, the next bit is zero. If not, it is 1.  Example: Take two bit values X and Y, where X = 7= (111)2 and Y = 4 = (100)2 . Take Bitwise OR of both X, y Explanation: On the basis of truth table of bitwise OR operator we can conclude that the result of 1 | 1  = 11 | 0 = 10 | 1 = 10 | 0 = 0 We used the similar concept of bitwise operator that are show in the image. Time Complexity: O(1) Auxiliary Space: O(1) The ^ operator (also known as the XOR operator) stands for Exclusive Or. Here, if bits in the compared position do not match their resulting bit is 1. i.e, The result of the bitwise XOR operator is 1 if the corresponding bits of two operands are opposite, otherwise 0.  Example: Take two bit values X and Y, where X = 7= (111)2 and Y = 4 = (100)2 . Take Bitwise and of both X & y Explanation: On the basis of truth table of bitwise XOR operator we can conclude that the result of 1 ^ 1  = 01 ^ 0 = 10 ^ 1 = 10 ^ 0 = 0 We used the similar concept of bitwise operator that are show in the image. Time Complexity: O(1) Auxiliary Space: O(1) All the above three bitwise operators are binary operators (i.e, requiring two operands in order to operate). Unlike other bitwise operators, this one requires only one operand to operate. The bitwise Not Operator takes a single value and returns its one’s complement. The one’s complement of a binary number is obtained by toggling all bits in it, i.e, transforming the 0 bit to 1 and the 1 bit to 0. Example: Take two bit values X and Y, where X = 5= (101)2 . Take Bitwise NOT of X. Explanation: On the basis of truth table of bitwise NOT operator we can conclude that the result of ~1  = 0~0 = 1 We used the similar concept of bitwise operator that are show in the image. Implementation of NOT operator: Time Complexity: O(1) Auxiliary Space: O(1) The left shift operator is denoted by the double left arrow key (<<). The general syntax for left shift is shift-expression << k. The left-shift operator causes the bits in shift expression to be shifted to the left by the number of positions specified by k. The bit positions that the shift operation has vacated are zero-filled. Note: Every time we shift a number towards the left by 1 bit it multiply that number by 2. Example: Input: Left shift of 5 by 1.Binary representation of 5 = 00101 and Left shift of 001012 by 1 (i.e, 00101 << 1) Output: 10Explanation: All bit of 5 will be shifted by 1 to left side and this result in 010102, Which is equivalent to 10 Input: Left shift of 5 by 2.Binary representation of 5 = 00101 and Left shift of 001012 by 1 (i.e, 00101 << 2) Output: 20Explanation: All bit of 5 will be shifted by 1 to left side and this result in 101002, Which is equivalent to 20 Input: Left shift of 5 by 3.Binary representation of 5 = 00101 and Left shift of 001012 by 1 (i.e, 00101 << 3) Output: 40Explanation: All bit of 5 will be shifted by 1 to left side and this result in 010002, Which is equivalent to 40 Implementation of Left shift operator: Time Complexity: O(1) Auxiliary Space: O(1) The right shift operator is denoted by the double right arrow key (>>). The general syntax for the right shift is \"shift-expression >> k\". The right-shift operator causes the bits in shift expression to be shifted to the right by the number of positions specified by k. For unsigned numbers, the bit positions that the shift operation has vacated are zero-filled. For signed numbers, the sign bit is used to fill the vacated bit positions. In other words, if the number is positive, 0 is used, and if the number is negative, 1 is used. Note: Every time we shift a number towards the right by 1 bit it divides that number by 2. Example: Input: Left shift of 5 by 1.Binary representation of 5 = 00101 and Left shift of 001012 by 1 (i.e, 00101 << 1) Output: 10Explanation: All bit of 5 will be shifted by 1 to left side and this result in 010102, Which is equivalent to 10 Input: Left shift of 5 by 2.Binary representation of 5 = 00101 and Left shift of 001012 by 1 (i.e, 00101 << 2) Output: 20Explanation: All bit of 5 will be shifted by 1 to left side and this result in 101002, Which is equivalent to 20 Input: Left shift of 5 by 3.Binary representation of 5 = 00101 and Left shift of 001012 by 1 (i.e, 00101 << 3) Output: 40Explanation: All bit of 5 will be shifted by 1 to left side and this result in 010002, Which is equivalent to 40 Implementation of Right shift operator: Time Complexity: O(1) Auxiliary Space: O(1)  ",
        "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n\n    int a = 7, b = 4;\n    int result = a & b;\n    cout << result << endl;\n\n    return 0;\n}\n/*package whatever //do not write package name here */\n\nimport java.io.*;\n\nclass GFG {\n    public static void main (String[] args) {\n        int a = 7, b = 4;\n          int result = a & b;\n          System.out.println(result);\n    }\n}\n\n// This code is contributed by lokeshmvs21.\na = 7\nb = 4\nresult = a & b\nprint(result)\n# This code is contributed by akashish__\nusing System;\n\npublic class GFG{\n\n    static public void Main (){\n      int a = 7, b = 4;\n      int result = a & b;\n      Console.WriteLine(result);\n    }\n}\n\n// This code is contributed by akashish__\nlet a = 7, b = 4;\nlet result = a & b;\nconsole.log(result);\n// This code is contributed by akashish__\n4\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n\n    int a = 12, b = 25;\n    int result = a | b;\n    cout << result;\n\n    return 0;\n}\nimport java.io.*;\n\nclass GFG {\n    public static void main(String[] args)\n    {\n        int a = 12, b = 25;\n        int result = a | b;\n        System.out.println(result);\n    }\n}\na = 12\nb = 25\nresult = a | b\nprint(result)\n\n# This code is contributed by garg28harsh.\nusing System;\n\npublic class GFG{\n\n    static public void Main (){\n        int a = 12, b = 25;\n        int result = a | b;\n        Console.WriteLine(result);\n    }\n}\n// This code is contributed by akashish__\nlet a = 12, b = 25;\n    let result = a | b;\n    document.write(result);\n      \n// This code is contributed by garg28harsh.\n29\n#include <iostream>\nusing namespace std;\n\nint main()\n{\n\n    int a = 12, b = 25;\n    cout << (a ^ b);\n    return 0;\n}\nimport java.io.*;\n\nclass GFG {\n    public static void main(String[] args)\n    {\n        int a = 12, b = 25;\n        int result = a ^ b;\n        System.out.println(result);\n    }\n}\n\n// This code is contributed by garg28harsh.\na = 12\nb = 25\nresult = a ^ b\nprint(result)\n\n# This code is contributed by garg28harsh.\n// C# Code\n\nusing System;\n\npublic class GFG {\n\n    static public void Main()\n    {\n\n        // Code\n        int a = 12, b = 25;\n        int result = a ^ b;\n        Console.WriteLine(result);\n    }\n}\n\n// This code is contributed by lokesh\nlet a = 12;\nlet b = 25;\nconsole.log((a ^ b));\n// This code is contributed by akashish__\n21\n#include <iostream>\nusing namespace std;\n\nint main()\n{\n\n    int a = 0;\n    cout << \"Value of a without using NOT operator: \" << a;\n    cout << \"\\nInverting using NOT operator (with sign bit): \" << (~a);\n    cout << \"\\nInverting using NOT operator (without sign bit): \" << (!a);\n\n    return 0;\n}\n/*package whatever //do not write package name here */\n\nimport java.io.*;\n\nclass GFG {\n  public static void main(String[] args)\n  {\n    int a = 0;\n    System.out.println(\n      \"Value of a without using NOT operator: \" + a);\n    System.out.println(\n      \"Inverting using NOT operator (with sign bit): \"\n      + (~a));\n    if (a != 1)\n      System.out.println(\n      \"Inverting using NOT operator (without sign bit): 1\");\n    else\n      System.out.println(\n      \"Inverting using NOT operator (without sign bit): 0\");\n  }\n}\n\n// This code is contributed by lokesh.\na = 0\nprint(\"Value of a without using NOT operator: \" , a)\nprint(\"Inverting using NOT operator (with sign bit): \" , (~a))\nprint(\"Inverting using NOT operator (without sign bit): \" , int(not(a)))\n#  This code is contributed by akashish__\nusing System;\n\npublic class GFG {\n\n  static public void Main()\n  {\n\n    int a = 0;\n    Console.WriteLine(\n      \"Value of a without using NOT operator: \" + a);\n    Console.WriteLine(\n      \"Inverting using NOT operator (with sign bit): \"\n      + (~a));\n    if (a != 1)\n      Console.WriteLine(\n      \"Inverting using NOT operator (without sign bit): 1\");\n    else\n      Console.WriteLine(\n      \"Inverting using NOT operator (without sign bit): 0\");\n  }\n}\n\n// This code is contributed by akashish__\nlet a =0;\n    document.write(\"Value of a without using NOT operator: \" + a);\n    document.write( \"Inverting using NOT operator (with sign bit): \" + (~a));\n    if(!a)\n    document.write( \"Inverting using NOT operator (without sign bit): 1\" );\n    else\n    document.write( \"Inverting using NOT operator (without sign bit): 0\" );\nValue of a without using NOT operator: 0\nInverting using NOT operator (with sign bit): -1\nInverting using NOT operator (without sign bit): 1\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n    unsigned int num1 = 1024;\n\n    bitset<32> bt1(num1);\n    cout << bt1 << endl;\n\n    unsigned int num2 = num1 << 1;\n    bitset<32> bt2(num2);\n    cout << bt2 << endl;\n\n    unsigned int num3 = num1 << 2;\n    bitset<16> bitset13{ num3 };\n    cout << bitset13 << endl;\n}\n/*package whatever //do not write package name here */\n\nimport java.io.*;\n\nclass GFG {\n  public static void main(String[] args)\n  {\n    int num1 = 1024;\n\n    String bt1 = Integer.toBinaryString(num1);\n    bt1 = String.format(\"%32s\", bt1).replace(' ', '0');\n    System.out.println(bt1);\n\n    int num2 = num1 << 1;\n    String bt2 = Integer.toBinaryString(num2);\n    bt2 = String.format(\"%32s\", bt2).replace(' ', '0');\n    System.out.println(bt2);\n\n    int num3 = num1 << 2;\n    String bitset13 = Integer.toBinaryString(num3);\n    bitset13 = String.format(\"%16s\", bitset13)\n      .replace(' ', '0');\n    System.out.println(bitset13);\n  }\n}\n\n// This code is contributed by akashish__\n# Python code for the above approach\n\nnum1 = 1024\n\nbt1 = bin(num1)[2:].zfill(32)\nprint(bt1)\n\nnum2 = num1 << 1\nbt2 = bin(num2)[2:].zfill(32)\nprint(bt2)\n\nnum3 = num1 << 2\nbitset13 = bin(num3)[2:].zfill(16)\nprint(bitset13)\n\n# This code is contributed by Prince Kumar\nusing System;\n\nclass GFG {\n  public static void Main(string[] args)\n  {\n    int num1 = 1024;\n\n    string bt1 = Convert.ToString(num1, 2);\n    bt1 = bt1.PadLeft(32, '0');\n    Console.WriteLine(bt1);\n\n    int num2 = num1 << 1;\n    string bt2 = Convert.ToString(num2, 2);\n    bt2 = bt2.PadLeft(32, '0');\n    Console.WriteLine(bt2);\n\n    int num3 = num1 << 2;\n    string bitset13 = Convert.ToString(num3, 2);\n    bitset13 = bitset13.PadLeft(16, '0');\n    Console.WriteLine(bitset13);\n  }\n}\n\n// This code is contributed by akashish__\n// JavaScript code for the above approach\n\nlet num1 = 1024;\n\nlet bt1 = num1.toString(2).padStart(32, '0');\nconsole.log(bt1);\n\nlet num2 = num1 << 1;\nlet bt2 = num2.toString(2).padStart(32, '0');\nconsole.log(bt2);\n\nlet num3 = num1 << 2;\nlet bitset13 = num3.toString(2).padStart(16, '0');\nconsole.log(bitset13);\n00000000000000000000010000000000\n00000000000000000000100000000000\n0001000000000000\n#include <bitset>\n#include <iostream>\n\nusing namespace std;\n\nint main()\n{\n    unsigned int num1 = 1024;\n\n    bitset<32> bt1(num1);\n    cout << bt1 << endl;\n\n    unsigned int num2 = num1 >> 1;\n    bitset<32> bt2(num2);\n    cout << bt2 << endl;\n\n    unsigned int num3 = num1 >> 2;\n    bitset<16> bitset13{ num3 };\n    cout << bitset13 << endl;\n}\n// Java code for the above approach\n\nclass GFG {\n    public static void main(String[] args)\n    {\n        int num1 = 1024;\n\n        String bt1\n            = String\n                  .format(\"%32s\",\n                          Integer.toBinaryString(num1))\n                  .replace(' ', '0');\n        System.out.println(bt1);\n\n        int num2 = num1 >> 1;\n        String bt2\n            = String\n                  .format(\"%32s\",\n                          Integer.toBinaryString(num2))\n                  .replace(' ', '0');\n        System.out.println(bt2);\n\n        int num3 = num1 >> 2;\n        String bitset13\n            = String\n                  .format(\"%16s\",\n                          Integer.toBinaryString(num3))\n                  .replace(' ', '0');\n        System.out.println(bitset13);\n    }\n}\n\n// This code is contributed by ragul21\nnum1 = 1024\nbt1 = bin(num1)[2:].zfill(32)\nprint(bt1)\n\nnum2 = num1 >> 1\nbt2 = bin(num2)[2:].zfill(32)\nprint(bt2)\n\nnum3 = num1 >> 2\nbitset13 = bin(num3)[2:].zfill(16)\nprint(bitset13)\nusing System;\n\nclass Program\n{\n    static void Main()\n    {\n        int num1 = 1024;\n        \n        // Right shift by 1\n        int num2 = num1 >> 1;\n        \n        // Right shift by 2\n        int num3 = num1 >> 2;\n\n        // Print binary representations\n        string bt1 = Convert.ToString(num1, 2).PadLeft(32, '0');\n        string bt2 = Convert.ToString(num2, 2).PadLeft(32, '0');\n        string bitset13 = Convert.ToString(num3, 2).PadLeft(16, '0');\n\n        Console.WriteLine(bt1);\n        Console.WriteLine(bt2);\n        Console.WriteLine(bitset13);\n    }\n}\n// JavaScript code for the above approach\n\nlet num1 = 1024;\n\nlet bt1 = num1.toString(2).padStart(32, '0');\nconsole.log(bt1);\n\nlet num2 = num1 >> 1;\nlet bt2 = num2.toString(2).padStart(32, '0');\nconsole.log(bt2);\n\nlet num3 = num1 >> 2;\nlet bitset13 = num3.toString(2).padStart(16, '0');\nconsole.log(bitset13);\n// akashish__\n00000000000000000000010000000000\n00000000000000000000001000000000\n0000000100000000\n",
        "complexity": {
            "time": "Time Complexity: O(1) Auxiliary Space: O(1)",
            "space": ""
        },
        "tags": [
            "Bitwise Algorithms"
        ],
        "url": "https://www.geeksforgeeks.org/complete-reference-for-bitwise-operators-in-programming-coding/"
    },
    {
        "title": "Swap bits in a given number",
        "description": "Given a number x and two positions (0 based from the right side) in the binary representation of x, write a function that swaps n bits at the given two positions and returns the result. It is also given that the two sets of bits do not overlap. Examples: Input:x = 47 (00101111)p1 = 1 (Start from the second bit from the right side)p2 = 5 (Start from the 6th bit from the right side)n = 3 (No of bits to be swapped)Output:227 (11100011)Explanation:The 3 bits starting from the second bit (from the right side) are swapped with 3 bits starting from 6th position (from the right side) Input:x = 28 (11100)p1 = 0 (Start from first bit from right side)p2 = 3 (Start from 4th bit from right side)n = 2 (No of bits to be swapped)Output:7 (00111)Explanation:The 2 bits starting from 0th position (from right side) areswapped with 2 bits starting from 4th position (from right side) We need to swap two sets of bits. XOR can be used in a similar way as it is used to swap 2 numbers using XOR. The idea is to swap n bits at positions p1 and p2 in a number x by isolating these bit sets, XORing them to find the differences, and then selectively flipping only the bits that need to change, using the property that XOR marks differing bits and applying a second XOR operation restores the correct values in their swapped positions. Step by step approach: The idea is to perform a bit-by-bit swap by iterating through each of the n positions, checking if the corresponding bits at the two positions differ, and if they do, flipping both bits to effectively swap their values – this approach handles the swap one bit at a time rather than operating on the entire bit sequences in a single operation. Step by step approach: Related Article:  ",
        "code": "// C++ Program to swap bits\n// in a given number\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Function to swap bits in a given number\nint swapBits(int x, int p1, int p2, int n) {\n    \n    // Move all bits of first set to rightmost side \n    int set1 = (x >> p1) & ((1 << n) - 1);\n\n    // Move all bits of second set to rightmost side \n    int set2 = (x >> p2) & ((1 << n) - 1);\n\n    // Xor the two sets \n    int xorVal = (set1 ^ set2);\n\n    // Put the Xor bits back to their original positions \n    xorVal = (xorVal << p1) | (xorVal << p2);\n\n    // Xor the 'Xor' with the original number so that the \n    // two sets are swapped \n    int result = x ^ xorVal;\n\n    return result;\n}\n\nint main() {\n    int res = swapBits(28, 0, 3, 2);\n    cout << res;\n    return 0;\n}\n// Java Program to swap bits\n// in a given number\n\nclass GfG {\n\n    // Function to swap bits in a given number\n    static int swapBits(int x, int p1, int p2, int n) {\n        \n        // Move all bits of first set to rightmost side \n        int set1 = (x >> p1) & ((1 << n) - 1);\n\n        // Move all bits of second set to rightmost side \n        int set2 = (x >> p2) & ((1 << n) - 1);\n\n        // Xor the two sets \n        int xorVal = (set1 ^ set2);\n\n        // Put the Xor bits back to their original positions \n        xorVal = (xorVal << p1) | (xorVal << p2);\n\n        // Xor the 'Xor' with the original number so that the \n        // two sets are swapped \n        int result = x ^ xorVal;\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        int res = swapBits(28, 0, 3, 2);\n        System.out.println(res);\n    }\n}\n# Python Program to swap bits\n# in a given number\n\n# Function to swap bits in a given number\ndef swapBits(x, p1, p2, n):\n\n    # Move all bits of first set to rightmost side \n    set1 = (x >> p1) & ((1 << n) - 1)\n\n    # Move all bits of second set to rightmost side \n    set2 = (x >> p2) & ((1 << n) - 1)\n\n    # Xor the two sets \n    xorVal = (set1 ^ set2)\n\n    # Put the Xor bits back to their original positions \n    xorVal = (xorVal << p1) | (xorVal << p2)\n\n    # Xor the 'Xor' with the original number so that the \n    # two sets are swapped \n    result = x ^ xorVal\n\n    return result\n\nif __name__ == \"__main__\":\n    res = swapBits(28, 0, 3, 2)\n    print(res)\n// C# Program to swap bits\n// in a given number\nusing System;\n\nclass GfG {\n\n    // Function to swap bits in a given number\n    static int swapBits(int x, int p1, int p2, int n) {\n        \n        // Move all bits of first set to rightmost side \n        int set1 = (x >> p1) & ((1 << n) - 1);\n\n        // Move all bits of second set to rightmost side \n        int set2 = (x >> p2) & ((1 << n) - 1);\n\n        // Xor the two sets \n        int xorVal = (set1 ^ set2);\n\n        // Put the Xor bits back to their original positions \n        xorVal = (xorVal << p1) | (xorVal << p2);\n\n        // Xor the 'Xor' with the original number so that the \n        // two sets are swapped \n        int result = x ^ xorVal;\n\n        return result;\n    }\n\n    static void Main(string[] args) {\n        int res = swapBits(28, 0, 3, 2);\n        Console.WriteLine(res);\n    }\n}\n// JavaScript Program to swap bits\n// in a given number\n\n// Function to swap bits in a given number\nfunction swapBits(x, p1, p2, n) {\n\n    // Move all bits of first set to rightmost side \n    let set1 = (x >> p1) & ((1 << n) - 1);\n\n    // Move all bits of second set to rightmost side \n    let set2 = (x >> p2) & ((1 << n) - 1);\n\n    // Xor the two sets \n    let xorVal = (set1 ^ set2);\n\n    // Put the Xor bits back to their original positions \n    xorVal = (xorVal << p1) | (xorVal << p2);\n\n    // Xor the 'Xor' with the original number so that the \n    // two sets are swapped \n    let result = x ^ xorVal;\n\n    return result;\n}\n\nlet res = swapBits(28, 0, 3, 2);\nconsole.log(res);\n7\n// C++ Program to swap bits\n// in a given number\n#include <bits/stdc++.h>\nusing namespace std;\n\nint swapBits(int x, int p1, int p2, int n) {\n    int shift1, shift2, value1, value2;\n    while (n--) {\n        \n        // Setting bit at p1 position to 1\n        shift1 = 1 << p1;\n        // Setting bit at p2 position to 1\n        shift2 = 1 << p2;\n\n        // value1 and value2 will have 0 if num\n        // at the respective positions - p1 and p2 is 0.\n        value1 = ((x & shift1));\n        value2 = ((x & shift2));\n\n        // check if value1 and value2 are different\n        // i.e. at one position bit is set and other it is not\n        if ((!value1 && value2) || (!value2 && value1)) {\n            \n            // if bit at p1 position is set\n            if (value1) {\n                \n                // unset bit at p1 position\n                x = x & (~shift1);\n                \n                // set bit at p2 position\n                x = x | shift2;\n            }\n            // if bit at p2 position is set\n            else {\n                \n                // set bit at p2 position\n                x = x & (~shift2);\n                \n                // unset bit at p2 position\n                x = x | shift1;\n            }\n        }\n        p1++;\n        p2++;\n    }\n    \n    // return final result\n    return x;\n}\n\nint main() {\n    int res = swapBits(28, 0, 3, 2);\n    cout << res;\n    return 0;\n}\n// Java Program to swap bits\n// in a given number\n\nclass GfG {\n\n    static int swapBits(int x, int p1, int p2, int n) {\n        int shift1, shift2, value1, value2;\n        while (n > 0) {\n            \n            // Setting bit at p1 position to 1\n            shift1 = 1 << p1;\n            // Setting bit at p2 position to 1\n            shift2 = 1 << p2;\n\n            // value1 and value2 will have 0 if num\n            // at the respective positions - p1 and p2 is 0.\n            value1 = (x & shift1);\n            value2 = (x & shift2);\n\n            // check if value1 and value2 are different\n            // i.e. at one position bit is set and other it is not\n            if ((value1 == 0 && value2 != 0) || \n            (value2 == 0 && value1 != 0)) {\n                \n                // if bit at p1 position is set\n                if (value1 != 0) {\n                    \n                    // unset bit at p1 position\n                    x = x & (~shift1);\n                    \n                    // set bit at p2 position\n                    x = x | shift2;\n                }\n                // if bit at p2 position is set\n                else {\n                    \n                    // set bit at p2 position\n                    x = x & (~shift2);\n                    \n                    // unset bit at p2 position\n                    x = x | shift1;\n                }\n            }\n            p1++;\n            p2++;\n            n--;\n        }\n        \n        // return final result\n        return x;\n    }\n\n    public static void main(String[] args) {\n        int res = swapBits(28, 0, 3, 2);\n        System.out.println(res);\n    }\n}\n# Python Program to swap bits\n# in a given number\n\ndef swapBits(x, p1, p2, n):\n    shift1 = shift2 = value1 = value2 = 0\n    while n > 0:\n        \n        # Setting bit at p1 position to 1\n        shift1 = 1 << p1\n        # Setting bit at p2 position to 1\n        shift2 = 1 << p2\n\n        # value1 and value2 will have 0 if num\n        # at the respective positions - p1 and p2 is 0.\n        value1 = x & shift1\n        value2 = x & shift2\n\n        # check if value1 and value2 are different\n        # i.e. at one position bit is set and other it is not\n        if (not value1 and value2) or (not value2 and value1):\n\n            # if bit at p1 position is set\n            if value1:\n\n                # unset bit at p1 position\n                x = x & (~shift1)\n\n                # set bit at p2 position\n                x = x | shift2\n\n            # if bit at p2 position is set\n            else:\n\n                # set bit at p2 position\n                x = x & (~shift2)\n\n                # unset bit at p2 position\n                x = x | shift1\n\n        p1 += 1\n        p2 += 1\n        n -= 1\n\n    # return final result\n    return x\n\nif __name__ == \"__main__\":\n    res = swapBits(28, 0, 3, 2)\n    print(res)\n// C# Program to swap bits\n// in a given number\nusing System;\n\nclass GfG {\n\n    static int swapBits(int x, int p1, int p2, int n) {\n        int shift1, shift2, value1, value2;\n        while (n-- > 0) {\n            \n            // Setting bit at p1 position to 1\n            shift1 = 1 << p1;\n            // Setting bit at p2 position to 1\n            shift2 = 1 << p2;\n\n            // value1 and value2 will have 0 if num\n            // at the respective positions - p1 and p2 is 0.\n            value1 = (x & shift1);\n            value2 = (x & shift2);\n\n            // check if value1 and value2 are different\n            // i.e. at one position bit is set and other it is not\n            if ((!Convert.ToBoolean(value1) && value2 != 0) || \n            (!Convert.ToBoolean(value2) && value1 != 0)) {\n                \n                // if bit at p1 position is set\n                if (value1 != 0) {\n                    \n                    // unset bit at p1 position\n                    x = x & (~shift1);\n                    \n                    // set bit at p2 position\n                    x = x | shift2;\n                }\n                // if bit at p2 position is set\n                else {\n                    \n                    // set bit at p2 position\n                    x = x & (~shift2);\n                    \n                    // unset bit at p2 position\n                    x = x | shift1;\n                }\n            }\n            p1++;\n            p2++;\n        }\n\n        // return final result\n        return x;\n    }\n\n    static void Main(string[] args) {\n        int res = swapBits(28, 0, 3, 2);\n        Console.WriteLine(res);\n    }\n}\n// JavaScript Program to swap bits\n// in a given number\n\nfunction swapBits(x, p1, p2, n) {\n    let shift1, shift2, value1, value2;\n    while (n--) {\n\n        // Setting bit at p1 position to 1\n        shift1 = 1 << p1;\n        // Setting bit at p2 position to 1\n        shift2 = 1 << p2;\n\n        // value1 and value2 will have 0 if num\n        // at the respective positions - p1 and p2 is 0.\n        value1 = x & shift1;\n        value2 = x & shift2;\n\n        // check if value1 and value2 are different\n        // i.e. at one position bit is set and other it is not\n        if ((!value1 && value2) || (!value2 && value1)) {\n\n            // if bit at p1 position is set\n            if (value1) {\n\n                // unset bit at p1 position\n                x = x & (~shift1);\n\n                // set bit at p2 position\n                x = x | shift2;\n            }\n            // if bit at p2 position is set\n            else {\n\n                // set bit at p2 position\n                x = x & (~shift2);\n\n                // unset bit at p2 position\n                x = x | shift1;\n            }\n        }\n        p1++;\n        p2++;\n    }\n\n    // return final result\n    return x;\n}\n\nlet res = swapBits(28, 0, 3, 2);\nconsole.log(res);\n7\n",
        "complexity": {
            "time": "",
            "space": ""
        },
        "tags": [
            "Bitwise Algorithms"
        ],
        "url": "https://www.geeksforgeeks.org/swap-bits-in-a-given-number/"
    },
    {
        "title": "All about Bit Manipulation",
        "description": "Bit Manipulation is a technique used in a variety of problems to get the solution in an optimized way. This technique is very effective from a Competitive Programming point of view. It is all about Bitwise Operators which directly works upon binary numbers or bits of numbers that help the implementation fast. Below are the Bitwise Operators that are used: All data in computer programs are internally stored as bits, i.e., as numbers 0 and 1. Bit representation In programming, an n-bit integer is internally stored as a binary number that consists of n bits. For example, the C++ type int is a 32-bit type, which means that every int number consists of 32 bits. The int number 43 = 00000000000000000000000000101011 The bits in the representation are indexed from right to left. To convert a bit representation bk ···b2 b1 b0 into a number, we can use the formula bk2k +…+ b222 + b121 + b020. E.g., 1·25+1·23 +1·21 +1·20 = 43. The bit representation of a number is either signed or unsigned.Usually, a signed representation is used, which means that both negative and positive numbers can be represented.A signed variable of n bits can contain any integer between -2n-1 and 2n-1 – 1The int type in C++ is a signed type, so an int variable can contain any integer between -231 and 231 – 1. The first bit in a signed representation is the sign of the number, 0 for non-negative numbers and 1 for negative numbers and the remaining n−1 bits contain the magnitude of the number. Two’s complement is used, which means that the opposite number of a number is calculated by first inverting all the bits in the number, and then increasing the number by one.The bit representation of the int number −43 is 11111111111111111111111111010101In an unsigned representation, only non-negative numbers can be used, but the upper bound for the values is larger.An unsigned variable of n bits can contain any integer between 0 and 2n −1. In C++, an unsigned int variable can contain any integer between 0 and 232 −1.There is a connection between the representations:A signed number −x equals an unsigned number 2n − x.For example, the following pseudo-code snippet shows that the signed number x = −43 equals the unsigned number y = 232 −43: the pseudo-code snippet shows that the signed number If a number is larger than the upper bound of the bit representation, the number will overflow. In a signed representation, the next number after  2n-1 – 1 is -2n-1, and in an unsigned representation, the next number after  2n -1 is 0. For example, consider the following pseudo-code snippet:  Initially, the value of x is 231 −1. This is the largest value that can be stored in an int variable, so the next number after 231 −1 is −231 . Learn more about Bitwise Operators in this article. Below are some common bit operations that are frequently used in programming: Bitwise Operations: Below is the table to illustrate the result when the operation is performed using Bitwise Operators. Here 0s or 1s mean a sequence of 0 or 1 respectively. This method is used to find the bit at a particular position(say i) of the given number N. The idea is to find the Bitwise AND of the given number and 2i that can be represented as (1 << i). If the value return is 1 then the bit at the ith position is set. Otherwise, it is unset. Below is the pseudo-code for the same:                This method is used to set the bit at a particular position(say i) of the given number N. The idea is to update the value of the given number N to the Bitwise OR of the given number N and 2i that can be represented as (1 << i). If the value return is 1 then the bit at the ith position is set. Otherwise, it is unset. Below is the pseudo-code for the same:                This method is used to clear the bit at a particular position(say i) of the given number N. The idea is to update the value of the given number N to the Bitwise AND of the given number N and the compliment of 2i that can be represented as ~(1 << i). If the value return is 1 then the bit at the ith position is set. Otherwise, it is unset. Below is the pseudo-code for the same:                Below is the program that implements the above functionalities:                Time Complexity: O(1)Auxiliary Space: O(1) Application of Bitwise Operator S  ",
        "code": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThe bit at the 3rd position from LSB is: 0\nThe value of the given number after setting the bit at LSB is: 71\nThe value of the given number after clearing the bit at LSB is: 70\n",
        "complexity": {
            "time": "Time Complexity: O(1)Auxiliary Space: O(1)",
            "space": ""
        },
        "tags": [
            "Bitwise Algorithms"
        ],
        "url": "https://www.geeksforgeeks.org/all-about-bit-manipulation/"
    },
    {
        "title": "Count set bits in an integer",
        "description": "Write an efficient program to count the number of 1s in the binary representation of an integer.Examples : Input : n = 6Output : 2Binary representation of 6 is 110 and has 2 set bits Input : n = 13Output : 3Binary representation of 13 is 1101 and has 3 set bits  This approach counts the number of set bits (1s) in the binary representation of a given integer. It works by repeatedly checking the least significant bit of the number using the bitwise AND operation (n & 1). If the least significant bit is 1, the count is incremented. Then, the number is right-shifted by 1 (n >>= 1), effectively removing the least significant bit and moving on to the next one. This process continues until the number becomes 0, and the function returns the total count of set bits. Time Complexity: O(log n) Auxiliary Space: O(1) Recursive Implementation The function checks if the least significant bit is set (i.e., if it’s 1). It does this by using a bitwise operation that isolates the least significant bit. If the bit is 1, it adds 1 to the count; otherwise, it adds 0. After checking the bit, the function recursively calls itself with the number shifted right by one position, essentially removing the checked bit. This process continues until all bits are checked, and the final count of set bits is returned. Time Complexity: O(log n)Auxiliary Space: O(log n)for recursive stack space This approach uses the Brian Kernighan’s algorithm to count the number of set bits (1s) in the binary representation of a given integer. The key idea is that the expression n &= (n - 1) clears the least significant set bit in the number n. By repeatedly applying this operation, we reduce the number and count how many set bits are cleared, which directly gives us the count of set bits. This method is more efficient than checking each bit individually, as it only processes the set bits in the number, making it faster in cases where the number has fewer set bits. Subtracting 1 from a decimal number flips all the bits after the rightmost set bit(which is 1) including the rightmost set bit. for example : 10 in binary is 00001010 9 in binary is 00001001 8 in binary is 00001000 7 in binary is 00000111 So if we subtract a number by 1 and do it bitwise & with itself (n & (n-1)), we unset the rightmost set bit. If we do n & (n-1) in a loop and count the number of times the loop executes, we get the set bit count. The beauty of this solution is the number of times it loops is equal to the number of set bits in a given integer. 1  Initialize count: = 0   2  If integer n is not zero      (a) Do bitwise & with (n-1) and assign the value back to n          n: = n&(n-1)      (b) Increment count by 1      (c) go to step 2   3  Else return count Example for Brian Kernighan’s Algorithm: n =  9 (1001)   count = 0   Since 9 > 0, subtract by 1 and do bitwise & with (9-1)   n = 9&8  (1001 & 1000)   n = 8   count  = 1   Since 8 > 0, subtract by 1 and do bitwise & with (8-1)   n = 8&7  (1000 & 0111)   n = 0   count = 2   Since n = 0, return count which is 2 now. Time Complexity: O(log n)Auxiliary Space: O(1) This approach uses a lookup table to count the number of set bits (1s) in a number efficiently. The program first initializes a table, BitsSetTable256[], where each entry at index i contains the number of set bits in the 8-bit binary representation of i. This is done by iterating through all numbers from 0 to 255 and calculating the set bits for each. In the function countSetBits, the number is divided into 4 bytes (8 bits each), and the lookup table is used to quickly get the number of set bits for each byte. The result is the sum of the set bits in all 4 bytes, giving the total number of set bits in the integer. This method is fast because it avoids looping through individual bits by using precomputed values stored in the lookup table. It is particularly useful when there are many set bits to count. Time Complexity: O(1)Auxiliary Space: O(1) It simply maintains a map(or array) of numbers to bits for a nibble. A Nibble contains 4 bits. So we need an array of up to 15. int num_to_bits[16] = {0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4}; Now we just need to get nibbles of a given long/int/word etc recursively. Time Complexity: O(log n), because we have log(16, n) levels of recursion.Storage Complexity: O(1) Whether the given number is short, int, long, or long long we require an array of 16 sizes only, which is constant. Iterate from k to 0 , where k is the largest power of 2 such that pow(2, k) <= num . And check if the Bitwise AND of num and pow(2, i) is greater than zero or not. If it is greater than zero , Then i-th bit is set ,then increase the count by 1. Time Complexity: O(logn) Auxiliary Space: O(1) In C++ GCC, we can directly count set bits using __builtin_popcount(). So we can avoid a separate function for counting set bits. Similarly, we have direct syntax in other programming languages.  ",
        "code": "// C++ program to Count set\n// bits in an integer\n#include <bits/stdc++.h>\nusing namespace std;\n\n/* Function to get no of set bits in binary\nrepresentation of positive integer n */\nunsigned int countSetBits(unsigned int n)\n{\n    unsigned int count = 0;\n    while (n) {\n        count += n & 1;\n        n >>= 1;\n    }\n    return count;\n}\n\n/* Program to test function countSetBits */\nint main()\n{\n    int i = 9;\n    cout << countSetBits(i);\n    return 0;\n}\n// C program to Count set\n// bits in an integer\n#include <stdio.h>\n\n/* Function to get no of set bits in binary\n   representation of positive integer n */\nunsigned int countSetBits(unsigned int n)\n{\n    unsigned int count = 0;\n    while (n) {\n        count += n & 1;\n        n >>= 1;\n    }\n    return count;\n}\n\n/* Program to test function countSetBits */\nint main()\n{\n    int i = 9;\n    printf(\"%d\", countSetBits(i));\n    return 0;\n}\n// Java program to Count set\n// bits in an integer\nimport java.io.*;\n\nclass countSetBits {\n    /* Function to get no of set \n    bits in binary representation \n    of positive integer n */\n    static int countSetBits(int n)\n    {\n        int count = 0;\n        while (n > 0) {\n            count += n & 1;\n            n >>= 1;\n        }\n        return count;\n    }\n\n    // driver program\n    public static void main(String args[])\n    {\n        int i = 9;\n        System.out.println(countSetBits(i));\n    }\n}\n# Python3 program to Count set\n# bits in an integer \n\n# Function to get no of set bits in binary\n# representation of positive integer n */\ndef  countSetBits(n):\n    count = 0\n    while (n):\n        count += n & 1\n        n >>= 1\n    return count\n\n\n# Program to test function countSetBits */\ni = 9\nprint(countSetBits(i))\n// C# program to Count set\n// bits in an integer\nusing System;\n\nclass GFG {\n    // Function to get no of set\n    // bits in binary representation\n    // of positive integer n\n    static int countSetBits(int n)\n    {\n        int count = 0;\n        while (n > 0) {\n            count += n & 1;\n            n >>= 1;\n        }\n        return count;\n    }\n\n    // Driver Code\n    public static void Main()\n    {\n        int i = 9;\n        Console.Write(countSetBits(i));\n    }\n}\n// Javascript program to Count set\n    // bits in an integer\n\n    /* Function to get no of set bits in binary\n    representation of positive integer n */\n    function countSetBits(n)\n    {\n      var count = 0;\n      while (n)\n      {\n        count += n & 1;\n        n >>= 1;\n      }\n      return count;\n    }\n\n    /* Program to test function countSetBits */\n    var i = 9;\n    console.log(countSetBits(i));\n<?php\n// PHP program to Count set\n// bits in an integer \n\n// Function to get no of set  \n// bits in binary representation \n// of positive integer n \nfunction countSetBits($n)\n{\n    $count = 0;\n    while ($n)\n    {\n        $count += $n & 1;\n        $n >>= 1;\n    }\n    return $count;\n}\n\n// Driver Code\n$i = 9;\necho countSetBits($i);\n\n?>\n2\n// cpp implementation of recursive approach to find the\n// number of set bits in binary representation of positive\n// integer n\n#include <bits/stdc++.h>\nusing namespace std;\n\n// recursive function to count set bits\nint countSetBits(int n)\n{\n    // base case\n    if (n == 0)\n        return 0;\n    else\n        // if last bit set add 1 else add 0\n        return (n & 1) + countSetBits(n >> 1);\n}\n\n// driver code\nint main()\n{\n    int n = 9;\n    // function calling\n    cout << countSetBits(n);\n    return 0;\n}\n// cpp implementation of recursive approach to find the\n// number of set bits in binary representation of positive\n// integer n\n#include <stdio.h>\n\n// recursive function to count set bits\nint countSetBits(int n)\n{\n    // base case\n    if (n == 0)\n        return 0;\n    else\n        // if last bit set add 1 else add 0\n        return (n & 1) + countSetBits(n >> 1);\n}\n\n// driver code\nint main()\n{\n    int n = 9;\n    // function calling\n    printf(\"%d\", countSetBits(n));\n    return 0;\n}\n// Java implementation of recursive\n// approach to find the number\n// of set bits in binary representation\n// of positive integer n\nimport java.io.*;\n\nclass GFG {\n\n    // recursive function to count set bits\n    public static int countSetBits(int n)\n    {\n\n        // base case\n        if (n == 0)\n            return 0;\n\n        else\n\n            // if last bit set add 1 else add 0\n            return (n & 1) + countSetBits(n >> 1);\n    }\n\n    // Driver code\n    public static void main(String[] args)\n    {\n\n        // get value from user\n        int n = 9;\n\n        // function calling\n        System.out.println(countSetBits(n));\n    }\n}\n# Python3 implementation of recursive\n# approach to find the number of set\n# bits in binary representation of \n# positive integer n\n\ndef countSetBits( n):\n    \n    # base case\n    if (n == 0):\n        return 0\n\n    else:\n\n        # if last bit set add 1 else\n        # add 0\n        return (n & 1) + countSetBits(n >> 1)\n        \n# Get value from user\nn = 9\n\n# Function calling\nprint( countSetBits(n))\n// C# implementation of recursive\n// approach to find the number of\n// set bits in binary representation\n// of positive integer n\nusing System;\n\nclass GFG {\n\n    // recursive function\n    // to count set bits\n    public static int countSetBits(int n)\n    {\n\n        // base case\n        if (n == 0)\n            return 0;\n\n        else\n\n            // if last bit set\n            // add 1 else add 0\n            return (n & 1) + countSetBits(n >> 1);\n    }\n\n    // Driver code\n    static public void Main()\n    {\n\n        // get value\n        // from user\n        int n = 9;\n\n        // function calling\n        Console.WriteLine(countSetBits(n));\n    }\n}\n// Javascript implementation of recursive\n// approach to find the number\n// of set bits in binary representation\n// of positive integer n\n\n// recursive function to count set bits\nfunction countSetBits(n)\n{\n\n    // base case\n    if (n == 0)\n        return 0;\n\n    else\n\n        // if last bit set add 1 else add 0\n        return (n & 1) + countSetBits(n >> 1);\n}\n\n// driver code\n\n    // get value from user\n    let n = 9;\n\n    // function calling\n    console.log (countSetBits(n));\n<?php\n// PHP implementation of recursive\n// approach to find the number of \n// set bits in binary representation\n// of positive integer n\n\n// recursive function \n// to count set bits\nfunction countSetBits($n)\n{\n    // base case\n    if ($n == 0)\n        return 0;\n\n    else\n\n        // if last bit set \n        // add 1 else add 0\n        return ($n & 1) + \n                countSetBits($n >> 1);\n}\n\n// Driver code\n\n// get value from user\n$n = 9;\n\n// function calling\necho countSetBits($n);\n\n?>\n2\n// C++ program to Count set\n// bits in an integer\n#include <iostream>\nusing namespace std;\nclass gfg {\n    /* Function to get no of set bits in binary\nrepresentation of passed binary no. */\npublic:\n    unsigned int countSetBits(int n)\n    {\n        unsigned int count = 0;\n        while (n) {\n            n &= (n - 1);\n            count++;\n        }\n        return count;\n    }\n};\n/* Program to test function countSetBits */\nint main()\n{\n    gfg g;\n    int i = 9;\n    cout << g.countSetBits(i);\n    return 0;\n}\n// C program to Count set\n// bits in an integer\n#include <stdio.h>\n\n/* Function to get no of set bits in binary\n   representation of passed binary no. */\nunsigned int countSetBits(int n)\n{\n    unsigned int count = 0;\n    while (n) {\n        n &= (n - 1);\n        count++;\n    }\n    return count;\n}\n\n/* Program to test function countSetBits */\nint main()\n{\n    int i = 9;\n    printf(\"%d\", countSetBits(i));\n    getchar();\n    return 0;\n}\n// Java program to Count set\n// bits in an integer\nimport java.io.*;\n\nclass countSetBits {\n    /* Function to get no of set \n    bits in binary representation \n    of passed binary no. */\n    static int countSetBits(int n)\n    {\n        int count = 0;\n        while (n > 0) {\n            n &= (n - 1);\n            count++;\n        }\n        return count;\n    }\n\n    // driver program\n    public static void main(String args[])\n    {\n        int i = 9;\n        System.out.println(countSetBits(i));\n    }\n}\n\n// This code is contributed by Anshika Goyal.\n# Function to get no of set bits in binary\n# representation of passed binary no. */\ndef countSetBits(n):\n\n    count = 0\n    while (n):\n        n &= (n-1) \n        count+= 1\n    \n    return count\n\n\n# Program to test function countSetBits \ni = 9\nprint(countSetBits(i))\n// C# program to Count set\n// bits in an integer\nusing System;\n\nclass GFG {\n\n    /* Function to get no of set \n    bits in binary representation \n    of passed binary no. */\n    static int countSetBits(int n)\n    {\n        int count = 0;\n        while (n > 0) {\n            n &= (n - 1);\n            count++;\n        }\n        return count;\n    }\n\n    // Driver Code\n    static public void Main()\n    {\n        int i = 9;\n        Console.WriteLine(countSetBits(i));\n    }\n}\n\n// This code is contributed by ajit\n// JavaScript program to Count set\n// bits in an integerclass \n\n/* Function to get no of set \nbits in binary representation \nof passed binary no. */\n\nfunction countSetBits(n)\n{\n    var count = 0;\n    while (n > 0)\n    {\n        n &= (n - 1);\n        count++;\n    }\n    return count;\n}\n\n// driver program\nvar i = 9;\nconsole.log (countSetBits(i));\n<?php\n\n/* Function to get no of \nset bits in binary\nrepresentation of passed \nbinary no. */\nfunction countSetBits($n)\n{\n    $count = 0;\n    while ($n)\n    {\n    $n &= ($n - 1) ;\n    $count++;\n    }\n    return $count;\n}\n\n// Driver Code\n$i = 9;\necho countSetBits($i);\n\n?>\n2\n// C++ implementation of the approach \n#include <bits/stdc++.h>\nusing namespace std;\n\nint BitsSetTable256[256];\n\n// Function to initialise the lookup table \nvoid initialize() \n{ \n\n    // To initially generate the \n    // table algorithmically \n    BitsSetTable256[0] = 0; \n    for (int i = 0; i < 256; i++)\n    { \n        BitsSetTable256[i] = (i & 1) + \n        BitsSetTable256[i / 2]; \n    } \n} \n\n// Function to return the count \n// of set bits in n \nint countSetBits(int n) \n{ \n    return (BitsSetTable256[n & 0xff] + \n            BitsSetTable256[(n >> 8) & 0xff] + \n            BitsSetTable256[(n >> 16) & 0xff] + \n            BitsSetTable256[n >> 24]); \n} \n\n// Driver code \nint main() \n{ \n    // Initialise the lookup table \n    initialize(); \n    int n = 9; \n    cout << countSetBits(n);\n}\n// Java implementation of the approach\nimport java.util.*;\nclass GFG {\n\n    // Lookup table\n    static int[] BitsSetTable256 = new int[256];\n\n    // Function to initialise the lookup table\n    public static void initialize()\n    {\n\n        // To initially generate the\n        // table algorithmically\n        BitsSetTable256[0] = 0;\n        for (int i = 0; i < 256; i++) {\n            BitsSetTable256[i] = (i & 1) + BitsSetTable256[i / 2];\n        }\n    }\n\n    // Function to return the count\n    // of set bits in n\n    public static int countSetBits(int n)\n    {\n        return (BitsSetTable256[n & 0xff]\n                + BitsSetTable256[(n >> 8) & 0xff]\n                + BitsSetTable256[(n >> 16) & 0xff]\n                + BitsSetTable256[n >> 24]);\n    }\n\n    // Driver code\n    public static void main(String[] args)\n    {\n\n        // Initialise the lookup table\n        initialize();\n        int n = 9;\n        System.out.print(countSetBits(n));\n    }\n}\n# Python implementation of the approach \nBitsSetTable256 = [0] * 256\n\n# Function to initialise the lookup table \ndef initialize():\n    \n    # To initially generate the \n    # table algorithmically \n    BitsSetTable256[0] = 0\n    for i in range(256):\n        BitsSetTable256[i] = (i & 1) + BitsSetTable256[i // 2] \n\n# Function to return the count \n# of set bits in n \ndef countSetBits(n):\n    return (BitsSetTable256[n & 0xff] +\n            BitsSetTable256[(n >> 8) & 0xff] +\n            BitsSetTable256[(n >> 16) & 0xff] +\n            BitsSetTable256[n >> 24]) \n\n# Driver code \n\n# Initialise the lookup table \ninitialize() \nn = 9\nprint(countSetBits(n))\n// C# implementation of the approach\nusing System;\nusing System.Collections.Generic;\n\nclass GFG \n{\n\n    // Lookup table\n    static int[] BitsSetTable256 = new int[256];\n\n    // Function to initialise the lookup table\n    public static void initialize()\n    {\n\n        // To initially generate the\n        // table algorithmically\n        BitsSetTable256[0] = 0;\n        for (int i = 0; i < 256; i++)\n        {\n            BitsSetTable256[i] = (i & 1) + BitsSetTable256[i / 2];\n        }\n    }\n\n    // Function to return the count\n    // of set bits in n\n    public static int countSetBits(int n)\n    {\n        return (BitsSetTable256[n & 0xff]\n                + BitsSetTable256[(n >> 8) & 0xff]\n                + BitsSetTable256[(n >> 16) & 0xff]\n                + BitsSetTable256[n >> 24]);\n    }\n\n    // Driver code\n    public static void Main(String[] args)\n    {\n\n        // Initialise the lookup table\n        initialize();\n        int n = 9;\n        Console.Write(countSetBits(n));\n    }\n}\n// javascript implementation of the approach   \n\nvar BitsSetTable256 = Array.from({length: 256}, (_, i) => 0);\n\n// Function to initialise the lookup table\nfunction initialize()\n{\n\n    // To initially generate the\n    // table algorithmically\n    BitsSetTable256[0] = 0;\n    for (var i = 0; i < 256; i++) {\n        BitsSetTable256[i] = (i & 1) + \n        BitsSetTable256[parseInt(i / 2)];\n    }\n}\n\n// Function to return the count\n// of set bits in n\nfunction countSetBits(n)\n{\n    return (BitsSetTable256[n & 0xff]\n            + BitsSetTable256[(n >> 8) & 0xff]\n            + BitsSetTable256[(n >> 16) & 0xff]\n            + BitsSetTable256[n >> 24]);\n}\n\n// Driver code\n // Initialise the lookup table\ninitialize();\nvar n = 9;\nconsole.log (countSetBits(n));\n2\n// C++ program to count set bits by pre-storing\n// count set bits in nibbles.\n#include <bits/stdc++.h>\nusing namespace std;\n\nint num_to_bits[16] = { 0, 1, 1, 2, 1, 2, 2, 3,\n                        1, 2, 2, 3, 2, 3, 3, 4 };\n\n/* Recursively get nibble of a given number \nand map them in the array */\nunsigned int countSetBitsRec(unsigned int num)\n{\n    int nibble = 0;\n    if (0 == num)\n        return num_to_bits[0];\n\n    // Find last nibble\n    nibble = num & 0xf;\n\n    // Use pre-stored values to find count\n    // in last nibble plus recursively add\n    // remaining nibbles.\n    return num_to_bits[nibble] + countSetBitsRec(num >> 4);\n}\n\n// Driver code\nint main()\n{\n    int num = 31;\n    cout << countSetBitsRec(num);\n    return 0;\n}\n// C program to count set bits by pre-storing\n// count set bits in nibbles.\n#include <stdio.h>\n\nint num_to_bits[16] = { 0, 1, 1, 2, 1, 2, 2, 3,\n                        1, 2, 2, 3, 2, 3, 3, 4 };\n\n/* Recursively get nibble of a given number \n  and map them in the array  */\nunsigned int countSetBitsRec(unsigned int num)\n{\n    int nibble = 0;\n    if (0 == num)\n        return num_to_bits[0];\n\n    // Find last nibble\n    nibble = num & 0xf;\n\n    // Use pre-stored values to find count\n    // in last nibble plus recursively add\n    // remaining nibbles.\n    return num_to_bits[nibble] + countSetBitsRec(num >> 4);\n}\n\n// Driver code\nint main()\n{\n    int num = 31;\n    printf(\"%d\\n\", countSetBitsRec(num));\n}\n// Java program to count set bits by pre-storing\n// count set bits in nibbles.\nimport java.util.*;\nclass GFG {\n    static int[] num_to_bits = new int[] { 0, 1, 1, 2, 1, 2, 2,\n                                           3, 1, 2, 2, 3, 2, 3, 3, 4 };\n\n    /* Recursively get nibble of a given number \nand map them in the array */\n    static int countSetBitsRec(int num)\n    {\n        int nibble = 0;\n        if (0 == num)\n            return num_to_bits[0];\n\n        // Find last nibble\n        nibble = num & 0xf;\n\n        // Use pre-stored values to find count\n        // in last nibble plus recursively add\n        // remaining nibbles.\n        return num_to_bits[nibble] + countSetBitsRec(num >> 4);\n    }\n\n    // Driver code\n    public static void main(String[] args)\n    {\n        int num = 31;\n        System.out.println(countSetBitsRec(num));\n    }\n}\n// this code is contributed by mits\n# Python3 program to count set bits by pre-storing \n# count set bits in nibbles. \n\nnum_to_bits =[0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4]; \n\n# Recursively get nibble of a given number \n# and map them in the array\ndef countSetBitsRec(num):\n    nibble = 0;\n    if(0 == num):\n        return num_to_bits[0];\n    \n    # Find last nibble\n    nibble = num & 0xf;\n    \n    # Use pre-stored values to find count\n    # in last nibble plus recursively add\n    # remaining nibbles.\n    \n    return num_to_bits[nibble] + countSetBitsRec(num >> 4); \n \n\n# Driver code \n \nnum = 31; \nprint(countSetBitsRec(num)); \n\n\n# this code is contributed by mits\n// C# program to count set bits by pre-storing\n// count set bits in nibbles.\n\nclass GFG {\n    static int[] num_to_bits = new int[16] { 0, 1, 1, 2, 1, 2, 2,\n                                             3, 1, 2, 2, 3, 2, 3, 3, 4 };\n\n    /* Recursively get nibble of a given number \nand map them in the array */\n    static int countSetBitsRec(int num)\n    {\n        int nibble = 0;\n        if (0 == num)\n            return num_to_bits[0];\n\n        // Find last nibble\n        nibble = num & 0xf;\n\n        // Use pre-stored values to find count\n        // in last nibble plus recursively add\n        // remaining nibbles.\n        return num_to_bits[nibble] + countSetBitsRec(num >> 4);\n    }\n\n    // Driver code\n    static void Main()\n    {\n        int num = 31;\n        System.Console.WriteLine(countSetBitsRec(num));\n    }\n}\n// this code is contributed by mits\n// Javascript program to count set bits by pre-storing\n// count set bits in nibbles.   \nvar num_to_bits =[ 0, 1, 1, 2, 1, 2, 2,\n                   3, 1, 2, 2, 3, 2, 3, 3, 4 ];\n\n/* Recursively get nibble of a given number \nand map them in the array */\nfunction countSetBitsRec(num)\n{\n    var nibble = 0;\n    if (0 == num)\n        return num_to_bits[0];\n\n    // Find last nibble\n    nibble = num & 0xf;\n\n    // Use pre-stored values to find count\n    // in last nibble plus recursively add\n    // remaining nibbles.\n    return num_to_bits[nibble] + countSetBitsRec(num >> 4);\n}\n\n// Driver code\nvar num = 31;\nconsole.log (countSetBitsRec(num));\n<?php\n// PHP program to count set bits by \n// pre-storing count set bits in nibbles. \n\n$num_to_bits = array(0, 1, 1, 2, 1, 2, 2, 3,\n                     1, 2, 2, 3, 2, 3, 3, 4); \n\n/* Recursively get nibble of a given \nnumber and map them in the array */\nfunction countSetBitsRec( $num) \n{ \n    global $num_to_bits;\n    $nibble = 0; \n    if (0 == $num) \n        return $num_to_bits[0]; \n    \n    // Find last nibble \n    $nibble = $num & 0xf; \n    \n    // Use pre-stored values to find count \n    // in last nibble plus recursively add \n    // remaining nibbles. \n    return $num_to_bits[$nibble] + \n           countSetBitsRec($num >> 4); \n} \n\n// Driver code \n$num = 31; \necho (countSetBitsRec($num)); \n\n// This code is contributed by mits\n?>\n5\n// C++ implementation of the above approach\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Function to find largest power of 2 such that\n// pow(2,k) <= N \nint findk(int n)\n{ int k; int i=0; int val=pow(2,i);\n  \n while(val<=n)\n { \n     k=i; i++;\n    val=pow(2,i);\n }\n  return k;\n}\n\n// Function to count set bits in a number\nint countSetBits(int N)\n{\n    int count = 0;\n    int k=findk(N);\n    int val , x;\n  \n    // Iterating from largest power to 2 such that \n    // pow(2,k) to 0\n    for (int i = k; i >= 0; i--)\n    {\n        val=pow(2,i);\n        x=val & N; //x will store Bitwise AND of N & val\n      \n       if(x > 0)\n       { count++;\n       }\n    }\n    return count;//return count of set bits\n}\n\n// Drive Code\nint main()\n{\n    int N = 15;\n    \n    // Function call\n    cout << countSetBits(N) << endl;\n    return 0;\n}\n/*package whatever //do not write package name here */\n\nimport java.io.*;\n\n// import java.lang.Math;\n\npublic class GFG {\n    // Function to find largest power of 2 such that\n    // pow(2,k) <= N\n    static int findk(int n)\n    {\n        int k = 0;\n        int i = 0;\n        int val = (int)Math.pow(2, i);\n\n        while (val <= n) {\n            k = i;\n            i++;\n            val = (int)Math.pow(2, i);\n        }\n        return k;\n    }\n\n    // Function to count set bits in a number\n    static int countSetBits(int N)\n    {\n        int count = 0;\n        int k = findk(N);\n        int val, x;\n\n        // Iterating from largest power to 2 such that\n        // pow(2,k) to 0\n        for (int i = k; i >= 0; i--) {\n            val = (int)Math.pow(2, i);\n            x = val\n                & N; // x will store Bitwise AND of N & val\n\n            if (x > 0) {\n                count++;\n            }\n        }\n        return count; // return count of set bits\n    }\n\n    // Driver code\n    public static void main(String[] args)\n    {\n        int N = 15;\n\n        // Function call\n        System.out.println(countSetBits(N));\n    }\n}\n# Python implementation of the above approach\nimport math\n\n# Function to find largest power of 2 such that\n# pow(2,k) <= N\ndef findk(n):\n    i = 0\n    val = math.pow(2, i)\n    while val <= n:\n        k = i\n        i += 1\n        val = math.pow(2, i)\n    return k\n\n# Function to count set bits in a number\ndef countSetBits(N):\n    count = 0\n    k = findk(N)\n    for i in range(k, -1, -1):\n        val = int(math.pow(2, i))\n        x = val & N # x will store Bitwise AND of N & val\n        if x > 0:\n            count += 1\n    return count\n\n# Drive Code\nif __name__ == '__main__':\n    N = 15\n\n    # Function call\n    print(countSetBits(N))\nusing System;\n\nclass Program\n{\n    // Function to find largest power of 2 such that\n    // pow(2,k) <= N\n    static int FindK(int n)\n    {\n        int k = 0;\n        int i = 0;\n        int val = (int)Math.Pow(2, i);\n\n        while (val <= n)\n        {\n            k = i;\n            i++;\n            val = (int)Math.Pow(2, i);\n        }\n        return k;\n    }\n\n    // Function to count set bits in a numnber\n    static int CountSetBits(int N)\n    {\n        int count = 0;\n        int k = FindK(N);\n        int val, x;\n\n        // Iterating from largest power to 2 such that\n        // pow(2,k) to 0\n        for (int i = k; i >= 0; i--)\n        {\n            val = (int)Math.Pow(2, i);\n            x = val & N; //x will store Bitwise AND of N & val\n\n            if (x > 0)\n            {\n                count++;\n            }\n        }\n        return count; //return count of set bits\n    }\n\n    // Drive Code\n    static void Main()\n    {\n        int N = 15;\n\n        // Function call\n        Console.WriteLine(CountSetBits(N));\n    }\n}\n//this code is contributed by ajay\n// JavaScript implementation of the above approach\n// function to find largest power of 2 such that\n// pow(2,k) <= N\nfunction findk(n){\n    let k;\n    let i = 0;\n    let val = Math.pow(2,i);\n    while(val <= n){\n        k=i;\n        i++;\n        val = Math.pow(2,i);\n    }\n    return k;\n}\n\n// function to count set bits in a number\nfunction countSetBits(N){\n    let count = 0;\n    let k = findk(N);\n    let val;\n    let x;\n    \n    // iterating from largest power to 2 such that\n    // pow(2,k) to 0\n    for(let i = k; i>=0; i--){\n        val = Math.pow(2,i);\n        x = val & N; // x will store bitwise and of N and val\n        \n        if(x > 0) count++;\n    }\n    return count; // return count of set bits\n}\n\n// driver program\nlet N = 15;\n\n// function call\nconsole.log(countSetBits(N));\n4\n// C++ program to demonstrate __builtin_popcount()\n#include <iostream>\nusing namespace std;\n\nint main()\n{\n    cout << __builtin_popcount(4) << endl;\n    cout << __builtin_popcount(15);\n\n    return 0;\n}\n// java program to demonstrate\n// __builtin_popcount()\n\nimport java.io.*;\n\nclass GFG {\n\n    // Driver code\n    public static void main(String[] args)\n    {\n\n        System.out.println(Integer.bitCount(4));\n        System.out.println(Integer.bitCount(15));\n    }\n}\nprint(bin(4).count('1'));\nprint(bin(15).count('1'));\n\n# This code is Contributed by mits\nusing System;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        Console.WriteLine(Convert.ToString(4, 2).Replace(\"0\", \"\").Length);\n        Console.WriteLine(Convert.ToString(15, 2).Replace(\"0\", \"\").Length);\n    }\n}\n// Javascript program to demonstrate\n// __builtin_popcount()\n\nconsole.log ((4).toString(2).split('').\n  filter(x => x == '1').length + \"<br>\");\nconsole.log ((15).toString(2).split('').\n  filter(x => x == '1').length);\n<?php\n// PHP program to demonstrate\n// __builtin_popcount()\n\n// Driver code\n$t = log10(4);\n$x = log(15, 2);\n$tt = ceil($t);\n$xx = ceil($x);\n\necho ($tt), \"\\n\";\necho ($xx), \"\\n\";\n\n\n?>\n1\n4\n",
        "complexity": {
            "time": "Time Complexity: O(logn) Auxiliary Space: O(1)",
            "space": ""
        },
        "tags": [
            "Bitwise Algorithms"
        ],
        "url": "https://www.geeksforgeeks.org/count-set-bits-in-an-integer/"
    },
    {
        "title": "Set the K-th bit of a given number",
        "description": "Given a number n and a value k. From the right, set the kth bit in the binary representation of n. The position of LSB(or last bit) is 0, second last bit is 1 and so on. Also, 0 <= k < x, where x is the number of bits in the binary representation of n.Examples:  To set any bit we use bitwise OR | operator. As we already know bitwise OR | operator evaluates each bit of the result to 1 if any of the operand’s corresponding bit is set (1). In-order to set kth bit of a number we need to shift 1 k times to its left and then perform bitwise OR operation with the number and result of left shift performed just before.                    Output: Time Complexity: O(1) Auxiliary Space: O(1)  A  ",
        "code": "Input : n = 10, k = 2\nOutput : 14\n(10)10 = (1010)2\nNow, set the 2nd bit from right.\n(14)10 = (1110)2\n2nd bit has been set.\n\nInput : n = 15, k = 3\nOutput : 15\n3rd bit of 15 is already set.\nIn general, (1 << k) | n.\n\n\n\n\n\n\n\n\n\n\n\n\nKth bit set number = 14\n",
        "complexity": {
            "time": "Time Complexity: O(1)",
            "space": ""
        },
        "tags": [
            "Bitwise Algorithms"
        ],
        "url": "https://www.geeksforgeeks.org/set-k-th-bit-given-number/"
    },
    {
        "title": "Program to clear K-th bit of a number N",
        "description": "Given a number N, the task is to clear the K-th bit of this number N. If K-th bit is 1, then clear it to 0 and if it is 0 then leave it unchanged.Examples:  Approach: Below is the implementation of the above approach:                    Time Complexity: O(1) Auxiliary Space: O(1) C  ",
        "code": "Input: N = 5, K = 1\nOutput: 4\n5 is represented as 101 in binary\nand has its first bit 1, so clearing\nit will result in 100 i.e. 4.\n\nInput: N = 5, K = 2\nOutput: 5\n5 is represented as 101 in binary\nand has its second bit is already 0,\nso clearing it will result in 101 i.e. 5.\nAny bit <bitwise AND> Reset bit = Reset bit\n\nwhich means,\n0 & 0 = 0\n1 & 0 = 0\nn = n & ~(1 << k)\nOR\nn &= ~(1 << k)\n\nwhere k is the bit that is to be cleared\n\n\n\n\n\n\n\n\n\n\n\n\n4\n",
        "complexity": {
            "time": "Time Complexity: O(1)",
            "space": ""
        },
        "tags": [
            "Bitwise Algorithms"
        ],
        "url": "https://www.geeksforgeeks.org/program-to-clear-k-th-bit-of-a-number-n/"
    },
    {
        "title": "Toggle bits in the given range",
        "description": "Given a non-negative number n and two values l and r. The problem is to toggle the bits in the range l to r in the binary representation of n, i.e., to toggle bits from the lth least significant bit bit to the rth least significant bit (the rightmost bit as counted as first bit). A toggle operation flips a bit 0 to 1 and a bit 1 to 0.Constraint: 1 <= l <= r <= number of bits in the binary representation of n.Examples: Input: n = 17, l = 1, r = 3Output: 22Explanation: (17)10 = (10001)2                       (22)10 = (10110)2The bits in the range 1 to 3 in the binary representation of 17 are toggled. Input: n = 50, l = 2, r = 5Output: 44 Explanation: (50)10 = (110010)2                       (44)10 = (101100)2The bits in the range 2 to 5 in the binary representation of 50 are toggled. Approach: Following are the steps: Time Complexity: O(1)Auxiliary Space: O(1) Approach 2: Iterate over the given range from L to R and check if the ith bit is set or not. if the ith bit is set then make it unset otherwise make it set bit. Time Complexity: O(R – L + 1) Auxiliary Space: O(1)   ",
        "code": "// C++ implementation to toggle bits in\n// the given range\n#include <bits/stdc++.h>\nusing namespace std;\n\n// function to toggle bits in the given range\nunsigned int toggleBitsFromLToR(unsigned int n,\n                                unsigned int l,\n                                unsigned int r)\n{\n    // calculating a number 'num' having 'r'\n    // number of bits and bits in the range l\n    // to r are the only set bits\n    int num = ((1 << r) - 1) ^ ((1 << (l - 1)) - 1);\n\n    // toggle bits in the range l to r in 'n'\n    // and return the number\n    // Besides this, we can calculate num as: num=(1<<r)-l .\n    return (n ^ num);\n}\n\n// Driver program to test above\nint main()\n{\n    unsigned int n = 17;\n    unsigned int l = 1, r = 3;\n    cout << toggleBitsFromLToR(n, l, r);\n    return 0;\n}\n// Java implementation to toggle bits in\n// the given range\nimport java.io.*;\n\nclass GFG {\n    // Function to toggle bits in the given range\n    static int toggleBitsFromLToR(int n, int l, int r)\n    {\n        // calculating a number 'num' having 'r'\n        // number of bits and bits in the range l\n        // to r are the only set bits\n        int num = ((1 << r) - 1) ^ ((1 << (l - 1)) - 1);\n\n        // toggle bits in the range l to r in 'n'\n        // and return the number\n        // Besides this, we can calculate num as:\n        // num=(1<<r)-l .\n        return (n ^ num);\n    }\n\n    // driver program\n    public static void main(String[] args)\n    {\n        int n = 50;\n        int l = 2, r = 5;\n        System.out.println(toggleBitsFromLToR(n, l, r));\n    }\n}\n\n// Contributed by Pramod Kumar\n// C# implementation to toggle bits\n// in the given range\nusing System;\n\nnamespace Toggle {\npublic class GFG {\n\n    // Function to toggle bits in the given range\n    static int toggleBitsFromLToR(int n, int l, int r)\n    {\n        // calculating a number 'num' having 'r'\n        // number of bits and bits in the range l\n        // to r are the only set bits\n        int num = ((1 << r) - 1) ^ ((1 << (l - 1)) - 1);\n\n        // toggle bits in the range l to r in 'n'\n        // Besides this, we can calculate num as:\n        // num=(1<<r)-l .\n        // and return the number\n        return (n ^ num);\n    }\n\n    // Driver Code\n    public static void Main()\n    {\n        int n = 50;\n        int l = 2, r = 5;\n        Console.Write(toggleBitsFromLToR(n, l, r));\n    }\n}\n}\n\n// This code is contributed by Sam007.\n<script>\n\n// Javascript implementation to toggle bits in\n// the given range\n\n// function to toggle bits in the given range\nfunction toggleBitsFromLToR(n, l, r)\n{\n    // calculating a number 'num' having 'r'\n    // number of bits and bits in the range l\n    // to r are the only set bits\n    var num = ((1 << r) - 1) ^ ((1 << (l - 1)) - 1);\n\n    // toggle bits in the range l to r in 'n'\n    // and return the number\n//Besides this, we can calculate num as: num=(1<<r)-l .\n    return (n ^ num);\n}\n\n// Driver program to test above\nvar n = 50;\nvar l = 2, r = 5;\ndocument.write( toggleBitsFromLToR(n, l, r));\n\n</script>\n<?php\n// PHP implementation \n// to toggle bits in\n// the given range\n\n// function to toggle bits \n// in the given range\nfunction toggleBitsFromLToR($n, $l, $r)\n{\n    \n    // calculating a number \n    // 'num' having 'r'\n    // number of bits and \n    // bits in the range l\n    // to r are the only \n    // set bits\n    $num = ((1 << $r) - 1) ^ \n           ((1 << ($l - 1)) - 1);\n\n    // toggle bits in the \n    // range l to r in 'n'\n    //Besides this, we can calculate num as: $num=(1<<$r)-$l .\n    // and return the number\n\n    return ($n ^ $num);\n}\n\n    // Driver Code\n    $n = 50;\n    $l = 2; $r = 5;\n    echo toggleBitsFromLToR($n, $l, $r);\n\n// This code is contributed by anuj_67\n?>\n# Python implementation\n# to toggle bits in\n# the given range\n\n# function to toggle bits\n# in the given range\n\n\ndef toggleBitsFromLToR(n, l, r):\n\n    # calculating a number\n    # 'num' having 'r'\n    # number of bits and\n    # bits in the range l\n    # to r are the only set bits\n    num = ((1 << r) - 1) ^ ((1 << (l - 1)) - 1)\n\n    # toggle bits in the\n    # range l to r in 'n'\n    # Besides this, we can calculate num as: num=(1<<r)-l .\n\n    # and return the number\n    return (n ^ num)\n\n# Driver code\n\n\nn = 50\nl = 2\nr = 5\n\nprint(toggleBitsFromLToR(n, l, r))\n\n# This code is contributed\n# by Anant Agarwal.\n44\n// C++ implementation to toggle bits in\n// the given range\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n// Function to toggle bits in the given range\nint toggleBitsFromLToR(int N, int L, int R)\n{\n    int res = N;\n    for (int i = L; i <= R; i++) {\n\n        // Set bit\n        if ((N & (1 << (i - 1))) != 0) {\n\n            // XOR will set 0 to already set\n            // bits(a^a=0)\n            res = res ^ (1 << (i - 1));\n        }\n\n        // unset bits\n        else {\n            // OR will set'0'bits to 1\n            res = res | (1 << (i - 1));\n        }\n    }\n    return res;\n}\n\n// Driver code\nint main()\n{\n    int n = 50;\n    int l = 2, r = 5;\n    cout << toggleBitsFromLToR(n, l, r);\n\n    return 0;\n}\n\n// This code is contributed by phasing17\n// Java implementation to toggle bits in\n// the given range\nimport java.io.*;\n\nclass GFG {\n\n    // Function to toggle bits in the given range\n    static int toggleBitsFromLToR(int N, int L, int R)\n    {\n        int res = N;\n        for (int i = L; i <= R; i++) {\n\n            // Set bit\n            if ((N & (1 << (i - 1))) != 0) {\n\n                // XOR will set 0 to already set\n                // bits(a^a=0)\n                res = res ^ (1 << (i - 1));\n            }\n\n            // unset bits\n            else {\n                // OR will set'0'bits to 1\n                res = res | (1 << (i - 1));\n            }\n        }\n        return res;\n    }\n\n    // Driver method\n    public static void main(String[] args)\n    {\n        int n = 50;\n        int l = 2, r = 5;\n        System.out.println(toggleBitsFromLToR(n, l, r));\n    }\n}\n\n// Contributed by Ocean Bhardwaj\n// C# implementation to toggle bits in\n// the given range\nusing System;\n\nclass GFG {\n\n  // Function to toggle bits in the given range\n  static int toggleBitsFromLToR(int N, int L, int R)\n  {\n    int res = N;\n    for (int i = L; i <= R; i++) {\n\n      // Set bit\n      if ((N & (1 << (i - 1))) != 0) {\n\n        // XOR will set 0 to already set\n        // bits(a^a=0)\n        res = res ^ (1 << (i - 1));\n      }\n\n      // unset bits\n      else {\n        // OR will set'0'bits to 1\n        res = res | (1 << (i - 1));\n      }\n    }\n    return res;\n  }\n\n  // Driver Code\n  public static void Main(string[] args)\n  {\n    int n = 50;\n    int l = 2, r = 5;\n\n    // Function call\n    Console.WriteLine(toggleBitsFromLToR(n, l, r));\n  }\n}\n\n// This code is Contributed by phasing17\n// JavaScript implementation to toggle bits in\n// the given range\n\n// Function to toggle bits in the given range\nfunction toggleBitsFromLToR(N, L, R)\n{\n    let res = N;\n    for (let i = L; i <= R; i++) {\n\n        // Set bit\n        if ((N & (1 << (i - 1))) != 0) {\n\n            // XOR will set 0 to already set\n            // bits(a^a=0)\n            res = res ^ (1 << (i - 1));\n        }\n\n        // unset bits\n        else {\n            // OR will set'0'bits to 1\n            res = res | (1 << (i - 1));\n        }\n    }\n    return res;\n}\n\n\n// Driver code\nlet n = 50;\nlet l = 2, r = 5;\nconsole.log(toggleBitsFromLToR(n, l, r));\n\n\n\n// This code is contributed by phasing17\n# Python3 implementation to toggle bits in\n# the given range\n\n# Function to toggle bits in the given range\ndef toggleBitsFromLToR(N, L, R):\n\n    res = N\n    for i in range(L, R + 1):\n\n        # Set bit\n        if ((N & (1 << (i - 1))) != 0):\n\n            # XOR will set 0 to already set\n            # bits(a^a=0)\n            res = res ^ (1 << (i - 1))\n\n        # unset bits\n        else:\n            # OR will set'0'bits to 1\n            res = res | (1 << (i - 1))\n\n    return res\n\n# Driver code\nn = 50\nl = 2\nr = 5\nprint(toggleBitsFromLToR(n, l, r))\n\n# This code is contributed by phasing17\n44\n",
        "complexity": {
            "time": "Time Complexity: O(R – L + 1) Auxiliary Space: O(1)",
            "space": ""
        },
        "tags": [
            "Bitwise Algorithms"
        ],
        "url": "https://www.geeksforgeeks.org/toggle-bits-given-range/"
    },
    {
        "title": "Left Shift and Right Shift Operators in C/C++",
        "description": "In C/C++, left shift (<<) and right shift (>>) operators are binary bitwise operators that are used to shift the bits either left or right of the first operand by the number of positions specified by the second operand allowing efficient data manipulation. In this article, we will learn about the left shift and right shift operators. Let’s take a look at an example: The left shift(<<) is a binary operator that takes two numbers, left shifts the bits of the first operand, and the second operand decides the number of places to shift. In other words, left-shifting an integer “a” with an integer “b” denoted as ‘(a<<b)’ is equivalent to multiplying a with 2^b (2 raised to power b). where, Example: Let’s take a=21; which is 10101 in Binary Form. Now, if “a is left-shifted by 1” i.e a = a << 1 then a will become a = a * ( 2 ^ 1). Thus, a = 21 * (2 ^ 1) = 42 which can be written as 101010. But if the size of the data type of a is only 5 bits, then the first bit will be discarded we will be left with a = 10, which is 01010 in binary. It is shown in the below image. Right Shift(>>) is a binary operator that takes two numbers, right shifts the bits of the first operand, and the second operand decides the number of places to shift. In other words, right-shifting an integer “a” with an integer “b” denoted as ‘(a>>b)‘ is equivalent to dividing a with 2^b. where, Example: Let’s take a=21; which is 10101 in Binary Form. Now, if a is right shifted by 1 i.e a = a >> 1 then a will become a=a/(2^1). Thus, a = a/(2^1) = 10 which can be written as 1010. 1. The left-shift and right-shift operators should not be used for negative numbers. The result of is undefined behavior if any of the operands is a negative number. For example, results of both 1 >> -1 and 1 << -1 is undefined. 2. If the number is shifted more than the size of the integer, the behavior is undefined. For example, 1 << 33 is undefined if integers are stored using 32 bits. For bit shift of larger values 1ULL<<62  ULL is used for Unsigned Long Long which is defined using 64 bits that can store large values. 3. The left-shift by 1 and right-shift by 1 are equivalent to the product of the first term and 2 to the power given element(1<<3 = 1*pow(2,3)) and division of the first term and second term raised to power 2 (1>>3 = 1/pow(2,3)) respectively. Must Read: Bitwise Operators in C/C++  ",
        "code": "#include <iostream>\nusing namespace std;\n\nint main() {\n  \n    // a = 21(00010101)\n    unsigned char a = 21;\n\n    // The result is 00101010\n    cout << \"a << 1 = \" << (a << 1) << endl;\n  \n  \t// The result is 00000101\n  \tcout << \"a >> 2 = \" << (a >> 2);\n\n    return 0;\n}\n#include <stdio.h>\n\nint main() {\n  \n    // a = 21(00010101)\n    unsigned char a = 21;\n\n    // The result is 00101010\n    printf(\"a << 1 = %d\\n\", (a << 1));\n  \n  \t// The result is 00000101\n  \tprintf(\"a >> 2 = %d\", (a >> 2));\n\n    return 0;\n}\na << 1 = 42\na >> 2 = 5\na << b;\n// C++ Program to demonstrate use\n// of left shift  operator\n#include <iostream>\nusing namespace std;\n\nint main() {\n  \n    // a = 21(00010101)\n    unsigned char a = 21;\n\n    // The result is 00101010\n    cout << \"a << 1 = \" << (a << 1);\n\n    return 0;\n}\n// C Program to demonstrate use\n// of left shift  operator\n#include <stdio.h>\n\nint main() {\n  \n    // a = 21(000010101)\n    unsigned char a = 21;\n\n    // The result is 00101010\n    printf(\"a << 1 = %d\\n\", (a << 1));\n\n    return 0;\n}\na << 1 = 42\na >> b;\n// C++ Program to demonstrate\n// use of right-shift operator\n#include <iostream>\nusing namespace std;\n\nint main() {\n    // a = 21(00010101)\n    unsigned char a = 21;\n\n    // The result is 00001010\n    cout << \"a >> 1 = \" << (a >> 1);\n\n    return 0;\n}\n// C Program to demonstrate\n// use of right-shift operator\n#include <stdio.h>\n\n// Driver code\nint main()\n{\n    // a = 21(00010101)\n    unsigned char a = 21;\n\n    // The result is 00001010\n    printf(\"a >> 1 = %d\\n\", (a >> 1));\n\n    return 0;\n}\na >> 1 = 10\n// C++ program to show behaviour of shift operators for\n// negative values\n#include <iostream>\n\nusing namespace std;\n\nint main()\n{\n    // left shift for negative value\n    cout << \"2 << -5 = \" << (2 << -5) << endl;\n\n    //    right shift for negative value\n    cout << \"2 >> -5 = \" << (2 >> -5) << endl;\n\n    return 0;\n}\n// C program to show behaviour of shift operators for\n// negative values\n#include <stdio.h>\n\nint main()\n{\n    // left shift for negative value\n    printf(\"2 << -5 = %d\\n\", (2 << -5));\n\n    //    right shift for negative value\n    printf(\"2 >> -5 = %d\", (2 >> -5));\n\n    return 0;\n}\n2 << -5 = 0\n2 >> -5 = 64\n//    c++ program to demonstrate the behaviour of bitwise\n// shift operators for large values\n#include <iostream>\n\nusing namespace std;\n\nint main()\n{\n    int N = 3;\n\n    // left shift by 65 digits\n    cout << \"3 << 65\" << (3 << 65) << endl;\n\n    return 0;\n}\n//    c program to demonstrate the behaviour of bitwise\n// shift operators for large values\n#include <stdio.h>\n\nint main()\n{\n    int N = 3;\n\n    // left shift of 65 digits\n    printf(\"3 << 65 = %d\", (3 << 65));\n\n    return 0;\n}\n3 << 650\n// C++ program to get the shifted values using pow()\n#include <cmath>\n#include <iostream>\n\nusing namespace std;\n\nint main()\n{\n    cout << \"2^5 using pow() function\" << pow(2, 5) << endl;\n\n    cout << \"2^5 using leftshift\" << (1 << 5) << endl;\n\n    return 0;\n}\n// C program for the above approach\n\n#include <math.h>\n#include <stdio.h>\n\nint main()\n{\n    printf(\"2^5 using pow() function: %.0f\\n\", pow(2, 5));\n    printf(\"2^5 using left shift: %d\\n\", (1 << 5));\n    return 0;\n}\n\n// This code is contributed Prince Kumar\n2^5 using pow() function32\n2^5 using leftshift32\n",
        "complexity": {
            "time": "",
            "space": ""
        },
        "tags": [
            "Bitwise Algorithms"
        ],
        "url": "https://www.geeksforgeeks.org/left-shift-right-shift-operators-c-cpp/"
    },
    {
        "title": "Generate n-bit Gray Codes",
        "description": "Given a number N, generate bit patterns from 0 to 2^N-1 such that successive patterns differ by one bit. Examples: Method-1 The above sequences are Gray Codes of different widths. Following is an interesting pattern in Gray Codes.n-bit Gray Codes can be generated from list of (n-1)-bit Gray codes using following steps. For example, following are steps for generating the 3-bit Gray code list from the list of 2-bit Gray code list. L1 = {00, 01, 11, 10} (List of 2-bit Gray Codes) L2 = {10, 11, 01, 00} (Reverse of L1) Prefix all entries of L1 with ‘0’, L1 becomes {000, 001, 011, 010} Prefix all entries of L2 with ‘1’, L2 becomes {110, 111, 101, 100} Concatenate L1 and L2, we get {000, 001, 011, 010, 110, 111, 101, 100} To generate n-bit Gray codes, we start from list of 1 bit Gray codes. The list of 1 bit Gray code is {0, 1}. We repeat above steps to generate 2 bit Gray codes from 1 bit Gray codes, then 3-bit Gray codes from 2-bit Gray codes till the number of bits becomes equal to n. Below is the implementation of the above approach:                Time Complexity: O(2N)Auxiliary Space: O(2N) Method 2: Recursive Approach The idea is to recursively append the bit 0 and 1 each time until the number of bits is not equal to N. Base Condition: The base case for this problem will be when the value of N = 0 or 1. If (N == 0)return {“0”}if (N == 1)return {“0”, “1”} Recursive Condition: Otherwise, for any value greater than 1, recursively generate the gray codes of the N – 1 bits and then for each of the gray code generated add the prefix 0 and 1. Below is the implementation of the above approach:                Time Complexity: O(2N)Auxiliary Space: O(2N) Method3: (Using bitset) We should first find binary no from 1 to n and then convert it into string and then print it using substring function of string. Below is the implementation of the above idea:                Time Complexity: O(2N)Auxiliary Space: O(N)  ",
        "code": "Input: N = 2\nOutput: 00 01 11 10\n\nInput: N = 3\nOutput: 000 001 011 010 110 111 101 100\n\n\n\n\n\n\n\n\n\n\n000\n001\n011\n010\n110\n111\n101\n100\n\n\n\n\n\n\n\n\n\n\n000\n001\n011\n010\n110\n111\n101\n100\n\n\n\n\n\n\n\n\n\n\n0000 0001 0011 0010 0110 0111 0101 0100 1100 1101 1111 1110 1010 1011 1001 1000\n",
        "complexity": {
            "time": "Time Complexity: O(2N)Auxiliary Space: O(N)",
            "space": ""
        },
        "tags": [
            "Bitwise Algorithms"
        ],
        "url": "https://www.geeksforgeeks.org/generate-n-bit-gray-codes/"
    },
    {
        "title": "Program to find whether a given number is power of 2",
        "description": "Given a positive integer n, the task is to find if it is a power of 2 or not. Examples: Input : n = 16Output : YesExplanation: 24 = 16 Input : n = 42Output : NoExplanation: 42 is not a power of 2 Input : n = 1Output : YesExplanation: 20 = 1 The idea is to use the mathematical property that if a number n is a power of 2, then log2(n) will be an integer. We can compute log2(n) and check if it’s an integer by comparing if 2 raised to the power of log2(n) equals n. The idea is to repeatedly divide the number by 2 and check if there’s any remainder during the process. If n is a power of 2, then dividing it by 2 repeatedly will eventually reduce it to 1 without encountering any odd number in between. If at any point n becomes odd (except for the final value 1), then n is not a power of 2. The idea is to leverage the binary representation of powers of 2, which always have exactly one bit set to 1 (the rest are 0). We can count the number of set bits in the binary representation of n, and if there’s exactly one set bit, then n is a power of 2. This works because powers of 2 have the form 2^k, which in binary is a 1 followed by k zeros. The idea is to use bit manipulation based on the observation that if n is a power of 2, then its binary representation has exactly one bit set to 1, and n-1 will have all bits to the right of that bit set to 1. Therefore, n & (n-1) will always be 0 for powers of 2. This provides an elegant one-line solution to check if a number is a power of 2 or not. The idea is to use a bit manipulation technique similar to approach 4, but with a different pattern. When n is a power of 2, it has exactly one bit set to 1. For n-1, all bits to the right of that single set bit will be 1, and the set bit itself will be 0. Taking the NOT of (n-1) flips all these bits, resulting in a number where all bits to the right of the original set bit position will be 0, and all bits to the left (including the bit position itself) will be 1. When we perform n & (~(n-1)), for a power of 2, this operation preserves the original number n because the only set bit in n aligns with a set bit in ~(n-1). For non-powers of 2, this equality doesn’t hold.  ",
        "code": "// C++ program to find whether\n// a given number is power of 2\n#include <iostream>\n#include <cmath>\nusing namespace std;\n\nbool isPowerofTwo(int n) {\n    if (n <= 0)\n        return false;\n    \n    // Calculate log base 2 of n\n    int logValue = log2(n);\n    \n    // Check if log2(n) is an integer\n    // and 2^(logn) = n\n    return pow(2, logValue) == n;\n}\n\nint main() {\n    int n = 16;\n    if (isPowerofTwo(n)) {\n        cout << \"Yes\" << endl;\n    }\n    else {\n        cout << \"No\" << endl;\n    }\n}\n// Java program to find whether\n// a given number is power of 2\nimport java.lang.Math;\n\nclass GfG {\n    \n    static boolean isPowerofTwo(int n) {\n        if (n <= 0)\n            return false;\n        \n        // Calculate log base 2 of n\n        int logValue = (int)(Math.log(n) / Math.log(2));\n        \n        // Check if log2(n) is an integer\n        // and 2^(logn) = n\n        return Math.pow(2, logValue) == n;\n    }\n\n    public static void main(String[] args) {\n        int n = 16;\n        if (isPowerofTwo(n)) {\n            System.out.println(\"Yes\");\n        } else {\n            System.out.println(\"No\");\n        }\n    }\n}\n# Python program to find whether\n# a given number is power of 2\nimport math\n\ndef isPowerofTwo(n):\n    if n <= 0:\n        return False\n    \n    # Calculate log base 2 of n\n    logValue = int(math.log2(n))\n    \n    # Check if log2(n) is an integer\n    # and 2^(logn) = n\n    return pow(2, logValue) == n\n\nif __name__ == \"__main__\":\n    n = 16\n    if isPowerofTwo(n):\n        print(\"Yes\")\n    else:\n        print(\"No\")\n// C# program to find whether\n// a given number is power of 2\nusing System;\n\nclass GfG {\n    \n    static bool isPowerofTwo(int n) {\n        if (n <= 0)\n            return false;\n        \n        // Calculate log base 2 of n\n        int logValue = (int)(Math.Log(n, 2));\n        \n        // Check if log2(n) is an integer\n        // and 2^(logn) = n\n        return Math.Pow(2, logValue) == n;\n    }\n\n    static void Main() {\n        int n = 16;\n        if (isPowerofTwo(n)) {\n            Console.WriteLine(\"Yes\");\n        } else {\n            Console.WriteLine(\"No\");\n        }\n    }\n}\n// JavaScript program to find whether\n// a given number is power of 2\n\nfunction isPowerofTwo(n) {\n    if (n <= 0)\n        return false;\n    \n    // Calculate log base 2 of n\n    let logValue = Math.floor(Math.log2(n));\n    \n    // Check if log2(n) is an integer\n    // and 2^(logn) = n\n    return Math.pow(2, logValue) === n;\n}\n\nlet n = 16;\nif (isPowerofTwo(n)) {\n    console.log(\"Yes\");\n} else {\n    console.log(\"No\");\n}\nYes\n// C++ program to find whether\n// a given number is power of 2\n#include <iostream>\nusing namespace std;\n\nbool isPowerofTwo(int n) {\n    if (n <= 0)\n        return false;\n    \n    while (n > 1) {\n        if (n % 2 != 0)\n            return false;\n        n = n / 2;\n    }\n    return true;\n}\n\nint main() {\n    int n = 16;\n    if (isPowerofTwo(n)) {\n        cout << \"Yes\" << endl;\n    }\n    else {\n        cout << \"No\" << endl;\n    }\n}\n// Java program to find whether\n// a given number is power of 2\n\nclass GfG {\n    \n    static boolean isPowerofTwo(int n) {\n        if (n <= 0)\n            return false;\n        \n        while (n > 1) {\n            if (n % 2 != 0)\n                return false;\n            n = n / 2;\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        int n = 16;\n        if (isPowerofTwo(n)) {\n            System.out.println(\"Yes\");\n        } else {\n            System.out.println(\"No\");\n        }\n    }\n}\n# Python program to find whether\n# a given number is power of 2\n\ndef isPowerofTwo(n):\n    if n <= 0:\n        return False\n    \n    while n > 1:\n        if n % 2 != 0:\n            return False\n        n = n // 2\n    return True\n\nif __name__ == \"__main__\":\n    n = 16\n    if isPowerofTwo(n):\n        print(\"Yes\")\n    else:\n        print(\"No\")\n// C# program to find whether\n// a given number is power of 2\nusing System;\n\nclass GfG {\n    \n    static bool isPowerofTwo(int n) {\n        if (n <= 0)\n            return false;\n        \n        while (n > 1) {\n            if (n % 2 != 0)\n                return false;\n            n = n / 2;\n        }\n        return true;\n    }\n\n    static void Main() {\n        int n = 16;\n        if (isPowerofTwo(n)) {\n            Console.WriteLine(\"Yes\");\n        } else {\n            Console.WriteLine(\"No\");\n        }\n    }\n}\n// JavaScript program to find whether\n// a given number is power of 2\n\nfunction isPowerofTwo(n) {\n    if (n <= 0)\n        return false;\n    \n    while (n > 1) {\n        if (n % 2 !== 0)\n            return false;\n        n = Math.floor(n / 2);\n    }\n    return true;\n}\n\nlet n = 16;\nif (isPowerofTwo(n)) {\n    console.log(\"Yes\");\n} else {\n    console.log(\"No\");\n}\nYes\n// C++ program to find whether\n// a given number is power of 2\n#include <iostream>\nusing namespace std;\n\nbool isPowerofTwo(int n) {\n    if (n <= 0)\n        return false;\n    \n    // Count set bits\n    int count = 0;\n    while (n > 0) {\n        if (n & 1)\n            count++;\n        n = n >> 1;\n    }\n    \n    // If count of set bits is 1, \n    // then n is a power of 2\n    return (count == 1);\n}\n\nint main() {\n    int n = 16;\n    if (isPowerofTwo(n)) {\n        cout << \"Yes\" << endl;\n    }\n    else {\n        cout << \"No\" << endl;\n    }\n}\n// Java program to find whether\n// a given number is power of 2\n\nclass GfG {\n    \n    static boolean isPowerofTwo(int n) {\n        if (n <= 0)\n            return false;\n        \n        // Count set bits\n        int count = 0;\n        while (n > 0) {\n            if ((n & 1) != 0)\n                count++;\n            n = n >> 1;\n        }\n        \n        // If count of set bits is 1, \n        // then n is a power of 2\n        return (count == 1);\n    }\n\n    public static void main(String[] args) {\n        int n = 16;\n        if (isPowerofTwo(n)) {\n            System.out.println(\"Yes\");\n        } else {\n            System.out.println(\"No\");\n        }\n    }\n}\n# Python program to find whether\n# a given number is power of 2\n\ndef isPowerofTwo(n):\n    if n <= 0:\n        return False\n    \n    # Count set bits\n    count = 0\n    while n > 0:\n        if n & 1:\n            count += 1\n        n = n >> 1\n    \n    # If count of set bits is 1, \n    # then n is a power of 2\n    return count == 1\n\nif __name__ == \"__main__\":\n    n = 16\n    if isPowerofTwo(n):\n        print(\"Yes\")\n    else:\n        print(\"No\")\n// C# program to find whether\n// a given number is power of 2\nusing System;\n\nclass GfG {\n    \n    static bool isPowerofTwo(int n) {\n        if (n <= 0)\n            return false;\n        \n        // Count set bits\n        int count = 0;\n        while (n > 0) {\n            if ((n & 1) != 0)\n                count++;\n            n = n >> 1;\n        }\n        \n        // If count of set bits is 1, \n        // then n is a power of 2\n        return (count == 1);\n    }\n\n    static void Main() {\n        int n = 16;\n        if (isPowerofTwo(n)) {\n            Console.WriteLine(\"Yes\");\n        } else {\n            Console.WriteLine(\"No\");\n        }\n    }\n}\n// JavaScript program to find whether\n// a given number is power of 2\n\nfunction isPowerofTwo(n) {\n    if (n <= 0)\n        return false;\n    \n    // Count set bits\n    let count = 0;\n    while (n > 0) {\n        if (n & 1)\n            count++;\n        n = n >> 1;\n    }\n    \n    // If count of set bits is 1, \n    // then n is a power of 2\n    return count === 1;\n}\n\nlet n = 16;\nif (isPowerofTwo(n)) {\n    console.log(\"Yes\");\n} else {\n    console.log(\"No\");\n}\nYes\n// C++ program to find whether\n// a given number is power of 2\n#include <iostream>\nusing namespace std;\n\nbool isPowerofTwo(int n) {\n    \n    // Check if n is positive and n & (n-1) is 0\n    return (n > 0) && ((n & (n-1)) == 0);\n}\n\nint main() {\n    int n = 16;\n    if (isPowerofTwo(n)) {\n        cout << \"Yes\" << endl;\n    }\n    else {\n        cout << \"No\" << endl;\n    }\n}\n// Java program to find whether\n// a given number is power of 2\n\nclass GfG {\n    \n    static boolean isPowerofTwo(int n) {\n        \n        // Check if n is positive and n & (n-1) is 0\n        return (n > 0) && ((n & (n - 1)) == 0);\n    }\n\n    public static void main(String[] args) {\n        int n = 16;\n        if (isPowerofTwo(n)) {\n            System.out.println(\"Yes\");\n        } else {\n            System.out.println(\"No\");\n        }\n    }\n}\n# Python program to find whether\n# a given number is power of 2\n\ndef isPowerofTwo(n):\n    \n    # Check if n is positive and n & (n-1) is 0\n    return (n > 0) and ((n & (n - 1)) == 0)\n\nif __name__ == \"__main__\":\n    n = 16\n    if isPowerofTwo(n):\n        print(\"Yes\")\n    else:\n        print(\"No\")\n// C# program to find whether\n// a given number is power of 2\nusing System;\n\nclass GfG {\n    \n    static bool isPowerofTwo(int n) {\n        \n        // Check if n is positive and n & (n-1) is 0\n        return (n > 0) && ((n & (n - 1)) == 0);\n    }\n\n    static void Main() {\n        int n = 16;\n        if (isPowerofTwo(n)) {\n            Console.WriteLine(\"Yes\");\n        } else {\n            Console.WriteLine(\"No\");\n        }\n    }\n}\n// JavaScript program to find whether\n// a given number is power of 2\n\nfunction isPowerofTwo(n) {\n    \n    // Check if n is positive and n & (n-1) is 0\n    return (n > 0) && ((n & (n - 1)) === 0);\n}\n\nlet n = 16;\nif (isPowerofTwo(n)) {\n    console.log(\"Yes\");\n} else {\n    console.log(\"No\");\n}\nYes\n// C++ program to find whether\n// a given number is power of 2\n#include <iostream>\nusing namespace std;\n\nbool isPowerofTwo(int n) {\n    \n    // Check if n is positive and n & ~(n-1) equals n\n    return (n > 0) && ((n & (~(n-1))) == n);\n}\n\nint main() {\n    int n = 16;\n    if (isPowerofTwo(n)) {\n        cout << \"Yes\" << endl;\n    }\n    else {\n        cout << \"No\" << endl;\n    }\n}\n// Java program to find whether\n// a given number is power of 2\nclass GfG {\n    \n    // Check if n is positive and n & ~(n-1) equals n\n    static boolean isPowerofTwo(int n) {\n        return (n > 0) && ((n & (~(n - 1))) == n);\n    }\n\n    public static void main(String[] args) {\n        int n = 16;\n        if (isPowerofTwo(n)) {\n            System.out.println(\"Yes\");\n        } else {\n            System.out.println(\"No\");\n        }\n    }\n}\n# Python program to find whether\n# a given number is power of 2\n\ndef isPowerofTwo(n):\n    \n    # Check if n is positive and n & ~(n-1) equals n\n    return (n > 0) and ((n & (~(n - 1))) == n)\n\nif __name__ == \"__main__\":\n    n = 16\n    if isPowerofTwo(n):\n        print(\"Yes\")\n    else:\n        print(\"No\")\n// C# program to find whether\n// a given number is power of 2\nusing System;\n\nclass GfG {\n    \n    static bool isPowerofTwo(int n) {\n        \n        // Check if n is positive and n & ~(n-1) equals n\n        return (n > 0) && ((n & (~(n - 1))) == n);\n    }\n\n    static void Main() {\n        int n = 16;\n        if (isPowerofTwo(n)) {\n            Console.WriteLine(\"Yes\");\n        } else {\n            Console.WriteLine(\"No\");\n        }\n    }\n}\n// JavaScript program to find whether\n// a given number is power of 2\n\nfunction isPowerofTwo(n) {\n    \n    // Check if n is positive and n & ~(n-1) equals n\n    return (n > 0) && ((n & (~(n - 1))) === n);\n}\n\nlet n = 16;\nif (isPowerofTwo(n)) {\n    console.log(\"Yes\");\n} else {\n    console.log(\"No\");\n}\nYes\n",
        "complexity": {
            "time": "",
            "space": ""
        },
        "tags": [
            "Bitwise Algorithms"
        ],
        "url": "https://www.geeksforgeeks.org/program-to-find-whether-a-given-number-is-power-of-2/"
    },
    {
        "title": "Bits manipulation (Important tactics)",
        "description": "Prerequisites: Bitwise operators in C, Bitwise Hacks for Competitive Programming, Bit Tricks for Competitive Programming Table of Contents The  problem can be solved based on the following observations: Say x = n%4. The XOR value depends on the value if x. If Below is the implementation of the above approach. Time Complexity: O(1)Auxiliary Space: O(1) Refer Compute XOR from 1 to n for details. The count of such numbers x can be counted using the following mathematical trick. The count = pow(2, count of zero bits). Refer Equal Sum and XOR for details. Time complexity: O(log n) Auxiliary Space: O(1) This can be solved based on the following fact: If a number N is a power of 2, then the bitwise AND of N and N-1 will be 0. But this will not work if N is 0. So just check these two conditions, if any of these two conditions is true. Refer check if a number is power of two for details. Below is the implementation of the above approach. Time Complexity: O(1)Auxiliary Space: O(1) We can do it in O(1) time. The answer is always 0 if the given set has more than one element. For sets with a single element, the answer is the value of the single element. Refer XOR of the XOR’s of all subsets for details. We can quickly find the number of leading, trailing zeroes and number of 1’s in a binary code of an integer in C++ using GCC. It can be done by using inbuilt functions i.e. Number of leading zeroes: __builtin_clz(x)Number of trailing zeroes : __builtin_ctz(x)Number of 1-bits: __builtin_popcount(x) Refer GCC inbuilt functions for details. Time Complexity: O(1)Auxiliary Space: O(1) Two numbers can be swapped easily using the following bitwise operations: a ^= b;b ^= a; a ^= b; Time Complexity: O(1)Auxiliary Space: O(1) Refer swap two numbers for more details. We can find the most significant set bit in O(1) time for a fixed size integer. For example below code is for 32-bit integer. Time Complexity: O(1)Auxiliary Space: O(1) Refer Find most significant set bit of a number for details. We can quickly check if bits in a number are in an alternate pattern (like 101010). Compute bitwise XOR (XOR denoted using ^) of n and (n >> 1). If n has an alternate pattern, then n ^ (n >> 1) operation will produce a number having all bits set. Below is the implementation of the above approach. Time Complexity: O(1)Auxiliary Space: O(1) Refer check if a number has bits in alternate pattern for details. DSA Self Paced Course   ",
        "code": "// Direct XOR of all numbers from 1 to n\nint computeXOR(int n)\n{\n    if (n % 4 == 0)\n        return n;\n    if (n % 4 == 1)\n        return 1;\n    if (n % 4 == 2)\n        return n + 1;\n    else\n        return 0;\n}\n/*package whatever //do not write package name here */\nimport java.io.*;\n\nclass GFG\n{\n  \n  // Direct XOR of all numbers from 1 to n\n  public static int computeXOR(int n)\n  {\n    if (n % 4 == 0)\n      return n;\n    if (n % 4 == 1)\n      return 1;\n    if (n % 4 == 2)\n      return n + 1;\n    else\n      return 0;\n  }\n\n  public static void main (String[] args) {\n\n  }\n}\n\n// This code is contributed by akashish__\n# Direct XOR of all numbers from 1 to n\ndef computeXOR(n):\n    if (n % 4 is 0):\n        return n\n    if (n % 4 is 1):\n        return 1\n    if (n % 4 is 2):\n        return n + 1\n    else:\n        return 0\n\n      \n# This code is contributed by akashish__\nusing System;\npublic class GFG\n{\n\n  // Direct XOR of all numbers from 1 to n\n  public static int computeXOR(int n)\n  {\n\n    if (n % 4 == 0)\n\n      return n;\n\n    if (n % 4 == 1)\n\n      return 1;\n\n    if (n % 4 == 2)\n\n      return n + 1;\n\n    else\n\n      return 0;\n\n  }\n  public static void Main(){}\n\n\n}\n\n// This code is contributed by akashish__\n<script>\n\n// Direct XOR of all numbers from 1 to n\nfunction computeXOR(n)\n{\n    if (n % 4 == 0)\n        return n;\n    if (n % 4 == 1)\n        return 1;\n    if (n % 4 == 2)\n        return n + 1;\n    else\n        return 0;\n}\n\n// This code is contributed by Shubham Singh\n\n</script>\n// Count of numbers (x) smaller than or equal to n such that n+x = n^x:\n// here unset bits means zero bits\n#include <bits/stdc++.h>\nusing namespace std;\n\n// function to count number of values less than\n// equal to n that satisfy the given condition\nint countValues(int n)\n{\n    // unset_bits keeps track of count of un-set\n    // bits in binary representation of n\n    int unset_bits=0;\n    while (n)\n    {\n        if ((n & 1) == 0)\n            unset_bits++;\n        n=n>>1;\n    }\n\n    // Return 2 ^ unset_bits i.e. pow(2,count of zero bits)\n    return 1 << unset_bits;\n}\n\n// Driver code\nint main()\n{\n    int n = 15;\n    cout << countValues(n);\n    return 0;\n}\n\n// contributed by akashish__\n// Count of numbers (x) smaller than or equal to n such that n+x = n^x:\n// here unset bits means zero bits\nimport java.io.*;\nclass GFG\n{\n\n  // function to count number of values less than\n  // equal to n that satisfy the given condition\n  public static int countValues(int n)\n  {\n    // unset_bits keeps track of count of un-set\n    // bits in binary representation of n\n    int unset_bits = 0;\n    while (n > 0)\n    {\n      if ((n & 1) == 0)\n        unset_bits++;\n      n = n>>1;\n    }\n\n    // Return 2 ^ unset_bits i.e. pow(2,count of zero bits)\n    return 1 << unset_bits;\n  }\n\n  // Driver code\n  public static void main (String[] args) {\n    int n = 15;\n    System.out.print(countValues(n));\n  }\n}\n\n// This code is contributed by poojaagrawal2.\n# Count of numbers (x) smaller than or equal to n such that n+x = n^x:\n# here unset bits means zero bits\n\n# function to count number of values less than\n# equal to n that satisfy the given condition\ndef countValues(n):\n  \n    # unset_bits keeps track of count of un-set\n    # bits in binary representation of n\n    unset_bits=0\n    while (n):\n        if ((n & 1) == 0):\n            unset_bits+=1\n        n=n>>1\n\n    # Return 2 ^ unset_bits i.e. pow(2,count of zero bits)\n    return 1 << unset_bits\n\n# Driver code\nn = 15\nprint(countValues(n))\n\n# This code is contributed by akashish__\n// C# code to implement the approach\nusing System;\nusing System.Collections.Generic;\n\nclass GFG {\n\n  // Count of numbers (x) smaller than or equal to n such that n+x = n^x:\n  // here unset bits means zero bits\n\n  // function to count number of values less than\n  // equal to n that satisfy the given condition\n  static int countValues(int n)\n  {\n\n    // unset_bits keeps track of count of un-set\n    // bits in binary representation of n\n    int unset_bits = 0;\n    while (n > 0)\n    {\n      if ((n & 1) == 0)\n        unset_bits++;\n      n = n>>1;\n    }\n\n    // Return 2 ^ unset_bits i.e. pow(2,count of zero bits)\n    return 1 << unset_bits;\n  }\n\n  // Driver code\n  public static void Main()\n  {\n    int n = 15;\n    Console.Write(countValues(n));\n  }\n}\n\n// This code is contributed by agrawalpoojaa976.\n// Count of numbers (x) smaller than or equal to n such that n+x = n^x:\n// here unset bits means zero bits\n\n// function to count number of values less than\n// equal to n that satisfy the given condition\nfunction countValues(n)\n{\n    // unset_bits keeps track of count of un-set\n    // bits in binary representation of n\n    let unset_bits=0;\n    while (n)\n    {\n        if ((n & 1) == 0)\n            unset_bits++;\n        n=n>>1;\n    }\n\n    // Return 2 ^ unset_bits i.e. pow(2,count of zero bits)\n    return 1 << unset_bits;\n}\n\n// Driver code\n    let n = 15;\n    document.write(countValues(n));\n1\n//  Function to check if x is power of 2\nbool isPowerOfTwo(int x)\n{\n     // First x in the below expression is\n     // for  the case when x is 0 \n     return x && (!(x & (x - 1)));\n}\n/*package whatever //do not write package name here */\nimport java.io.*;\n\nclass GFG {\n\n  //  Function to check if x is power of 2\n  static public boolean isPowerOfTwo(int x)\n  {\n\n    // First x in the below expression is\n    // for  the case when x is 0 \n    return (x != 0) && ((x & (x - 1)) == 0);\n  }\n\n  public static void main (String[] args) {\n\n\n  }\n}\n// contributed by akashish__\n#  Function to check if x is power of 2\ndef isPowerOfTwo(x):\n  \n  # First x in the below expression is\n  # for  the case when x is 0 \n  return x and (not(x & (x - 1)))\n\n# This code is contributed by akashish__\nusing System;\n\npublic class GFG{\n  \n  //  Function to check if x is power of 2\nstatic public bool isPowerOfTwo(int x)\n{\n     // First x in the below expression is\n     // for  the case when x is 0 \n       return (x != 0) && ((x & (x - 1)) == 0);\n}\n\n    static public void Main (){\n\n    }\n}\n\n// This code is contributed by akashish__\n//  Function to check if x is power of 2\nfunction isPowerOfTwo(x)\n{\n     // First x in the below expression is\n     // for  the case when x is 0 \n     return x && (!(x & (x - 1)));\n}\n\n// This code is contributed by akashish__\n// Conversion into Binary code\n\n#include <iostream>\nusing namespace std;\n\nint main()\n{\n    auto number = 0b011;\n    cout << number;\n    return 0;\n}\n/*package whatever //do not write package name here */\n// Conversion into Binary code\nimport java.io.*;\n\nclass GFG {\n    public static void main(String[] args)\n    {\n        int number = 0b011;\n        System.out.println(number);\n    }\n}\n\n// This code is contributed by akashish__\n# Python Code\nnumber = 0b011\nprint(number)\n\n# This code is contributed by akashish__\n// Conversion into Binary code\n\nusing System;\n\npublic class GFG {\n\n    static public void Main()\n    {\n\n        // Code\n        int number = 0b011;\n        Console.WriteLine(number);\n    }\n}\n\n// This code is contributed by karthik\n// Conversion into Binary code\n\nlet number = 0b011;\nconsole.log(number);\n3\n#include <iostream>\nusing namespace std;\n\nint main()\n{\n    int a = 5;\n      int b = 7;\n      cout<<\"Before Swapping, a = \"<<a<<\" \"<<\"b = \"<<b<<endl;\n    a ^= b;\n    b ^= a;\n    a ^= b;\n      cout<<\"After Swapping, a = \"<<a<<\" \"<<\"b = \"<<b<<endl;\n    return 0;\n}\n\n// This code is contributed by akashish__\n/*package whatever //do not write package name here */\nimport java.io.*;\nimport java.util.*;\n\nclass GFG {\n  public static void main(String[] args)\n  {\n    int a = 5;\n    int b = 7;\n    System.out.print(\"Before Swapping, a = \");\n    System.out.print(a);\n    System.out.print(\" \");\n    System.out.print(\"b = \");\n    System.out.print(b);\n    System.out.println(\"\");\n    a ^= b;\n    b ^= a;\n    a ^= b;\n    System.out.print(\"After Swapping, a = \");\n    System.out.print(a);\n    System.out.print(\" \");\n    System.out.print(\"b = \");\n    System.out.print(b);\n  }\n}\n\n// This code is contributed by akashish__\na = 5\nb = 7\nprint(\"Before Swapping, a = \",a,\" \",\"b = \",b)\na ^= b\nb ^= a\na ^= b\nprint(\"After Swapping, a = \",a,\" \",\"b = \",b)\n\n# This code is contributed by akashish__\nusing System;\n\npublic class GFG {\n\n    static public void Main()\n    {\n\n        int a = 5;\n        int b = 7;\n        Console.WriteLine(\"Before Swapping, a = \" + a + \" \"\n                          + \"b = \" + b);\n        a ^= b;\n        b ^= a;\n        a ^= b;\n        Console.WriteLine(\"After Swapping, a = \" + a + \" \"\n                          + \"b = \" + b);\n    }\n}\n// This code is contributed by akashish__\nlet a = 5;\nlet b = 7;\nconsole.log(\"Before Swapping, a = \" , a , \" \" , \"b = \" , b);\na ^= b;\nb ^= a;\na ^= b;\nconsole.log(\"After Swapping, a = \" , a , \" \" , \"b = \" , b);\n\n// This code is contributed by akashish__\nBefore Swapping, a = 5 b = 7\nAfter Swapping, a = 7 b = 5\nint setBitNumber(int n)\n{\n    // Below steps set bits after\n    // MSB (including MSB)\n\n    // Suppose n is 273 (binary\n    // is 100010001). It does following\n    // 100010001 | 010001000 = 110011001\n    n |= n >> 1;\n\n    // This makes sure 4 bits\n    // (From MSB and including MSB)\n    // are set. It does following\n    // 110011001 | 001100110 = 111111111\n    n |= n >> 2;\n\n    n |= n >> 4;\n    n |= n >> 8;\n    n |= n >> 16;\n\n    // Increment n by 1 so that\n    // there is only one set bit\n    // which is just before original\n    // MSB. n now becomes 1000000000\n    n = n + 1;\n\n    // Return original MSB after shifting.\n    // n now becomes 100000000\n    return (n >> 1);\n}\n/*package whatever //do not write package name here */\n\nimport java.io.*;\n\nclass GFG {\n\n  public static int setBitNumber(int n)\n  {\n    // Below steps set bits after\n    // MSB (including MSB)\n\n    // Suppose n is 273 (binary\n    // is 100010001). It does following\n    // 100010001 | 010001000 = 110011001\n    n |= n >> 1;\n\n    // This makes sure 4 bits\n    // (From MSB and including MSB)\n    // are set. It does following\n    // 110011001 | 001100110 = 111111111\n    n |= n >> 2;\n\n    n |= n >> 4;\n    n |= n >> 8;\n    n |= n >> 16;\n\n    // Increment n by 1 so that\n    // there is only one set bit\n    // which is just before original\n    // MSB. n now becomes 1000000000\n    n = n + 1;\n\n    // Return original MSB after shifting.\n    // n now becomes 100000000\n    return (n >> 1);\n  }\n\n\n  public static void main (String[] args) {\n  }\n}\n\n// This code is contributed by akashish__\ndef setBitNumber(n):\n    # Below steps set bits after\n    # MSB (including MSB)\n\n    # Suppose n is 273 (binary\n    # is 100010001). It does following\n    # 100010001 | 010001000 = 110011001\n    n |= n >> 1\n\n    # This makes sure 4 bits\n    # (From MSB and including MSB)\n    # are set. It does following\n    # 110011001 | 001100110 = 111111111\n    n |= n >> 2\n\n    n |= n >> 4\n    n |= n >> 8\n    n |= n >> 16\n\n    # Increment n by 1 so that\n    # there is only one set bit\n    # which is just before original\n    # MSB. n now becomes 1000000000\n    n = n + 1\n\n    # Return original MSB after shifting.\n    # n now becomes 100000000\n    return (n >> 1)\n  \n# This code is contributed by akashish__\nusing System;\n\npublic class GFG{\n  \n  public static int setBitNumber(int n)\n{\n    // Below steps set bits after\n    // MSB (including MSB)\n\n    // Suppose n is 273 (binary\n    // is 100010001). It does following\n    // 100010001 | 010001000 = 110011001\n    n |= n >> 1;\n\n    // This makes sure 4 bits\n    // (From MSB and including MSB)\n    // are set. It does following\n    // 110011001 | 001100110 = 111111111\n    n |= n >> 2;\n\n    n |= n >> 4;\n    n |= n >> 8;\n    n |= n >> 16;\n\n    // Increment n by 1 so that\n    // there is only one set bit\n    // which is just before original\n    // MSB. n now becomes 1000000000\n    n = n + 1;\n\n    // Return original MSB after shifting.\n    // n now becomes 100000000\n    return (n >> 1);\n}\n\n    static public void Main (){\n\n        // Code\n    }\n}\n\n// This code is contributed by akashish__\nfunction setBitNumber(n)\n{\n    // Below steps set bits after\n    // MSB (including MSB)\n\n    // Suppose n is 273 (binary\n    // is 100010001). It does following\n    // 100010001 | 010001000 = 110011001\n    n |= n >> 1;\n\n    // This makes sure 4 bits\n    // (From MSB and including MSB)\n    // are set. It does following\n    // 110011001 | 001100110 = 111111111\n    n |= n >> 2;\n\n    n |= n >> 4;\n    n |= n >> 8;\n    n |= n >> 16;\n\n    // Increment n by 1 so that\n    // there is only one set bit\n    // which is just before original\n    // MSB. n now becomes 1000000000\n    n = n + 1;\n\n    // Return original MSB after shifting.\n    // n now becomes 100000000\n    return (n >> 1);\n}\n\n// This code is contributed by akashish__\n// function to check if all the bits\n// are set or not in the binary\n// representation of 'n'\nstatic bool allBitsAreSet(int n)\n{\n    // if true, then all bits are set\n    if (((n + 1) & n) == 0)\n        return true;\n\n    // else all bits are not set\n    return false;\n}\n\n// Function to check if a number\n// has bits in alternate pattern\nbool bitsAreInAltOrder(unsigned int n)\n{\n    unsigned int num = n ^ (n >> 1);\n\n    // To check if all bits are set in 'num'\n    return allBitsAreSet(num);\n}\n/*package whatever //do not write package name here */\nimport java.io.*;\n\nclass GFG {\n\n  // function to check if all the bits\n  // are set or not in the binary\n  // representation of 'n'\n  public static boolean allBitsAreSet(long n)\n  {\n\n    // if true, then all bits are set\n    if (((n + 1) & n) == 0)\n      return true;\n\n    // else all bits are not set\n    return false;\n  }\n\n  // Function to check if a number\n  // has bits in alternate pattern\n  public static boolean bitsAreInAltOrder(long n)\n  {\n    long num = n ^ (n >> 1);\n\n    // To check if all bits are set in 'num'\n    return allBitsAreSet(num);\n  }\n  public static void main (String[] args) {\n\n  }\n}\n\n// This code is contributed by akashish__\n# function to check if all the bits\n# are set or not in the binary\n# representation of 'n'\ndef allBitsAreSet(n):\n  # if true, then all bits are set\n  if (((n + 1) & n) == 0):\n    return True\n\n  # else all bits are not set\n  return False\n\n# Function to check if a number\n# has bits in alternate pattern\ndef bitsAreInAltOrder(n):\n  num = n ^ (n >> 1)\n\n  # To check if all bits are set in 'num'\n  return allBitsAreSet(num)\n\n\n# This code is contributed by akashish__\nusing System;\npublic class GFG \n{\n\n    // function to check if all the bits\n    // are set or not in the binary\n    // representation of 'n'\n    public static bool allBitsAreSet(uint n)\n    {\n      \n        // if true, then all bits are set\n        if (((n + 1) & n) == 0)\n            return true;\n\n        // else all bits are not set\n        return false;\n    }\n\n    // Function to check if a number\n    // has bits in alternate pattern\n    public static bool bitsAreInAltOrder(uint n)\n    {\n        uint num = n ^ (n >> 1);\n\n        // To check if all bits are set in 'num'\n        return allBitsAreSet(num);\n    }\n\n    static public void Main() {}\n}\n\n// This code is contributed by akashish__\n// function to check if all the bits\n// are set or not in the binary\n// representation of 'n'\nfunction allBitsAreSet(n)\n{\n    // if true, then all bits are set\n    if (((n + 1) & n) == 0)\n        return true;\n\n    // else all bits are not set\n    return false;\n}\n\n// Function to check if a number\n// has bits in alternate pattern\nfunction bitsAreInAltOrder(n)\n{\n    let num = n ^ (n >> 1);\n\n    // To check if all bits are set in 'num'\n    return allBitsAreSet(num);\n}\n\n// This code is contributed by akashish__\n",
        "complexity": {
            "time": "Time Complexity: O(1)Auxiliary Space: O(1)",
            "space": ""
        },
        "tags": [
            "Bitwise Algorithms"
        ],
        "url": "https://www.geeksforgeeks.org/bits-manipulation-important-tactics/"
    },
    {
        "title": "Bit Manipulation for Competitive Programming",
        "description": "Bit manipulation is a technique in competitive programming that involves the manipulation of individual bits in binary representations of numbers. It is a valuable technique in competitive programming because it allows you to solve problems efficiently, often reducing time complexity and memory usage. Table of Content Bitwise Operators are used to perform operations on individual bits in binary representations of numbers. Some common bitwise operators that are used in competitive programming:- This can be done by left-shifting the value 1 by 'pos' positions (1<< pos) and performing a bitwise OR operation with number n. This operation effectively turns on the bit at the specified position. This can be done by left-shifting the value 1 by pos positions (1<< pos) and then use bitwise NOT operator ‘~’ to unset this shifted 1, making the bit at position pos to 0 and then use Bitwise AND with the number n that will unset bit at desired positoon of number n. Use the bitwise XOR (^) operator to toggle (flip) the bit at the given position. If the bit is 0, it becomes 1, and if it's 1, it becomes 0. This can be done by performing a bitwise AND operation with a mask having only that bit set. If the result is non-zero, the bit is set; otherwise, it's unset. A power of two is a number with only one bit set in its binary representation, while the number just before it has that bit unset and all the following bits set. Consequently, when you perform a bitwise AND operation between a number and its predecessor, the result will always be 0. Suppose you are given an array a of n numbers and q queries and each query is of the form (l,r). The task is to compute Bitwise AND of the numbers from index l to r i.e., (al & al+1 .....  & ar-1 & ar). A simple approach will be for each query travese from index l to r and compute Bitwise AND. By this we will be able to answer each query in O(n) time in worst case. But to answer each query in constant time prefix sum can be a useful method. Below is the code for above approach: Note- When you increase the range for Bitwise AND, the result will never increase; it will either stay the same or decrease. This is a useful property and we can apply Binary search on answer we are given to determine the largest range whose Bitwise AND is greater than or equal to a given number. Bitwise OR can be computed in a similar way. WE will make temp and psum array in a similar way, Below is the code for above approach: Note: When you increase the range for Bitwise OR, the result will never decrease; it will either stay the same or increase. Again this is a useful property and we can apply Binary search on answer we are given to determine the smallest range whose Bitwise OR is smaller than or equal to a given number. Bitwise XOR for a range can be done in similar way:  Below is the implementation of the above approach: a|b = a⊕b + a&b a⊕(a&b) = (a|b)⊕b (a&b)⊕(a|b) = a⊕b a+b = a|b + a&b a+b = a⊕b + 2(a&b) In most of the problems involving bit manipulation it is better to work bit by bit i.e., break down the problem into individual bits. Focus on solving the problem for a single bit position before moving on to the next. Let's consider few examples: Example 1: Given an integer array arr. The task is to find the size of largest subset such that bitwise AND of all the elements of the subset is greater than 0. Solution: Example 2: Given an integer array arr of size n. A graph is formed using these elements. There exists an edge between index i and index j if i!=j and a[i] AND a[j]>0. The task is to determine whether there exists a cycle in the graph. Solution: Bitwise Analysis: We begin by analyzing each bit position in the binary representation of the numbers and for each bit determine how many elements have that bit set. Count Bit Sets of a Number Count Total Set Bits of a first N natural number Check whether the number has only first and last bits set Shortest path length between two given nodes such that adjacent nodes are at bit difference 2 Calculate Bitwise OR of two integers from their given Bitwise AND and Bitwise XOR values Unset least significant K bits of a given number Find all powers of 2 less than or equal to a given number Powers-2-required-sum Print bitwise AND set of a number N Print all submasks of a given mask Count of subsets not containing adjacent elements Find array such that no subarray has xor zero or Y Minimum Bitwise OR operations to make any two array elements equal Minimum Bitwise XOR operations to make any two array elements equal Minimum Bitwise AND operations to make any two array elements equal Longest substring whose characters can be rearranged to form a Palindrome Number of ordered pairs such that (Ai & Aj) = 0 Minimize product of first N – 1 natural numbers by swapping same positioned bits of pairs Minimum number N such that total set bits of all numbers from 1 to N is at-least X Find a number X such that XOR of given Array after adding X to each element is 0 Count numbers in the range [L, R] having only three set bits M  ",
        "code": "// n=number\n// pos=It is the position at which we want to set the bit\nvoid set(int & n, int pos)\n{\n     n |= (1 << pos);\n}\npublic class GFG {\n    // Function to set a bit at a given position\n    // in a number\n    static int setBit(int n, int pos)\n    {\n        return n | (1 << pos);\n    }\n}\n# n = number\n# pos = It is the position at which we want to set the bit\ndef set_bit(n, pos):\n    n |= (1 << pos)\n// Function to set a bit at the specified position in an\n// integer n: reference to the number pos: the position at\n// which the bit should be set\nstatic void Set(ref int n, int pos)\n{\n    // Use bitwise left shift (1 << pos) to create a mask\n    // with a 1 at the specified position Use bitwise OR\n    // assignment (|=) to set the bit at the specified\n    // position in the number\n    n |= (1 << pos);\n}\n// n = number\n// pos = It is the position at which we want to set the bit\nfunction set(n, pos) {\n    n |= (1 << pos);\n}\n//this code is contributed by Adarsh\n#include <iostream>\n\n// Unset (clear) a bit at position pos in number n\nvoid unset(int &n, int pos) {\n    n &= ~(1 << pos);\n}\n\nint main() {\n    int n = 15; // 1111 in binary\n    int pos = 1;\n    unset(n, pos); // Should change n to 13, which is 1101 in binary\n    std::cout << n << std::endl; // Output should be 13\n    return 0;\n}\npublic class UnsetBit {\n    // Unset (clear) a bit at position pos in number n\n    public static int unset(int n, int pos) {\n        n &= ~(1 << pos);\n        return n;\n    }\n\n    public static void main(String[] args) {\n        int n = 15; // 1111 in binary\n        int pos = 1;\n        n = unset(n, pos); // Should change n to 13, which is 1101 in binary\n        System.out.println(n); // Output should be 13\n    }\n}\ndef unset(n, pos):\n    n &= ~(1 << pos)\n    return n\n\n# Example usage\nn = 15  # 1111 in binary\npos = 1\nn = unset(n, pos)  # Should change n to 13, which is 1101 in binary\nprint(n)  # Output should be 13\nfunction unset(n, pos) {\n    n &= ~(1 << pos);\n    return n;\n}\n\n// Example usage\nlet n = 15; // 1111 in binary\nlet pos = 1;\nn = unset(n, pos); // Should change n to 13, which is 1101 in binary\nconsole.log(n); // Output should be 13\n// Flip (toggle) a bit at position pos in number n\nvoid flip(int &n, int pos) {\n    n ^= (1 << pos);\n}\n// Flip (toggle) a bit at position pos in number n\nstatic void flip(int[] n, int pos) {\n    n[0] ^= (1 << pos);\n}\n# Flip (toggle) a bit at position pos in number n\ndef flip_bit(n, pos):\n    n ^= (1 << pos)\n// Flip (toggle) a bit at position pos in number n\nfunction flip(n, pos) {\n    n ^= (1 << pos);\n    return n;\n}\n// Check if the bit at position pos in number n is set (1) or unset (0)\nbool isBitSet(int n, int pos) {\n    return ((n & (1 << pos)) != 0);\n}\nstatic boolean isBitSet(int n, int pos) {\n        return ((n & (1 << pos)) != 0);\n    }\n//This code is contributed by Kishan.\n# Check if the bit at position pos in number n is set (1) or unset (0)\ndef is_bit_set(n, pos):\n    return (n & (1 << pos)) != 0\n// Check if n is a power of two\nbool isPowerOfTwo(int n) {\n    return  ((n & (n - 1)) == 0);\n}\npublic class Main {\n  // Check if n is a power of two\n    public static boolean isPowerOfTwo(int n) {\n        return (n != 0) && ((n & (n - 1)) == 0);\n    }\n}\n# Check if n is a power of two\ndef is_power_of_two(n):\n    return (n & (n - 1)) == 0\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<vector<int>> prefixsumBit(vector<int>& nums) {\n    int n = nums.size();\n\n    // Step 1: Store bit information in 'temp'\n    vector<vector<int>> temp(n + 1, vector<int>(32, 0));\n    for (int i = 1; i <= n; ++i) {\n        int num = nums[i - 1]; // Fix indexing error\n        for (int j = 0; j < 32; ++j) {\n            // Check if the j-th bit of nums[i] is set\n            if (((1 << j) & num) != 0) { // Fix indexing error\n                temp[i][j] = 1;\n            }\n        }\n    }\n\n    // Step 2: Compute prefix sums\n    vector<vector<int>> psum(n + 1, vector<int>(32, 0));\n    for (int j = 0; j < 32; ++j) {\n        for (int i = 1; i <= n; ++i) {\n            // Calculate prefix sum for each bit\n            psum[i][j] = psum[i - 1][j] + temp[i][j];\n        }\n    }\n    return psum;\n}\n\nint rangeBitwiseAND(vector<vector<int>>& psum, int l, int r) {\n    int result = 0;\n    for (int j = 0; j < 32; ++j) {\n        // Calculate the count of elements with j-th bit set\n        // in the range [l, r]\n        int count = psum[r][j] - psum[l - 1][j];\n        if (count == r - l + 1) {\n            // If all elements in the range have j-th bit\n            // set, add it to the result\n            result = result + (1 << j);\n        }\n    }\n    return result;\n}\n\n// driver's code\nint main() {\n    // Input Array\n    vector<int> nums = { 13, 11, 2, 3, 6 };\n\n    // Range\n    int l = 2, r = 4;\n\n    // 2D prefix sum\n    vector<vector<int>> psum = prefixsumBit(nums);\n\n    cout << \"Bitwise AND of range [2,4] is: \" << rangeBitwiseAND(psum, l, r);\n\n    return 0;\n}\n// Java program for the above approach\nimport java.util.*;\n\npublic class GFG {\n\n    public static List<List<Integer> >\n    prefixsumBit(List<Integer> nums)\n    {\n        int n = nums.size();\n\n        // Step 1: Store bit information in 'temp'\n        List<List<Integer> > temp = new ArrayList<>();\n        for (int i = 0; i <= n; ++i) {\n            temp.add(new ArrayList<>(\n                Collections.nCopies(32, 0)));\n        }\n        for (int i = 1; i <= n; ++i) {\n            int num = nums.get(i - 1);\n            for (int j = 0; j < 32; ++j) {\n                // Check if the j-th bit of nums[i] is set\n                if (((1 << j) & num) != 0) {\n                    temp.get(i).set(j, 1);\n                }\n            }\n        }\n\n        // Step 2: Compute prefix sums\n        List<List<Integer> > psum = new ArrayList<>();\n        for (int i = 0; i <= n; ++i) {\n            psum.add(new ArrayList<>(\n                Collections.nCopies(32, 0)));\n        }\n        for (int j = 0; j < 32; ++j) {\n            for (int i = 1; i <= n; ++i) {\n                // Calculate prefix sum for each bit\n                psum.get(i).set(j,\n                                psum.get(i - 1).get(j)\n                                    + temp.get(i).get(j));\n            }\n        }\n        return psum;\n    }\n\n    public static int\n    rangeBitwiseAND(List<List<Integer> > psum, int l, int r)\n    {\n        int result = 0;\n        for (int j = 0; j < 32; ++j) {\n            // Calculate the count of elements with j-th bit\n            // set in the range [l, r]\n            int count = psum.get(r).get(j)\n                        - psum.get(l - 1).get(j);\n            if (count == r - l + 1) {\n                // If all elements in the range have j-th\n                // bit set, add it to the result\n                result = result + (1 << j);\n            }\n        }\n        return result;\n    }\n\n    public static void main(String[] args)\n    {\n        // Input Array\n        List<Integer> nums = new ArrayList<>(\n            Arrays.asList(13, 11, 2, 3, 6));\n\n        // Range\n        int l = 2, r = 4;\n\n        // 2D prefix sum\n        List<List<Integer> > psum = prefixsumBit(nums);\n\n        System.out.println(\n            \"Bitwise AND of range [2,4] is : \"\n            + rangeBitwiseAND(psum, l, r));\n    }\n}\n\n// This code is contributed by Susobhan Akhuli\ndef prefixsumBit(nums):\n    n = len(nums)\n    temp = [[0] * 32 for _ in range(n + 1)]\n\n    # Step 1: Store bit information in 'temp'\n    for i in range(1, n + 1):\n        num = nums[i - 1]\n        for j in range(32):\n            # Check if the j-th bit of nums[i] is set\n            if ((1 << j) & num) != 0:\n                temp[i][j] = 1\n\n    # Step 2: Compute prefix sums\n    psum = [[0] * 32 for _ in range(n + 1)]\n    for j in range(32):\n        for i in range(1, n + 1):\n            # Calculate prefix sum for each bit\n            psum[i][j] = psum[i - 1][j] + temp[i][j]\n\n    return psum\n\n\ndef rangeBitwiseAND(psum, l, r):\n    result = 0\n    for j in range(32):\n        # Calculate the count of elements with j-th bit set\n        # in the range [l, r]\n        count = psum[r][j] - psum[l - 1][j]\n        if count == r - l + 1:\n            # If all elements in the range have j-th bit\n            # set, add it to the result\n            result += (1 << j)\n    return result\n\n\n# driver's code\nif __name__ == \"__main__\":\n    # Input Array\n    nums = [13, 11, 2, 3, 6]\n    # Range\n    l, r = 2, 4\n    # 2D prefix sum\n    psum = prefixsumBit(nums)\n    print(\"Bitwise AND of range [2,4] is:\", rangeBitwiseAND(psum, l, r))\nfunction GFG(nums) {\n    const n = nums.length;\n    // Step 1: Store bit information in 'temp'\n    const temp = new Array(n + 1).fill(0).map(() => new Array(32).fill(0));\n    for (let i = 1; i <= n; ++i) {\n        let num = nums[i - 1];\n        for (let j = 0; j < 32; ++j) {\n            // Check if the j-th bit of the nums[i] is set\n            if (((1 << j) & num) !== 0) {\n                temp[i][j] = 1;\n            }\n        }\n    }\n    // Step 2: Compute prefix sums\n    const psum = new Array(n + 1).fill(0).map(() => new Array(32).fill(0));\n    for (let j = 0; j < 32; ++j) {\n        for (let i = 1; i <= n; ++i) {\n            // Calculate prefix sum for the each bit\n            psum[i][j] = psum[i - 1][j] + temp[i][j];\n        }\n    }\n    return psum;\n}\n// Function to compute bitwise AND of range [l, r]\nfunction rangeBitwiseAND(psum, l, r) {\n    let result = 0;\n    for (let j = 0; j < 32; ++j) {\n        // Calculate the count of elements with j-th bit set\n        // in the range [l, r]\n        const count = psum[r][j] - psum[l - 1][j];\n        if (count === r - l + 1) {\n            result += (1 << j);\n        }\n    }\n    return result;\n}\n// Main function\nfunction main() {\n    // Input Array\n    const nums = [13, 11, 2, 3, 6];\n    const l = 2, r = 4;\n    const psum = GFG(nums);\n    console.log(`Bitwise AND of range [${l},${r}] is : ${rangeBitwiseAND(psum, l, r)}`);\n}\n// Invoke main function\nmain();\nBitwise AND of range [2,4] is: 2\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<vector<int>> prefixsumBit(vector<int>& nums) {\n    int n = nums.size();\n    vector<vector<int>> temp(n + 1, vector<int>(32, 0));\n\n    // Step 1: Store bit information in 'temp'\n    for (int i = 1; i <= n; ++i) {\n        int num = nums[i - 1];\n        for (int j = 0; j < 32; ++j) {\n            // Check if the j-th bit of nums[i] is set\n            if ((1 << j) & num) {\n                temp[i][j] = 1;\n            }\n        }\n    }\n\n    // Step 2: Compute prefix sums\n    vector<vector<int>> psum(n + 1, vector<int>(32, 0));\n    for (int j = 0; j < 32; ++j) {\n        for (int i = 1; i <= n; ++i) {\n            // Calculate prefix sum for each bit\n            psum[i][j] = psum[i - 1][j] + temp[i][j];\n        }\n    }\n\n    return psum;\n}\n\nint rangeBitwiseOR(vector<vector<int>>& psum, int l, int r) {\n    int result = 0;\n    for (int j = 0; j < 32; ++j) {\n        // Calculate the count of elements with j-th bit set\n        // in the range [l, r]\n        int count = psum[r][j] - psum[l - 1][j];\n\n        // If at least one element in the range has j-th bit\n        // set, add it to the result\n        if (count > 0) {\n            result += (1 << j);\n        }\n    }\n    return result;\n}\n\n// Driver's code\nint main() {\n    // Input Array\n    vector<int> nums = {13, 11, 2, 3, 6};\n    // Range\n    int l = 2, r = 4;\n    // 2D prefix sum\n    vector<vector<int>> psum = prefixsumBit(nums);\n    cout << \"Bitwise OR of range [2,4] is: \" << rangeBitwiseOR(psum, l, r) << endl;\n\n    return 0;\n}\nimport java.util.*;\n\npublic class Main {\n    public static int[][] prefixsumBit(int[] nums) {\n        int n = nums.length;\n        int[][] temp = new int[n + 1][32];\n\n        // Step 1: Store bit information in 'temp'\n        for (int i = 1; i <= n; ++i) {\n            int num = nums[i - 1];\n            for (int j = 0; j < 32; ++j) {\n                // Check if the j-th bit of nums[i] is set\n                if (((1 << j) & num) != 0) {\n                    temp[i][j] = 1;\n                }\n            }\n        }\n\n        // Step 2: Compute prefix sums\n        int[][] psum = new int[n + 1][32];\n        for (int j = 0; j < 32; ++j) {\n            for (int i = 1; i <= n; ++i) {\n                // Calculate prefix sum for each bit\n                psum[i][j] = psum[i - 1][j] + temp[i][j];\n            }\n        }\n\n        return psum;\n    }\n\n    public static int rangeBitwiseOR(int[][] psum, int l, int r) {\n        int result = 0;\n        for (int j = 0; j < 32; ++j) {\n            // Calculate the count of elements with j-th bit set\n            // in the range [l, r]\n            int count = psum[r][j] - psum[l - 1][j];\n\n            // If at least one element in the range has j-th bit\n            // set, add it to the result\n            if (count > 0) {\n                result += (1 << j);\n            }\n        }\n        return result;\n    }\n\n    public static void main(String[] args) {\n        // Input Array\n        int[] nums = {13, 11, 2, 3, 6};\n        // Range\n        int l = 2, r = 4;\n        // 2D prefix sum\n        int[][] psum = prefixsumBit(nums);\n        System.out.println(\"Bitwise OR of range [2,4] is: \" + rangeBitwiseOR(psum, l, r));\n    }\n}\ndef prefixsumBit(nums):\n    n = len(nums)\n    temp = [[0] * 32 for _ in range(n + 1)]\n\n    # Step 1: Store bit information in 'temp'\n    for i in range(1, n + 1):\n        num = nums[i - 1]\n        for j in range(32):\n            # Check if the j-th bit of nums[i] is set\n            if (1 << j) & num:\n                temp[i][j] = 1\n\n    # Step 2: Compute prefix sums\n    psum = [[0] * 32 for _ in range(n + 1)]\n    for j in range(32):\n        for i in range(1, n + 1):\n            # Calculate prefix sum for each bit\n            psum[i][j] = psum[i - 1][j] + temp[i][j]\n\n    return psum\n\n\ndef rangeBitwiseOR(psum, l, r):\n    result = 0\n    for j in range(32):\n        # Calculate the count of elements with j-th bit set\n        # in the range [l, r]\n        count = psum[r][j] - psum[l - 1][j]\n\n        # If at least one element in the range has j-th bit\n        # set, add it to the result\n        if count > 0:\n            result += (1 << j)\n\n    return result\n\n\n# Driver's code\nif __name__ == \"__main__\":\n    # Input Array\n    nums = [13, 11, 2, 3, 6]\n    # Range\n    l, r = 2, 4\n    # 2D prefix sum\n    psum = prefixsumBit(nums)\n    print(\"Bitwise OR of range [2,4] is:\", rangeBitwiseOR(psum, l, r))\nusing System;\nusing System.Collections.Generic;\n\nclass Program\n{\n    static List<List<int>> PrefixSumBit(List<int> nums)\n    {\n        int n = nums.Count;\n\n        //  Store bit information in 'temp'\n        List<List<int>> temp = new List<List<int>>(n + 1);\n        for (int i = 0; i <= n; ++i)\n        {\n            temp.Add(new List<int>(32));\n            for (int j = 0; j < 32; ++j)\n            {\n                temp[i].Add(0);\n            }\n        }\n\n        for (int i = 1; i <= n; ++i)\n        {\n            int num = nums[i - 1];\n            for (int j = 0; j < 32; ++j)\n            {\n                // Check if the j-th bit of nums[i] is set\n                if (((1 << j) & num) != 0)\n                {\n                    temp[i][j] = 1;\n                }\n            }\n        }\n\n        //  Compute prefix sums\n        List<List<int>> psum = new List<List<int>>(n + 1);\n        for (int i = 0; i <= n; ++i)\n        {\n            psum.Add(new List<int>(32));\n            for (int j = 0; j < 32; ++j)\n            {\n                psum[i].Add(0);\n            }\n        }\n\n        for (int j = 0; j < 32; ++j)\n        {\n            for (int i = 1; i <= n; ++i)\n            {\n                // Calculate prefix sum for each bit\n                psum[i][j] = psum[i - 1][j] + temp[i][j];\n            }\n        }\n        return psum;\n    }\n\n    static int RangeBitwiseOR(List<List<int>> psum, int l, int r)\n    {\n        int result = 0;\n        for (int j = 0; j < 32; ++j)\n        {\n            // Calculate the count of elements with j-th bit set\n            // in the range [l, r]\n            int count = psum[r][j] - psum[l - 1][j];\n\n            // If at least one element in the range has j-th bit\n            // set, add it to the result\n            if (count > 0)\n            {\n                result = result + (1 << j);\n            }\n        }\n        return result;\n    }\n\n    // driver's code\n    static void Main()\n    {\n        // Input Array\n        List<int> nums = new List<int> { 13, 11, 2, 3, 6 };\n\n        // Range\n        int l = 2, r = 4;\n\n        // 2D prefix sum\n        List<List<int>> psum = PrefixSumBit(nums);\n\n        Console.WriteLine($\"Bitwise OR of range [2,4] is : {RangeBitwiseOR(psum, l, r)}\");\n    }\n}\nfunction prefixSumBit(nums) {\n    const n = nums.length;\n\n    // Step 1: Store bit information in 'temp'\n    const temp = Array.from({ length: n + 1 }, () => Array(32).fill(0));\n    for (let i = 1; i <= n; ++i) {\n        const num = nums[i - 1];\n        for (let j = 0; j < 32; ++j) {\n            // Check if the j-th bit of nums[i] is set\n            if (((1 << j) & num) !== 0) {\n                temp[i][j] = 1;\n            }\n        }\n    }\n\n    // Step 2: Compute prefix sums\n    const psum = Array.from({ length: n + 1 }, () => Array(32).fill(0));\n    for (let j = 0; j < 32; ++j) {\n        for (let i = 1; i <= n; ++i) {\n            // Calculate prefix sum for each bit\n            psum[i][j] = psum[i - 1][j] + temp[i][j];\n        }\n    }\n    return psum;\n}\n\nfunction rangeBitwiseOR(psum, l, r) {\n    let result = 0;\n    for (let j = 0; j < 32; ++j) {\n        // Calculate the count of elements with j-th bit set\n        // in the range [l, r]\n        const count = psum[r][j] - psum[l - 1][j];\n\n        // If at least one element in the range has j-th bit\n        // set, add it to the result\n        if (count > 0) {\n            result = result + (1 << j);\n        }\n    }\n    return result;\n}\n\n// Driver's code\nfunction main() {\n    // Input Array\n    const nums = [13, 11, 2, 3, 6];\n\n    // Range\n    const l = 2, r = 4;\n\n    // 2D prefix sum\n    const psum = prefixSumBit(nums);\n\n    console.log(\"Bitwise OR of range [2,4] is:\", rangeBitwiseOR(psum, l, r));\n}\n\n// Call the main function\nmain();\nBitwise OR of range [2,4] is: 11\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<vector<int>> prefixsumBit(vector<int>& nums)\n{\n    int n = nums.size();\n\n    // Step 1: Store bit information in 'temp'\n    vector<vector<int>> temp(n + 1, vector<int>(32, 0));\n    for (int i = 1; i <= n; ++i) { // Fixed indexing\n        int num = nums[i - 1]; // Fixed indexing\n        for (int j = 0; j < 32; ++j) {\n            // Check if the j-th bit of nums[i] is set\n            if (((1 << j) & num) != 0) { // Fixed indexing\n                temp[i][j] = 1;\n            }\n        }\n    }\n\n    // Step 2: Compute prefix sums\n    vector<vector<int>> psum(n + 1, vector<int>(32, 0));\n    for (int j = 0; j < 32; ++j) {\n        for (int i = 1; i <= n; ++i) {\n            // Calculate prefix sum for each bit\n            psum[i][j] = psum[i - 1][j] + temp[i][j];\n        }\n    }\n    return psum;\n}\n\nint rangeBitwiseXOR(vector<vector<int>>& psum, int l,\n                    int r)\n{\n    int result = 0;\n    for (int j = 0; j < 32; ++j) {\n        // Calculate the count of elements with j-th bit set\n        // in the range [l, r]\n        int count = psum[r][j] - psum[l - 1][j];\n\n        // If count is odd, add it to the result\n        if (count % 2 == 1) {\n            result = result + (1 << j);\n        }\n    }\n    return result;\n}\n\n// driver's code\nint main()\n{\n    // Input Array\n    vector<int> nums = { 13, 11, 2, 3, 6 };\n\n    // Range\n    int l = 2, r = 4;\n\n    // 2D prefix sum\n    vector<vector<int>> psum = prefixsumBit(nums);\n\n    cout << \"Bitwise XOR of range [2,4] is :\" << rangeBitwiseXOR(psum, l, r);\n\n    return 0;\n}\n// Java Code\n\npublic class PrefixSumBit {\n\n    // Function to compute the prefix sum of bits for each element in nums\n    public static int[][] prefixSumBit(int[] nums) {\n        int n = nums.length;\n        int[][] temp = new int[n + 1][32];\n\n        // Step 1: Store bit information in 'temp'\n        for (int i = 1; i <= n; i++) {\n            int num = nums[i - 1];\n            for (int j = 0; j < 32; j++) {\n                // Check if the j-th bit of nums[i] is set\n                if ((1 << j & num) != 0) {\n                    temp[i][j] = 1;\n                }\n            }\n        }\n\n        // Step 2: Compute prefix sums\n        int[][] psum = new int[n + 1][32];\n        for (int j = 0; j < 32; j++) {\n            for (int i = 1; i <= n; i++) {\n                // Calculate prefix sum for each bit\n                psum[i][j] = psum[i - 1][j] + temp[i][j];\n            }\n        }\n\n        return psum;\n    }\n\n    // Function to calculate bitwise XOR of range [l, r]\n    public static int rangeBitwiseXOR(int[][] psum, int l, int r) {\n        int result = 0;\n        for (int j = 0; j < 32; j++) {\n            // Calculate the count of elements with j-th bit set\n            // in the range [l, r]\n            int count = psum[r][j] - psum[l - 1][j];\n\n            // If count is odd, add it to the result\n            if (count % 2 == 1) {\n                result += (1 << j);\n            }\n        }\n\n        return result;\n    }\n\n    // Driver's code\n    public static void main(String[] args) {\n        // Input Array\n        int[] nums = {13, 11, 2, 3, 6};\n        // Range\n        int l = 2, r = 4;\n        // 2D prefix sum\n        int[][] psum = prefixSumBit(nums);\n        System.out.println(\"Bitwise XOR of range [2,4] is: \" + rangeBitwiseXOR(psum, l, r));\n    }\n}\n\n// This Code is contributed by guptapratik\ndef prefixsumBit(nums):\n    n = len(nums)\n    temp = [[0] * 32 for _ in range(n + 1)]\n\n    # Step 1: Store bit information in 'temp'\n    for i in range(1, n + 1):\n        num = nums[i - 1]\n        for j in range(32):\n            # Check if the j-th bit of nums[i] is set\n            if (1 << j) & num:\n                temp[i][j] = 1\n\n    # Step 2: Compute prefix sums\n    psum = [[0] * 32 for _ in range(n + 1)]\n    for j in range(32):\n        for i in range(1, n + 1):\n            # Calculate prefix sum for each bit\n            psum[i][j] = psum[i - 1][j] + temp[i][j]\n\n    return psum\n\n\ndef rangeBitwiseXOR(psum, l, r):\n    result = 0\n    for j in range(32):\n        # Calculate the count of elements with j-th bit set\n        # in the range [l, r]\n        count = psum[r][j] - psum[l - 1][j]\n\n        # If count is odd, add it to the result\n        if count % 2 == 1:\n            result += (1 << j)\n\n    return result\n\n\n# Driver's code\nif __name__ == \"__main__\":\n    # Input Array\n    nums = [13, 11, 2, 3, 6]\n    # Range\n    l, r = 2, 4\n    # 2D prefix sum\n    psum = prefixsumBit(nums)\n    print(\"Bitwise XOR of range [2,4] is:\", rangeBitwiseXOR(psum, l, r))\n// C# program for the above approach\nusing System;\nusing System.Collections.Generic;\n\npublic class GFG {\n    // Function to compute the prefix sum of each bit in the\n    // given array\n    static List<List<int> > PrefixSumBit(List<int> nums)\n    {\n        int n = nums.Count;\n\n        // Step 1: Store bit information in 'temp'\n        List<List<int> > temp = new List<List<int> >();\n        for (int i = 0; i <= n; ++i) {\n            temp.Add(new List<int>(\n                new int[32])); // Initialize with 32 zeros\n            if (i > 0) {\n                int num = nums[i - 1];\n                for (int j = 0; j < 32; ++j) {\n                    // Check if the j-th bit of nums[i] is\n                    // set\n                    if (((1 << j) & num) != 0) {\n                        temp[i][j] = 1;\n                    }\n                }\n            }\n        }\n\n        // Step 2: Compute prefix sums\n        List<List<int> > psum = new List<List<int> >();\n        for (int i = 0; i <= n; ++i) {\n            psum.Add(new List<int>(\n                new int[32])); // Initialize with 32 zeros\n        }\n        for (int j = 0; j < 32; ++j) {\n            for (int i = 1; i <= n; ++i) {\n                // Calculate prefix sum for each bit\n                psum[i][j] = psum[i - 1][j] + temp[i][j];\n            }\n        }\n        return psum;\n    }\n\n    // Function to compute the bitwise XOR of the range [l,\n    // r]\n    static int RangeBitwiseXOR(List<List<int> > psum, int l,\n                               int r)\n    {\n        int result = 0;\n        for (int j = 0; j < 32; ++j) {\n            // Calculate the count of elements with j-th bit\n            // set in the range [l, r]\n            int count = psum[r][j] - psum[l - 1][j];\n\n            // If count is odd, add it to the result\n            if (count % 2 == 1) {\n                result = result + (1 << j);\n            }\n        }\n        return result;\n    }\n\n    // Main method\n    public static void Main(string[] args)\n    {\n        // Input Array\n        List<int> nums = new List<int>{ 13, 11, 2, 3, 6 };\n\n        // Range\n        int l = 2, r = 4;\n\n        // 2D prefix sum\n        List<List<int> > psum = PrefixSumBit(nums);\n\n        Console.WriteLine(\"Bitwise XOR of range [2,4] is: \"\n                          + RangeBitwiseXOR(psum, l, r));\n    }\n}\n\n// This code is contributed by Susobhan Akhuli\n// Function to compute the prefix sum of bits for each element in nums\nfunction prefixSumBit(nums) {\n    let n = nums.length;\n    let temp = new Array(n + 1).fill(null).map(() => new Array(32).fill(0));\n\n    // Step 1: Store bit information in 'temp'\n    for (let i = 1; i <= n; i++) {\n        let num = nums[i - 1];\n        for (let j = 0; j < 32; j++) {\n            // Check if the j-th bit of nums[i] is set\n            if ((1 << j & num) !== 0) {\n                temp[i][j] = 1;\n            }\n        }\n    }\n\n    // Step 2: Compute prefix sums\n    let psum = new Array(n + 1).fill(null).map(() => new Array(32).fill(0));\n    for (let j = 0; j < 32; j++) {\n        for (let i = 1; i <= n; i++) {\n            // Calculate prefix sum for each bit\n            psum[i][j] = psum[i - 1][j] + temp[i][j];\n        }\n    }\n\n    return psum;\n}\n\n// Function to calculate bitwise XOR of range [l, r]\nfunction rangeBitwiseXOR(psum, l, r) {\n    let result = 0;\n    for (let j = 0; j < 32; j++) {\n        // Calculate the count of elements with j-th bit set\n        // in the range [l, r]\n        let count = psum[r][j] - psum[l - 1][j];\n\n        // If count is odd, add it to the result\n        if (count % 2 === 1) {\n            result += (1 << j);\n        }\n    }\n\n    return result;\n}\n\n// Driver's code\nfunction main() {\n    // Input Array\n    let nums = [13, 11, 2, 3, 6];\n    // Range\n    let l = 2, r = 4;\n    // 2D prefix sum\n    let psum = prefixSumBit(nums);\n    console.log(\"Bitwise XOR of range [2,4] is: \" + rangeBitwiseXOR(psum, l, r));\n}\n\n// Calling the main function\nmain();\nBitwise XOR of range [2,4] is :10\n",
        "complexity": {
            "time": "Bit manipulation is a technique in competitive programming that involves the manipulation of individual bits in binary representations of numbers. It is a valuable technique in competitive programming because it allows you to solve problems efficiently, often reducing time complexity and memory usage.",
            "space": ""
        },
        "tags": [
            "Bitwise Algorithms"
        ],
        "url": "https://www.geeksforgeeks.org/bit-manipulation-for-competitive-programming/"
    },
    {
        "title": "Fast Exponentiation using Bit Manipulation",
        "description": "Given two integers A and N, the task is to calculate A raised to power N (i.e. AN). Examples: Input: A = 3, N = 5 Output: 243 Explanation: 3 raised to power 5 = (3*3*3*3*3) = 243 Input: A = 21, N = 4Output: 194481 Explanation: 21 raised to power 4 = (21*21*21*21) = 194481 Naive Approach: The simplest approach to solve this problem is to repetitively multiply A, N times and print the product. Time Complexity: O(N) Auxiliary Space: O(1) Efficient Approach: To optimize the above approach, the idea is to use Bit Manipulation. Convert the integer N to its binary form and follow the steps below: Below is the implementation of the above approach: Time Complexity: O(logN) Auxiliary Space: O(1) Recursive exponentiation is a method used to efficiently compute AN, where A & N are integers. It leverages recursion to break down the problem into smaller subproblems. Follow the steps below : Below is the implementation of the above approach : Complexity Analysis : Time Complexity: O(logN) Auxiliary Space: O(1) T  ",
        "code": "#include <iostream>\nusing namespace std;\n\n// Function to calculate power using brute force approach\nlong long findPower(int a, int n) {\n    long long result = 1;\n\n    // Multiply 'a' by itself 'n' times\n    for (int i = 0; i < n; ++i) {\n        result *= a;\n    }\n\n    return result;\n}\n\nint main() {\n    int a = 3;\n    int n = 5;\n\n    // Calculate and display the result\n    long long result = findPower(a, n);\n    cout<<result<<endl;\n    return 0;\n}\npublic class Main {\n    // Function to calculate power using brute force approach\n    static long findPower(int a, int n) {\n        long result = 1;\n\n        // Multiply 'a' by itself 'n' times\n        for (int i = 0; i < n; ++i) {\n            result *= a;\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        int a = 3;\n        int n = 5;\n\n        // Calculate and display the result\n        long result = findPower(a, n);\n        System.out.println(result);\n    }\n}\n//This code is contributed by Aman\n# Function to calculate power using brute force approach\ndef findPower(a, n):\n    result = 1\n\n    # Multiply 'a' by itself 'n' times\n    for i in range(n):\n        result *= a\n\n    return result\n\n# Main function\na = 3\nn = 5\n\n# Calculate and display the result\nresult = findPower(a, n)\nprint(result)\n\n# This code is contributed by Yash Agarwal(yashagarwal2852002)\nusing System;\n\npublic class PowerCalculation\n{\n    // Function to calculate power using brute force approach\n    public static long FindPower(int a, int n)\n    {\n        long result = 1;\n\n        // Multiply 'a' by itself 'n' times\n        for (int i = 0; i < n; ++i)\n        {\n            result *= a;\n        }\n\n        return result;\n    }\n\n    public static void Main(string[] args)\n    {\n        int a = 3;\n        int n = 5;\n\n        // Calculate and display the result\n        long result = FindPower(a, n);\n        Console.WriteLine(result);\n    }\n}\n// Function to calculate power using brute force approach\nfunction findPower(a, n) {\n    let result = 1;\n\n    // Multiply 'a' by itself 'n' times\n    for (let i = 0; i < n; i++) {\n        result *= a;\n    }\n\n    return result;\n}\n\n// Main function\nconst a = 3;\nconst n = 5;\n\n// Calculate and display the result\nconst result = findPower(a, n);\nconsole.log(result);\n//This code is contributed by Aman.\n243\n// C++ Program to implement\n// the above approach\n#include <iostream>\nusing namespace std;\n\n// Function to return a^n\nint powerOptimised(int a, int n)\n{\n\n    // Stores final answer\n    int ans = 1;\n\n    while (n > 0) {\n\n        int last_bit = (n & 1);\n\n        // Check if current LSB\n        // is set\n        if (last_bit) {\n            ans = ans * a;\n        }\n\n        a = a * a;\n\n        // Right shift\n        n = n >> 1;\n    }\n\n    return ans;\n}\n\n// Driver Code\nint main()\n{\n    int a = 3, n = 5;\n\n    cout << powerOptimised(a, n);\n\n    return 0;\n}\n// Java program to implement \n// the above approach \nclass GFG{ \n\n// Function to return a^n \nstatic int powerOptimised(int a, int n) \n{ \n\n    // Stores final answer \n    int ans = 1; \n\n    while (n > 0) \n    { \n        int last_bit = (n & 1); \n\n        // Check if current LSB \n        // is set \n        if (last_bit > 0)\n        { \n            ans = ans * a; \n        } \n        \n        a = a * a; \n\n        // Right shift \n        n = n >> 1; \n    } \n    return ans; \n} \n\n// Driver Code \npublic static void main(String[] args) \n{ \n    int a = 3, n = 5; \n\n    System.out.print(powerOptimised(a, n)); \n}\n}\n\n// This code is contributed by PrinciRaj1992\n# Python3 program to implement\n# the above approach\n\n# Function to return a^n\ndef powerOptimised(a, n):\n    \n    # Stores final answer \n    ans = 1\n    \n    while (n > 0):\n        last_bit = (n & 1)\n        \n        # Check if current LSB \n        # is set \n        if (last_bit):\n            ans = ans * a\n        a = a * a\n        \n        # Right shift \n        n = n >> 1\n        \n    return ans\n\n# Driver code\nif __name__ == '__main__':\n    \n    a = 3\n    n = 5\n    \n    print(powerOptimised(a,n))\n\n# This code is contributed by virusbuddah_\n// C# program to implement \n// the above approach \nusing System;\n\nclass GFG{ \n\n// Function to return a^n \nstatic int powerOptimised(int a, int n) \n{ \n    \n    // Stores readonly answer \n    int ans = 1; \n\n    while (n > 0) \n    { \n        int last_bit = (n & 1); \n\n        // Check if current LSB \n        // is set \n        if (last_bit > 0) \n        { \n            ans = ans * a; \n        } \n        a = a * a; \n\n        // Right shift \n        n = n >> 1; \n    } \n    return ans; \n} \n\n// Driver Code \npublic static void Main(String[] args) \n{ \n    int a = 3, n = 5; \n\n    Console.Write(powerOptimised(a, n)); \n} \n} \n\n// This code is contributed by Princi Singh\n// JavaScript program to implement\n// the above approach\n\n// Function to return a^n \nfunction powerOptimised(a, n) \n{ \n    // Stores final answer \n    let ans = 1; \n  \n    while (n > 0) \n    { \n        let last_bit = (n & 1); \n  \n        // Check if current LSB \n        // is set \n        if (last_bit > 0)\n        { \n            ans = ans * a; \n        } \n          \n        a = a * a; \n  \n        // Right shift \n        n = n >> 1; \n    } \n    return ans; \n}  \n\n// Driver Code\nlet a = 3, n = 5; \n\nconsole.log(powerOptimised(a, n));\n243\n#include <iostream>\nusing namespace std;\n\n// Function to calculate A raised to the power N using recursion\nlong long recursive_exponentiation(long long A, long long N) {\n    if (N == 0) {\n        // Base case: A^0 = 1\n        return 1;\n    } else if (N % 2 == 0) {\n        // If N is even, recursively compute A^(N/2) and square it\n        long long temp = recursive_exponentiation(A, N / 2);\n        return temp * temp;\n    } else {\n        // If N is odd, recursively compute A^(N-1) and multiply by A\n        return A * recursive_exponentiation(A, N - 1);\n    }\n}\n\nint main() {\n    // Test case\n    cout << recursive_exponentiation(3, 5);\n    return 0;\n}\npublic class RecursiveExponentiation {\n    // Function to calculate A raised to the power N using recursion\n    public static long recursiveExponentiation(long A, long N) {\n        if (N == 0) {\n            // Base case: A^0 = 1\n            return 1;\n        } else if (N % 2 == 0) {\n            // If N is even, recursively compute A^(N/2) and square it\n            long temp = recursiveExponentiation(A, N / 2);\n            return temp * temp;\n        } else {\n            // If N is odd, recursively compute A^(N-1) and multiply by A\n            return A * recursiveExponentiation(A, N - 1);\n        }\n    }\n\n    public static void main(String[] args) {\n        // Test case\n        System.out.println(recursiveExponentiation(3, 5));\n    }\n}\ndef recursive_exponentiation(A, N):\n    if N == 0:\n        return 1\n    elif N % 2 == 0:\n        # If N is even, recursively compute A^(N/2) and square it\n        temp = recursive_exponentiation(A, N // 2)\n        return temp * temp\n    else:\n        # If N is odd, recursively compute A^(N-1) and multiply by A\n        return A * recursive_exponentiation(A, N - 1)\n\n# Test cases\nprint(recursive_exponentiation(3, 5))\n// Function to calculate A raised to the power N using recursion\nfunction recursiveExponentiation(A, N) {\n    if (N === 0) {\n        // Base case: A^0 = 1\n        return 1;\n    } else if (N % 2 === 0) {\n        // If N is even, recursively compute A^(N/2) and square it\n        const temp = recursiveExponentiation(A, N / 2);\n        return temp * temp;\n    } else {\n        // If N is odd, recursively compute A^(N-1) and multiply by A\n        return A * recursiveExponentiation(A, N - 1);\n    }\n}\n\n// Test case\nconsole.log(recursiveExponentiation(3, 5));\n243\n",
        "complexity": {
            "time": "Time Complexity: O(logN)",
            "space": ""
        },
        "tags": [
            "Bitwise Algorithms"
        ],
        "url": "https://www.geeksforgeeks.org/fast-exponention-using-bit-manipulation/"
    },
    {
        "title": "DSA Tutorial - Learn Data Structures and Algorithms",
        "description": "DSA (Data Structures and Algorithms)  is the study of organizing data efficiently using data structures like arrays, stacks, and trees, paired with step-by-step procedures (or algorithms) to solve problems effectively. Data structures manage how data is stored and accessed, while algorithms focus on processing this data. Hoping you have learned a programming language of your choice, here comes the next stage of the roadmap - Learn about Time and Space Complexities. Once you have learned basics of a programming language, it is recommended that you learn basic logic building To analyze algorithms, we mainly measure order of growth of time or space taken in terms of input size.  We do this in the worst case scenario in most of the cases. Please refer the below links for a clear understanding of these concepts. Array is a linear data structure where elements are allocated contiguous memory, allowing for constant-time access. Searching algorithms are used to locate specific data within a large set of data. It helps find a target value within the data. There are various types of searching algorithms, each with its own approach and efficiency. Sorting algorithms are used to arrange the elements of a list in a specific order, such as numerical or alphabetical. It organizes the items in a systematic way, making it easier to search for and access specific elements. Hashing is a technique that generates a fixed-size output (hash value) from an input of variable size using mathematical formulas called hash functions. Hashing is commonly used in data structures for efficient searching, insertion and deletion. In Two Pointer Technique, we typically use two index variables from two corners of an array. We use the two pointer technique for searching a required point or value in an array. In Window Sliding Technique, we use the result of previous subarray to quickly compute the result of current. In Prefix Sum Technique, we compute prefix sums of an array to quickly find results for a subarray. String is a sequence of characters, typically immutable and have limited set of elements (lower case or all English alphabets). Recursion is a programming technique where a function calls itself within its own definition. It is usually used to solve problems that can be broken down into smaller instances of the same problem. Matrix is a two-dimensional array of elements, arranged in rows and columns. It is represented as a rectangular grid, with each element at the intersection of a row and column. Linked list is a linear data structure that stores data in nodes, which are connected by pointers. Unlike arrays, nodes of linked lists are not stored in contiguous memory locations and can only be accessed sequentially, starting from the head of list. Stack is a linear data structure that follows the Last In, First Out (LIFO) principle. Stacks play an important role in managing function calls, memory, and are widely used in algorithms like stock span problem, next greater element and largest area in a histogram. Queue is a linear data structure that follows the First In, First Out (FIFO) principle. Queues play an important role in managing tasks or data in order, scheduling and message handling systems. A deque (double-ended queue) is a data structure that allows elements to be added or removed from both ends efficiently. Tree is a non-linear, hierarchical data structure consisting of nodes connected by edges, with a top node called the root and nodes having child nodes. It is widely used in file systems, databases, decision-making algorithms, etc. Heap is a complete binary tree data structure that satisfies the heap property. Heaps are usually used to implement priority queues, where the smallest or largest element is always at the root of the tree. Graph is a non-linear data structure consisting of a finite set of vertices(or nodes) and a set of edges(or links)that connect a pair of nodes. Graphs are widely used to represent relationships between entities. Greedy Algorithm builds up the solution one piece at a time and chooses the next piece which gives the most obvious and immediate benefit i.e., which is the most optimal choice at that moment. So the problems where choosing locally optimal also leads to the global solutions are best fit for Greedy. Dynamic Programming is a method used to solve complex problems by breaking them down into simpler subproblems. By solving each subproblem only once and storing the results, it avoids redundant computations, leading to more efficient solutions for a wide range of problems. Bitwise Algorithms: Operate on individual bits of numbers. Backtracking Algorithm : Follow Recursion  with the option to revert and traces back if the solution from current point is not feasible. Divide and conquer:  A strategy to solve problems by dividing them into smaller subproblems, solving those subproblems, and combining the solutions to obtain the final solution. Branch and Bound : Used in combinatorial optimization problems to systematically search for the best solution. It works by dividing the problem into smaller subproblems, or branches, and then eliminating certain branches based on bounds on the optimal solution. This process continues until the best solution is found or all branches have been explored. Geometric algorithms are a set of algorithms that solve problems related to shapes, points, lines and polygons. Randomized algorithms are algorithms that use randomness to solve problems. They make use of random input to achieve their goals, often leading to simpler and more efficient solutions. These algorithms may not product same result but are particularly useful in situations when a probabilistic approach is acceptable. Advanced Data Structures like Trie, Segment Tree, Red-Black Tree and Binary Indexed Tree offer significant performance improvements for specific problem domains. They provide efficient solutions for tasks like fast prefix searches, range queries, dynamic updates, and maintaining balanced data structures, which are crucial for handling large datasets and real-time processing. By optimizing time complexity, they enable better scalability and faster execution in many computational problems. R  ",
        "code": "",
        "complexity": {
            "time": "Advanced Data Structures like Trie, Segment Tree, Red-Black Tree and Binary Indexed Tree offer significant performance improvements for specific problem domains. They provide efficient solutions for tasks like fast prefix searches, range queries, dynamic updates, and maintaining balanced data structures, which are crucial for handling large datasets and real-time processing. By optimizing time complexity, they enable better scalability and faster execution in many computational problems.",
            "space": ""
        },
        "tags": [
            "Branch & Bound"
        ],
        "url": "https://www.geeksforgeeks.org/learn-data-structures-and-algorithms-dsa-tutorial/"
    },
    {
        "title": "Introduction to Branch and Bound – Data Structures and Algorithms Tutorial",
        "description": "Branch and bound algorithms are used to find the optimal solution for combinatory, discrete, and general mathematical optimization problems. A branch and bound algorithm provide an optimal solution to an NP-Hard problem by exploring the entire search space. Through the exploration of the entire search space, a branch and bound algorithm identify possible candidates for solutions step-by-step. There are many optimization problems in computer science, many of which have a finite number of the feasible shortest path in a graph or minimum spanning tree that can be solved in polynomial time. Typically, these problems require a worst-case scenario of all possible permutations. The branch and bound algorithm create branches and bounds for the best solution. In this tutorial, we’ll discuss the branch and bound method in detail. The Branch  algorithms incorporate different search techniques to traverse a state space tree. Different search techniques used in B&B are listed below: 1. LC search (Least Cost Search): It uses a heuristic cost function to compute the bound values at each node. Nodes are added to the list of live nodes as soon as they get generated.The node with the least value of a cost function selected as a next E-node. 2.BFS(Breadth First Search):It is also known as a FIFO search.It maintains the list of live nodes in first-in-first-out order i.e, in a queue, The live nodes are searched in the FIFO order to make them next E-nodes. 3. DFS (Depth First Search):It is also known as a LIFO search.It maintains the list of live nodes in last-in-first-out order i.e. in a stack. The live nodes are searched in the LIFO order to make them next E-nodes. Introduction to Branch and Bound Branch and bound is an effective solution to some problems, which we have already discussed. We’ll discuss all such cases where branching and binding are appropriate in this section. ▸ Generation of a state space tree: As in the case of backtracking, B&B generates a state space tree to efficiently search the solution space of a given problem instance. In B&B, all children of an E-node in a state space tree are produced before any live node gets converted in an E-node. Thus, the E-node remains an E-node until i becomes a dead node. Unlike backtracking, B&B needs additional factors evaluate a candidate solution: It optimizes the search for a solution vector in the solution space of a given problem instance. It is a heuristic function that evaluates the lower and upper bounds on the possible solutions at each node. The bound values are used to search the partial solutions leading to an optimal solution. If a node does not produce a solution better than the best solution obtained thus far, then it is abandoned without further exploration. The algorithm then branches to another path to get a better solution. The desired solution to the problem is the value of the best solution produced so far. ▸ The reasons to dismiss a search path at the current node : (i) The bound value of the node is lower than the upper bound in the case of the maximization problem and higher than the lower bound in the case of the minimization problem. (i.e. the bound value of the ade is not better than the value of the best solution obtained until that node). (ii) The node represents infeasible solutions, de violation of the constraints of the problem. (iii) The node represents a subset of a feasible solution containing a single point. In this case, if the latest solution is better than the best solution obtained so far the best solution is modified to the value of a feasible solution at that node. The solution of the Branch and the bound problem can be represented in two ways: The Branch and Bound method can be classified into three types based on the order in which the state space tree is searched. We will now discuss each of these methods in more detail. To denote the solutions in these methods, we will use the variable solution method. First-In-First-Out is an approach to the branch and bound problem that uses the queue approach to create a state-space tree. In this case, the breadth-first search is performed, that is, the elements at a certain level are all searched, and then the elements at the next level are searched, starting with the first child of the first node at the previous level. For a given set {A, B, C, D}, the state space tree will be constructed as follows : State Space tree for set {A, B, C, D} The above diagram shows that we first consider element A, then element B, then element C and finally we’ll consider the last element which is D. We are performing BFS while exploring the nodes. So, once the first level is completed. We’ll consider the first element, then we can consider either B, C, or D. If we follow the route then it says that we are doing elements A and D so we will not consider elements B and C. If we select the elements A and D only, then it says that we are selecting elements A and D and we are not considering elements B and C. Selecting element A Now, we will expand node 3, as we have considered element B and not considered element A, so, we have two options to explore that is elements C and D. Let’s create nodes 9 and 10 for elements C and D respectively. Considered element B and not considered element A Now, we will expand node 4 as we have only considered elements C and not considered elements A and B, so, we have only one option to explore which is element  D. Let’s create node 11 for D. Considered elements C and not considered elements A and B Till node 5, we have only considered elements D, and not selected elements A, B, and C. So, We have no more elements to explore, Therefore on node 5, there won’t be any expansion. Now, we will expand node 6 as we have considered elements A and B, so, we have only two option to explore that is element C and D. Let’s create node 12 and 13 for C and D respectively. Expand node 6 Now, we will expand node 7 as we have considered elements A and C and not consider element B, so, we have only one option to explore which is element  D. Let’s create node 14 for D. Expand node 7 Till node 8, we have considered elements A and D, and not selected elements B and C, So, We have no more elements to explore, Therefore on node 8, there won’t be any expansion. Now, we will expand node 9 as we have considered elements B and C and not considered element A, so, we have only one option to explore which is element  D. Let’s create node 15 for D. Expand node 9 The Last-In-First-Out approach for this problem uses stack in creating the state space tree. When nodes are added to a state space tree, they are added to a stack. After all nodes of a level have been added, we pop the topmost element from the stack and explore it. For a given set {A, B, C, D}, the state space tree will be constructed as follows : State space tree for element {A, B, C, D} Now the expansion would be based on the node that appears on the top of the stack. Since node 5 appears on the top of the stack, so we will expand node 5. We will pop out node 5 from the stack. Since node 5 is in the last element, i.e., D so there is no further scope for expansion. The next node that appears on the top of the stack is node 4. Pop-out node 4 and expand. On expansion, element D will be considered and node 6 will be added to the stack shown below: Expand node 4 The next node is 6 which is to be expanded. Pop-out node 6 and expand. Since node 6 is in the last element, i.e., D so there is no further scope for expansion. The next node to be expanded is node 3. Since node 3 works on element B so node 3 will be expanded to two nodes, i.e., 7 and 8 working on elements C and D respectively. Nodes 7 and 8 will be pushed into the stack. The next node that appears on the top of the stack is node 8. Pop-out node 8 and expand. Since node 8 works on element D so there is no further scope for the expansion. Expand node 3 The next node that appears on the top of the stack is node 7. Pop-out node 7 and expand. Since node 7 works on element C so node 7 will be further expanded to node 9 which works on element D and node 9 will be pushed into the stack. The next node is 6 which is to be expanded. Pop-out node 6 and expand. Since node 6 is in the last element, i.e., D so there is no further scope for expansion. Expand node 7 The next node that appears on the top of the stack is node 9. Since node 9 works on element D, there is no further scope for expansion. The next node that appears on the top of the stack is node 2. Since node 2 works on the element A so it means that node 2 can be further expanded. It can be expanded up to three nodes named 10, 11, 12 working on elements B, C, and D respectively. There new nodes will be pushed into the stack shown as below: Expand node 2 In the above method, we explored all the nodes using the stack that follows the LIFO principle. To explore the state space tree, this method uses the cost function. The previous two methods also calculate the cost function at each node but the cost is not been used for further exploration. In this technique, nodes are explored based on their costs, the cost of the node can be defined using the problem and with the help of the given problem, we can define the cost function. Once the cost function is defined, we can define the cost of the node.Now, Consider a node whose cost has been determined. If this value is greater than U0, this node or its children will not be able to give a solution. As a result, we can kill this node and not explore its further branches. As a result, this method prevents us from exploring cases that are not worth it, which makes it more efficient for us. Let’s first consider node 1 having cost infinity shown below: In the following diagram, node 1 is expanded into four nodes named 2, 3, 4, and 5. Node 1 is expanded into four nodes named 2, 3, 4, and 5 Assume that cost of the nodes 2, 3, 4, and 5 are 12, 16, 10, and 315 respectively.In this method, we will explore the node which is having the least cost. In the above figure, we can observe that the node with a minimum cost is node 4. So, we will explore node 4 having a cost of 10. During exploring node 4 which is element C, we can notice that there is only one possible element that remains unexplored which is D (i.e, we already decided not to select elements A, and B). So, it will get expanded to one single element D, let’s say this node number is 6. Exploring node 4 which is element C Now, Node 6 has no element left to explore. So, there is no further scope for expansion. Hence the element {C, D} is the optimal way to choose for the least cost. The Branch and Bound method can be used for solving most combinatorial problems. Some of these problems are given below: Question The branch and bound algorithms are one of the most popular algorithms used in optimization problems that we have discussed in our tutorial. We have also explained when a branch and bound algorithm is appropriate for a user to use. In addition, we presented an algorithm based on branches and bounds for assigning jobs. Lastly, we discussed some advantages and disadvantages of branch and bound algorithms. H  ",
        "code": "",
        "complexity": {
            "time": "",
            "space": ""
        },
        "tags": [
            "Branch & Bound"
        ],
        "url": "https://www.geeksforgeeks.org/introduction-to-branch-and-bound-data-structures-and-algorithms-tutorial/"
    },
    {
        "title": "Difference between Backtracking and Branch-N-Bound technique",
        "description": "Algorithms are the methodical sequence of steps which are defined to solve complex problems. In this article, we will see the difference between two such algorithms which are backtracking and branch and bound technique. Before getting into the differences, lets first understand each of these algorithms. Backtracking: Backtracking is a general algorithm for finding all the solutions to some computational problems, notably constraint satisfaction problems, that incrementally builds possible candidates to the solutions and abandons a candidate as soon as it determines that the candidate cannot possibly be completed to finally become a valid solution. It is an algorithmic-technique for solving problems recursively by trying to build a solution incrementally, one piece at a time, removing those solutions that fail to satisfy the constraints of the problem at any point of time (by time, here, is referred to the time elapsed till reaching any level of the search tree). Branch and Bound: Branch and bound is an algorithm design paradigm for discrete and combinatoric optimisation problems, as well as mathematical optimisation. A branch-and-bound algorithm consists of a systematic enumeration of candidate solutions. That is, the set of candidate solutions is thought of as forming a rooted tree with the full set at the root. The algorithm explores branches of this tree, which represent the subsets of the solution set. Before enumerating the candidate solutions of a branch, the branch is checked against upper and lower estimated bounds on the optimal solution and is discarded if it cannot produce a better solution than the best one found so far by the algorithm. Branch and bound algorithmic strategy for solving the problem- Branch and bound builds the state space tree and find the optimal solution quickly by pruning few of the tree branches which does not satisfy the bound. Backtracking can be useful where some other optimization techniques like greedy or dynamic programming fail. Such algorithms are typically slower than their counterparts. In the worst case, it may run in exponential time, but careful selection of bounds and branches makes an algorithm to run reasonably faster. Most of the terminologies of backtracking are used in this chapter too. In branch and bound, all the children of E nodes are generated before any other live node becomes E node. Branch and bound technique in which E-node puts its children in the queue is called FIFO branch and bound approach. And if E-node puts its children in the stack, then it is called LIFO branch and bound approach. Bounding functions are a heuristic function. Heuristic function computes the node which maximizes the probability of better search minimizes the probability of worst search. According to maximization or minimization problem, highest or lowest heuristic valued node is selected for further expansion from a set of nodes. The following table explains the difference between both the algorithms:  M  ",
        "code": "",
        "complexity": {
            "time": "",
            "space": ""
        },
        "tags": [
            "Branch & Bound"
        ],
        "url": "https://www.geeksforgeeks.org/difference-between-backtracking-and-branch-n-bound-technique/"
    },
    {
        "title": "Implementation of 0/1 Knapsack using Branch and Bound",
        "description": "Given two arrays v[] and w[] that represent values and weights associated with n items respectively. Find out the maximum value subset(Maximum Profit) of v[] such that the sum of the weights of this subset is smaller than or equal to Knapsack capacity Cap(W). Note: The constraint here is we can either put an item completely into the bag or cannot put it at all. It is not possible to put a part of an item into the bag. Example: Input: N = 3, W = 4, v[] = {1, 2, 3}, w[] = {4, 5, 1}Output: 3Explanation: There are two items which have weight less than or equal to 4. If we select the item with weight 4, the possible profit is 1. And if we select the item with weight 1, the possible profit is 3. So the maximum possible profit is 3. Note that we cannot put both the items with weight 4 and 1 together as the capacity of the bag is 4. Input: N = 3, W = 4, v[] = {2, 3.14, 1.98, 5, 3}, w[] = {40, 50, 100, 95, 30}Output: 235 We strongly recommend to refer below post as a prerequisite for this. Branch and Bound | Set 1 (Introduction with 0/1 Knapsack) We discussed different approaches to solve above problem and saw that the Branch and Bound solution is the best suited method when item weights are not integers. In this post implementation of Branch and Bound method for 0/1 knapsack problem is discussed. Implementation of 0/1 Knapsack using Branch and Bound The idea is to use the fact that the Greedy approach provides the best solution for Fractional Knapsack problem. To check if a particular node can give us a better solution or not, we compute the optimal solution (through the node) using Greedy approach. If the solution computed by Greedy approach itself is more than the best so far, then we can’t get a better solution through the node. Algorithm: Following is implementation of above idea.                Time complexity: O(2n) because the while loop runs n times, and inside the while loop, there is another loop that also runs n times in the worst case.Auxiliary Space: O(n) because the queue stores the nodes, and in the worst case, all nodes are stored, so the size of the queue is proportional to the number of items, which is n.  ",
        "code": "\n\n\n\n\n\n\n\n\n\nMaximum possible profit = 235\n",
        "complexity": {
            "time": "Time complexity: O(2n) because the while loop runs n times, and inside the while loop, there is another loop that also runs n times in the worst case.Auxiliary Space: O(n) because the queue stores the nodes, and in the worst case, all nodes are stored, so the size of the queue is proportional to the number of items, which is n.",
            "space": ""
        },
        "tags": [
            "Branch & Bound"
        ],
        "url": "https://www.geeksforgeeks.org/implementation-of-0-1-knapsack-using-branch-and-bound/"
    },
    {
        "title": "8 puzzle Problem",
        "description": "Given a 3×3 board with 8 tiles (each numbered from 1 to 8) and one empty space, the objective is to place the numbers to match the final configuration using the empty space. We can slide four adjacent tiles (left, right, above, and below) into the empty space. Table of Content We can perform a depth-first search on state-space (Set of all configurations of a given problem i.e. all states that can be reached from the initial state) tree. Step by step approach:  We can perform a Breadth-first search on the state space tree. This always finds a goal state nearest to the root. But no matter what the initial state is, the algorithm attempts the same sequence of moves like DFS. Step by step approach: Branch and Bound enhances search efficiency by using a cost function to guide exploration. C(X) = g(X) + h(X)C(X) = g(X) + h(X) Where: Only nodes with the lowest cost function value are expanded, ensuring an optimal path.   A  ",
        "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <stack>\n\nusing namespace std;\n\n// Define the dimensions of the puzzle\n#define N 3\n\n// Structure to store a state of the puzzle\nstruct PuzzleState {\n    vector<vector<int>> board;  \n    int x, y;  \n    int depth; \n\n    PuzzleState(vector<vector<int>> b, int i, int j, int d) : board(b), x(i), y(j), depth(d) {}\n};\n\n// Possible moves: Left, Right, Up, Down\nint row[] = {0, 0, -1, 1};\nint col[] = {-1, 1, 0, 0};\n\n// Function to check if a given state is the goal state\nbool isGoalState(vector<vector<int>>& board) {\n    vector<vector<int>> goal = {{1, 2, 3}, {4, 5, 6}, {7, 8, 0}};\n    return board == goal;\n}\n\n// Function to check if a move is valid\nbool isValid(int x, int y) {\n    return (x >= 0 && x < N && y >= 0 && y < N);\n}\n\n// Function to print the board\nvoid printBoard(vector<vector<int>>& board) {\n    for (auto& row : board) {\n        for (auto& num : row)\n            cout << num << \" \";\n        cout << endl;\n    }\n    cout << \"--------\" << endl;\n}\n\n// Depth-First Search to solve the 8-puzzle problem\nvoid solvePuzzleDFS(vector<vector<int>>& start, int x, int y) {\n    stack<PuzzleState> st;\n    set<vector<vector<int>>> visited;\n    \n    st.push(PuzzleState(start, x, y, 0));\n    visited.insert(start);\n\n    while (!st.empty()) {\n        PuzzleState curr = st.top();\n        st.pop();\n\n        // Print the current board\n        cout << \"Depth: \" << curr.depth << endl;\n        printBoard(curr.board);\n\n        // Check if goal state is reached\n        if (isGoalState(curr.board)) {\n            cout << \"Goal state reached at depth \" << curr.depth << endl;\n            return;\n        }\n\n        // Explore possible moves\n        for (int i = 0; i < 4; i++) {\n            int newX = curr.x + row[i];\n            int newY = curr.y + col[i];\n\n            if (isValid(newX, newY)) {\n                vector<vector<int>> newBoard = curr.board;\n                swap(newBoard[curr.x][curr.y], newBoard[newX][newY]);\n\n                // If this state has not been visited before, push to stack\n                if (visited.find(newBoard) == visited.end()) {\n                    visited.insert(newBoard);\n                    st.push(PuzzleState(newBoard, newX, newY, curr.depth + 1));\n                }\n            }\n        }\n    }\n\n    cout << \"No solution found (DFS Brute Force reached depth limit)\" << endl;\n}\n\n// Driver Code\nint main() {\n    vector<vector<int>> start = {{1, 2, 3}, {4, 0, 5}, {6, 7, 8}};\n    int x = 1, y = 1; \n\n    cout << \"Initial State: \" << endl;\n    printBoard(start);\n\n    solvePuzzleDFS(start, x, y);\n\n    return 0;\n}\nimport java.util.*;\n\nclass PuzzleSolver {\n    static final int N = 3;\n\n    static int[] row = {0, 0, -1, 1};\n    static int[] col = {-1, 1, 0, 0};\n\n    static class PuzzleState {\n        int[][] board;\n        int x, y;\n        int depth;\n        int hash; \n\n        PuzzleState(int[][] b, int i, int j, int d) {\n            board = new int[N][N];\n            for (int k = 0; k < N; k++)\n                board[k] = Arrays.copyOf(b[k], N);\n            x = i;\n            y = j;\n            depth = d;\n            hash = Arrays.deepHashCode(board); \n        }\n\n        @Override\n        public boolean equals(Object obj) {\n            if (this == obj) return true;\n            if (obj == null || getClass() != obj.getClass()) return false;\n            PuzzleState that = (PuzzleState) obj;\n            return hash == that.hash; \n        }\n\n\n        @Override\n        public int hashCode() {\n            return hash; \n        }\n    }\n\n    static boolean isGoalState(int[][] board) {\n        int[][] goal = {{1, 2, 3}, {4, 5, 6}, {7, 8, 0}};\n        return Arrays.deepEquals(board, goal);\n    }\n\n    static boolean isValid(int x, int y) {\n        return (x >= 0 && x < N && y >= 0 && y < N);\n    }\n\n    static void printBoard(int[][] board) {\n        for (int[] row : board) {\n            for (int num : row)\n                System.out.print(num + \" \");\n            System.out.println();\n        }\n        System.out.println(\"--------\");\n    }\n\n    static void solvePuzzleBFS(int[][] start, int x, int y) {\n        Queue<PuzzleState> queue = new LinkedList<>();\n        Set<PuzzleState> visited = new HashSet<>(); \n\n        queue.add(new PuzzleState(start, x, y, 0));\n        visited.add(new PuzzleState(start, x, y, 0));\n\n        while (!queue.isEmpty()) {\n            PuzzleState curr = queue.poll();\n\n            System.out.println(\"Depth: \" + curr.depth);\n            printBoard(curr.board);\n\n            if (isGoalState(curr.board)) {\n                System.out.println(\"Goal state reached at depth \" + curr.depth);\n                return;\n            }\n\n            for (int i = 0; i < 4; i++) {\n                int newX = curr.x + row[i];\n                int newY = curr.y + col[i];\n\n                if (isValid(newX, newY)) {\n                    int[][] newBoard = new int[N][N];\n                    for (int j = 0; j < N; j++)\n                        newBoard[j] = Arrays.copyOf(curr.board[j], N);\n\n                    int temp = newBoard[curr.x][curr.y];\n                    newBoard[curr.x][curr.y] = newBoard[newX][newY];\n                    newBoard[newX][newY] = temp;\n\n                    PuzzleState newState = new PuzzleState(newBoard, newX, newY, curr.depth + 1);\n\n                    if (!visited.contains(newState)) {\n                        visited.add(newState);\n                        queue.add(newState);\n                    }\n                }\n            }\n        }\n\n        System.out.println(\"No solution found (Unsolvable Puzzle)\");\n    }\n\n    public static void main(String[] args) {\n        int[][] start = {{1, 2, 3}, {4, 0, 5}, {6, 7, 8}};\n        int x = 1, y = 1;\n\n        System.out.println(\"Initial State: \");\n        printBoard(start);\n\n        solvePuzzleBFS(start, x, y);\n    }\n}\n# Import necessary libraries\nfrom collections import deque\n\n# Define the dimensions of the puzzle\nN = 3\n\n# Structure to store a state of the puzzle\nclass PuzzleState:\n    def __init__(self, board, x, y, depth):\n        self.board = board\n        self.x = x\n        self.y = y\n        self.depth = depth\n\n# Possible moves: Left, Right, Up, Down\nrow = [0, 0, -1, 1]\ncol = [-1, 1, 0, 0]\n\n# Function to check if a given state is the goal state\ndef is_goal_state(board):\n    goal = [[1, 2, 3], [4, 5, 6], [7, 8, 0]]\n    return board == goal\n\n# Function to check if a move is valid\ndef is_valid(x, y):\n    return 0 <= x < N and 0 <= y < N\n\n# Function to print the board\ndef print_board(board):\n    for row in board:\n        print(' '.join(map(str, row)))\n    print(\"--------\")\n\n# Depth-First Search to solve the 8-puzzle problem\ndef solve_puzzle_dfs(start, x, y):\n    stack = []\n    visited = set()\n\n    stack.append(PuzzleState(start, x, y, 0))\n    visited.add(tuple(map(tuple, start)))\n\n    while stack:\n        curr = stack.pop()\n\n        # Print the current board\n        print(f'Depth: {curr.depth}')\n        print_board(curr.board)\n\n        # Check if goal state is reached\n        if is_goal_state(curr.board):\n            print(f'Goal state reached at depth {curr.depth}')\n            return\n\n        # Explore possible moves\n        for i in range(4):\n            new_x = curr.x + row[i]\n            new_y = curr.y + col[i]\n\n            if is_valid(new_x, new_y):\n                new_board = [row[:] for row in curr.board]\n                # Swap the tiles\n                new_board[curr.x][curr.y], new_board[new_x][new_y] = new_board[new_x][new_y], new_board[curr.x][curr.y]\n\n                # If this state has not been visited before, push to stack\n                board_tuple = tuple(map(tuple, new_board))\n                if board_tuple not in visited:\n                    visited.add(board_tuple)\n                    stack.append(PuzzleState(new_board, new_x, new_y, curr.depth + 1))\n\n    print('No solution found (DFS Brute Force reached depth limit)')\n\n# Driver Code\nif __name__ == '__main__':\n    start = [[1, 2, 3], [4, 0, 5], [6, 7, 8]]\n    x, y = 1, 1\n\n    print('Initial State:')\n    print_board(start)\n\n    solve_puzzle_dfs(start, x, y)\n// Define the dimensions of the puzzle\nconst N = 3;\n\n// Structure to store a state of the puzzle\nclass PuzzleState {\n    constructor(board, x, y, depth) {\n        this.board = board;\n        this.x = x;\n        this.y = y;\n        this.depth = depth;\n    }\n}\n\n// Possible moves: Left, Right, Up, Down\nconst row = [0, 0, -1, 1];\nconst col = [-1, 1, 0, 0];\n\n// Function to check if a given state is the goal state\nfunction isGoalState(board) {\n    const goal = [[1, 2, 3], [4, 5, 6], [7, 8, 0]];\n    return JSON.stringify(board) === JSON.stringify(goal);\n}\n\n// Function to check if a move is valid\nfunction isValid(x, y) {\n    return x >= 0 && x < N && y >= 0 && y < N;\n}\n\n// Function to print the board\nfunction printBoard(board) {\n    board.forEach(row => console.log(row.join(' ')));\n    console.log('--------');\n}\n\n// Breadth-First Search to solve the 8-puzzle problem\nfunction solvePuzzleBFS(start, x, y) {\n    const queue = [];\n    const visited = new Set();\n\n    queue.push(new PuzzleState(start, x, y, 0));\n    visited.add(JSON.stringify(start));\n\n    while (queue.length > 0) {\n        const curr = queue.shift();\n\n        console.log(`Depth: ${curr.depth}`);\n        printBoard(curr.board);\n\n        if (isGoalState(curr.board)) {\n            console.log(`Goal state reached at depth ${curr.depth}`);\n            return;\n        }\n\n        for (let i = 0; i < 4; i++) {\n            const newX = curr.x + row[i];\n            const newY = curr.y + col[i];\n\n            if (isValid(newX, newY)) {\n                const newBoard = curr.board.map(r => r.slice());\n                // Swap the tiles\n                [newBoard[curr.x][curr.y], newBoard[newX][newY]] = [newBoard[newX][newY], newBoard[curr.x][curr.y]];\n\n                const boardString = JSON.stringify(newBoard);\n                if (!visited.has(boardString)) {\n                    visited.add(boardString);\n                    queue.push(new PuzzleState(newBoard, newX, newY, curr.depth + 1));\n                }\n            }\n        }\n    }\n\n    console.log('No solution found (Unsolvable Puzzle)');\n}\n\n// Driver Code\nconst start = [[1, 2, 3], [4, 0, 5], [6, 7, 8]];\nconst x = 1, y = 1;\n\nconsole.log('Initial State:');\nprintBoard(start);\n\nsolvePuzzleBFS(start, x, y);\nInitial State: \n1 2 3 \n4 0 5 \n6 7 8 \n--------\nDepth: 0\n1 2 3 \n4 0 5 \n6 7 8 \n--------\nDepth: 1\n1 2 3 \n4 7 5 \n6 0 8 \n--------\nDepth: 2\n1 2 3 \n4 7 5 \n6 8 0 \n--------\nDepth: 3\n1 2 3 \n4 7 0 \n6 8 5 \n-------...\n#include <iostream>\n#include <vector>\n#include <queue>\n#include <set>\nusing namespace std;\n\n// Define the dimensions of the puzzle\n#define N 3\n\n// Structure to represent the state of the puzzle\nstruct PuzzleState {\n    vector<vector<int>> board; \n    int x, y;  \n    int depth; \n\n    // Constructor\n    PuzzleState(vector<vector<int>> b, int i, int j, int d) : board(b), x(i), y(j), depth(d) {}\n};\n\n// Possible moves: Left, Right, Up, Down\nint row[] = {0, 0, -1, 1};\nint col[] = {-1, 1, 0, 0};\n\n// Function to check if the current state is the goal state\nbool isGoalState(vector<vector<int>>& board) {\n    vector<vector<int>> goal = {{1, 2, 3}, {4, 5, 6}, {7, 8, 0}};\n    return board == goal;\n}\n\n// Function to check if a move is valid\nbool isValid(int x, int y) {\n    return (x >= 0 && x < N && y >= 0 && y < N);\n}\n\n// Function to print the puzzle board\nvoid printBoard(vector<vector<int>>& board) {\n    for (auto& row : board) {\n        for (auto& num : row)\n            cout << num << \" \";\n        cout << endl;\n    }\n    cout << \"--------\" << endl;\n}\n\n// BFS function to solve the 8-puzzle problem\nvoid solvePuzzleBFS(vector<vector<int>>& start, int x, int y) {\n    queue<PuzzleState> q;\n    set<vector<vector<int>>> visited;\n\n    // Enqueue initial state\n    q.push(PuzzleState(start, x, y, 0));\n    visited.insert(start);\n\n    while (!q.empty()) {\n        PuzzleState curr = q.front();\n        q.pop();\n\n        // Print the current board state\n        cout << \"Depth: \" << curr.depth << endl;\n        printBoard(curr.board);\n\n        // Check if goal state is reached\n        if (isGoalState(curr.board)) {\n            cout << \"Goal state reached at depth \" << curr.depth << endl;\n            return;\n        }\n\n        // Explore all possible moves\n        for (int i = 0; i < 4; i++) {\n            int newX = curr.x + row[i];\n            int newY = curr.y + col[i];\n\n            if (isValid(newX, newY)) {\n                vector<vector<int>> newBoard = curr.board;\n                swap(newBoard[curr.x][curr.y], newBoard[newX][newY]);\n\n                // If this state has not been visited before, push to queue\n                if (visited.find(newBoard) == visited.end()) {\n                    visited.insert(newBoard);\n                    q.push(PuzzleState(newBoard, newX, newY, curr.depth + 1));\n                }\n            }\n        }\n    }\n\n    cout << \"No solution found (BFS Brute Force reached depth limit)\" << endl;\n}\n\n// Driver Code\nint main() {\n    vector<vector<int>> start = {{1, 2, 3}, {4, 0, 5}, {6, 7, 8}}; // Initial state\n    int x = 1, y = 1; \n\n    cout << \"Initial State: \" << endl;\n    printBoard(start);\n\n    solvePuzzleBFS(start, x, y);\n\n    return 0;\n}\nimport java.util.*;\n\nclass PuzzleState implements Comparable<PuzzleState> {\n    long board;\n    int x, y;\n    int depth;\n    int f;\n\n    PuzzleState(long b, int i, int j, int d, int h) {\n        this.board = b;\n        this.x = i;\n        this.y = j;\n        this.depth = d;\n        this.f = d + h; \n    }\n\n    @Override\n    public int compareTo(PuzzleState other) {\n        return Integer.compare(this.f, other.f); \n    }\n}\n\npublic class EightPuzzleAStar {\n    static final int N = 3;\n    static int[] row = {0, 0, -1, 1};\n    static int[] col = {-1, 1, 0, 0};\n    static final long GOAL_STATE = 123456780L;\n\n    static long boardToLong(int[][] board) {\n        long result = 0;\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < N; j++) {\n                result = result * 10 + board[i][j];\n            }\n        }\n        return result;\n    }\n\n    static String boardToString(long board) {\n        String s = String.valueOf(board);\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < 9 - s.length(); i++) { \n            sb.append('0');\n        }\n        sb.append(s);\n        return sb.toString();\n    }\n\n    static boolean isGoalState(long board) {\n        return board == GOAL_STATE;\n    }\n\n    static void printBoard(long board) {\n        String s = boardToString(board); \n        for (int i = 0; i < 9; i++) {\n            System.out.print(s.charAt(i) + \" \");\n            if ((i + 1) % 3 == 0) {\n                System.out.println();\n            }\n        }\n        System.out.println(\"--------\");\n    }\n\n    static int calculateHeuristic(long board) { \n        String s = boardToString(board);\n        int h = 0;\n        for (int i = 0; i < 9; i++) {\n            int num = s.charAt(i) - '0';\n            if (num != 0) {\n                int goalX = (num - 1) % 3;\n                int goalY = (num - 1) / 3;\n                int currentX = i % 3;\n                int currentY = i / 3;\n                h += Math.abs(goalX - currentX) + Math.abs(goalY - currentY);\n            }\n        }\n        return h;\n    }\n\n    static void solvePuzzleAStar(int[][] start, int x, int y) {\n        PriorityQueue<PuzzleState> queue = new PriorityQueue<>(); \n        Set<Long> visited = new HashSet<>();\n\n        long startBoard = boardToLong(start);\n        int h = calculateHeuristic(startBoard); // Calculate initial heuristic\n        queue.add(new PuzzleState(startBoard, x, y, 0, h));\n        visited.add(startBoard);\n\n        while (!queue.isEmpty()) {\n            PuzzleState curr = queue.poll();\n\n            System.out.println(\"Depth: \" + curr.depth);\n            printBoard(curr.board);\n\n            if (isGoalState(curr.board)) {\n                System.out.println(\"Goal state reached at depth \" + curr.depth);\n                return;\n            }\n\n            String s = boardToString(curr.board);  \n            char[] boardArray = s.toCharArray();\n\n            for (int i = 0; i < 4; i++) {\n                int newX = curr.x + row[i];\n                int newY = curr.y + col[i];\n\n                if (newX >= 0 && newX < N && newY >= 0 && newY < N) {\n                    int zeroPos = curr.x * N + curr.y;\n                    int swapPos = newX * N + newY;\n\n                    char temp = boardArray[zeroPos];\n                    boardArray[zeroPos] = boardArray[swapPos];\n                    boardArray[swapPos] = temp;\n\n                    long newBoardLong = Long.parseLong(new String(boardArray));\n\n                    if (!visited.contains(newBoardLong)) {\n                        int newH = calculateHeuristic(newBoardLong); \n                        visited.add(newBoardLong);\n                        queue.add(new PuzzleState(newBoardLong, newX, newY, curr.depth + 1, newH)); \n                    }\n\n                    // Restore board for next iteration (important!)\n                    boardArray[swapPos] = boardArray[zeroPos];\n                    boardArray[zeroPos] = temp;\n\n                }\n            }\n        }\n\n        System.out.println(\"No solution found\");\n    }\n\n    public static void main(String[] args) {\n        int[][] start = {{1, 2, 3}, {4, 0, 5}, {6, 7, 8}};\n        int x = 1, y = 1;\n\n        System.out.println(\"Initial State:\");\n        printBoard(boardToLong(start));\n\n        solvePuzzleAStar(start, x, y); \n    }\n}\n# Import necessary libraries\nfrom collections import deque\n\n# Define the dimensions of the puzzle\nN = 3\n\n# Class to represent the state of the puzzle\nclass PuzzleState:\n    def __init__(self, board, x, y, depth):\n        self.board = board\n        self.x = x\n        self.y = y\n        self.depth = depth\n\n# Possible moves: Left, Right, Up, Down\nrow = [0, 0, -1, 1]\ncol = [-1, 1, 0, 0]\n\n# Function to check if the current state is the goal state\ndef is_goal_state(board):\n    goal = [[1, 2, 3], [4, 5, 6], [7, 8, 0]]\n    return board == goal\n\n# Function to check if a move is valid\ndef is_valid(x, y):\n    return 0 <= x < N and 0 <= y < N\n\n# Function to print the puzzle board\ndef print_board(board):\n    for row in board:\n        print(' '.join(map(str, row)))\n    print('--------')\n\n# BFS function to solve the 8-puzzle problem\ndef solve_puzzle_bfs(start, x, y):\n    q = deque()\n    visited = set()\n\n    # Enqueue initial state\n    q.append(PuzzleState(start, x, y, 0))\n    visited.add(tuple(map(tuple, start)))\n\n    while q:\n        curr = q.popleft()\n\n        # Print the current board state\n        print(f'Depth: {curr.depth}')\n        print_board(curr.board)\n\n        # Check if goal state is reached\n        if is_goal_state(curr.board):\n            print(f'Goal state reached at depth {curr.depth}')\n            return\n\n        # Explore all possible moves\n        for i in range(4):\n            new_x = curr.x + row[i]\n            new_y = curr.y + col[i]\n\n            if is_valid(new_x, new_y):\n                new_board = [row[:] for row in curr.board]\n                new_board[curr.x][curr.y], new_board[new_x][new_y] = new_board[new_x][new_y], new_board[curr.x][curr.y]\n\n                # If this state has not been visited before, push to queue\n                if tuple(map(tuple, new_board)) not in visited:\n                    visited.add(tuple(map(tuple, new_board)))\n                    q.append(PuzzleState(new_board, new_x, new_y, curr.depth + 1))\n\n    print('No solution found (BFS Brute Force reached depth limit)')\n\n# Driver Code\nif __name__ == '__main__':\n    start = [[1, 2, 3], [4, 0, 5], [6, 7, 8]]  # Initial state\n    x, y = 1, 1\n\n    print('Initial State:')\n    print_board(start)\n\n    solve_puzzle_bfs(start, x, y)\nusing System;\nusing System.Collections.Generic;\n\nclass PuzzleState\n{\n    public string Board;  // Board stored as a string (e.g., \"123456780\")\n    public int X, Y;  // Position of '0'\n    public int Depth; // BFS depth level\n\n    public PuzzleState(string board, int x, int y, int depth)\n    {\n        Board = board;\n        X = x;\n        Y = y;\n        Depth = depth;\n    }\n}\n\nclass EightPuzzleBFS\n{\n    const int N = 3;\n\n    // Possible moves: Left, Right, Up, Down\n    static int[] row = { 0, 0, -1, 1 };\n    static int[] col = { -1, 1, 0, 0 };\n\n    static readonly string GOAL_STATE = \"123456780\"; // Goal state stored as string\n\n    // Function to convert 2D board to a string representation\n    static string BoardToString(int[,] board)\n    {\n        char[] sb = new char[9];\n        int index = 0;\n        for (int i = 0; i < N; i++)\n            for (int j = 0; j < N; j++)\n                sb[index++] = (char)(board[i, j] + '0');\n        return new string(sb);\n    }\n\n    // Function to print board from string representation\n    static void PrintBoard(string board)\n    {\n        for (int i = 0; i < 9; i++)\n        {\n            Console.Write(board[i] + \" \");\n            if ((i + 1) % 3 == 0)\n                Console.WriteLine();\n        }\n        Console.WriteLine(\"--------\");\n    }\n\n    // BFS function to solve the 8-puzzle problem\n    static void SolvePuzzleBFS(int[,] start, int x, int y)\n    {\n        Queue<PuzzleState> queue = new Queue<PuzzleState>();\n        HashSet<string> visited = new HashSet<string>();\n\n        string startBoard = BoardToString(start);\n        queue.Enqueue(new PuzzleState(startBoard, x, y, 0));\n        visited.Add(startBoard);\n\n        while (queue.Count > 0)\n        {\n            PuzzleState curr = queue.Dequeue();\n\n            // Print the current board state\n            Console.WriteLine(\"Depth: \" + curr.Depth);\n            PrintBoard(curr.Board);\n\n            // Check if goal state is reached\n            if (curr.Board == GOAL_STATE)\n            {\n                Console.WriteLine(\"Goal state reached at depth \" + curr.Depth);\n                return;\n            }\n\n            char[] boardArray = curr.Board.ToCharArray();\n            for (int i = 0; i < 4; i++)\n            {\n                int newX = curr.X + row[i];\n                int newY = curr.Y + col[i];\n\n                if (newX >= 0 && newX < N && newY >= 0 && newY < N)\n                {\n                    int zeroPos = curr.X * N + curr.Y;\n                    int swapPos = newX * N + newY;\n\n                    // Swap 0 with the new position\n                    char temp = boardArray[zeroPos];\n                    boardArray[zeroPos] = boardArray[swapPos];\n                    boardArray[swapPos] = temp;\n\n                    string newBoard = new string(boardArray);\n\n                    // If this state has not been visited before, add to queue\n                    if (!visited.Contains(newBoard))\n                    {\n                        visited.Add(newBoard);\n                        queue.Enqueue(new PuzzleState(newBoard, newX, newY, curr.Depth + 1));\n                    }\n\n                    // Swap back to restore original board for next iteration\n                    temp = boardArray[zeroPos];\n                    boardArray[zeroPos] = boardArray[swapPos];\n                    boardArray[swapPos] = temp;\n                }\n            }\n        }\n\n        Console.WriteLine(\"No solution found (BFS Brute Force reached depth limit)\");\n    }\n\n    // Driver Code\n    static void Main()\n    {\n        int[,] start = {\n            { 1, 2, 3 },\n            { 4, 0, 5 },\n            { 6, 7, 8 }\n        }; // Initial state\n        int x = 1, y = 1; // Position of the empty tile (0)\n\n        Console.WriteLine(\"Initial State:\");\n        PrintBoard(BoardToString(start));\n\n        SolvePuzzleBFS(start, x, y);\n    }\n}\n// Define the dimensions of the puzzle\nconst N = 3;\n\n// Class to represent the state of the puzzle\nclass PuzzleState {\n    constructor(board, x, y, depth) {\n        this.board = board;\n        this.x = x;\n        this.y = y;\n        this.depth = depth;\n    }\n}\n\n// Possible moves: Left, Right, Up, Down\nconst row = [0, 0, -1, 1];\nconst col = [-1, 1, 0, 0];\n\n// Function to check if the current state is the goal state\nfunction isGoalState(board) {\n    const goal = [[1, 2, 3], [4, 5, 6], [7, 8, 0]];\n    return JSON.stringify(board) === JSON.stringify(goal);\n}\n\n// Function to check if a move is valid\nfunction isValid(x, y) {\n    return (x >= 0 && x < N && y >= 0 && y < N);\n}\n\n// Function to print the puzzle board\nfunction printBoard(board) {\n    for (let row of board) {\n        console.log(row.join(' '));\n    }\n    console.log(\"--------\");\n}\n\n// BFS function to solve the 8-puzzle problem\nfunction solvePuzzleBFS(start, x, y) {\n    const queue = [];\n    const visited = new Set();\n\n    // Enqueue initial state\n    queue.push(new PuzzleState(start, x, y, 0));\n    visited.add(JSON.stringify(start));\n\n    while (queue.length > 0) {\n        const curr = queue.shift();\n\n        // Print the current board state\n        console.log(`Depth: ${curr.depth}`);\n        printBoard(curr.board);\n\n        // Check if goal state is reached\n        if (isGoalState(curr.board)) {\n            console.log(`Goal state reached at depth ${curr.depth}`);\n            return;\n        }\n\n        // Explore all possible moves\n        for (let i = 0; i < 4; i++) {\n            const newX = curr.x + row[i];\n            const newY = curr.y + col[i];\n\n            if (isValid(newX, newY)) {\n                const newBoard = curr.board.map(arr => arr.slice());\n                [newBoard[curr.x][curr.y], newBoard[newX][newY]] = [newBoard[newX][newY], newBoard[curr.x][curr.y]];\n\n                // If this state has not been visited before, push to queue\n                if (!visited.has(JSON.stringify(newBoard))) {\n                    visited.add(JSON.stringify(newBoard));\n                    queue.push(new PuzzleState(newBoard, newX, newY, curr.depth + 1));\n                }\n            }\n        }\n    }\n\n    console.log(\"No solution found (BFS Brute Force reached depth limit)\");\n}\n\n// Driver Code\nconst start = [[1, 2, 3], [4, 0, 5], [6, 7, 8]]; // Initial state\nconst x = 1, y = 1;\n\nconsole.log(\"Initial State: \");\nprintBoard(start);\n\nsolvePuzzleBFS(start, x, y);\nInitial State: \n1 2 3 \n4 0 5 \n6 7 8 \n--------\nDepth: 0\n1 2 3 \n4 0 5 \n6 7 8 \n--------\nDepth: 1\n1 2 3 \n0 4 5 \n6 7 8 \n--------\nDepth: 1\n1 2 3 \n4 5 0 \n6 7 8 \n--------\nDepth: 1\n1 0 3 \n4 2 5 \n6 7 8 \n-------...\n#include <bits/stdc++.h>\nusing namespace std;\n#define N 3\n\n// State space tree node\nstruct Node {\n    Node* parent;  \n    int mat[N][N];\n    int x, y;      \n    int cost;     \n    int level;     \n};\n\n// Function to print N x N matrix\nvoid printMatrix(int mat[N][N]) {\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++)\n            cout << mat[i][j] << \" \";\n        cout << endl;\n    }\n}\n\n// Function to allocate a new node\nNode* newNode(int mat[N][N], int x, int y, int newX, int newY, int level, Node* parent) {\n    Node* node = new Node;\n    if (!node) {\n        cout << \"Memory allocation failed\" << endl;\n        exit(1);\n    }\n    \n    node->parent = parent;\n    memcpy(node->mat, mat, sizeof node->mat);\n    swap(node->mat[x][y], node->mat[newX][newY]); // Swap blank tile\n    node->cost = INT_MAX;\n    node->level = level;\n    node->x = newX;\n    node->y = newY;\n    return node;\n}\n\n// Bottom, left, top, right movement\nint row[] = {1, 0, -1, 0};\nint col[] = {0, -1, 0, 1};\n\n// Function to calculate misplaced tiles\nint calculateCost(int initial[N][N], int final[N][N]) {\n    int count = 0;\n    for (int i = 0; i < N; i++)\n        for (int j = 0; j < N; j++)\n            if (initial[i][j] && initial[i][j] != final[i][j])\n                count++;\n    return count;\n}\n\n// Function to check if coordinates are valid\nbool isSafe(int x, int y) {\n    return (x >= 0 && x < N && y >= 0 && y < N);\n}\n\n// Print path from root node to destination node\nvoid printPath(Node* root) {\n    if (root == NULL)\n        return;\n    printPath(root->parent);\n    printMatrix(root->mat);\n    cout << endl;\n}\n\n// Custom comparison object for priority queue\nstruct comp {\n    bool operator()(const Node* lhs, const Node* rhs) const {\n        return (lhs->cost + lhs->level) > (rhs->cost + rhs->level);\n    }\n};\n\n// Function to solve the 8-puzzle using Branch and Bound\nvoid solve(int initial[N][N], int x, int y, int final[N][N]) {\n    priority_queue<Node*, vector<Node*>, comp> pq;\n    Node* root = newNode(initial, x, y, x, y, 0, NULL);\n    root->cost = calculateCost(initial, final);\n    pq.push(root);\n\n    while (!pq.empty()) {\n        Node* min = pq.top();\n        pq.pop();\n\n        // If final state is reached, print the solution path\n        if (min->cost == 0) {\n            printPath(min);\n            return;\n        }\n\n        // Generate all possible child nodes\n        for (int i = 0; i < 4; i++) {\n            int newX = min->x + row[i], newY = min->y + col[i];\n            if (isSafe(newX, newY)) {\n                Node* child = newNode(min->mat, min->x, min->y, newX, newY, min->level + 1, min);\n                child->cost = calculateCost(child->mat, final);\n                pq.push(child);\n            }\n        }\n        \n        // Free the memory of explored node\n        delete min;\n    }\n}\n\n// Driver Code\nint main() {\n    // Initial configuration\n    int initial[N][N] = {\n        {1, 0, 2},\n        {3, 4, 5},\n        {6, 7, 8}\n    };\n\n    // Solvable Final configuration\n    int final[N][N] = {\n        {0, 1, 2},\n        {3, 4, 5},\n        {6, 7, 8}\n    };\n\n    // Blank tile coordinates in initial configuration\n    int x = 0, y = 1;\n\n    solve(initial, x, y, final);\n    return 0;\n}\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n\n#define N 3\n\n// State space tree node\nstruct Node {\n    struct Node* parent;\n    int mat[N][N];\n    int x, y;\n    int cost;\n    int level;\n};\n\n// Function to print N x N matrix\nvoid printMatrix(int mat[N][N]) {\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++)\n            printf(\"%d \", mat[i][j]);\n        printf(\"\\n\");\n    }\n}\n\n// Function to allocate a new node\nstruct Node* newNode(int mat[N][N], int x, int y, int newX, int newY, int level, struct Node* parent) {\n    struct Node* node = (struct Node*)malloc(sizeof(struct Node));\n    if (!node) {\n        printf(\"Memory allocation failed\\n\");\n        exit(1);\n    }\n    \n    node->parent = parent;\n    memcpy(node->mat, mat, sizeof(node->mat));\n    int temp = node->mat[x][y];\n    node->mat[x][y] = node->mat[newX][newY];\n    node->mat[newX][newY] = temp; // Swap blank tile\n    node->cost = INT_MAX;\n    node->level = level;\n    node->x = newX;\n    node->y = newY;\n    return node;\n}\n\n// Bottom, left, top, right movement\nint row[] = {1, 0, -1, 0};\nint col[] = {0, -1, 0, 1};\n\n// Function to calculate misplaced tiles\nint calculateCost(int initial[N][N], int final[N][N]) {\n    int count = 0;\n    for (int i = 0; i < N; i++)\n        for (int j = 0; j < N; j++)\n            if (initial[i][j] && initial[i][j] != final[i][j])\n                count++;\n    return count;\n}\n\n// Function to check if coordinates are valid\nint isSafe(int x, int y) {\n    return (x >= 0 && x < N && y >= 0 && y < N);\n}\n\n// Print path from root node to destination node\nvoid printPath(struct Node* root) {\n    if (root == NULL)\n        return;\n    printPath(root->parent);\n    printMatrix(root->mat);\n    printf(\"\\n\");\n}\n\n// Custom comparison object for priority queue\nint compare(const void* a, const void* b) {\n    struct Node* lhs = *(struct Node**)a;\n    struct Node* rhs = *(struct Node**)b;\n    return (lhs->cost + lhs->level) - (rhs->cost + rhs->level);\n}\n\n// Function to solve the 8-puzzle using Branch and Bound\nvoid solve(int initial[N][N], int x, int y, int final[N][N]) {\n    struct Node* pq[100];\n    int pqSize = 0;\n    struct Node* root = newNode(initial, x, y, x, y, 0, NULL);\n    root->cost = calculateCost(initial, final);\n    pq[pqSize++] = root;\n\n    while (pqSize > 0) {\n        qsort(pq, pqSize, sizeof(struct Node*), compare);\n        struct Node* min = pq[0];\n        for (int i = 1; i < pqSize; i++) {\n            pq[i - 1] = pq[i];\n        }\n        pqSize--;\n\n        // If final state is reached, print the solution path\n        if (min->cost == 0) {\n            printPath(min);\n            return;\n        }\n\n        // Generate all possible child nodes\n        for (int i = 0; i < 4; i++) {\n            int newX = min->x + row[i], newY = min->y + col[i];\n            if (isSafe(newX, newY)) {\n                struct Node* child = newNode(min->mat, min->x, min->y, newX, newY, min->level + 1, min);\n                child->cost = calculateCost(child->mat, final);\n                pq[pqSize++] = child;\n            }\n        }\n        \n        // Free the memory of explored node\n        free(min);\n    }\n}\n\n// Driver Code\nint main() {\n    // Initial configuration\n    int initial[N][N] = {\n        {1, 0, 2},\n        {3, 4, 5},\n        {6, 7, 8}\n    };\n\n    // Solvable Final configuration\n    int final[N][N] = {\n        {0, 1, 2},\n        {3, 4, 5},\n        {6, 7, 8}\n    };\n\n    // Blank tile coordinates in initial configuration\n    int x = 0, y = 1;\n\n    solve(initial, x, y, final);\n    return 0;\n}\n// Import necessary libraries\nimport java.util.*;\n\nclass EightPuzzleSolver {\n    // State space tree node\n    static class Node {\n        Node parent;\n        int[][] mat;\n        int x, y;\n        int cost;\n        int level;\n\n        Node(int[][] mat, int x, int y, int level, Node parent) {\n            this.mat = new int[3][3];\n            for (int i = 0; i < 3; i++)\n                System.arraycopy(mat[i], 0, this.mat[i], 0, 3);\n\n            this.x = x;\n            this.y = y;\n            this.level = level;\n            this.parent = parent;\n            this.cost = Integer.MAX_VALUE;\n        }\n    }\n\n    // Function to print N x N matrix\n    static void printMatrix(int[][] mat) {\n        for (int[] row : mat) {\n            for (int val : row) {\n                System.out.print(val + \" \");\n            }\n            System.out.println();\n        }\n    }\n\n    // Bottom, left, top, right movement\n    static int[] row = {1, 0, -1, 0};\n    static int[] col = {0, -1, 0, 1};\n\n    // Function to calculate misplaced tiles\n    static int calculateCost(int[][] initial, int[][] goal) {\n        int count = 0;\n        for (int i = 0; i < 3; i++)\n            for (int j = 0; j < 3; j++)\n                if (initial[i][j] != 0 && initial[i][j] != goal[i][j])\n                    count++;\n        return count;\n    }\n\n    // Function to check if coordinates are valid\n    static boolean isSafe(int x, int y) {\n        return (x >= 0 && x < 3 && y >= 0 && y < 3);\n    }\n\n    // Print path from root node to destination node\n    static void printPath(Node root) {\n        if (root == null)\n            return;\n        printPath(root.parent);\n        printMatrix(root.mat);\n        System.out.println();\n    }\n\n    // Custom comparator for priority queue\n    static class Comp implements Comparator<Node> {\n        public int compare(Node lhs, Node rhs) {\n            return (lhs.cost + lhs.level) - (rhs.cost + rhs.level);\n        }\n    }\n\n    // Function to solve the 8-puzzle using Branch and Bound\n    static void solve(int[][] initial, int x, int y, int[][] goal) {\n        PriorityQueue<Node> pq = new PriorityQueue<>(new Comp());\n        Node root = new Node(initial, x, y, 0, null);\n        root.cost = calculateCost(initial, goal);\n        pq.add(root);\n\n        while (!pq.isEmpty()) {\n            Node min = pq.poll();\n\n            // If final state is reached, print the solution path\n            if (min.cost == 0) {\n                printPath(min);\n                return;\n            }\n\n            // Generate all possible child nodes\n            for (int i = 0; i < 4; i++) {\n                int newX = min.x + row[i], newY = min.y + col[i];\n                if (isSafe(newX, newY)) {\n                    int[][] newMat = new int[3][3];\n                    for (int j = 0; j < 3; j++)\n                        System.arraycopy(min.mat[j], 0, newMat[j], 0, 3);\n\n                    // Swap blank tile\n                    newMat[min.x][min.y] = newMat[newX][newY];\n                    newMat[newX][newY] = 0;\n\n                    Node child = new Node(newMat, newX, newY, min.level + 1, min);\n                    child.cost = calculateCost(child.mat, goal);\n                    pq.add(child);\n                }\n            }\n        }\n    }\n\n    // Driver Code\n    public static void main(String[] args) {\n        // Initial configuration\n        int[][] initial = {\n            {1, 0, 2},\n            {3, 4, 5},\n            {6, 7, 8}\n        };\n\n        // Solvable Final configuration\n        int[][] goal = {\n            {0, 1, 2},\n            {3, 4, 5},\n            {6, 7, 8}\n        };\n\n        // Blank tile coordinates in initial configuration\n        int x = 0, y = 1;\n\n        solve(initial, x, y, goal);\n    }\n}\n# State space tree node\nclass Node:\n    def __init__(self, mat, x, y, level, parent):\n        self.parent = parent\n        self.mat = mat\n        self.x = x\n        self.y = y\n        self.cost = float('inf')\n        self.level = level\n\n# Function to print N x N matrix\ndef print_matrix(mat):\n    for row in mat:\n        print(' '.join(map(str, row)))\n\n# Bottom, left, top, right movement\nrow = [1, 0, -1, 0]\ncol = [0, -1, 0, 1]\n\n# Function to calculate misplaced tiles\ndef calculate_cost(initial, final):\n    count = 0\n    for i in range(3):\n        for j in range(3):\n            if initial[i][j] != 0 and initial[i][j] != final[i][j]:\n                count += 1\n    return count\n\n# Function to check if coordinates are valid\ndef is_safe(x, y):\n    return 0 <= x < 3 and 0 <= y < 3\n\n# Print path from root node to destination node\ndef print_path(root):\n    if root is None:\n        return\n    print_path(root.parent)\n    print_matrix(root.mat)\n    print()\n\n# Function to solve the 8-puzzle using Branch and Bound\ndef solve(initial, x, y, final):\n    pq = []\n    root = Node(initial, x, y, 0, None)\n    root.cost = calculate_cost(initial, final)\n    pq.append(root)\n\n    while pq:\n        min_node = min(pq, key=lambda n: n.cost + n.level)\n        pq.remove(min_node)\n\n        # If final state is reached, print the solution path\n        if min_node.cost == 0:\n            print_path(min_node)\n            return\n\n        # Generate all possible child nodes\n        for i in range(4):\n            new_x, new_y = min_node.x + row[i], min_node.y + col[i]\n            if is_safe(new_x, new_y):\n                new_mat = [row[:] for row in min_node.mat]\n                new_mat[min_node.x][min_node.y], new_mat[new_x][new_y] = new_mat[new_x][new_y], new_mat[min_node.x][min_node.y]\n                child = Node(new_mat, new_x, new_y, min_node.level + 1, min_node)\n                child.cost = calculate_cost(child.mat, final)\n                pq.append(child)\n\n# Driver Code\nif __name__ == '__main__':\n    # Initial configuration\n    initial = [\n        [1, 0, 2],\n        [3, 4, 5],\n        [6, 7, 8]\n    ]\n\n    # Solvable Final configuration\n    final = [\n        [0, 1, 2],\n        [3, 4, 5],\n        [6, 7, 8]\n    ]\n\n    # Blank tile coordinates in initial configuration\n    x, y = 0, 1\n\n    solve(initial, x, y, final)\nusing System;\nusing System.Collections.Generic;\n\nclass EightPuzzleSolver {\n    // State space tree node\n    class Node {\n        public Node parent;\n        public int[,] mat;\n        public int x, y;\n        public int cost;\n        public int level;\n\n        public Node(int[,] mat, int x, int y, int level, Node parent) {\n            this.mat = new int[3, 3];\n            Array.Copy(mat, this.mat, mat.Length);\n\n            this.x = x;\n            this.y = y;\n            this.level = level;\n            this.parent = parent;\n            this.cost = int.MaxValue;\n        }\n    }\n\n    // Function to print N x N matrix\n    static void PrintMatrix(int[,] mat) {\n        for (int i = 0; i < 3; i++) {\n            for (int j = 0; j < 3; j++) {\n                Console.Write(mat[i, j] + \" \");\n            }\n            Console.WriteLine();\n        }\n    }\n\n    // Bottom, left, top, right movement\n    static readonly int[] row = {1, 0, -1, 0};\n    static readonly int[] col = {0, -1, 0, 1};\n\n    // Function to calculate misplaced tiles\n    static int CalculateCost(int[,] initial, int[,] goal) {\n        int count = 0;\n        for (int i = 0; i < 3; i++)\n            for (int j = 0; j < 3; j++)\n                if (initial[i, j] != 0 && initial[i, j] != goal[i, j])\n                    count++;\n        return count;\n    }\n\n    // Function to check if coordinates are valid\n    static bool IsSafe(int x, int y) {\n        return (x >= 0 && x < 3 && y >= 0 && y < 3);\n    }\n\n    // Print path from root node to destination node\n    static void PrintPath(Node root) {\n        if (root == null)\n            return;\n        PrintPath(root.parent);\n        PrintMatrix(root.mat);\n        Console.WriteLine();\n    }\n\n    // Custom comparator for priority queue simulation using SortedSet\n    class Comp : IComparer<Node> {\n        public int Compare(Node lhs, Node rhs) {\n            int costCompare = (lhs.cost + lhs.level).CompareTo(rhs.cost + rhs.level);\n            return costCompare != 0 ? costCompare : lhs.GetHashCode().CompareTo(rhs.GetHashCode());\n        }\n    }\n\n    // Function to solve the 8-puzzle using Branch and Bound\n    static void Solve(int[,] initial, int x, int y, int[,] goal) {\n        SortedSet<Node> pq = new SortedSet<Node>(new Comp()); // Simulating a priority queue\n        Node root = new Node(initial, x, y, 0, null);\n        root.cost = CalculateCost(initial, goal);\n        pq.Add(root);\n\n        while (pq.Count > 0) {\n            Node min = null;\n            foreach (var node in pq) { \n                min = node; break; // Get the node with the smallest cost\n            }\n            pq.Remove(min);\n\n            // If final state is reached, print the solution path\n            if (min.cost == 0) {\n                PrintPath(min);\n                return;\n            }\n\n            // Generate all possible child nodes\n            for (int i = 0; i < 4; i++) {\n                int newX = min.x + row[i], newY = min.y + col[i];\n                if (IsSafe(newX, newY)) {\n                    int[,] newMat = new int[3, 3];\n                    Array.Copy(min.mat, newMat, min.mat.Length);\n\n                    // Swap blank tile\n                    newMat[min.x, min.y] = newMat[newX, newY];\n                    newMat[newX, newY] = 0;\n\n                    Node child = new Node(newMat, newX, newY, min.level + 1, min);\n                    child.cost = CalculateCost(child.mat, goal);\n                    pq.Add(child);\n                }\n            }\n        }\n    }\n\n    // Driver Code\n    public static void Main(string[] args) {\n        // Initial configuration\n        int[,] initial = {\n            {1, 0, 2},\n            {3, 4, 5},\n            {6, 7, 8}\n        };\n\n        // Solvable Final configuration\n        int[,] goal = {\n            {0, 1, 2},\n            {3, 4, 5},\n            {6, 7, 8}\n        };\n\n        // Blank tile coordinates in initial configuration\n        int x = 0, y = 1;\n\n        Solve(initial, x, y, goal);\n    }\n}\n// State space tree node\nclass Node {\n    constructor(parent, mat, x, y, cost, level) {\n        this.parent = parent;\n        this.mat = mat;\n        this.x = x;\n        this.y = y;\n        this.cost = cost;\n        this.level = level;\n    }\n}\n\n// Function to print N x N matrix\nfunction printMatrix(mat) {\n    for (let i = 0; i < mat.length; i++) {\n        console.log(mat[i].join(' '));\n    }\n}\n\n// Function to allocate a new node\nfunction newNode(mat, x, y, newX, newY, level, parent) {\n    let newMat = mat.map(row => [...row]); // Faster matrix copy\n    [newMat[x][y], newMat[newX][newY]] = [newMat[newX][newY], newMat[x][y]]; // Swap blank tile\n    return new Node(parent, newMat, newX, newY, Infinity, level);\n}\n\n// Bottom, left, top, right movement\nconst row = [1, 0, -1, 0];\nconst col = [0, -1, 0, 1];\n\n// Function to calculate misplaced tiles\nfunction calculateCost(initial, final) {\n    let count = 0;\n    for (let i = 0; i < initial.length; i++) {\n        for (let j = 0; j < initial[i].length; j++) {\n            if (initial[i][j] && initial[i][j] !== final[i][j])\n                count++;\n        }\n    }\n    return count;\n}\n\n// Function to check if coordinates are valid\nfunction isSafe(x, y, N) {\n    return (x >= 0 && x < N && y >= 0 && y < N);\n}\n\n// Print path from root node to destination node\nfunction printPath(root) {\n    if (!root) return;\n    printPath(root.parent);\n    printMatrix(root.mat);\n    console.log('');\n}\n\n// Generate a unique string representation of the state (to avoid duplicates)\nfunction stateToString(mat) {\n    return mat.map(row => row.join(',')).join(';');\n}\n\n// Optimized MinHeap (Priority Queue)\nclass MinHeap {\n    constructor() {\n        this.nodes = [];\n    }\n    push(node) {\n        this.nodes.push(node);\n        this.bubbleUp();\n    }\n    pop() {\n        if (this.nodes.length === 0) return null;\n        const min = this.nodes[0];\n        const end = this.nodes.pop();\n        if (this.nodes.length > 0) {\n            this.nodes[0] = end;\n            this.sinkDown();\n        }\n        return min;\n    }\n    bubbleUp() {\n        let index = this.nodes.length - 1;\n        const element = this.nodes[index];\n        while (index > 0) {\n            let parentIndex = Math.floor((index - 1) / 2);\n            let parent = this.nodes[parentIndex];\n            if (element.cost + element.level >= parent.cost + parent.level) break;\n            this.nodes[index] = parent;\n            index = parentIndex;\n        }\n        this.nodes[index] = element;\n    }\n    sinkDown() {\n        let index = 0;\n        const length = this.nodes.length;\n        const element = this.nodes[0];\n        while (true) {\n            let leftChildIndex = 2 * index + 1;\n            let rightChildIndex = 2 * index + 2;\n            let leftChild, rightChild;\n            let swap = null;\n            if (leftChildIndex < length) {\n                leftChild = this.nodes[leftChildIndex];\n                if (leftChild.cost + leftChild.level < element.cost + element.level) {\n                    swap = leftChildIndex;\n                }\n            }\n            if (rightChildIndex < length) {\n                rightChild = this.nodes[rightChildIndex];\n                if ((swap === null && rightChild.cost + rightChild.level < element.cost + element.level) || \n                    (swap !== null && rightChild.cost + rightChild.level < leftChild.cost + leftChild.level)) {\n                    swap = rightChildIndex;\n                }\n            }\n            if (swap === null) break;\n            this.nodes[index] = this.nodes[swap];\n            index = swap;\n        }\n        this.nodes[index] = element;\n    }\n}\n\n// Function to solve the 8-puzzle using Branch and Bound\nfunction solve(initial, x, y, final) {\n    const pq = new MinHeap();\n    const root = newNode(initial, x, y, x, y, 0, null);\n    root.cost = calculateCost(initial, final);\n    pq.push(root);\n\n    // HashSet to avoid visiting the same state twice\n    const visited = new Set();\n    visited.add(stateToString(initial));\n\n    while (pq.nodes.length) {\n        const min = pq.pop();\n\n        // If final state is reached, print the solution path\n        if (min.cost === 0) {\n            printPath(min);\n            return;\n        }\n\n        // Generate all possible child nodes\n        for (let i = 0; i < 4; i++) {\n            const newX = min.x + row[i], newY = min.y + col[i];\n            if (isSafe(newX, newY, initial.length)) {\n                const child = newNode(min.mat, min.x, min.y, newX, newY, min.level + 1, min);\n                child.cost = calculateCost(child.mat, final);\n\n                // Convert state to string and check if it's visited\n                const stateStr = stateToString(child.mat);\n                if (!visited.has(stateStr)) {\n                    visited.add(stateStr);\n                    pq.push(child);\n                }\n            }\n        }\n    }\n}\n\n// Driver Code\nconst initial = [\n    [1, 0, 2],\n    [3, 4, 5],\n    [6, 7, 8]\n];\n\n// Solvable Final configuration\nconst final = [\n    [0, 1, 2],\n    [3, 4, 5],\n    [6, 7, 8]\n];\n\n// Blank tile coordinates in initial configuration\nconst x = 0, y = 1;\n\nsolve(initial, x, y, final);\n1 2 3 \n5 6 0 \n7 8 4 \n\n1 2 3 \n5 0 6 \n7 8 4 \n\n1 2 3 \n5 8 6 \n7 0 4 \n\n1 2 3 \n5 8 6 \n0 7 4\n",
        "complexity": {
            "time": "",
            "space": ""
        },
        "tags": [
            "Branch & Bound"
        ],
        "url": "https://www.geeksforgeeks.org/8-puzzle-problem-using-branch-and-bound/"
    },
    {
        "title": "Job Assignment Problem using Branch And Bound",
        "description": "Let there be N workers and N jobs. Any worker can be assigned to perform any job, incurring some cost that may vary depending on the work-job assignment. It is required to perform all jobs by assigning exactly one worker to each job and exactly one job to each agent in such a way that the total cost of the assignment is minimized.  Let us explore all approaches for this problem. We generate n! possible job assignments and for each such assignment, we compute its total cost and return the less expensive assignment. Since the solution is a permutation of the n jobs, its complexity is O(n!). The optimal assignment can be found using the Hungarian algorithm. The Hungarian algorithm has worst case run-time complexity of O(n^3). A state space tree is a N-ary tree with property that any path from root to leaf node holds one of many solutions to given problem. We can perform depth-first search on state space tree and but successive moves can take us away from the goal rather than bringing closer. The search of state space tree follows leftmost path from the root regardless of initial state. An answer node may never be found in this approach. We can also perform a Breadth-first search on state space tree. But no matter what the initial state is, the algorithm attempts the same sequence of moves like DFS. The selection rule for the next node in BFS and DFS is “blind”. i.e. the selection rule does not give any preference to a node that has a very good chance of getting the search to an answer node quickly. The search for an optimal solution can often be speeded by using an “intelligent” ranking function, also called an approximate cost function to avoid searching in sub-trees that do not contain an optimal solution. It is similar to BFS-like search but with one major optimization. Instead of following FIFO order, we choose a live node with least cost. We may not get optimal solution by following node with least promising cost, but it will provide very good chance of getting the search to an answer node quickly. There are two approaches to calculate the cost function: In this article, the first approach is followed. Let’s take below example and try to calculate promising cost when Job 2 is assigned to worker A.  Since Job 2 is assigned to worker A (marked in green), cost becomes 2 and Job 2 and worker A becomes unavailable (marked in red).  Now we assign job 3 to worker B as it has minimum cost from list of unassigned jobs. Cost becomes 2 + 3 = 5 and Job 3 and worker B also becomes unavailable.  Finally, job 1 gets assigned to worker C as it has minimum cost among unassigned jobs and job 4 gets assigned to worker D as it is only Job left. Total cost becomes 2 + 3 + 5 + 4 = 14.  Below diagram shows complete search space diagram showing optimal solution path in green.  Complete Algorithm: Below is the implementation of the above approach: Output : Time Complexity: O(M*N). This is because the algorithm uses a double for loop to iterate through the M x N matrix. Auxiliary Space: O(M+N). This is because it uses two arrays of size M and N to track the applicants and jobs. A  ",
        "code": "/* findMinCost uses Least() and Add() to maintain the   list of live nodes   Least() finds a live node with least cost, deletes   it from the list and returns it   Add(x) calculates cost of x and adds it to the list   of live nodes   Implements list of live nodes as a min heap */// Search Space Tree Nodenode{   int job_number;   int worker_number;   node parent;   int cost;}// Input: Cost Matrix of Job Assignment problem// Output: Optimal cost and Assignment of Jobsalgorithm findMinCost (costMatrix mat[][]){   // Initialize list of live nodes(min-Heap)   // with root of search tree i.e. a Dummy node   while (true)   {      // Find a live node with least estimated cost      E = Least();      // The found node is deleted from the list      // of live nodes      if (E is a leaf node)      {         printSolution();         return;      }     for each child x of E     {         Add(x); // Add x to list of live nodes;         x->parent = E; // Pointer for path to root     }   }}\n// Program to solve Job Assignment problem\n// using Branch and Bound\n#include <bits/stdc++.h>\nusing namespace std;\n#define N 4\n\n// state space tree node\nstruct Node\n{\n    // stores parent node of current node\n    // helps in tracing path when answer is found\n    Node* parent;\n\n    // contains cost for ancestors nodes\n    // including current node\n    int pathCost;\n\n    // contains least promising cost\n    int cost;\n\n    // contain worker number\n    int workerID;\n\n    // contains Job ID\n    int jobID;\n\n    // Boolean array assigned will contains\n    // info about available jobs\n    bool assigned[N];\n};\n\n// Function to allocate a new search tree node\n// Here Person x is assigned to job y\nNode* newNode(int x, int y, bool assigned[],\n              Node* parent)\n{\n    Node* node = new Node;\n\n    for (int j = 0; j < N; j++)\n        node->assigned[j] = assigned[j];\n    node->assigned[y] = true;\n\n    node->parent = parent;\n    node->workerID = x;\n    node->jobID = y;\n\n    return node;\n}\n\n// Function to calculate the least promising cost\n// of node after worker x is assigned to job y.\nint calculateCost(int costMatrix[N][N], int x,\n                  int y, bool assigned[])\n{\n    int cost = 0;\n\n    // to store unavailable jobs\n    bool available[N] = {true};\n\n    // start from next worker\n    for (int i = x + 1; i < N; i++)\n    {\n        int min = INT_MAX, minIndex = -1;\n\n        // do for each job\n        for (int j = 0; j < N; j++)\n        {\n            // if job is unassigned\n            if (!assigned[j] && available[j] &&\n                costMatrix[i][j] < min)\n            {\n                // store job number\n                minIndex = j;\n\n                // store cost\n                min = costMatrix[i][j];\n            }\n        }\n\n        // add cost of next worker\n        cost += min;\n\n        // job becomes unavailable\n        available[minIndex] = false;\n    }\n\n    return cost;\n}\n\n// Comparison object to be used to order the heap\nstruct comp\n{\n    bool operator()(const Node* lhs,\n                   const Node* rhs) const\n    {\n        return lhs->cost > rhs->cost;\n    }\n};\n\n// print Assignments\nvoid printAssignments(Node *min)\n{\n    if(min->parent==NULL)\n        return;\n\n    printAssignments(min->parent);\n    cout << \"Assign Worker \" << char(min->workerID + 'A')\n         << \" to Job \" << min->jobID << endl;\n\n}\n\n// Finds minimum cost using Branch and Bound.\nint findMinCost(int costMatrix[N][N])\n{\n    // Create a priority queue to store live nodes of\n    // search tree;\n    priority_queue<Node*, std::vector<Node*>, comp> pq;\n\n    // initialize heap to dummy node with cost 0\n    bool assigned[N] = {false};\n    Node* root = newNode(-1, -1, assigned, NULL);\n    root->pathCost = root->cost = 0;\n    root->workerID = -1;\n\n    // Add dummy node to list of live nodes;\n    pq.push(root);\n\n    // Finds a live node with least cost,\n    // add its childrens to list of live nodes and\n    // finally deletes it from the list.\n    while (!pq.empty())\n    {\n      // Find a live node with least estimated cost\n      Node* min = pq.top();\n\n      // The found node is deleted from the list of\n      // live nodes\n      pq.pop();\n\n      // i stores next worker\n      int i = min->workerID + 1;\n\n      // if all workers are assigned a job\n      if (i == N)\n      {\n          printAssignments(min);\n          return min->cost;\n      }\n\n      // do for each job\n      for (int j = 0; j < N; j++)\n      {\n        // If unassigned\n        if (!min->assigned[j])\n        {\n          // create a new tree node\n          Node* child = newNode(i, j, min->assigned, min);\n\n          // cost for ancestors nodes including current node\n          child->pathCost = min->pathCost + costMatrix[i][j];\n\n          // calculate its lower bound\n          child->cost = child->pathCost +\n            calculateCost(costMatrix, i, j, child->assigned);\n\n          // Add child to list of live nodes;\n          pq.push(child);\n        }\n      }\n    }\n}\n\n// Driver code\nint main()\n{\n    // x-coordinate represents a Worker\n    // y-coordinate represents a Job\n    int costMatrix[N][N] =\n    {\n        {9, 2, 7, 8},\n        {6, 4, 3, 7},\n        {5, 8, 1, 8},\n        {7, 6, 9, 4}\n    };\n\n\n    /* int costMatrix[N][N] =\n    {\n        {82, 83, 69, 92},\n        {77, 37, 49, 92},\n        {11, 69,  5, 86},\n        { 8,  9, 98, 23}\n    };\n    */\n\n    /* int costMatrix[N][N] =\n    {\n        {2500, 4000, 3500},\n        {4000, 6000, 3500},\n        {2000, 4000, 2500}\n    };*/\n\n    /*int costMatrix[N][N] =\n    {\n        {90, 75, 75, 80},\n        {30, 85, 55, 65},\n        {125, 95, 90, 105},\n        {45, 110, 95, 115}\n    };*/\n\n\n    cout << \"\\nOptimal Cost is \"\n        << findMinCost(costMatrix);\n\n    return 0;\n}\nimport java.util.*;\n\n// Node class represents a job assignment\nclass Node {\n    Node parent; // parent node\n    int pathCost; // cost to reach this node\n    int cost; // lower bound cost\n    int workerID; // worker ID\n    int jobID; // job ID\n    boolean assigned[]; // keeps track of assigned jobs\n\n    public Node(int N) {\n        assigned = new boolean[N]; // initialize assigned jobs array\n    }\n}\n\npublic class Main {\n    static final int N = 4; // number of workers and jobs\n\n    // Function to create a new search tree node\n    static Node newNode(int x, int y, boolean assigned[], Node parent) {\n        Node node = new Node(N);\n        for (int j = 0; j < N; j++)\n            node.assigned[j] = assigned[j];\n        if (y != -1) {\n            node.assigned[y] = true;\n        }\n        node.parent = parent;\n        node.workerID = x;\n        node.jobID = y;\n        return node;\n    }\n\n    // Function to calculate the least promising cost of a node\n    static int calculateCost(int costMatrix[][], int x, int y, boolean assigned[]) {\n        int cost = 0;\n        boolean available[] = new boolean[N];\n        Arrays.fill(available, true);\n\n        for (int i = x + 1; i < N; i++) {\n            int min = Integer.MAX_VALUE, minIndex = -1;\n            for (int j = 0; j < N; j++) {\n                if (!assigned[j] && available[j] && costMatrix[i][j] < min) {\n                    minIndex = j;\n                    min = costMatrix[i][j];\n                }\n            }\n            cost += min;\n            available[minIndex] = false;\n        }\n        return cost;\n    }\n\n    // Function to print job assignment\n    static void printAssignments(Node min) {\n        if (min.parent == null)\n            return;\n        printAssignments(min.parent);\n        System.out.println(\"Assign Worker \" + (char)(min.workerID + 'A') + \" to Job \" + min.jobID);\n    }\n\n    // Function to solve Job Assignment Problem using Branch and Bound\n    static int findMinCost(int costMatrix[][]) {\n        PriorityQueue<Node> pq = new PriorityQueue<>(Comparator.comparingInt(node -> node.cost));\n        boolean assigned[] = new boolean[N];\n        Node root = newNode(-1, -1, assigned, null);\n        root.pathCost = root.cost = 0;\n        root.workerID = -1;\n        pq.add(root);\n\n        while (!pq.isEmpty()) {\n            Node min = pq.poll();\n            int i = min.workerID + 1;\n            if (i == N) {\n                printAssignments(min);\n                return min.cost;\n            }\n            for (int j = 0; j < N; j++) {\n                if (!min.assigned[j]) {\n                    Node child = newNode(i, j, min.assigned, min);\n                    child.pathCost = min.pathCost + costMatrix[i][j];\n                    child.cost = child.pathCost + calculateCost(costMatrix, i, j, child.assigned);\n                    pq.add(child);\n                }\n            }\n        }\n        return 0;\n    }\n\n    public static void main(String[] args) {\n        int costMatrix[][] = {\n            {9, 2, 7, 8},\n            {6, 4, 3, 7},\n            {5, 8, 1, 8},\n            {7, 6, 9, 4}\n        };\n        System.out.println(\"\\nOptimal Cost is \" + findMinCost(costMatrix));\n    }\n}\nimport heapq\nimport copy\n\nN = 4\n\n# State space tree node\nclass Node:\n    def __init__(self, x, y, assigned, parent):\n        self.parent = parent\n        self.pathCost = 0\n        self.cost = 0\n        self.workerID = x\n        self.jobID = y\n        self.assigned = copy.deepcopy(assigned)\n        if y != -1:\n            self.assigned[y] = True\n\n# Custom heap class with push and pop functions\nclass CustomHeap:\n    def __init__(self):\n        self.heap = []\n\n    def push(self, node):\n        heapq.heappush(self.heap, (node.cost, node))\n\n    def pop(self):\n        if self.heap:\n            _, node = heapq.heappop(self.heap)\n            return node\n        return None\n\n# Function to allocate a new search tree node\n# Here Person x is assigned to job y\ndef new_node(x, y, assigned, parent):\n    return Node(x, y, assigned, parent)\n\n# Function to calculate the least promising cost\n# of node after worker x is assigned to job y.\ndef calculate_cost(cost_matrix, x, y, assigned):\n    cost = 0\n\n    # to store unavailable jobs\n    available = [True] * N\n\n    # start from the next worker\n    for i in range(x + 1, N):\n        min_val, min_index = float('inf'), -1\n\n        # do for each job\n        for j in range(N):\n            # if job is unassigned\n            if not assigned[j] and available[j] and cost_matrix[i][j] < min_val:\n                # store job number\n                min_index = j\n\n                # store cost\n                min_val = cost_matrix[i][j]\n\n        # add cost of next worker\n        cost += min_val\n\n        # job becomes unavailable\n        available[min_index] = False\n\n    return cost\n\n# Comparison object to be used to order the heap\nclass Comp:\n    def __init__(self, node):\n        self.node = node\n\n    def __lt__(self, other):\n        return self.node.cost > other.node.cost\n\n# Print Assignments\ndef print_assignments(min_node):\n    if min_node.parent is None:\n        return\n\n    print_assignments(min_node.parent)\n    print(\"Assign Worker {} to Job {}\".format(chr(min_node.workerID + ord('A')), min_node.jobID))\n\n# Finds minimum cost using Branch and Bound\ndef find_min_cost(cost_matrix):\n    # Create a priority queue to store live nodes of the search tree\n    pq = CustomHeap()\n\n    # initialize heap to dummy node with cost 0\n    assigned = [False] * N\n    root = new_node(-1, -1, assigned, None)\n    root.pathCost = root.cost = 0\n    root.workerID = -1\n\n    # Add dummy node to list of live nodes;\n    pq.push(root)\n\n    # Finds a live node with least estimated cost,\n    # add its children to the list of live nodes and\n    # finally deletes it from the list.\n    while True:\n        # Find a live node with least estimated cost\n        min_node = pq.pop()\n\n        # i stores the next worker\n        i = min_node.workerID + 1\n\n        # if all workers are assigned a job\n        if i == N:\n            print_assignments(min_node)\n            return min_node.cost\n\n        # do for each job\n        for j in range(N):\n            # If unassigned\n            if not min_node.assigned[j]:\n                # create a new tree node\n                child = new_node(i, j, min_node.assigned, min_node)\n\n                # cost for ancestors nodes including the current node\n                child.pathCost = min_node.pathCost + cost_matrix[i][j]\n\n                # calculate its lower bound\n                child.cost = child.pathCost + calculate_cost(cost_matrix, i, j, child.assigned)\n\n                # Add child to list of live nodes;\n                pq.push(child)\n\n# Driver code\nif __name__ == \"__main__\":\n    # x-coordinate represents a Worker\n    # y-coordinate represents a Job\n    cost_matrix = [\n        [9, 2, 7, 8],\n        [6, 4, 3, 7],\n        [5, 8, 1, 8],\n        [7, 6, 9, 4]\n    ]\n\n    # Optimal Cost\n    optimal_cost = find_min_cost(cost_matrix)\n    if optimal_cost is not None:\n        print(\"\\nOptimal Cost is {}\".format(optimal_cost))\n    else:\n        print(\"\\nNo optimal solution found.\")\nusing System;\nusing System.Collections.Generic;\n\npublic class Node\n{\n    public Node parent;         // Parent node in the state space tree\n    public int pathCost;        // Path cost from root to this node\n    public int cost;            // Total cost for this node\n    public int workerID;        // ID of the worker\n    public int jobID;           // ID of the job\n    public bool[] assigned;     // Array indicating which jobs are assigned\n\n    // Constructor to initialize a node\n    public Node(int x, int y, bool[] assigned, Node parent)\n    {\n        this.parent = parent;\n        this.pathCost = 0;\n        this.cost = 0;\n        this.workerID = x;\n        this.jobID = y;\n        // Deep copy of the assigned array to prevent modification of the original\n        this.assigned = (bool[])assigned.Clone();\n        if (y != -1)\n            this.assigned[y] = true;   // Marking the job as assigned if it's not -1\n    }\n}\n\n// Custom implementation of a min heap\npublic class CustomHeap\n{\n    private List<(int, Node)> heap;   // List to store nodes and their costs\n\n    // Constructor to initialize the heap\n    public CustomHeap()\n    {\n        heap = new List<(int, Node)>();\n    }\n\n    // Method to push a node into the heap\n    public void Push(Node node)\n    {\n        heap.Add((node.cost, node));   // Adding node with its cost to the heap\n        heap.Sort((x, y) => x.Item1.CompareTo(y.Item1));   // Sorting the heap based on costs\n    }\n\n    // Method to pop the node with the minimum cost from the heap\n    public Node Pop()\n    {\n        if (heap.Count > 0)\n        {\n            var node = heap[0].Item2;   // Extracting the node with minimum cost\n            heap.RemoveAt(0);           // Removing the node from the heap\n            return node;                // Returning the extracted node\n        }\n        return null;\n    }\n}\n\npublic class BranchAndBound\n{\n    private static int N = 4;   // Number of workers and jobs\n\n    // Method to create a new node\n    public static Node NewNode(int x, int y, bool[] assigned, Node parent)\n    {\n        return new Node(x, y, assigned, parent);   // Creating a new node and returning it\n    }\n\n    // Method to calculate the cost of assigning a worker to a job\n    public static int CalculateCost(int[][] costMatrix, int x, int y, bool[] assigned)\n    {\n        int cost = 0;\n        bool[] available = new bool[N];\n        for (int i = 0; i < N; i++)\n        {\n            available[i] = true;   // Initializing all jobs as available\n        }\n\n        // Loop through the remaining workers\n        for (int i = x + 1; i < N; i++)\n        {\n            int minVal = int.MaxValue;\n            int minIndex = -1;\n\n            // Find the minimum cost job for the current worker\n            for (int j = 0; j < N; j++)\n            {\n                if (!assigned[j] && available[j] && costMatrix[i][j] < minVal)\n                {\n                    minIndex = j;\n                    minVal = costMatrix[i][j];\n                }\n            }\n            cost += minVal;          // Add the cost of the assigned job to the total cost\n            available[minIndex] = false;    // Mark the assigned job as unavailable\n        }\n        return cost;    // Return the total cost\n    }\n\n    // Method to print the assignments recursively\n    public static void PrintAssignments(Node minNode)\n    {\n        if (minNode.parent == null)\n            return;\n\n        PrintAssignments(minNode.parent);\n        Console.WriteLine($\"Assign Worker {(char)(minNode.workerID + 'A')} to Job {minNode.jobID}\");\n    }\n\n    // Method to find the minimum cost using Branch and Bound algorithm\n    public static int FindMinCost(int[][] costMatrix)\n    {\n        CustomHeap pq = new CustomHeap();   // Priority queue to store live nodes\n        bool[] assigned = new bool[N];\n        Node root = NewNode(-1, -1, assigned, null);    // Root node with dummy values\n        root.pathCost = root.cost = 0;\n        root.workerID = -1;\n        pq.Push(root);    // Pushing the root node into the priority queue\n\n        while (true)\n        {\n            Node minNode = pq.Pop();    // Pop the node with the minimum cost\n\n            int i = minNode.workerID + 1;\n\n            if (i == N)\n            {\n                PrintAssignments(minNode);    // Print the assignments if all workers are assigned jobs\n                return minNode.cost;          // Return the minimum cost\n            }\n\n            for (int j = 0; j < N; j++)\n            {\n                if (!minNode.assigned[j])\n                {\n                    Node child = NewNode(i, j, minNode.assigned, minNode);    // Create a new node\n                    child.pathCost = minNode.pathCost + costMatrix[i][j];     // Calculate path cost\n                    child.cost = child.pathCost + CalculateCost(costMatrix, i, j, child.assigned);   // Calculate total cost\n                    pq.Push(child);   // Push the child node into the priority queue\n                }\n            }\n        }\n    }\n\n    // Main method\n    static void Main(string[] args)\n    {\n        int[][] costMatrix = new int[][] {\n            new int[] { 9, 2, 7, 8 },\n            new int[] { 6, 4, 3, 7 },\n            new int[] { 5, 8, 1, 8 },\n            new int[] { 7, 6, 9, 4 }\n        };\n\n        int optimalCost = FindMinCost(costMatrix);   // Find the optimal cost using Branch and Bound\n        if (optimalCost != int.MaxValue)\n            Console.WriteLine($\"\\nOptimal Cost is {optimalCost}\");   // Print the optimal cost\n        else\n            Console.WriteLine(\"\\nNo optimal solution found.\");   // Print a message if no optimal solution is found\n    }\n}\n// Define the size of the problem\nconst N = 4;\n\n// Function to calculate the least promising cost\n// of node after worker x is assigned to job y.\nfunction calculateCost(costMatrix, x, y, assigned) {\n    let cost = 0;\n\n    // to store unavailable jobs\n    let available = Array(N).fill(true);\n\n    // start from next worker\n    for (let i = x + 1; i < N; i++) {\n        let min = Number.MAX_SAFE_INTEGER, minIndex = -1;\n\n        // do for each job\n        for (let j = 0; j < N; j++) {\n            // if job is unassigned\n            if (!assigned[j] && available[j] && costMatrix[i][j] < min) {\n                // store job number\n                minIndex = j;\n\n                // store cost\n                min = costMatrix[i][j];\n            }\n        }\n\n        // add cost of next worker\n        cost += min;\n\n        // job becomes unavailable\n        available[minIndex] = false;\n    }\n\n    return cost;\n}\n\n// print Assignments\nfunction printAssignments(min) {\n    if(min.parent == null)\n        return;\n\n    printAssignments(min.parent);\n    console.log(\"Assign Worker \" + String.fromCharCode('A'.charCodeAt(0) + min.workerID) + \" to Job \" + min.jobID);\n}\n\n// Finds minimum cost using Branch and Bound.\nfunction findMinCost(costMatrix) {\n    // Create a priority queue to store live nodes of\n    // search tree;\n    let pq = [];\n\n    // initialize heap to dummy node with cost 0\n    let assigned = Array(N).fill(false);\n    let root = {parent: null, workerID: -1, pathCost: 0, cost: 0, assigned: assigned};\n\n    // Add dummy node to list of live nodes;\n    pq.push(root);\n\n    // Finds a live node with least cost,\n    // add its childrens to list of live nodes and\n    // finally deletes it from the list.\n    while (pq.length > 0) {\n        // Find a live node with least estimated cost\n        let min = pq.shift();\n\n        // i stores next worker\n        let i = min.workerID + 1;\n\n        // if all workers are assigned a job\n        if (i == N) {\n            printAssignments(min);\n            return min.cost;\n        }\n\n        // do for each job\n        for (let j = 0; j < N; j++) {\n            // If unassigned\n            if (!min.assigned[j]) {\n                // create a new tree node\n                let child = {parent: min, workerID: i, jobID: j, pathCost: min.pathCost + costMatrix[i][j], assigned: [...min.assigned]};\n                child.assigned[j] = true;\n\n                // calculate its lower bound\n                child.cost = child.pathCost + calculateCost(costMatrix, i, j, child.assigned);\n\n                // Add child to list of live nodes;\n                pq.push(child);\n            }\n        }\n\n        // sort the queue in ascending order of cost\n        pq.sort((a, b) => a.cost - b.cost);\n    }\n}\n\n// Driver code\nfunction main() {\n    // x-coordinate represents a Worker\n    // y-coordinate represents a Job\n    let costMatrix = [\n        [9, 2, 7, 8],\n        [6, 4, 3, 7],\n        [5, 8, 1, 8],\n        [7, 6, 9, 4]\n    ];\n\n    console.log(\"\\nOptimal Cost is \" + findMinCost(costMatrix));\n}\n\nmain();\nAssign Worker A to Job 1Assign Worker B to Job 0Assign Worker C to Job 2Assign Worker D to Job 3Optimal Cost is 13\n",
        "complexity": {
            "time": "Time Complexity: O(M*N). This is because the algorithm uses a double for loop to iterate through the M x N matrix. Auxiliary Space: O(M+N). This is because it uses two arrays of size M and N to track the applicants and jobs.",
            "space": ""
        },
        "tags": [
            "Branch & Bound"
        ],
        "url": "https://www.geeksforgeeks.org/job-assignment-problem-using-branch-and-bound/"
    },
    {
        "title": "N Queen Problem using Branch And Bound",
        "description": "The N queens puzzle is the problem of placing N chess queens on an N×N chessboard so that no two queens threaten each other. Thus, a solution requires that no two queens share the same row, column, or diagonal. The backtracking Algorithm for N-Queen is already discussed here. In a backtracking solution, we backtrack when we hit a dead end. In Branch and Bound solution, after building a partial solution, we figure out that there is no point going any deeper as we are going to hit a dead end. Let’s begin by describing the backtracking solution. “The idea is to place queens one by one in different columns, starting from the leftmost column. When we place a queen in a column, we check for clashes with already placed queens. In the current column, if we find a row for which there is no clash, we mark this row and column as part of the solution. If we do not find such a row due to clashes, then we backtrack and return false.”  Placing 1st queen on (3, 0) and 2nd queen on (5, 1) We need to figure out an efficient way of keeping track of which cells are under attack. In previous solution we kept an 8­-by­-8 Boolean matrix and update it each time we placed a queen, but that required linear time to update as we need to check for safe cells.Basically, we have to ensure 4 things: 1. No two queens share a column. 2. No two queens share a row. 3. No two queens share a top-right to left-bottom diagonal. 4. No two queens share a top-left to bottom-right diagonal. Number 1 is automatic because of the way we store the solution. For number 2, 3 and 4, we can perform updates in O(1) time. The idea is to keep three Boolean arrays that tell us which rows and which diagonals are occupied. Lets do some pre-processing first. Let’s create two N x N matrix one for / diagonal and other one for \\ diagonal. Let’s call them slashCode and backslashCode respectively. The trick is to fill them in such a way that two queens sharing a same /­diagonal will have the same value in matrix slashCode, and if they share same \\­diagonal, they will have the same value in backslashCode matrix.For an N x N matrix, fill slashCode and backslashCode matrix using below formula –slashCode[row][col] = row + col backslashCode[row][col] = row – col + (N-1) Using above formula will result in below matrices    The ‘N – 1’ in the backslash code is there to ensure that the codes are never negative because we will be using the codes as indices in an array.Now before we place queen i on row j, we first check whether row j is used (use an array to store row info). Then we check whether slash code ( j + i ) or backslash code ( j – i + 7 ) are used (keep two arrays that will tell us which diagonals are occupied). If yes, then we have to try a different location for queen i. If not, then we mark the row and the two diagonals as used and recurse on queen i + 1. After the recursive call returns and before we try another position for queen i, we need to reset the row, slash code and backslash code as unused again, like in the code from the previous notes. Below is the implementation of above idea – This code Takes the Dynamic Input:                   Input: Enter the no of rows for the square Board : 8 Output : The time and space complexity of the N-Queen problem solver implemented in the provided code are: Time Complexity: The time complexity of the solver algorithm is O(N!), where N is the number of rows and columns in the square board. This is because for each column, the algorithm tries to place a queen in each row and then recursively tries to place the queens in the remaining columns. The number of possible combinations of queen placements in the board is N! since there can be only one queen in each row and each column. Space Complexity: The space complexity of the solver algorithm is O(N^2), where N is the number of rows and columns in the square board. This is because we are using a 2D vector to represent the board, which takes up N^2 space. Additionally, we are using three boolean arrays to keep track of the occupied rows and diagonals, which take up 2N-1 space each. Therefore, the total space complexity is O(N^2 + 6N – 3), which is equivalent to O(N^2). A  ",
        "code": "\n\n\n\n\n\n\n\n\n\n\n\n1  0  0  0  0  0  0  0  0  0  0  0  0  0  1  0  0  0  0  0  1  0  0  0  0  0  0  0  0  0  0  1  0  1  0  0  0  0  0  0  0  0  0  1  0  0  0  0  0  0  0  0  0  1  0  0  0  0  1  0  0  0  0  0\n",
        "complexity": {
            "time": "Time Complexity: The time complexity of the solver algorithm is O(N!), where N is the number of rows and columns in the square board. This is because for each column, the algorithm tries to place a queen in each row and then recursively tries to place the queens in the remaining columns. The number of possible combinations of queen placements in the board is N! since there can be only one queen in each row and each column.",
            "space": "Space Complexity: The space complexity of the solver algorithm is O(N^2), where N is the number of rows and columns in the square board. This is because we are using a 2D vector to represent the board, which takes up N^2 space. Additionally, we are using three boolean arrays to keep track of the occupied rows and diagonals, which take up 2N-1 space each. Therefore, the total space complexity is O(N^2 + 6N – 3), which is equivalent to O(N^2)."
        },
        "tags": [
            "Branch & Bound"
        ],
        "url": "https://www.geeksforgeeks.org/n-queen-problem-using-branch-and-bound/"
    },
    {
        "title": "Traveling Salesman Problem using Branch And Bound",
        "description": "Given a set of cities and distance between every pair of cities, the problem is to find the shortest possible tour that visits every city exactly once and returns to the starting point.  For example, consider the graph shown in figure on right side. A TSP tour in the graph is 0-1-3-2-0. The cost of the tour is 10+25+30+15 which is 80.We have discussed following solutions 1) Naive and Dynamic Programming 2) Approximate solution using MST   Branch and Bound Solution As seen in the previous articles, in Branch and Bound method, for current node in tree, we compute a bound on best possible solution that we can get if we down this node. If the bound on best possible solution itself is worse than current best (best computed so far), then we ignore the subtree rooted with the node. Note that the cost through a node includes two costs. 1) Cost of reaching the node from the root (When we reach a node, we have this cost computed) 2) Cost of reaching an answer from current node to a leaf (We compute a bound on this cost to decide whether to ignore subtree with this node or not). In branch and bound, the challenging part is figuring out a way to compute a bound on best possible solution. Below is an idea used to compute bounds for Travelling salesman problem.Cost of any tour can be written as below. For example, consider the above shown graph. Below are minimum cost two edges adjacent to every node. Now we have an idea about computation of lower bound. Let us see how to how to apply it state space search tree. We start enumerating all possible nodes (preferably in lexicographical order)1. The Root Node: Without loss of generality, we assume we start at vertex “0” for which the lower bound has been calculated above.Dealing with Level 2: The next level enumerates all possible vertices we can go to (keeping in mind that in any path a vertex has to occur only once) which are, 1, 2, 3… n (Note that the graph is complete). Consider we are calculating for vertex 1, Since we moved from 0 to 1, our tour has now included the edge 0-1. This allows us to make necessary changes in the lower bound of the root. How does it work? To include edge 0-1, we add the edge cost of 0-1, and subtract an edge weight such that the lower bound remains as tight as possible which would be the sum of the minimum edges of 0 and 1 divided by 2. Clearly, the edge subtracted can’t be smaller than this.Dealing with other levels: As we move on to the next level, we again enumerate all possible vertices. For the above case going further after 1, we check out for 2, 3, 4, …n. Consider lower bound for 2 as we moved from 1 to 1, we include the edge 1-2 to the tour and alter the new lower bound for this node. Note: The only change in the formula is that this time we have included second minimum edge cost for 1, because the minimum edge cost has already been subtracted in previous level.                Output : The rounding is being done in this line of code: In the Branch and Bound TSP algorithm, we compute a lower bound on the total cost of the optimal solution by adding up the minimum edge costs for each vertex, and then dividing by two. However, this lower bound may not be an integer. To get an integer lower bound, we can use rounding. In the above code, the curr_bound variable holds the current lower bound on the total cost of the optimal solution. When we visit a new vertex at level level, we compute a new lower bound new_bound by taking the sum of the minimum edge costs for the new vertex and its two closest neighbors. We then update the curr_bound variable by rounding new_bound to the nearest integer. If level is 1, we round down to the nearest integer. This is because we have only visited one vertex so far, and we want to be conservative in our estimate of the total cost of the optimal solution. If level is greater than 1, we use a more aggressive rounding strategy that takes into account the fact that we have already visited some vertices and can therefore make a more accurate estimate of the total cost of the optimal solution. Time Complexity: The worst case complexity of Branch and Bound remains same as that of the Brute Force clearly because in worst case, we may never get a chance to prune a node. Whereas, in practice it performs very well depending on the different instance of the TSP. The complexity also depends on the choice of the bounding function as they are the ones deciding how many nodes to be pruned.References: http://lcm.csa.iisc.ernet.in/dsa/node187.html  A  ",
        "code": "Cost of a tour T = (1/2) * ? (Sum of cost of two edges\n                              adjacent to u and in the\n                              tour T) \n                   where u ? V\nFor every vertex u, if we consider two edges through it in T,\nand sum their costs.  The overall sum for all vertices would\nbe twice of cost of tour T (We have considered every edge \ntwice.)\n\n(Sum of two tour edges adjacent to u) >= (sum of minimum weight\n                                          two edges adjacent to\n                                          u)\n\nCost of any tour >=  1/2) * ? (Sum of cost of two minimum\n                              weight edges adjacent to u) \n                   where u ? V\nNode     Least cost edges   Total cost            \n0     (0, 1), (0, 2)            25\n1     (0, 1), (1, 3)         35\n2    (0, 2), (2, 3)            45\n3     (0, 3), (1, 3)            45\n\nThus a lower bound on the cost of any tour = \n         1/2(25 + 35 + 45 + 45)\n       = 75\nRefer this for one more example.\nLower Bound for vertex 1 = \n   Old lower bound - ((minimum edge cost of 0 + \n                    minimum edge cost of 1) / 2) \n                  + (edge cost 0-1)\nLower bound(2) = \n     Old lower bound - ((second minimum edge cost of 1 + \n                         minimum edge cost of 2)/2)\n                     + edge cost 1-2)\n\n\n\n\n\n\n\n\n\n\nMinimum cost : 80\nPath Taken : 0 1 3 2 0\nif (level==1)\n   curr_bound -= ((firstMin(adj, curr_path[level-1]) +\n                   firstMin(adj, i))/2);\nelse\n   curr_bound -= ((secondMin(adj, curr_path[level-1]) +\n                   firstMin(adj, i))/2);\n",
        "complexity": {
            "time": "Time Complexity: The worst case complexity of Branch and Bound remains same as that of the Brute Force clearly because in worst case, we may never get a chance to prune a node. Whereas, in practice it performs very well depending on the different instance of the TSP. The complexity also depends on the choice of the bounding function as they are the ones deciding how many nodes to be pruned.References: http://lcm.csa.iisc.ernet.in/dsa/node187.html",
            "space": ""
        },
        "tags": [
            "Branch & Bound"
        ],
        "url": "https://www.geeksforgeeks.org/traveling-salesman-problem-using-branch-and-bound-2/"
    },
    {
        "title": "DSA Tutorial - Learn Data Structures and Algorithms",
        "description": "DSA (Data Structures and Algorithms)  is the study of organizing data efficiently using data structures like arrays, stacks, and trees, paired with step-by-step procedures (or algorithms) to solve problems effectively. Data structures manage how data is stored and accessed, while algorithms focus on processing this data. Hoping you have learned a programming language of your choice, here comes the next stage of the roadmap - Learn about Time and Space Complexities. Once you have learned basics of a programming language, it is recommended that you learn basic logic building To analyze algorithms, we mainly measure order of growth of time or space taken in terms of input size.  We do this in the worst case scenario in most of the cases. Please refer the below links for a clear understanding of these concepts. Array is a linear data structure where elements are allocated contiguous memory, allowing for constant-time access. Searching algorithms are used to locate specific data within a large set of data. It helps find a target value within the data. There are various types of searching algorithms, each with its own approach and efficiency. Sorting algorithms are used to arrange the elements of a list in a specific order, such as numerical or alphabetical. It organizes the items in a systematic way, making it easier to search for and access specific elements. Hashing is a technique that generates a fixed-size output (hash value) from an input of variable size using mathematical formulas called hash functions. Hashing is commonly used in data structures for efficient searching, insertion and deletion. In Two Pointer Technique, we typically use two index variables from two corners of an array. We use the two pointer technique for searching a required point or value in an array. In Window Sliding Technique, we use the result of previous subarray to quickly compute the result of current. In Prefix Sum Technique, we compute prefix sums of an array to quickly find results for a subarray. String is a sequence of characters, typically immutable and have limited set of elements (lower case or all English alphabets). Recursion is a programming technique where a function calls itself within its own definition. It is usually used to solve problems that can be broken down into smaller instances of the same problem. Matrix is a two-dimensional array of elements, arranged in rows and columns. It is represented as a rectangular grid, with each element at the intersection of a row and column. Linked list is a linear data structure that stores data in nodes, which are connected by pointers. Unlike arrays, nodes of linked lists are not stored in contiguous memory locations and can only be accessed sequentially, starting from the head of list. Stack is a linear data structure that follows the Last In, First Out (LIFO) principle. Stacks play an important role in managing function calls, memory, and are widely used in algorithms like stock span problem, next greater element and largest area in a histogram. Queue is a linear data structure that follows the First In, First Out (FIFO) principle. Queues play an important role in managing tasks or data in order, scheduling and message handling systems. A deque (double-ended queue) is a data structure that allows elements to be added or removed from both ends efficiently. Tree is a non-linear, hierarchical data structure consisting of nodes connected by edges, with a top node called the root and nodes having child nodes. It is widely used in file systems, databases, decision-making algorithms, etc. Heap is a complete binary tree data structure that satisfies the heap property. Heaps are usually used to implement priority queues, where the smallest or largest element is always at the root of the tree. Graph is a non-linear data structure consisting of a finite set of vertices(or nodes) and a set of edges(or links)that connect a pair of nodes. Graphs are widely used to represent relationships between entities. Greedy Algorithm builds up the solution one piece at a time and chooses the next piece which gives the most obvious and immediate benefit i.e., which is the most optimal choice at that moment. So the problems where choosing locally optimal also leads to the global solutions are best fit for Greedy. Dynamic Programming is a method used to solve complex problems by breaking them down into simpler subproblems. By solving each subproblem only once and storing the results, it avoids redundant computations, leading to more efficient solutions for a wide range of problems. Bitwise Algorithms: Operate on individual bits of numbers. Backtracking Algorithm : Follow Recursion  with the option to revert and traces back if the solution from current point is not feasible. Divide and conquer:  A strategy to solve problems by dividing them into smaller subproblems, solving those subproblems, and combining the solutions to obtain the final solution. Branch and Bound : Used in combinatorial optimization problems to systematically search for the best solution. It works by dividing the problem into smaller subproblems, or branches, and then eliminating certain branches based on bounds on the optimal solution. This process continues until the best solution is found or all branches have been explored. Geometric algorithms are a set of algorithms that solve problems related to shapes, points, lines and polygons. Randomized algorithms are algorithms that use randomness to solve problems. They make use of random input to achieve their goals, often leading to simpler and more efficient solutions. These algorithms may not product same result but are particularly useful in situations when a probabilistic approach is acceptable. Advanced Data Structures like Trie, Segment Tree, Red-Black Tree and Binary Indexed Tree offer significant performance improvements for specific problem domains. They provide efficient solutions for tasks like fast prefix searches, range queries, dynamic updates, and maintaining balanced data structures, which are crucial for handling large datasets and real-time processing. By optimizing time complexity, they enable better scalability and faster execution in many computational problems. R  ",
        "code": "",
        "complexity": {
            "time": "Advanced Data Structures like Trie, Segment Tree, Red-Black Tree and Binary Indexed Tree offer significant performance improvements for specific problem domains. They provide efficient solutions for tasks like fast prefix searches, range queries, dynamic updates, and maintaining balanced data structures, which are crucial for handling large datasets and real-time processing. By optimizing time complexity, they enable better scalability and faster execution in many computational problems.",
            "space": ""
        },
        "tags": [
            "Randomized Algorithms"
        ],
        "url": "https://www.geeksforgeeks.org/learn-data-structures-and-algorithms-dsa-tutorial/"
    },
    {
        "title": "Randomized Algorithms | Set 1 (Introduction and Analysis)",
        "description": "An algorithm that uses random numbers to decide what to do next anywhere in its logic is called a Randomized Algorithm. For example, in Randomized Quick Sort, we use a random number to pick the next pivot (or we randomly shuffle the array). And in Karger’s algorithm, we randomly pick an edge. Some randomized algorithms have deterministic time complexity. For example, this implementation of Karger’s algorithm has time complexity is O(E). Such algorithms are called Monte Carlo Algorithms and are easier to analyse for worst case. On the other hand, time complexity of other randomized algorithms (other than Las Vegas) is dependent on value of random variable. Such Randomized algorithms are called Las Vegas Algorithms. These algorithms are typically analysed for expected worst case. To compute expected time taken in worst case, all possible values of the used random variable needs to be considered in worst case and time taken by every possible value needs to be evaluated. Average of all evaluated times is the expected worst case time complexity. Below facts are generally helpful in analysis os such algorithms. Linearity of Expectation Expected Number of Trials until Success. For example consider below a randomized version of QuickSort. A Central Pivot is a pivot that divides the array in such a way that one side has at-least 1/4 elements. The important thing in our analysis is, time taken by step 2 is O(n). How many times while loop runs before finding a central pivot? The probability that the randomly chosen element is central pivot is 1/n. Therefore, expected number of times the while loop runs is n (See this for details) Thus, the expected time complexity of step 2 is O(n). What is overall Time Complexity in Worst Case? In worst case, each partition divides array such that one side has n/4 elements and other side has 3n/4 elements. The worst case height of recursion tree is Log 3/4 n which is O(Log n). Note that the above randomized algorithm is not the best way to implement randomized Quick Sort. The idea here is to simplify the analysis as it is simple to analyse. Typically, randomized Quick Sort is implemented by randomly picking a pivot (no loop). Or by shuffling array elements. Expected worst case time complexity of this algorithm is also O(n Log n), but analysis is complex, the MIT prof himself mentions same in his lecture here. Example :                   Randomized Algorithms | Set 2 (Classification and Applications) References: http://www.tcs.tifr.res.in/~workshop/nitrkl_igga/randomized-lecture.pdf  A  ",
        "code": "// Sorts an array arr[low..high]\nrandQuickSort(arr[], low, high)\n\n1. If low >= high, then EXIT.\n\n2. While pivot 'x' is not a Central Pivot.\n  (i)   Choose uniformly at random a number from [low..high]. \n        Let the randomly picked number number be x.\n  (ii)  Count elements in arr[low..high] that are smaller \n        than arr[x]. Let this count be sc.\n  (iii) Count elements in arr[low..high] that are greater \n        than arr[x]. Let this count be gc.\n  (iv)  Let n = (high-low+1). If sc >= n/4 and\n        gc >= n/4, then x is a central pivot.\n\n3. Partition arr[low..high] around the pivot x.\n\n4. // Recur for smaller elements\n   randQuickSort(arr, low, sc-1) \n\n5. // Recur for greater elements\n   randQuickSort(arr, high-gc+1, high)\nT(n) < T(n/4) + T(3n/4) + O(n)\nT(n) < 2T(3n/4) + O(n)\n\nSolution of above recurrence is O(n Log n)\n\n\n\n\n\n\n\n\n\n\n\n\nSolution: 10\n",
        "complexity": {
            "time": "Note that the above randomized algorithm is not the best way to implement randomized Quick Sort. The idea here is to simplify the analysis as it is simple to analyse. Typically, randomized Quick Sort is implemented by randomly picking a pivot (no loop). Or by shuffling array elements. Expected worst case time complexity of this algorithm is also O(n Log n), but analysis is complex, the MIT prof himself mentions same in his lecture here. Example :",
            "space": ""
        },
        "tags": [
            "Randomized Algorithms"
        ],
        "url": "https://www.geeksforgeeks.org/randomized-algorithms-set-1-introduction-and-analysis/"
    },
    {
        "title": "Importance of Randomized Algorithms",
        "description": "Introduction: Advantages: Some design principles are listed in the following subsections: Concept of Witness: Fingerprinting: Checking Identities: Random Sampling and Ordering: Foiling the Adversary: P  ",
        "code": "",
        "complexity": {
            "time": "",
            "space": ""
        },
        "tags": [
            "Randomized Algorithms"
        ],
        "url": "https://www.geeksforgeeks.org/importance-of-randomized-algorithms/"
    },
    {
        "title": "Random Variable",
        "description": "Random variable is a fundamental concept in statistics that bridges the gap between theoretical probability and real-world data. A Random variable in statistics is a function that assigns a real value to an outcome in the sample space of a random experiment. For example: if you roll a die, you can assign a number to each possible outcome. There are two basic types of random variables: We define a random variable as a function that maps from the sample space of an experiment to the real numbers. Mathematically, Random Variable is expressed as, X: S →R where, Table of Content Read: Probability in Maths Random variables are generally represented by capital letters like X and Y. This is explained by the example below: If two unbiased coins are tossed then find the random variable associated with that event.Solution: Suppose Two (unbiased) coins are tossedX = number of heads. [X is a random variable or function] Here, the sample space S = {HH, HT, TH, TT} Suppose a random variable X takes m different values, X = {x1, x2, x3………xm}, with corresponding probabilities P(X = xi) = pi, where 1 ≤ i ≤ m.The probabilities must satisfy the following conditions : For example, Suppose a die is thrown (X = outcome of the dice). Here, the sample space S = {1, 2, 3, 4, 5, 6}. The output of the function will be: This also satisfies the condition ∑6i=1 P(X = i) = 1, since:P(X = 1) + P(X = 1) + P(X = 2) + P(X = 3) + P(X = 4) + P(X = 5) + P(X = 6) = 6 × 1/6 = 1 A variate is a general term often used interchangeably with a random variable, particularly in contexts where the random variable is not yet fully specified by a particular probabilistic experiment. A variate is an abstract concept that represents a real-valued outcome of a random process, but without necessarily being tied to a specific experiment or probability distribution.It has the same properties as a random variable, such as a defined range of possible values. The range of values that a random variable X can take is denoted as RX​, and individual values within this range are called quantiles. The probability of the random variable X taking a specific value x is written as P(X = x). Random variables are of two types that are,  A Discrete Random Variable takes on a finite number of values. The probability function associated with it is said to be PMF. If X is a discrete random variable and the PMF of X is P(xi), then Example: Let S = {0, 1, 2} xi 0 1 2 Pi(X = xi) P1 0.3 0.5 Find the value of P (X = 0) Solution: We know that the sum of all probabilities is equal to 1. And P (X = 0) be P1P1 + 0.3 + 0.5 = 1P1 = 0.2 Then, P (X = 0) is 0.2 Continuous Random Variable takes on an infinite number of values. The probability function associated with it is said to be PDF (Probability Density Function). If X is a continuous random variable. P (x < X < x + dx) = f(x)dx then, Then P (X) is said to be a PDF of the distribution. Find the value of P (1 < X < 2)Such that, Otherwise f(x) is a density function. Solution: If a function f is said to be a density function, then the sum of all probabilities is equal to 1. Since it is a continuous random variable Integral value is 1 overall sample space s. ∫ f(x) dx = 1∫ kx3 dx = 1K[x4]/4 = 1 Given interval, 0 ≤ x ≤ 3 = 0 K[34 – 04]/4 = 1K(81/4) = 1K = 4/81 Thus, P (1 < X < 2) = k × [X4]/4P = 4/81 × [16-1]/4P = 15/81 There are two main random variable formulas, Let’s learn about the same in detail, For any random variable X where P is its respective probability we define its mean as, Mean(μ) = ∑ X.P where, The variance of a random variable tells us how the random variable is spread about the mean value of the random variable. The variance of the Random Variable is calculated using the formula, Var(x) = σ2 = E(X2) – {E(X)}2 where, For any random variable X if it assume the values x1, x2,…xn where the probability corresponding to each random variable is P(x1), P(x2),…P(xn), then the expected value of the variable is, Expectation of X, E(x) = ∑ x.P(x) Now for any new random variable Y in which the random variable X is its input, i.e. Y = f(X), then the cumulative distribution function of Y is, Fy(Y) = P(g(X) ≤ y) For a random variable, its probability distribution is calculated using three methods, The probability of a random variable X that takes values x is defined using a probability function of X that is denoted by f (x) = f (X = x). Various probability distributions are, People Also Read: Here are some of the solved examples on Random variable. Learn random variables by practicing these solved examples. Question 1: Find the mean value for the continuous random variable, f(x) = x2, 1 ≤ x ≤ 3Solution: Given,f(x) = x21 ≤ x ≤ 3 E(x) = ∫31 x.f(x)dxE(x) = ∫31 x.x2.dxE(x) = ∫31 x3.dxE(x) = [x4/4]31E(x) = 1/4 × {34– 14} = 1/4 × {81 – 1}E(x) = 1/4 × {80} = 20 Question 2: Find the mean value for the continuous random variable, f(x) = ex, 1 ≤ x ≤ 3Solution: Given,f(x) = ex1 ≤ x ≤ 3 E(x) = ∫31 x.f(x)dxE(x) = ∫31 x.ex.dxE(x) = [x.ex – ex]31E(x) = [ex(x – 1)]31E(x) = e3(2) – e(0) Question 3: Given the discrete random variable X with the following probability distribution: X 1 2 3 4 P(X) 0.1 0.2 0.4 0.3 Find the mean value (or expected value) of the random variable X.Solution: To find the mean value (expected value) of a discrete random variable X, we use the formula:Using the relation: E(X) = μX = x1P(x1) + x2P(x2) + … + xnP(xn)E(X) = ∑i Xi  · P(Xi) The expected value E(X), or mean μX of a discrete random variable XE(X) = μX = ∑ [ xi * P(xi) ]E(X) = 1 * 0.1 + 2 * 0.2 + 3 * 0.4 + 4 * 0.3E(X) = 0.100 + 0.400 + 1.200 + 1.200 = 2.900E(X) = 2.900 Question 4: Given the discrete random variable X with the following probability distribution:Suppose a discrete random variable X represents the number of defective items in a sample of 10 items from a batch of 100 items. The possible values of X are 0, 3, 5, and 7 defective items, with the following probability distribution: X 0 3 5 7 P(X) 0.2 0.5 0.2 0.1 Find the mean value (or expected value) of the random variable X.Solution: The formula for the mean (or expected value) of a discrete random variable X is:E(X) = ∑i Xi ⋅ P(Xi) The expected value E(X), or mean μX of a discrete random variable X E(X) = μX = ∑ [ xi * P(xi) ]E(X) = 0 * 0.2 + 3 * 0.5 + 5 * 0.2 + 7 * 0.1E(X) = 0.000 + 1.500 + 1.000 + 0.700 = 3.200E(X) = 3.200 Question 1: Find the mean value for the continuous random variable, f(x) = x3, 1 ≤ x ≤ 5Question 2: Find the mean value for the continuous random variable, f(x) = x, 1 ≤ x ≤ 4.Question 3: Given the discrete random variable X with the following probability distribution: X 1 2 3 4 P(X) 0.2 0.3 0.4 0.1 Find the mean value (or expected value) of the random variable X. Question 4: Given the discrete random variable X with the following probability distribution: X 0 1 3 5 P(X) 0.3 0.3 0.3 0.1 Find the mean value (or expected value) of the random variable X.  ",
        "code": "",
        "complexity": {
            "time": "",
            "space": ""
        },
        "tags": [
            "Randomized Algorithms"
        ],
        "url": "https://www.geeksforgeeks.org/random-variable/"
    },
    {
        "title": "Randomized Binary Search Algorithm",
        "description": "We are given a sorted array A[] of n elements. We need to find if x is present in A or not.In binary search we always used middle element, here we will randomly pick one element in given range.In Binary Search we had In Randomized binary search we do following It is a Las Vegas randomized algorithm as it always finds the correct result. Expected Time complexity of Randomized Binary Search Algorithm For n elements let say expected time required be T(n), After we choose one random pivot, array size reduces to say k. Since pivot is chosen with equal probability for all possible pivots, hence p = 1/n.T(n) is sum of time of all possible sizes after choosing pivot multiplied by probability of choosing that pivot plus time take to generate random pivot index.Hence Recursive implementation of Randomized Binary Search                Output: Iterative implementation of Randomized Binary Search                Output:  P  ",
        "code": "middle = (start + end)/2\nGenerate a random number t\nSince range of number in which we want a random\nnumber is [start, end]\nHence we do, t = t % (end-start+1)\nThen, t = start + t;\nHence t is a random number between start and end\nT(n) = p*T(1) + p*T(2) + ..... + p*T(n) + 1\nputting p = 1/n\nT(n) = ( T(1) + T(2) + ..... + T(n) ) / n + 1\nn*T(n) = T(1) + T(2) + .... + T(n) + n      .... eq(1)\nSimilarly for n-1\n(n-1)*T(n-1) = T(1) + T(2) + ..... + T(n-1) + n-1    .... eq(2)\nSubtract eq(1) - eq(2)\nn*T(n) - (n-1)*T(n-1) = T(n) + 1\n(n-1)*T(n) - (n-1)*T(n-1) =  1\n(n-1)*T(n) = (n-1)*T(n-1) + 1\nT(n) = 1/(n-1) + T(n-1)\nT(n) = 1/(n-1) + 1/(n-2) + T(n-2)\nT(n) = 1/(n-1) + 1/(n-2) + 1/(n-3) + T(n-3)\nSimilarly,\nT(n) = 1 + 1/2 + 1/3 + ... + 1/(n-1)\nHence T(n) is equal to (n-1)th Harmonic number, \nn-th harmonic number is O(log n)\nHence T(n) is O(log n)\n\n\n\n\n\n\n\n\n\n\nElement is present at index 3\n\n\n\n\n\n\n\n\n\n\nElement is present at index 3\n",
        "complexity": {
            "time": "Expected Time complexity of Randomized Binary Search Algorithm For n elements let say expected time required be T(n), After we choose one random pivot, array size reduces to say k. Since pivot is chosen with equal probability for all possible pivots, hence p = 1/n.T(n) is sum of time of all possible sizes after choosing pivot multiplied by probability of choosing that pivot plus time take to generate random pivot index.Hence",
            "space": ""
        },
        "tags": [
            "Randomized Algorithms"
        ],
        "url": "https://www.geeksforgeeks.org/randomized-binary-search-algorithm/"
    },
    {
        "title": "QuickSort using Random Pivoting",
        "description": "In this article, we will discuss how to implement QuickSort using random pivoting. In QuickSort we first partition the array in place such that all elements to the left of the pivot element are smaller, while all elements to the right of the pivot are greater than the pivot. Then we recursively call the same procedure for left and right subarrays. Unlike merge sort, we don’t need to merge the two sorted arrays. Thus Quicksort requires lesser auxiliary space than Merge Sort, which is why it is often preferred to Merge Sort. Using a randomly generated pivot we can further improve the time complexity of QuickSort. We have discussed at two popular methods for partitioning the arrays-Hoare’s vs Lomuto partition scheme It is advised that the reader has read that article or knows how to implement the QuickSort using either of the two partition schemes. Algorithm for random pivoting using Lomuto Partitioning Implementation using Lomuto Partitioning:                   Time Complexity: O(N*N)Auxiliary Space: O(N) // due to recursive call stack Algorithm for random pivoting using Hoare Partitioning Implementation using Hoare’s Partitioning:                Time Complexity: O(N*N)Auxiliary Space: O(N) // due to recursive call stack Implementation  using generateRandomPivot function  : Here is an implementation without using Hoare’s and  Lomuto partition scheme Implementation of QuickSort using random pivoting without partitioning:                Analysis of Randomized Quick Sort Notes S  ",
        "code": "partition(arr[], lo, hi)     pivot = arr[hi]    i = lo     // place for swapping    for j := lo to hi – 1 do        if arr[j] <= pivot then            swap arr[i] with arr[j]            i = i + 1    swap arr[i] with arr[hi]    return ipartition_r(arr[], lo, hi)    r = Random Number from lo to hi    Swap arr[r] and arr[hi]    return partition(arr, lo, hi)quicksort(arr[], lo, hi)    if lo < hi        p = partition_r(arr, lo, hi)        quicksort(arr, lo , p-1)        quicksort(arr, p+1, hi)\n\n\n\n\n\n\n\n\n\n\n\n\nSorted array: \n1 5 7 8 9 10\npartition(arr[], lo, hi)   pivot = arr[lo]   i = lo - 1  // Initialize left index   j = hi + 1  // Initialize right index        while(True)           // Find a value in left side greater than pivot           do              i = i + 1           while arr[i] < pivot        // Find a value in right side smaller than pivot           do              j = j - 1           while arr[j] > pivot                      if i >= j then                return j        else               swap arr[i] with arr[j]       end    while   partition_r(arr[], lo, hi)    r = Random number from lo to hi    Swap arr[r] and arr[lo]    return partition(arr, lo, hi)quicksort(arr[], lo, hi)    if lo < hi        p = partition_r(arr, lo, hi)        quicksort(arr, lo, p)        quicksort(arr, p+1, hi)\n\n\n\n\n\n\n\n\n\n\nSorted array: \n1 5 7 8 9 10\n\n\n\n\n\n\n\n\n\n\nOriginal array: 5 2 7 3 1 6 4 8 \nSorted array: 1 2 3 4 5 6 7 8\n",
        "complexity": {
            "time": "Time Complexity: O(N*N)Auxiliary Space: O(N) // due to recursive call stack",
            "space": ""
        },
        "tags": [
            "Randomized Algorithms"
        ],
        "url": "https://www.geeksforgeeks.org/quicksort-using-random-pivoting/"
    },
    {
        "title": "Randomized Algorithms | Set 2 (Classification and Applications)",
        "description": "We strongly recommend to refer below post as a prerequisite of this. Randomized Algorithms | Set 1 (Introduction and Analysis) Randomized algorithms are classified in two categories. A Las Vegas algorithm were introduced by Laszlo Babai in 1979. A Las Vegas algorithm is an algorithm which uses randomness, but gives guarantees that the solution obtained for given problem is correct. It takes the risk with resources used. A quick-sort algorithm is a simple example of Las-Vegas algorithm. To sort the given array of n numbers quickly we use the quick sort algorithm. For that we find out central element which is also called as pivot element and each element is compared with this pivot element. Sorting is done in less time or it requires more time is dependent on how we select the pivot element. To pick the pivot element randomly we can use Las-Vegas algorithm. Definition: A randomized algorithm that always produce correct result with only variation from one aun to another being its running time is known as Las-Vegas algorithm. OR A randomized algorithm which always produces a correct result or it informs about the failure is known as Las-Vegas algorithm. OR A Las-Vegas algorithm take the risk with the resources used for computation but it does not take risk with the result i.e. it gives correct and expected output for the given problem. Let us consider the above example of quick sort algorithm. In this algorithm we choose the pivot element randomly. But the result of this problem is always a sorted array. A Las-Vegas algorithm is having one restriction i.e. the solution for the given problem can be found out in finite time. In this algorithm the numbers of possible solutions arc limited. The actual solution is complex in nature or complicated to calculate but it is easy to verify the correctness of candidate solution. These algorithms always produce correct or optimum result. Time complexity of these algorithms is based on a random value and time complexity is evaluated as expected value. For example, Randomized Quick Sort always sorts an input array and expected worst case time complexity of Quick Sort is O(nLogn). Complexity Analysis: The complexity class of given problem which is solved by using a Las-Vegas algorithms is expect that the given problem is solved with zero error probability and in polynomial time. This zero error probability polynomial time is also called as ZPP which is obtained as follows, ZPP = RP ? CO-RP Where, RP = Randomized polynomial time. Randomized polynomial time algorithm always provide correct output when the correct output is no, but with a certain probability bounded away from one when the answer is yes. These kinds of decision problem can be included in class RP i.e. randomized where polynomial time. That is how we can solve given problem in expected polynomial time by using Las-Vegas algorithm. Generally there is no upper bound for Las-vegas algorithm related to worst case run time. The computational algorithms which rely on repeated random sampling to compute their results such algorithm are called as Monte-Carlo algorithms. OR The random algorithm is Monte-carlo algorithms if it can give the wrong answer sometimes. Whenever the existing deterministic algorithm is fail or it is impossible to compute the solution for given problem then Monte-Carlo algorithms or methods are used. Monte-carlo methods are best repeated computation of the random numbers, and that’s why these algorithms are used for solving physical simulation system and mathematical system. This Monte-carlo algorithms are specially useful for disordered materials, fluids, cellular structures. In case of mathematics these method are used to calculate the definite integrals, these integrals are provided with the complicated boundary conditions for multidimensional integrals. This method is successive one with consideration of risk analysis when compared to other methods. There is no single Monte carlo methods other than the term describes a large and widely used class approaches and these approach use the following pattern. 1. Possible inputs of domain is defined. 2. By using a certain specified probability distribution generate the inputs randomly from the domain. 3. By using these inputs perform a deterministic computation. 4.The final result can be computed by aggregating the results of the individual computation. Produce correct or optimum result with some probability. These algorithms have deterministic running time and it is generally easier to find out worst case time complexity. For example this implementation of Karger’s Algorithm produces minimum cut with probability greater than or equal to 1/n2 (n is number of vertices) and has worst case time complexity as O(E). Another example is Fermat Method for Primality Testing. Example to Understand Classification: A Las Vegas algorithm for this task is to keep picking a random element until we find a 1. A Monte Carlo algorithm for the same is to keep picking a random element until we either find 1 or we have tried maximum allowed times say k. The Las Vegas algorithm always finds an index of 1, but time complexity is determined as expect value. The expected number of trials before success is 2, therefore expected time complexity is O(1). The Monte Carlo Algorithm finds a 1 with probability [1 – (1/2)k]. Time complexity of Monte Carlo is O(k) which is deterministic The Monte-carlo methods has wider range of applications. It uses in various areas like physical science, Design and visuals, Finance and business, Telecommunication etc. In general Monte carlo methods are used in mathematics. By generating random numbers we can solve the various problem. The problems which are complex in nature or difficult to solve are solved by using Monte-carlo algorithms. Monte carlo integration is the most common application of Monte-carlo algorithm. The deterministic algorithm provides a correct solution but it takes long time or its runtime is large. This run-time can be improved by using the Monte carlo integration algorithms. There are various methods used for integration by using Monte-carlo methods such as, i) Direct sampling methods which includes the stratified sampling, recursivestratified sampling, importance sampling. ii) Random walk Monte-carlo algorithm which is used to find out the integration forgiven problem.iii) Gibbs sampling. Randomized algorithms are algorithms that use randomness as a key component in their operation. They can be used to solve a wide variety of problems, including optimization, search, and decision-making. Some examples of applications of randomized algorithms include: Example 1:                Example 2 :                Sources: http://theory.stanford.edu/people/pragh/amstalk.pdf https://en.wikipedia.org/wiki/Randomized_algorithm A  ",
        "code": "Consider a binary array where exactly half elements are 0\nand half are 1. The task is to find index of any 1.\n\n\n\n\n\n\n\n\n\n\n5 1 4 2 3\n\n\n\n\n\n\n\n\n\n\n4\n6\nNone\n7\n",
        "complexity": {
            "time": "A Las Vegas algorithm for this task is to keep picking a random element until we find a 1. A Monte Carlo algorithm for the same is to keep picking a random element until we either find 1 or we have tried maximum allowed times say k. The Las Vegas algorithm always finds an index of 1, but time complexity is determined as expect value. The expected number of trials before success is 2, therefore expected time complexity is O(1). The Monte Carlo Algorithm finds a 1 with probability [1 – (1/2)k]. Time complexity of Monte Carlo is O(k) which is deterministic",
            "space": ""
        },
        "tags": [
            "Randomized Algorithms"
        ],
        "url": "https://www.geeksforgeeks.org/randomized-algorithms-set-2-classification-and-applications/"
    },
    {
        "title": "Birthday Paradox",
        "description": "How many people must be there in a room to make the probability 100% that at-least two people in the room have same birthday? Answer: 367 (since there are 366 possible birthdays, including February 29). The above question was simple. Try the below question yourself. How many people must be there in a room to make the probability 50% that at-least two people in the room have same birthday? Answer: 23 The number is surprisingly very low. In fact, we need only 70 people to make the probability 99.9 %.Let us discuss the generalized formula. What is the probability that two persons among n have same birthday? Let the probability that two people in a room with n have same birthday be P(same). P(Same) can be easily evaluated in terms of P(different) where P(different) is the probability that all of them have different birthday.P(same) = 1 – P(different)P(different) can be written as 1 x (364/365) x (363/365) x (362/365) x …. x (1 – (n-1)/365)How did we get the above expression? Persons from first to last can get birthdays in following order for all birthdays to be distinct: The first person can have any birthday among 365 The second person should have a birthday which is not same as first person The third person should have a birthday which is not same as first two persons. ……………. …………… The n’th person should have a birthday which is not same as any of the earlier considered (n-1) persons. Approximation of above expression The above expression can be approximated using Taylor’s Series. provides a first-order approximation for ex for x << 1:To apply this approximation to the first expression derived for p(different), set x = -a / 365. Thus,The above expression derived for p(different) can be written as 1 x (1 – 1/365) x (1 – 2/365) x (1 – 3/365) x …. x (1 – (n-1)/365)By putting the value of 1 – a/365 as e-a/365, we get following.Therefore,p(same) = 1- p(different) An even coarser approximation is given byp(same) By taking Log on both sides, we get the reverse formula.Using the above approximate formula, we can approximate number of people for a given probability. For example the following C++ function find() returns the smallest n for which the probability is greater than the given p. Implementation of approximate formula. The following is program to approximate number of people for a given probability. Time Complexity: O(log n)Auxiliary Space: O(1) Source: http://en.wikipedia.org/wiki/Birthday_problem Applications: 1) Birthday Paradox is generally discussed with hashing to show importance of collision handling even for a small set of keys. 2) Birthday AttackBelow is an implementation: Time Complexity: O(log n)Auxiliary Space: O(1)  S  ",
        "code": "\n\n\n\n\n\n\n\n\n\n\n\n30\n\n\n\n\n\n\n\n\n\n\n\n\nProbability to find : \nTotal no. of people out of which there  is 0.0 probability that two of them have same birthdays is 239\n",
        "complexity": {
            "time": "Time Complexity: O(log n)Auxiliary Space: O(1)",
            "space": ""
        },
        "tags": [
            "Randomized Algorithms"
        ],
        "url": "https://www.geeksforgeeks.org/birthday-paradox/"
    },
    {
        "title": "Treap (A Randomized Binary Search Tree)",
        "description": "Like Red-Black and AVL Trees, Treap is a Balanced Binary Search Tree, but not guaranteed to have height as O(Log n). The idea is to use Randomization and Binary Heap property to maintain balance with high probability.  The expected time complexity of search, insert and delete is O(Log n).  Every node of Treap maintains two values.\n1) Key Follows standard BST ordering (left is smaller and right is greater)\n2) Priority Randomly assigned value that follows Max-Heap property. Basic Operation on Treap:\nLike other self-balancing Binary Search Trees, Treap uses rotations to maintain Max-Heap property during insertion and deletion. search(x)\nPerform standard BST Search to find x. Insert(x): \n1) Create new node with key equals to x and value equals to a random value.\n2) Perform standard BST insert.\n3) Use rotations to make sure that inserted node's priority follows max heap property.  Delete(x): \n1) If node to be deleted is a leaf, delete it.\n2) Else replace node's priority with minus infinite ( -INF ), and do appropriate rotations to bring the node down to a leaf.  Refer Implementation of Treap Search, Insert and Delete for more details. References:\nhttps://en.wikipedia.org/wiki/Treap\nhttps://courses.cs.washington.edu/courses/cse326/00wi/handouts/lecture19/sld017.htm  ",
        "code": "T1, T2 and T3 are subtrees of the tree rooted with y (on left side) \r\nor x (on right side)           \r\n                y                               x\r\n               / \\     Right Rotation          /  \\\r\n              x   T3   – – – – – – – >        T1   y \r\n             / \\       < - - - - - - -            / \\\r\n            T1  T2     Left Rotation            T2  T3\r\nKeys in both of the above trees follow the following order \r\n      keys(T1) < key(x) < keys(T2) < key(y) < keys(T3)\r\nSo BST property is not violated anywhere.\n",
        "complexity": {
            "time": "Like Red-Black and AVL Trees, Treap is a Balanced Binary Search Tree, but not guaranteed to have height as O(Log n). The idea is to use Randomization and Binary Heap property to maintain balance with high probability.  The expected time complexity of search, insert and delete is O(Log n).",
            "space": ""
        },
        "tags": [
            "Randomized Algorithms"
        ],
        "url": "https://www.geeksforgeeks.org/treap-a-randomized-binary-search-tree/"
    },
    {
        "title": "Skip List – Efficient Search, Insert and Delete in Linked List",
        "description": "A skip list is a data structure that allows for efficient search, insertion and deletion of elements in a sorted list. It is a probabilistic data structure, meaning that its average time complexity is determined through a probabilistic analysis. In a skip list, elements are organized in layers, with each layer having a smaller number of elements than the one below it. The bottom layer is a regular linked list, while the layers above it contain “skipping” links that allow for fast navigation to elements that are far apart in the bottom layer. The idea behind this is to allow for quick traversal to the desired element, reducing the average number of steps needed to reach it. Skip lists are implemented using a technique called “coin flipping.” In this technique, a random number is generated for each insertion to determine the number of layers the new element will occupy. This means that, on average, each element will be in log(n) layers, where n is the number of elements in the bottom layer. Skip lists have an average time complexity of O(log n) for search, insertion and deletion, which is similar to that of balanced trees, such as AVL trees and red-black trees, but with the advantage of simpler implementation and lower overhead. In summary, skip lists provide a simple and efficient alternative to balanced trees for certain use cases, particularly when the average number of elements in the list is large. Can we search in a sorted linked list better than O(n) time? The worst-case search time for a sorted linked list is O(n) as we can only linearly traverse the list and cannot skip nodes while searching. For a Balanced Binary Search Tree, we skip almost half of the nodes after one comparison with the root. For a sorted array, we have random access and we can apply Binary Search on arrays. Can we augment sorted linked lists to search faster? The answer is Skip List. The idea is simple, we create multiple layers so that we can skip some nodes. See the following example list with 16 nodes and two layers. The upper layer works as an “express lane” that connects only the main outer stations, and the lower layer works as a “normal lane” that connects every station. Suppose we want to search for 50, we start from the first node of the “express lane” and keep moving on the “express lane” till we find a node whose next is greater than 50. Once we find such a node (30 is the node in the following example) on “express lane”, we move to “normal lane” using a pointer from this node, and linearly search for 50 on “normal lane”. In the following example, we start from 30 on the “normal lane” and with linear search, we find 50.  What is the time complexity with two layers? worst-case time complexity is several nodes on the “express lane” plus several nodes in a segment (A segment is several “normal lane” nodes between two “express lane” nodes) of the “normal lane”. So if we have n nodes on “normal lane”, ?n (square root of n) nodes on “express lane” and we equally divide the “normal lane”, then there will be ?n nodes in every segment of “normal lane”. ?n is an optimal division with two layers. With this arrangement, the number of nodes traversed for a search will be O(?n). Therefore, with O(?n) extra space, we can reduce the time complexity to O(?n). Advantages of Skip List: Disadvantages of Skip List: Can we do better? The time complexity of skip lists can be reduced further by adding more layers. The time complexity of the search, the insert, and delete can become O(Logn) in an average cases with O(n) extra space. We will soon be publishing more posts on Skip Lists. References MIT Video Lecture on Skip Lists http://en.wikipedia.org/wiki/Skip_list  ",
        "code": "",
        "complexity": {
            "time": "Can we do better? The time complexity of skip lists can be reduced further by adding more layers. The time complexity of the search, the insert, and delete can become O(Logn) in an average cases with O(n) extra space. We will soon be publishing more posts on Skip Lists. References MIT Video Lecture on Skip Lists http://en.wikipedia.org/wiki/Skip_list",
            "space": ""
        },
        "tags": [
            "Randomized Algorithms"
        ],
        "url": "https://www.geeksforgeeks.org/skip-list/"
    },
    {
        "title": "Program to generate CAPTCHA and verify user",
        "description": "A CAPTCHA (Completely Automated Public Turing test to tell Computers and Humans Apart) is a test to determine whether the user is human or not.So, the task is to generate unique CAPTCHA every time and to tell whether the user is human or not by asking user to enter the same CAPTCHA as generated automatically and checking the user input with the generated CAPTCHA.Examples: The set of characters to generate CAPTCHA are stored in a character array chrs[] which contains (a-z, A-Z, 0-9), therefore size of chrs[] is 62. To generate a unique CAPTCHA every time, a random number is generated using rand() function (rand()%62) which generates a random number between 0 to 61 and the generated random number is taken as index to the character array chrs[] thus generates a new character of captcha[] and this loop runs n (length of CAPTCHA) times to generate CAPTCHA of given length. Algorithm:                Output: Time Complexity: O(n)Space Complexity: O(1) H  ",
        "code": "CAPTCHA: x9Pm72se\nInput: x9Pm62es\nOutput: CAPTCHA Not Matched\n\nCAPTCHA: cF3yl9T4\nInput: cF3yl9T4\nOutput: CAPTCHA Matched\n\n\n\n\n\n\n\n\n\n\nCAPTCHA: cF3yl9T4\nEnter CAPTCHA: cF3yl9T4\nCAPTCHA Matched\n",
        "complexity": {
            "time": "Time Complexity: O(n)Space Complexity: O(1)",
            "space": ""
        },
        "tags": [
            "Randomized Algorithms"
        ],
        "url": "https://www.geeksforgeeks.org/program-generate-captcha-verify-user/"
    },
    {
        "title": "Shuffle a given array using Fisher–Yates shuffle Algorithm",
        "description": "Given an array, write a program to generate a random permutation of array elements. This question is also asked as “shuffle a deck of cards” or “randomize a given array”. Here shuffle means that every permutation of array element should be equally likely.  Let the given array be arr[]. A simple solution is to create an auxiliary array temp[] which is initially a copy of arr[]. Randomly select an element from temp[], copy the randomly selected element to arr[0], and remove the selected element from temp[]. Repeat the same process n times and keep copying elements to arr[1], arr[2], … . The time complexity of this solution will be O(n^2). Fisher–Yates shuffle Algorithm works in O(n) time complexity. The assumption here is, we are given a function rand() that generates a random number in O(1) time. The idea is to start from the last element and swap it with a randomly selected element from the whole array (including the last). Now consider the array from 0 to n-2 (size reduced by 1), and repeat the process till we hit the first element. Following is the detailed algorithm that is as follows: Flowchart: flowchart Following is an implementation of this algorithm.                      Output : The above function assumes that rand() generates a random number. Time Complexity: O(n), assuming that the function rand() takes O(1) time., Auxiliary Space: O(1) How does this work? The probability that the ith element (including the last one) goes to the last position is 1/n, because we randomly pick an element in the first iteration. This means that each element has an equal chance of ending up in the last position. The probability that the ith element goes to the second-to-last position can be proven to be 1/n by dividing it into two cases: Case 1: i = n-1 (index of last element):In this case, the probability of the last element going to the second-to-last position is equal to the probability that the last element does not stay at its original position, multiplied by the probability that the index picked in the previous step is picked again so that the last element is swapped. This means that the probability is: ((n-1)/n) x (1/(n-1)) = 1/n Case 2: 0 < i < n-1 (index of non-last element):In this case, the probability of the ith element going to the second-to-last position is equal to the probability that the ith element is not picked in the previous iteration, multiplied by the probability that the ith element is picked in this iteration. This means that the probability is: ((n-1)/n) x (1/(n-1)) = 1/n We can easily generalize the proof for any other position by applying the same logic. For example, the probability that the ith element goes to the third-to-last position is 1/n, because it is equally likely to be picked in any iteration.For example, if we have an array with 5 elements, each element has a 1/5 chance of ending up in the last position. And if we shuffle the array multiple times, we should see that each element ends up in the last position about 1/5 of the time on average. This also applies to other positions in the array. For example, each element has a 1/5 chance of ending up in the second-to-last position, because it is equally likely to be picked in any iteration. Overall, this means that the shuffle is random and fair, because each element has an equal chance of ending up in any position.  https://www.youtube.com/playlist?list=PLqM7alHXFySEQDk2MDfbwEdjd2svVJH9p  ",
        "code": "To shuffle an array a of n elements (indices 0..n-1):\n  for i from n - 1 downto 1 do\n       j = random integer with 0 <= j <= i\n       exchange a[j] and a[i]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n7 8 4 6 3 1 2 5\n",
        "complexity": {
            "time": "Time Complexity: O(n), assuming that the function rand() takes O(1) time., Auxiliary Space: O(1)",
            "space": ""
        },
        "tags": [
            "Randomized Algorithms"
        ],
        "url": "https://www.geeksforgeeks.org/shuffle-a-given-array-using-fisher-yates-shuffle-algorithm/"
    },
    {
        "title": "Reservoir Sampling",
        "description": "Reservoir sampling is a family of randomized algorithms for randomly choosing k samples from a list of n items, where n is either a very large or unknown number. Typically n is large enough that the list doesn’t fit into main memory. For example, a list of search queries in Google and Facebook.So we are given a big array (or stream) of numbers (to simplify), and we need to write an efficient function to randomly select k numbers where 1 <= k <= n. Let the input array be stream[]. A simple solution is to create an array reservoir[] of maximum size k. One by one randomly select an item from stream[0..n-1]. If the selected item is not previously selected, then put it in reservoir[]. To check if an item is previously selected or not, we need to search the item in reservoir[]. The time complexity of this algorithm will be O(k^2). This can be costly if k is big. Also, this is not efficient if the input is in the form of a stream. It can be solved in O(n) time. The solution also suits well for input in the form of stream. The idea is similar to this post. Following are the steps.1) Create an array reservoir[0..k-1] and copy first k items of stream[] to it. 2) Now one by one consider all items from (k+1)th item to nth item. …a) Generate a random number from 0 to i where i is the index of the current item in stream[]. Let the generated random number is j. …b) If j is in range 0 to k-1, replace reservoir[j] with stream[i] Following is the implementation of the above algorithm.                      Output: Time Complexity: O(n) Auxiliary Space: O(k) How does this work? To prove that this solution works perfectly, we must prove that the probability that any item stream[i] where 0 <= i < n will be in final reservoir[] is k/n. Let us divide the proof in two cases as first k items are treated differently. Case 1: For last n-k stream items, i.e., for stream[i] where k <= i < n For every such stream item stream[i], we pick a random index from 0 to i and if the picked index is one of the first k indexes, we replace the element at picked index with stream[i]To simplify the proof, let us first consider the last item. The probability that the last item is in final reservoir = The probability that one of the first k indexes is picked for last item = k/n (the probability of picking one of the k items from a list of size n)Let us now consider the second last item. The probability that the second last item is in final reservoir[] = [Probability that one of the first k indexes is picked in iteration for stream[n-2]] X [Probability that the index picked in iteration for stream[n-1] is not same as index picked for stream[n-2] ] = [k/(n-1)]*[(n-1)/n] = k/n.Similarly, we can consider other items for all stream items from stream[n-1] to stream[k] and generalize the proof. Case 2: For first k stream items, i.e., for stream[i] where 0 <= i < k The first k items are initially copied to reservoir[] and may be removed later in iterations for stream[k] to stream[n]. The probability that an item from stream[0..k-1] is in final array = Probability that the item is not picked when items stream[k], stream[k+1], …. stream[n-1] are considered = [k/(k+1)] x [(k+1)/(k+2)] x [(k+2)/(k+3)] x … x [(n-1)/n] = k/n References: http://en.wikipedia.org/wiki/Reservoir_sampling  ",
        "code": "\n\n\n\n\n\n\n\n\n\n\n\n\n\nFollowing are k randomly selected items6 2 11 8 12Note: Output will differ every time as it selects and prints random elements\n",
        "complexity": {
            "time": "Time Complexity: O(n)",
            "space": ""
        },
        "tags": [
            "Randomized Algorithms"
        ],
        "url": "https://www.geeksforgeeks.org/reservoir-sampling/"
    },
    {
        "title": "Freivald’s Algorithm to check if a matrix is product of two",
        "description": "Given three matrices A, B and C, find if C is a product of A and B. Examples: A simple solution is to find product of A and B and then check if product is equal to C or not. A possible time complexity of this method is O(n2.8874) using Stression’s matrix multiplication. Freivalds’ algorithm is a probabilistic randomized algorithm that works in time O(n2) with high probability. In O(kn2) time the algorithm can verify a matrix product with probability of failure less than 2-k. Since the output is not always correct, it is a Monte Carlo randomized algorithm. Steps : The idea is based on the fact that if C is actually a product, then value of A × (Br)? – Cr? will always be 0. If the value is non-zero, then C can not be a product. The error condition is that the value may be 0 even when C is not a product. Below is the implementation of the above approach:                    Time Complexity: O(N ^ 2)Auxiliary Space: O(N )  ",
        "code": "Input : A = 1 1\n            1 1\n        B = 1 1\n            1 1\n        C = 2  2\n             2 2\nOutput : Yes\nC = A x B\n\nInput : A = 1 1 1\n            1 1 1\n            1 1 1\n        B = 1 1 1\n            1 1 1\n            1 1 1\n        C = 3 3 3\n            3 1 2\n            3 3 3 \nOutput : No\n\n\n\n\n\n\n\n\n\n\n\n\nYes\n",
        "complexity": {
            "time": "Time Complexity: O(N ^ 2)Auxiliary Space: O(N )",
            "space": ""
        },
        "tags": [
            "Randomized Algorithms"
        ],
        "url": "https://www.geeksforgeeks.org/freivalds-algorithm/"
    },
    {
        "title": "Randomized Algorithms | Set 3 (1/2 Approximate Median)",
        "description": "We strongly recommend to refer below articles as a prerequisite of this. Randomized Algorithms | Set 1 (Introduction and Analysis)\nRandomized Algorithms | Set 2 (Classification and Applications) In this post, a Monte Carlo algorithm is discussed. Problem Statement :  Given an unsorted array A[] of n numbers and ε > 0, compute an element whose rank (position in sorted A[]) is in the range [(1 – ε)n/2, (1 +  ε)n/2].\nFor ½ Approximate Median Algorithm &epsilom is 1/2 => rank should be in the range [n/4, 3n/4] We can find k’th smallest element in O(n) expected time and O(n) worst case time. What if we want in less than O(n) time with low probable error allowed?\nFollowing steps represent an algorithm that is O((Log n) x (Log Log n)) time and produces incorrect result with probability less than or equal to 2/n2.       Output: Time Complexity:\nWe use a set provided by the STL in C++. In STL Set, insertion for each element takes O(log k). So for k insertions, time taken is O (k log k).\nNow replacing k with c log n\n=>O(c log n (log (clog n))) =>O (log n (log log n)) How is probability of error less than 2/n2?\nAlgorithm makes an error if the set S has at least k/2 elements are from the Left Quarter or Right Quarter. It is quite easy to visualize this statement since the median which we report will be (k/2)th element and if we take k/2 elements from the left quarter(or right quarter) the median will be from the left quarter (or the right quarter). An array can be divided into 4 quarters each of size n/4. So P(selecting left quarter) is 1/4. So what is the probability that at least k/2 elements are from the Left Quarter or Right Quarter? This probability problem is same as below : Given a coin which gives HEADS with probability 1/4 and TAILS with 3/4. The coin is tossed k times. What is the probability that we get at least k/2 HEADS is less than or equal to? Explanation: Probability of selecting at least k/2 elements from the left quarter) <= 1/n2\nProbability of selecting at least k/2 elements from the left or right quarter) <= 2/n2 Therefore algorithm produces incorrect result with probability less than or equal to 2/n2. References:www.cse.iitk.ac.in/users/sbaswana/CS648/Lecture-2-CS648.pptx C  ",
        "code": "\n\n\n\nApproximate Median is 4\nIf we put k = c log n for c = 10, we get \r\nP <= (1/2)2log n\r\nP <= (1/2)log n2\r\nP <= n-2\n",
        "complexity": {
            "time": "Time Complexity:\nWe use a set provided by the STL in C++. In STL Set, insertion for each element takes O(log k). So for k insertions, time taken is O (k log k).\nNow replacing k with c log n\n=>O(c log n (log (clog n))) =>O (log n (log log n))",
            "space": ""
        },
        "tags": [
            "Randomized Algorithms"
        ],
        "url": "https://www.geeksforgeeks.org/randomized-algorithms-set-3-12-approximate-median/"
    }
]