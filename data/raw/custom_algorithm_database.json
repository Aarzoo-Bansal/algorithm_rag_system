{
  "algorithms": [
    {
      "name": "Quick Sort",
      "tags": [
        "sorting",
        "divide and conquer",
        "comparison sort"
      ],
      "description": "Quick sort is a highly efficient sorting algorithm that uses a divide-and-conquer strategy. It works by selecting a 'pivot' element from the array and partitioning the other elements into two sub-arrays according to whether they are less than or greater than the pivot. The sub-arrays are then recursively sorted.",
      "complexity": {
        "time": "O(n log n)",
        "worst_time": "O(n\u00b2)",
        "space": "O(log n)"
      },
      "problem_patterns": [
        "Need to sort an array or list efficiently",
        "When average-case performance is more important than worst-case",
        "When in-place sorting is desired"
      ],
      "leetcode_indicators": [
        "Sorting array or list",
        "Problems requiring efficient ordering",
        "Problems where elements need to be partitioned"
      ],
      "implementation": "\n                def quick_sort(arr):\n                    if len(arr) <= 1:\n                        return arr\n                    \n                    pivot = arr[len(arr) // 2]\n                    left = [x for x in arr if x < pivot]\n                    middle = [x for x in arr if x == pivot]\n                    right = [x for x in arr if x > pivot]\n                    \n                    return quick_sort(left) + middle + quick_sort(right)\n                ",
      "id": "3c96770a-7620-48c1-ba8f-a3622d959f0e"
    },
    {
      "name": "Merge Sort",
      "tags": [
        "sorting",
        "divide and conquer",
        "stable sort"
      ],
      "description": "Merge sort is an efficient, stable, comparison-based, divide and conquer sorting algorithm. It divides the input array into two halves, recursively sorts them, and then merges the sorted halves. The merge step is the key operation, where the two sorted sub-arrays are combined to form a single sorted array.",
      "complexity": {
        "time": "O(n log n)",
        "space": "O(n)"
      },
      "problem_patterns": [
        "Need for stable sorting (preserving relative order of equal elements)",
        "When guaranteed worst-case performance is important",
        "Sorting linked lists"
      ],
      "leetcode_indicators": [
        "Stable sorting required",
        "Linked list sorting",
        "Problems involving counting inversions"
      ],
      "implementation": "\n                def merge_sort(arr):\n                    if len(arr) <= 1:\n                        return arr\n                    \n                    mid = len(arr) // 2\n                    left = merge_sort(arr[:mid])\n                    right = merge_sort(arr[mid:])\n                    \n                    return merge(left, right)\n\n                def merge(left, right):\n                    result = []\n                    i = j = 0\n                    \n                    while i < len(left) and j < len(right):\n                        if left[i] <= right[j]:\n                            result.append(left[i])\n                            i += 1\n                        else:\n                            result.append(right[j])\n                            j += 1\n                    \n                    result.extend(left[i:])\n                    result.extend(right[j:])\n                    return result\n                ",
      "id": "0f6edd1a-d1c4-4c0a-9b8e-9efd3c5b1cd5"
    },
    {
      "name": "Heap Sort",
      "tags": [
        "sorting",
        "comparison sort",
        "in-place"
      ],
      "description": "Heap sort is a comparison-based sorting algorithm that uses a binary heap data structure. It divides its input into a sorted region and an unsorted region, and iteratively shrinks the unsorted region by extracting the largest element and inserting it into the sorted region.",
      "complexity": {
        "time": "O(n log n)",
        "space": "O(1)"
      },
      "problem_patterns": [
        "When space complexity is a concern",
        "Finding the k largest/smallest elements",
        "When in-place sorting is required"
      ],
      "leetcode_indicators": [
        "K largest/smallest elements",
        "Priority queue problems",
        "Sorting with minimal extra space"
      ],
      "implementation": "\n        def heapify(arr, n, i):\n            largest = i\n            left = 2 * i + 1\n            right = 2 * i + 2\n            \n            if left < n and arr[left] > arr[largest]:\n                largest = left\n            \n            if right < n and arr[right] > arr[largest]:\n                largest = right\n            \n            if largest != i:\n                arr[i], arr[largest] = arr[largest], arr[i]\n                heapify(arr, n, largest)\n\n        def heap_sort(arr):\n            n = len(arr)\n            \n            # Build max heap\n            for i in range(n // 2 - 1, -1, -1):\n                heapify(arr, n, i)\n            \n            # Extract elements one by one\n            for i in range(n - 1, 0, -1):\n                arr[i], arr[0] = arr[0], arr[i]\n                heapify(arr, i, 0)\n            \n            return arr\n        ",
      "id": "2a4ebb3a-d30c-44bf-a0f5-7bf433319e2b"
    },
    {
      "name": "Binary Search",
      "tags": [
        "searching",
        "divide and conquer",
        "sorted array"
      ],
      "description": "Binary search is an efficient algorithm for finding an item from a sorted list of items. It works by repeatedly dividing in half the portion of the list that could contain the item, until you've narrowed down the possible locations to just one.",
      "complexity": {
        "time": "O(log n)",
        "space": "O(1)"
      },
      "problem_patterns": [
        "Searching in a sorted array or list",
        "Finding the position to insert an element in a sorted array",
        "Problems requiring efficient search in monotonic functions"
      ],
      "leetcode_indicators": [
        "Search in sorted array",
        "Find first/last position of element",
        "Problems with O(log n) time complexity requirement",
        "Problems involving rotated sorted arrays"
      ],
      "implementation": "\n                def binary_search(arr, target):\n                    left, right = 0, len(arr) - 1\n                    \n                    while left <= right:\n                        mid = (left + right) // 2\n                        \n                        if arr[mid] == target:\n                            return mid\n                        elif arr[mid] < target:\n                            left = mid + 1\n                        else:\n                            right = mid - 1\n                    \n                    return -1  # Target not found\n                ",
      "id": "cd2e3419-704c-4cd1-b625-5f6c71e8e415"
    },
    {
      "name": "Depth-First Search (DFS)",
      "tags": [
        "searching",
        "graph algorithm",
        "tree traversal"
      ],
      "description": "Depth-First Search is an algorithm for traversing or searching tree or graph data structures. The algorithm starts at the root node and explores as far as possible along each branch before backtracking.",
      "complexity": {
        "time": "O(V + E)",
        "space": "O(V)"
      },
      "problem_patterns": [
        "Traversing trees or graphs",
        "Finding connected components",
        "Path finding problems",
        "Cycle detection"
      ],
      "leetcode_indicators": [
        "Graph or tree traversal",
        "Path finding",
        "Connected components",
        "Cycle detection",
        "Problems requiring backtracking"
      ],
      "implementation": "\n                def dfs(graph, start, visited=None):\n                    if visited is None:\n                        visited = set()\n                    \n                    visited.add(start)\n                    print(start, end=' ')\n                    \n                    for neighbor in graph[start]:\n                        if neighbor not in visited:\n                            dfs(graph, neighbor, visited)\n                    \n                    return visited\n                ",
      "id": "63cfd14f-ad35-4e29-aff1-e8763adef9ad"
    },
    {
      "name": "Breadth-First Search (BFS)",
      "tags": [
        "searching",
        "graph algorithm",
        "tree traversal"
      ],
      "description": "Breadth-First Search is an algorithm for traversing or searching tree or graph data structures. It starts at the tree root (or some arbitrary node in a graph) and explores all of the neighbor nodes at the present depth prior to moving on to the nodes at the next depth level.",
      "complexity": {
        "time": "O(V + E)",
        "space": "O(V)"
      },
      "problem_patterns": [
        "Finding shortest path in unweighted graphs",
        "Level order traversal of trees",
        "Finding all nodes within a distance k",
        "Problems requiring level-by-level processing"
      ],
      "leetcode_indicators": [
        "Shortest path in unweighted graph",
        "Level order traversal",
        "Minimum steps to reach target",
        "Problems involving word ladder or transformation"
      ],
      "implementation": "\n                from collections import deque\n\n                def bfs(graph, start):\n                    visited = set([start])\n                    queue = deque([start])\n                    \n                    while queue:\n                        vertex = queue.popleft()\n                        print(vertex, end=' ')\n                        \n                        for neighbor in graph[vertex]:\n                            if neighbor not in visited:\n                                visited.add(neighbor)\n                                queue.append(neighbor)\n                    \n                    return visited\n                ",
      "id": "694d1a82-a090-407a-a13a-cc24895b5d48"
    },
    {
      "name": "Dijkstra's Algorithm",
      "tags": [
        "graph algorithm",
        "shortest path",
        "weighted graph"
      ],
      "description": "Dijkstra's algorithm is used to find the shortest paths between nodes in a graph with non-negative edge weights. It uses a priority queue to greedily select the closest vertex that has not yet been processed and updates the distances to all its neighbors.",
      "complexity": {
        "time": "O((V + E) log V)",
        "space": "O(V)"
      },
      "problem_patterns": [
        "Finding shortest path in weighted graphs",
        "Network routing problems",
        "Problems involving path optimization"
      ],
      "leetcode_indicators": [
        "Shortest path in weighted graph",
        "Path with minimum cost/time/distance",
        "Network routing problems"
      ],
      "implementation": "\n                import heapq\n\n                def dijkstra(graph, start):\n                    # Initialize distances with infinity for all nodes except start\n                    distances = {node: float('infinity') for node in graph}\n                    distances[start] = 0\n                    \n                    # Priority queue to store vertices to be processed\n                    priority_queue = [(0, start)]\n                    \n                    while priority_queue:\n                        current_distance, current_node = heapq.heappop(priority_queue)\n                        \n                        # If current distance is greater than the known distance, skip\n                        if current_distance > distances[current_node]:\n                            continue\n                        \n                        # Process neighbors\n                        for neighbor, weight in graph[current_node].items():\n                            distance = current_distance + weight\n                            \n                            # If we found a shorter path, update and add to queue\n                            if distance < distances[neighbor]:\n                                distances[neighbor] = distance\n                                heapq.heappush(priority_queue, (distance, neighbor))\n                    \n                    return distances\n                ",
      "id": "89f1ba31-4f16-4a52-aeac-a85f8a02cde5"
    },
    {
      "name": "Kruskal's Algorithm",
      "tags": [
        "graph algorithm",
        "minimum spanning tree",
        "greedy"
      ],
      "description": "Kruskal's algorithm is a greedy algorithm that finds a minimum spanning tree for a connected weighted graph. It adds the edges in order of their weight (smallest to largest) as long as adding an edge doesn't create a cycle.",
      "complexity": {
        "time": "O(E log E)",
        "space": "O(V + E)"
      },
      "problem_patterns": [
        "Finding minimum spanning tree",
        "Network design problems",
        "Clustering problems"
      ],
      "leetcode_indicators": [
        "Minimum spanning tree",
        "Problems involving connecting all nodes at minimum cost",
        "Network design optimization"
      ],
      "implementation": "\n                def find(parent, i):\n                    if parent[i] != i:\n                        parent[i] = find(parent, parent[i])\n                    return parent[i]\n\n                def union(parent, rank, x, y):\n                    root_x = find(parent, x)\n                    root_y = find(parent, y)\n                    \n                    if root_x == root_y:\n                        return\n                    \n                    if rank[root_x] < rank[root_y]:\n                        parent[root_x] = root_y\n                    elif rank[root_x] > rank[root_y]:\n                        parent[root_y] = root_x\n                    else:\n                        parent[root_y] = root_x\n                        rank[root_x] += 1\n\n                def kruskal(graph, vertices):\n                    result = []\n                    i, e = 0, 0\n                    \n                    # Sort edges by weight\n                    graph = sorted(graph, key=lambda item: item[2])\n                    \n                    parent = []\n                    rank = []\n                    \n                    # Initialize parent and rank arrays\n                    for node in range(vertices):\n                        parent.append(node)\n                        rank.append(0)\n                    \n                    # Process edges\n                    while e < vertices - 1 and i < len(graph):\n                        u, v, w = graph[i]\n                        i += 1\n                        \n                        x = find(parent, u)\n                        y = find(parent, v)\n                        \n                        if x != y:\n                            e += 1\n                            result.append([u, v, w])\n                            union(parent, rank, x, y)\n                    \n                    return result\n                ",
      "id": "96d8dc91-70cf-41c2-8406-eba97fd940e7"
    },
    {
      "name": "Topological Sort",
      "tags": [
        "graph algorithm",
        "directed acyclic graph",
        "ordering"
      ],
      "description": "Topological Sort is an algorithm for ordering the vertices of a directed acyclic graph (DAG) such that for every directed edge (u, v), vertex u comes before vertex v in the ordering.",
      "complexity": {
        "time": "O(V + E)",
        "space": "O(V)"
      },
      "problem_patterns": [
        "Task scheduling with dependencies",
        "Course prerequisites ordering",
        "Any problem requiring ordering based on dependencies"
      ],
      "leetcode_indicators": [
        "Course schedule problems",
        "Task scheduling with prerequisites",
        "Problems involving dependency ordering"
      ],
      "implementation": "\n                from collections import defaultdict, deque\n\n                def topological_sort(graph):\n                    # Count in-degrees of all vertices\n                    in_degree = {node: 0 for node in graph}\n                    for node in graph:\n                        for neighbor in graph[node]:\n                            in_degree[neighbor] += 1\n                    \n                    # Queue with all nodes that have no incoming edges\n                    queue = deque([node for node, degree in in_degree.items() if degree == 0])\n                    result = []\n                    \n                    # Process nodes\n                    while queue:\n                        node = queue.popleft()\n                        result.append(node)\n                        \n                        # Decrease in-degree of neighbors\n                        for neighbor in graph[node]:\n                            in_degree[neighbor] -= 1\n                            if in_degree[neighbor] == 0:\n                                queue.append(neighbor)\n                    \n                    # Check if there's a cycle\n                    if len(result) != len(graph):\n                        return []  # Graph has at least one cycle\n                    \n                    return result\n                ",
      "id": "095376a9-f476-42bd-8809-7832e4ebd180"
    },
    {
      "name": "Linked List Reversal",
      "tags": [
        "linked list",
        "pointer manipulation",
        "in-place"
      ],
      "description": "The Linked List Reversal algorithm takes a singly linked list and reverses the order of its nodes in-place by manipulating the pointers. This is done by iterating through the list and changing each node's next pointer to point to the previous node instead of the next one.",
      "complexity": {
        "time": "O(n)",
        "space": "O(1)"
      },
      "problem_patterns": [
        "Reversing a linked list or parts of a linked list",
        "Problems requiring modification of link directions",
        "In-place list restructuring"
      ],
      "leetcode_indicators": [
        "Reverse a linked list",
        "Reverse nodes in k-group",
        "Problems involving list direction manipulation"
      ],
      "implementation": "\n            def reverse_linked_list(head):\n                prev = None\n                current = head\n                \n                while current:\n                    # Store next node\n                    next_node = current.next\n                    \n                    # Reverse the pointer\n                    current.next = prev\n                    \n                    # Move to next iteration\n                    prev = current\n                    current = next_node\n                \n                # Return new head (which is the previous tail)\n                return prev\n            ",
      "id": "6bdf856f-0fe2-441d-8a8e-b216c711bc36"
    },
    {
      "name": "Linked List Cycle Detection",
      "tags": [
        "linked list",
        "two pointers",
        "cycle detection"
      ],
      "description": "The Linked List Cycle Detection algorithm (also known as Floyd's Tortoise and Hare algorithm) determines if a linked list has a cycle by using two pointers that move at different speeds. If there is a cycle, the fast pointer will eventually catch up to the slow pointer.",
      "complexity": {
        "time": "O(n)",
        "space": "O(1)"
      },
      "problem_patterns": [
        "Detecting cycles in linked lists",
        "Finding the start of a cycle",
        "Problems involving loop detection"
      ],
      "leetcode_indicators": [
        "Linked list cycle detection",
        "Find the start of cycle",
        "Check if a linked list contains a loop"
      ],
      "implementation": "\n            def has_cycle(head):\n                if not head or not head.next:\n                    return False\n                \n                # Initialize slow and fast pointers\n                slow = head\n                fast = head\n                \n                # Move slow by 1 and fast by 2\n                while fast and fast.next:\n                    slow = slow.next\n                    fast = fast.next.next\n                    \n                    # If they meet, there's a cycle\n                    if slow == fast:\n                        return True\n                \n                # If fast reaches the end, there's no cycle\n                return False\n\n            def find_cycle_start(head):\n                if not head or not head.next:\n                    return None\n                \n                # First, detect if there's a cycle\n                slow = fast = head\n                has_cycle = False\n                \n                while fast and fast.next:\n                    slow = slow.next\n                    fast = fast.next.next\n                    \n                    if slow == fast:\n                        has_cycle = True\n                        break\n                \n                # If no cycle, return None\n                if not has_cycle:\n                    return None\n                \n                # Reset slow to head and keep fast at meeting point\n                slow = head\n                \n                # Move both at same pace until they meet\n                while slow != fast:\n                    slow = slow.next\n                    fast = fast.next\n                \n                # Return the start of the cycle\n                return slow\n            ",
      "id": "7fe10e88-254d-4599-858b-e08ce302b8d7"
    },
    {
      "name": "Linked List Rotation",
      "tags": [
        "linked list",
        "pointer manipulation",
        "two pointers"
      ],
      "description": "The Linked List Rotation algorithm rotates a linked list to the right or left by k positions by manipulating pointers. The operation is performed by connecting the tail of the list to the head to form a circle, then breaking the circle at the appropriate point.",
      "complexity": {
        "time": "O(n)",
        "space": "O(1)"
      },
      "problem_patterns": [
        "Rotating elements in a linked list",
        "Problems involving circular rearrangement",
        "Shifting node positions without creating new nodes"
      ],
      "leetcode_indicators": [
        "Rotate list to the right/left by k places",
        "Rotate elements in a linked list",
        "Shift node positions in a linked list"
      ],
      "implementation": "\n            def rotate_right(head, k):\n                # Handle edge cases\n                if not head or not head.next or k == 0:\n                    return head\n                \n                # Find the length of the list and the tail\n                current = head\n                length = 1\n                \n                while current.next:\n                    current = current.next\n                    length += 1\n                \n                # Connect tail to head to make it circular\n                tail = current\n                tail.next = head\n                \n                # Calculate the number of effective rotations\n                k = k % length\n                \n                # Find the new tail: (length - k - 1)th node\n                current = head\n                for _ in range(length - k - 1):\n                    current = current.next\n                \n                # The new head is the next node\n                new_head = current.next\n                \n                # Break the circle\n                current.next = None\n                \n                return new_head\n            ",
      "id": "195600ff-904a-4105-b698-e20257671be6"
    },
    {
      "name": "Linked List Merge",
      "tags": [
        "linked list",
        "two pointers",
        "sorting"
      ],
      "description": "The Linked List Merge algorithm combines two sorted linked lists into a single sorted linked list by comparing nodes from both lists and linking them in the correct order.",
      "complexity": {
        "time": "O(n + m)",
        "space": "O(1)"
      },
      "problem_patterns": [
        "Merging sorted linked lists",
        "Combining multiple sorted structures",
        "In-place list integration"
      ],
      "leetcode_indicators": [
        "Merge two sorted linked lists",
        "Merge k sorted linked lists",
        "Sort a linked list using merge sort"
      ],
      "implementation": "\n            def merge_two_lists(l1, l2):\n                # Create a dummy head\n                dummy = ListNode(0)\n                current = dummy\n                \n                # Compare nodes and link them in order\n                while l1 and l2:\n                    if l1.val <= l2.val:\n                        current.next = l1\n                        l1 = l1.next\n                    else:\n                        current.next = l2\n                        l2 = l2.next\n                    current = current.next\n                \n                # Link remaining nodes\n                current.next = l1 if l1 else l2\n                \n                return dummy.next\n            ",
      "id": "f650832a-e2a9-4a32-822d-d9b518980d10"
    },
    {
      "name": "Stack Implementation",
      "tags": [
        "stack",
        "data structure",
        "LIFO"
      ],
      "description": "The Stack data structure follows Last-In-First-Out (LIFO) principle. It supports two primary operations: push (adding an element to the top) and pop (removing the top element). Stacks can be implemented using arrays or linked lists.",
      "complexity": {
        "time": "O(1) for push/pop operations",
        "space": "O(n)"
      },
      "problem_patterns": [
        "Problems requiring last-in-first-out processing",
        "Function call management",
        "Expression evaluation and parsing"
      ],
      "leetcode_indicators": [
        "Valid parentheses",
        "Evaluate expressions",
        "History tracking",
        "Undo operations"
      ],
      "implementation": "\n            # Array-based stack implementation\n            class Stack:\n                def __init__(self):\n                    self.items = []\n                \n                def is_empty(self):\n                    return len(self.items) == 0\n                \n                def push(self, item):\n                    self.items.append(item)\n                \n                def pop(self):\n                    if self.is_empty():\n                        raise IndexError(\"Pop from an empty stack\")\n                    return self.items.pop()\n                \n                def peek(self):\n                    if self.is_empty():\n                        raise IndexError(\"Peek from an empty stack\")\n                    return self.items[-1]\n                \n                def size(self):\n                    return len(self.items)\n\n            # Linked list-based stack implementation\n            class Node:\n                def __init__(self, value):\n                    self.value = value\n                    self.next = None\n\n            class LinkedStack:\n                def __init__(self):\n                    self.top = None\n                    self.size = 0\n                \n                def is_empty(self):\n                    return self.top is None\n                \n                def push(self, value):\n                    new_node = Node(value)\n                    new_node.next = self.top\n                    self.top = new_node\n                    self.size += 1\n                \n                def pop(self):\n                    if self.is_empty():\n                        raise IndexError(\"Pop from an empty stack\")\n                    value = self.top.value\n                    self.top = self.top.next\n                    self.size -= 1\n                    return value\n                \n                def peek(self):\n                    if self.is_empty():\n                        raise IndexError(\"Peek from an empty stack\")\n                    return self.top.value\n            ",
      "id": "6c2445cd-04c0-4ea8-8f5a-939e40bac2ba"
    },
    {
      "name": "Balanced Parentheses Check",
      "tags": [
        "stack",
        "string",
        "validation"
      ],
      "description": "The Balanced Parentheses Check algorithm uses a stack to verify if an expression has balanced parentheses, brackets, and braces. It scans the expression from left to right, pushing opening delimiters onto a stack and popping when matching closing delimiters are encountered.",
      "complexity": {
        "time": "O(n)",
        "space": "O(n)"
      },
      "problem_patterns": [
        "Validating proper nesting of parentheses, brackets, and braces",
        "Checking syntax in expressions",
        "Problems requiring matching of opening and closing characters"
      ],
      "leetcode_indicators": [
        "Valid parentheses",
        "Check balanced brackets",
        "Expression validation"
      ],
      "implementation": "\n            def is_balanced(expression):\n                stack = []\n                \n                # Dictionary to map closing brackets to their opening counterparts\n                brackets_map = {')': '(', '}': '{', ']': '['}\n                \n                # Scan the expression\n                for char in expression:\n                    # If it's an opening bracket, push to stack\n                    if char in '({[':\n                        stack.append(char)\n                    # If it's a closing bracket\n                    elif char in ')}]':\n                        # If stack is empty or brackets don't match, it's not balanced\n                        if not stack or stack.pop() != brackets_map[char]:\n                            return False\n                \n                # If stack is empty, all brackets were matched\n                return len(stack) == 0\n            ",
      "id": "4582c9b6-aba3-42da-b002-ab522196bc97"
    },
    {
      "name": "Infix to Postfix Conversion",
      "tags": [
        "stack",
        "expression",
        "conversion"
      ],
      "description": "The Infix to Postfix Conversion algorithm transforms an infix expression (standard mathematical notation with operators between operands) to postfix notation (operators follow their operands) using a stack to handle operator precedence and parentheses.",
      "complexity": {
        "time": "O(n)",
        "space": "O(n)"
      },
      "problem_patterns": [
        "Expression parsing and evaluation",
        "Compiler design problems",
        "Problems involving operator precedence"
      ],
      "leetcode_indicators": [
        "Expression evaluation",
        "Convert expression notation",
        "Calculator implementation"
      ],
      "implementation": "\n            def infix_to_postfix(expression):\n                # Define operator precedence\n                precedence = {'+': 1, '-': 1, '*': 2, '/': 2, '^': 3}\n                \n                # Initialize result and stack\n                result = []\n                stack = []\n                \n                # Process each character\n                for char in expression:\n                    # If character is an operand, add to result\n                    if char.isalnum():\n                        result.append(char)\n                    # If character is an opening bracket, push to stack\n                    elif char == '(':\n                        stack.append(char)\n                    # If character is a closing bracket, pop from stack until opening bracket\n                    elif char == ')':\n                        while stack and stack[-1] != '(':\n                            result.append(stack.pop())\n                        stack.pop()  # Remove the opening bracket\n                    # If character is an operator\n                    else:\n                        # Pop operators with higher or equal precedence\n                        while stack and stack[-1] != '(' and (stack[-1] in precedence) and (precedence.get(char, 0) <= precedence.get(stack[-1], 0)):\n                            result.append(stack.pop())\n                        stack.append(char)\n                \n                # Pop any remaining operators\n                while stack:\n                    result.append(stack.pop())\n                \n                # Join the result\n                return ''.join(result)\n            ",
      "id": "33aab26d-9078-4076-9bf7-1ac51e044f92"
    },
    {
      "name": "0/1 Knapsack",
      "tags": [
        "dynamic programming",
        "optimization",
        "combinatorial"
      ],
      "description": "The 0/1 Knapsack problem is a problem in combinatorial optimization: given a set of items, each with a weight and a value, determine which items to include in a collection so that the total weight is less than or equal to a given limit and the total value is as large as possible.",
      "complexity": {
        "time": "O(n*W)",
        "space": "O(n*W)"
      },
      "problem_patterns": [
        "Resource allocation with constraints",
        "Item selection to maximize value with weight constraint",
        "Problems involving yes/no decisions for each item"
      ],
      "leetcode_indicators": [
        "Maximize value with weight constraint",
        "Problems involving subset selection with constraints",
        "Target sum with specific items"
      ],
      "implementation": "\n                def knapsack_01(values, weights, capacity):\n                    n = len(values)\n                    dp = [[0 for _ in range(capacity + 1)] for _ in range(n + 1)]\n                    \n                    for i in range(1, n + 1):\n                        for w in range(capacity + 1):\n                            if weights[i-1] <= w:\n                                dp[i][w] = max(\n                                    values[i-1] + dp[i-1][w-weights[i-1]],  # Include item\n                                    dp[i-1][w]  # Exclude item\n                                )\n                            else:\n                                dp[i][w] = dp[i-1][w]  # Can't include, so exclude\n                    \n                    return dp[n][capacity]\n                ",
      "id": "1737df71-53bf-471a-9187-05dcb911d330"
    },
    {
      "name": "Longest Common Subsequence",
      "tags": [
        "dynamic programming",
        "string algorithm",
        "sequence comparison"
      ],
      "description": "The Longest Common Subsequence (LCS) algorithm finds the longest sequence that is present in both given sequences in the same order (not necessarily consecutive).",
      "complexity": {
        "time": "O(m*n)",
        "space": "O(m*n)"
      },
      "problem_patterns": [
        "String comparison and similarity",
        "Sequence alignment problems",
        "Edit distance variations"
      ],
      "leetcode_indicators": [
        "Find common subsequence between strings",
        "String similarity problems",
        "Problems involving sequence comparison",
        "Edit distance variations"
      ],
      "implementation": "\n                def lcs(text1, text2):\n                    m, n = len(text1), len(text2)\n                    dp = [[0 for _ in range(n + 1)] for _ in range(m + 1)]\n                    \n                    for i in range(1, m + 1):\n                        for j in range(1, n + 1):\n                            if text1[i-1] == text2[j-1]:\n                                dp[i][j] = dp[i-1][j-1] + 1\n                            else:\n                                dp[i][j] = max(dp[i-1][j], dp[i][j-1])\n                    \n                    return dp[m][n]\n                ",
      "id": "0cd38ecb-4364-4c2b-9f0f-40fba6ca38a3"
    },
    {
      "name": "Coin Change",
      "tags": [
        "dynamic programming",
        "greedy",
        "optimization"
      ],
      "description": "The Coin Change problem asks for the minimum number of coins needed to make a certain amount of change, given a set of coin denominations.",
      "complexity": {
        "time": "O(amount * n)",
        "space": "O(amount)"
      },
      "problem_patterns": [
        "Making change with minimum number of coins",
        "Problems involving combinations that sum to target",
        "Minimum resource allocation problems"
      ],
      "leetcode_indicators": [
        "Minimum coins to make change",
        "Ways to make sum with given numbers",
        "Problems involving counting combinations"
      ],
      "implementation": "\n                def coin_change(coins, amount):\n                    # Initialize dp array with amount+1 (representing infinity)\n                    dp = [amount + 1] * (amount + 1)\n                    dp[0] = 0\n                    \n                    for coin in coins:\n                        for i in range(coin, amount + 1):\n                            dp[i] = min(dp[i], dp[i - coin] + 1)\n                    \n                    return dp[amount] if dp[amount] <= amount else -1\n                ",
      "id": "684a0c2d-4962-46dd-83f5-d676b147f399"
    },
    {
      "name": "Knuth-Morris-Pratt (KMP)",
      "tags": [
        "string algorithm",
        "pattern matching",
        "substring search"
      ],
      "description": "The Knuth-Morris-Pratt algorithm searches for occurrences of a 'pattern' within a main 'text' by employing the observation that when a mismatch occurs, the pattern itself contains sufficient information to determine where the next match could begin, thus bypassing re-examination of previously matched characters.",
      "complexity": {
        "time": "O(n + m)",
        "space": "O(m)"
      },
      "problem_patterns": [
        "Efficient substring search",
        "Pattern matching in strings",
        "Text processing problems"
      ],
      "leetcode_indicators": [
        "Find all occurrences of pattern in text",
        "String matching problems",
        "Problems requiring efficient substring search"
      ],
      "implementation": "\n                def kmp_search(text, pattern):\n                    if not pattern:\n                        return 0  # Empty pattern matches at position 0\n                    \n                    # Preprocess: Compute the longest proper prefix which is also suffix array\n                    lps = [0] * len(pattern)\n                    compute_lps_array(pattern, lps)\n                    \n                    i, j = 0, 0  # i for text, j for pattern\n                    results = []\n                    \n                    while i < len(text):\n                        if pattern[j] == text[i]:\n                            i += 1\n                            j += 1\n                        \n                        if j == len(pattern):\n                            results.append(i - j)  # Found a match\n                            j = lps[j - 1]\n                        elif i < len(text) and pattern[j] != text[i]:\n                            if j != 0:\n                                j = lps[j - 1]\n                            else:\n                                i += 1\n                    \n                    return results\n\n                    def compute_lps_array(pattern, lps):\n                        length = 0\n                        i = 1\n                        \n                        while i < len(pattern):\n                            if pattern[i] == pattern[length]:\n                                length += 1\n                                lps[i] = length\n                                i += 1\n                            else:\n                                if length != 0:\n                                    length = lps[length - 1]\n                                else:\n                                    lps[i] = 0\n                                    i += 1\n                    ",
      "id": "2608eb30-4da5-4cf0-a0a2-40d1d72095a5"
    },
    {
      "name": "Rabin-Karp",
      "tags": [
        "string algorithm",
        "pattern matching",
        "hashing"
      ],
      "description": "The Rabin-Karp algorithm is a string-searching algorithm that uses hashing to find patterns in strings. It calculates a hash value for the pattern and for each possible substring of the text, then compares the hash values instead of comparing the strings character by character.",
      "complexity": {
        "time": "O(n + m)",
        "worst_time": "O(n*m)",
        "space": "O(1)"
      },
      "problem_patterns": [
        "Multiple pattern search",
        "Substring matching",
        "Plagiarism detection"
      ],
      "leetcode_indicators": [
        "String matching with hash function",
        "Multiple pattern search in text",
        "Substring search problems"
      ],
      "implementation": "\n                def rabin_karp(text, pattern):\n                    if not pattern:\n                        return 0\n                    \n                    # Prime number for hash calculation\n                    q = 101\n                    \n                    # Radix for the number system (ASCII)\n                    d = 256\n                    \n                    m, n = len(pattern), len(text)\n                    p = 0  # Hash value for pattern\n                    t = 0  # Hash value for text\n                    h = 1\n                    results = []\n                    \n                    # Calculate h = d^(m-1) % q\n                    for i in range(m - 1):\n                        h = (h * d) % q\n                    \n                    # Calculate initial hash values\n                    for i in range(m):\n                        p = (d * p + ord(pattern[i])) % q\n                        t = (d * t + ord(text[i])) % q\n                    \n                    # Slide pattern over text\n                    for i in range(n - m + 1):\n                        # Check hash values\n                        if p == t:\n                            # Check characters one by one\n                            match = True\n                            for j in range(m):\n                                if text[i + j] != pattern[j]:\n                                    match = False\n                                    break\n                            \n                            if match:\n                                results.append(i)\n                        \n                        # Calculate hash for next window\n                        if i < n - m:\n                            t = (d * (t - ord(text[i]) * h) + ord(text[i + m])) % q\n                            if t < 0:\n                                t += q\n                    \n                    return results\n                ",
      "id": "7d85f7bc-9f82-4c4a-be53-6a308d03fcc5"
    },
    {
      "name": "Longest Palindromic Substring",
      "tags": [
        "string algorithm",
        "dynamic programming"
      ],
      "description": "The Longest Palindromic Substring algorithm finds the longest substring within a string that is a palindrome (reads the same backward as forward).",
      "complexity": {
        "time": "O(n\u00b2)",
        "space": "O(1)"
      },
      "problem_patterns": [
        "Finding palindromes in strings",
        "String processing with symmetry",
        "Text analysis problems"
      ],
      "leetcode_indicators": [
        "Find longest palindrome in string",
        "Problems involving substring palindromes",
        "String symmetry problems"
      ],
      "implementation": "\n                def longest_palindromic_substring(s):\n                    if not s:\n                        return \"\"\n                    \n                    start = 0\n                    max_length = 1\n                    \n                    # Helper function to expand around center\n                    def expand_around_center(left, right):\n                        while left >= 0 and right < len(s) and s[left] == s[right]:\n                            left -= 1\n                            right += 1\n                        return right - left - 1\n                    \n                    for i in range(len(s)):\n                        # Expand for odd length palindromes\n                        odd_length = expand_around_center(i, i)\n                        \n                        # Expand for even length palindromes\n                        even_length = expand_around_center(i, i + 1)\n                        \n                        # Update if longer palindrome found\n                        length = max(odd_length, even_length)\n                        if length > max_length:\n                            max_length = length\n                            start = i - (length - 1) // 2\n                    \n                    return s[start:start + max_length]\n                ",
      "id": "6f67ce43-df8d-4d08-ab9b-5e4c087dca93"
    },
    {
      "name": "Binary Tree Traversal",
      "tags": [
        "tree algorithm",
        "data structure",
        "traversal"
      ],
      "description": "Binary Tree Traversal algorithms systematically visit each node in a binary tree. The three most common traversal methods are in-order (left-root-right), pre-order (root-left-right), and post-order (left-right-root).",
      "complexity": {
        "time": "O(n)",
        "space": "O(h)"
      },
      "problem_patterns": [
        "Tree processing in specific orders",
        "Converting tree to array representations",
        "Tree validation problems"
      ],
      "leetcode_indicators": [
        "Tree traversal problems",
        "Convert tree to array",
        "Problems requiring specific node visit order"
      ],
      "implementation": "\n                class TreeNode:\n                    def __init__(self, val=0, left=None, right=None):\n                        self.val = val\n                        self.left = left\n                        self.right = right\n\n                # In-order traversal\n                def inorder_traversal(root):\n                    result = []\n                    \n                    def dfs(node):\n                        if not node:\n                            return\n                        dfs(node.left)\n                        result.append(node.val)\n                        dfs(node.right)\n                    \n                    dfs(root)\n                    return result\n\n                # Pre-order traversal\n                def preorder_traversal(root):\n                    result = []\n                    \n                    def dfs(node):\n                        if not node:\n                            return\n                        result.append(node.val)\n                        dfs(node.left)\n                        dfs(node.right)\n                    \n                    dfs(root)\n                    return result\n\n                # Post-order traversal\n                def postorder_traversal(root):\n                    result = []\n                    \n                    def dfs(node):\n                        if not node:\n                            return\n                        dfs(node.left)\n                        dfs(node.right)\n                        result.append(node.val)\n                    \n                    dfs(root)\n                    return result\n                ",
      "id": "c4b7be12-cbf4-402f-aea0-b11b780d5cf7"
    },
    {
      "name": "Binary Search Tree Operations",
      "tags": [
        "tree algorithm",
        "binary search tree",
        "data structure"
      ],
      "description": "Binary Search Tree (BST) operations include insertion, deletion, and searching in a tree where for each node, all elements in the left subtree are less than the node's value, and all elements in the right subtree are greater.",
      "complexity": {
        "time": "O(h)",
        "space": "O(h)"
      },
      "problem_patterns": [
        "Efficient data structures for sorted data",
        "Problems requiring ordered data operations",
        "Tree construction and modification"
      ],
      "leetcode_indicators": [
        "Binary search tree problems",
        "Tree with ordered property",
        "Problems involving tree insertion/deletion"
      ],
      "implementation": "\n                class TreeNode:\n                        def __init__(self, val=0, left=None, right=None):\n                            self.val = val\n                            self.left = left\n                            self.right = right\n\n                        # Insert value into BST\n                        def insert(root, val):\n                            if not root:\n                                return TreeNode(val)\n                                        \n                            if val < root.val:\n                                root.left = insert(root.left, val)\n                            else:\n                                root.right = insert(root.right, val)\n                                        \n                            return root\n\n                        # Search for value in BST\n                        def search(root, val):\n                            if not root or root.val == val:\n                                return root\n                                        \n                            if val < root.val:\n                                return search(root.left, val)\n                            else:\n                                return search(root.right, val)\n\n                        # Delete value from BST\n                        def delete(root, val):\n                            if not root:\n                                return None\n                \n                            if val < root.val:\n                                root.left = delete(root.left, val)\n                            elif val > root.val:\n                                root.right = delete(root.right, val)\n                            else:\n                                # Node with only one child or no child\n                            if not root.left:\n                                return root.right\n                            elif not root.right:\n                                return root.left\n                    \n                            # Node with two children\n                            # Get inorder successor (smallest in right subtree)\n                            temp = find_min(root.right)\n                            root.val = temp.val\n                            root.right = delete(root.right, temp.val)\n                \n                            return root\n\n                        def find_min(node):\n                            current = node\n                            while current.left:\n                                current = current.left\n                            return current\n                        ",
      "id": "53b8d281-368a-42d2-8b66-e3c157b4b0ce"
    },
    {
      "name": "Lowest Common Ancestor",
      "tags": [
        "tree algorithm",
        "binary tree",
        "ancestor finding"
      ],
      "description": "The Lowest Common Ancestor (LCA) algorithm finds the lowest node in a tree that has both given nodes as descendants. A node can be a descendant of itself.",
      "complexity": {
        "time": "O(n)",
        "space": "O(h)"
      },
      "problem_patterns": [
        "Finding common ancestors in trees",
        "Relationship problems in hierarchical structures",
        "Tree navigation problems"
      ],
      "leetcode_indicators": [
        "Lowest common ancestor problems",
        "Tree node relationship questions",
        "Problems involving finding a common parent"
      ],
      "implementation": "\n                class TreeNode:\n                    def __init__(self, val=0, left=None, right=None):\n                        self.val = val\n                        self.left = left\n                        self.right = right\n\n                def lowest_common_ancestor(root, p, q):\n                    # Base case\n                    if not root or root == p or root == q:\n                        return root\n                    \n                    # Look for p and q in left and right subtrees\n                    left = lowest_common_ancestor(root.left, p, q)\n                    right = lowest_common_ancestor(root.right, p, q)\n                    \n                    # If both p and q are found, this node is the LCA\n                    if left and right:\n                        return root\n                    \n                    # Otherwise, return the non-null value\n                    return left if left else right\n                ",
      "id": "025193de-af47-4e55-b3ae-1dce2890bb0f"
    },
    {
      "name": "Queue Implementation",
      "tags": [
        "queue",
        "data structure",
        "FIFO"
      ],
      "description": "The Queue data structure follows First-In-First-Out (FIFO) principle. It supports two primary operations: enqueue (adding an element to the rear) and dequeue (removing the front element). Queues can be implemented using arrays, linked lists, or a combination of stacks.",
      "complexity": {
        "time": "O(1) for enqueue/dequeue operations",
        "space": "O(n)"
      },
      "problem_patterns": [
        "Problems requiring first-in-first-out processing",
        "Breadth-first search",
        "Task scheduling",
        "Buffer management"
      ],
      "leetcode_indicators": [
        "Level order traversal",
        "BFS problems",
        "First-come-first-serve processing"
      ],
      "implementation": "\n            # Array-based queue implementation (using a Python list)\n            class Queue:\n                def __init__(self):\n                    self.items = []\n                \n                def is_empty(self):\n                    return len(self.items) == 0\n                \n                def enqueue(self, item):\n                    self.items.append(item)\n                \n                def dequeue(self):\n                    if self.is_empty():\n                        raise IndexError(\"Dequeue from an empty queue\")\n                    return self.items.pop(0)\n                \n                def peek(self):\n                    if self.is_empty():\n                        raise IndexError(\"Peek from an empty queue\")\n                    return self.items[0]\n                \n                def size(self):\n                    return len(self.items)\n\n            # Linked list-based queue implementation\n            class Node:\n                def __init__(self, value):\n                    self.value = value\n                    self.next = None\n\n            class LinkedQueue:\n                def __init__(self):\n                    self.front = None\n                    self.rear = None\n                    self.size = 0\n                \n                def is_empty(self):\n                    return self.front is None\n                \n                def enqueue(self, value):\n                    new_node = Node(value)\n                    \n                    if self.is_empty():\n                        self.front = new_node\n                    else:\n                        self.rear.next = new_node\n                    \n                    self.rear = new_node\n                    self.size += 1\n                \n                def dequeue(self):\n                    if self.is_empty():\n                        raise IndexError(\"Dequeue from an empty queue\")\n                    \n                    value = self.front.value\n                    self.front = self.front.next\n                    \n                    # If queue becomes empty, update rear\n                    if self.front is None:\n                        self.rear = None\n                    \n                    self.size -= 1\n                    return value\n                \n                def peek(self):\n                    if self.is_empty():\n                        raise IndexError(\"Peek from an empty queue\")\n                    return self.front.value\n            ",
      "id": "3b535e56-30f1-4907-9332-fde55f04fb6b"
    },
    {
      "name": "Circular Queue Implementation",
      "tags": [
        "queue",
        "circular",
        "data structure"
      ],
      "description": "A Circular Queue (also called Ring Buffer) is an enhancement of the regular queue that efficiently uses space by wrapping around to the beginning when it reaches the end of the allocated space. It maintains two pointers: front and rear, and uses modulo arithmetic to handle the wrap-around.",
      "complexity": {
        "time": "O(1) for enqueue/dequeue operations",
        "space": "O(n)"
      },
      "problem_patterns": [
        "Fixed-size buffer management",
        "Stream processing",
        "Problems requiring circular data structures",
        "Round-robin scheduling"
      ],
      "leetcode_indicators": [
        "Design circular queue",
        "Circular buffer",
        "Problems involving wraparound indexing"
      ],
      "implementation": "\n            class CircularQueue:\n                def __init__(self, capacity):\n                    self.capacity = capacity\n                    self.queue = [None] * capacity\n                    self.front = self.size = 0\n                    self.rear = capacity - 1\n                \n                def is_full(self):\n                    return self.size == self.capacity\n                \n                def is_empty(self):\n                    return self.size == 0\n                \n                def enqueue(self, item):\n                    if self.is_full():\n                        raise IndexError(\"Queue is full\")\n                    \n                    self.rear = (self.rear + 1) % self.capacity\n                    self.queue[self.rear] = item\n                    self.size += 1\n                \n                def dequeue(self):\n                    if self.is_empty():\n                        raise IndexError(\"Dequeue from an empty queue\")\n                    \n                    item = self.queue[self.front]\n                    self.front = (self.front + 1) % self.capacity\n                    self.size -= 1\n                    return item\n                \n                def peek(self):\n                    if self.is_empty():\n                        raise IndexError(\"Peek from an empty queue\")\n                    return self.queue[self.front]\n            ",
      "id": "97f60703-9373-431a-b4e8-446cfa1fc569"
    },
    {
      "name": "Priority Queue Implementation",
      "tags": [
        "queue",
        "priority",
        "heap",
        "data structure"
      ],
      "description": "A Priority Queue is an abstract data type similar to a regular queue but where each element has a priority. Elements with higher priority are dequeued before elements with lower priority. It can be implemented using a heap, a binary search tree, or an ordered array.",
      "complexity": {
        "time": "O(log n) for insertion/deletion with heap implementation",
        "space": "O(n)"
      },
      "problem_patterns": [
        "Problems requiring elements to be processed based on priority",
        "Scheduling algorithms",
        "Graph algorithms like Dijkstra's",
        "Huffman coding"
      ],
      "leetcode_indicators": [
        "Top-k elements",
        "Minimum cost problems",
        "Scheduling problems",
        "Merge k sorted lists"
      ],
      "implementation": "\n            import heapq\n\n            # Priority Queue using Python's heapq (min-heap)\n            class PriorityQueue:\n                def __init__(self):\n                    self.elements = []\n                \n                def is_empty(self):\n                    return len(self.elements) == 0\n                \n                def put(self, item, priority):\n                    # For min-heap, use priority as the first element\n                    heapq.heappush(self.elements, (priority, item))\n                \n                def get(self):\n                    if self.is_empty():\n                        raise IndexError(\"Dequeue from an empty priority queue\")\n                    return heapq.heappop(self.elements)[1]\n                \n                def peek(self):\n                    if self.is_empty():\n                        raise IndexError(\"Peek from an empty priority queue\")\n                    return self.elements[0][1]\n                \n                def size(self):\n                    return len(self.elements)\n\n            # Custom implementation of a Priority Queue using a binary heap\n            class CustomPriorityQueue:\n                def __init__(self, is_min_heap=True):\n                    self.heap = []\n                    self.is_min_heap = is_min_heap\n                \n                def size(self):\n                    return len(self.heap)\n                \n                def is_empty(self):\n                    return self.size() == 0\n                \n                def get_parent(self, i):\n                    return (i - 1) // 2\n                \n                def get_left_child(self, i):\n                    return 2 * i + 1\n                \n                def get_right_child(self, i):\n                    return 2 * i + 2\n                \n                def has_parent(self, i):\n                    return self.get_parent(i) >= 0\n                \n                def has_left_child(self, i):\n                    return self.get_left_child(i) < self.size()\n                \n                def has_right_child(self, i):\n                    return self.get_right_child(i) < self.size()\n                \n                def compare(self, a, b):\n                    if self.is_min_heap:\n                        return a < b\n                    return a > b\n                \n                def swap(self, i, j):\n                    self.heap[i], self.heap[j] = self.heap[j], self.heap[i]\n                \n                def peek(self):\n                    if self.is_empty():\n                        raise IndexError(\"Peek from an empty priority queue\")\n                    return self.heap[0][1]\n                \n                def push(self, priority, item):\n                    self.heap.append((priority, item))\n                    self.heapify_up(self.size() - 1)\n                \n                def pop(self):\n                    if self.is_empty():\n                        raise IndexError(\"Pop from an empty priority queue\")\n                    \n                    item = self.heap[0][1]\n                    self.heap[0] = self.heap[-1]\n                    self.heap.pop()\n                    if self.size() > 0:\n                        self.heapify_down(0)\n                    return item\n                \n                def heapify_up(self, index):\n                    while (self.has_parent(index) and \n                        self.compare(self.heap[index][0], self.heap[self.get_parent(index)][0])):\n                        self.swap(index, self.get_parent(index))\n                        index = self.get_parent(index)\n                \n                def heapify_down(self, index):\n                    smallest = index\n                    \n                    if (self.has_left_child(index) and \n                        self.compare(self.heap[self.get_left_child(index)][0], self.heap[smallest][0])):\n                        smallest = self.get_left_child(index)\n                    \n                    if (self.has_right_child(index) and \n                        self.compare(self.heap[self.get_right_child(index)][0], self.heap[smallest][0])):\n                        smallest = self.get_right_child(index)\n                    \n                    if smallest != index:\n                        self.swap(index, smallest)\n                        self.heapify_down(smallest)\n            ",
      "id": "7886f807-a71a-4fa5-bc83-efb64a4bd472"
    },
    {
      "name": "Hash Table Implementation",
      "tags": [
        "hash table",
        "data structure",
        "key-value"
      ],
      "description": "A Hash Table is a data structure that implements an associative array abstract data type, a structure that can map keys to values. It uses a hash function to compute an index into an array of buckets or slots, from which the desired value can be found.",
      "complexity": {
        "time": "O(1) average for insert/search/delete, O(n) worst case",
        "space": "O(n)"
      },
      "problem_patterns": [
        "Fast lookup, insertion, and deletion",
        "Caching and memoization",
        "Counting occurrences",
        "Two-sum type problems"
      ],
      "leetcode_indicators": [
        "Two sum",
        "Problems requiring fast lookup",
        "Frequency counting",
        "Symbol tables"
      ],
      "implementation": "\n            class HashNode:\n                def __init__(self, key, value):\n                    self.key = key\n                    self.value = value\n                    self.next = None\n\n            class HashTable:\n                def __init__(self, size=10):\n                    # Initialize the hash table with empty buckets\n                    self.size = size\n                    self.buckets = [None] * size\n                    self.count = 0\n                \n                def _hash(self, key):\n                    # Simple hash function\n                    if isinstance(key, int):\n                        return key % self.size\n                    # If key is a string, sum the ASCII values\n                    if isinstance(key, str):\n                        total = 0\n                        for char in key:\n                            total += ord(char)\n                        return total % self.size\n                    # For other types, use their hash\n                    return hash(key) % self.size\n                \n                def set(self, key, value):\n                    # Find the bucket\n                    index = self._hash(key)\n                    node = self.buckets[index]\n                    \n                    # Check if key already exists\n                    while node:\n                        if node.key == key:\n                            node.value = value  # Update value\n                            return\n                        node = node.next\n                    \n                    # Key not found, create new node\n                    new_node = HashNode(key, value)\n                    new_node.next = self.buckets[index]\n                    self.buckets[index] = new_node\n                    self.count += 1\n                    \n                    # Resize if load factor exceeds threshold\n                    if self.count > self.size * 0.7:\n                        self._resize(self.size * 2)\n                \n                def get(self, key):\n                    # Find the bucket\n                    index = self._hash(key)\n                    node = self.buckets[index]\n                    \n                    # Look for the key\n                    while node:\n                        if node.key == key:\n                            return node.value\n                        node = node.next\n                    \n                    # Key not found\n                    return None\n                \n                def delete(self, key):\n                    # Find the bucket\n                    index = self._hash(key)\n                    node = self.buckets[index]\n                    prev = None\n                    \n                    # Look for the key\n                    while node and node.key != key:\n                        prev = node\n                        node = node.next\n                    \n                    # If key found\n                    if node:\n                        if prev:\n                            prev.next = node.next\n                        else:\n                            self.buckets[index] = node.next\n                        self.count -= 1\n                        return True\n                    \n                    # Key not found\n                    return False\n                \n                def contains(self, key):\n                    return self.get(key) is not None\n                \n                def _resize(self, new_size):\n                    old_buckets = self.buckets\n                    self.size = new_size\n                    self.buckets = [None] * new_size\n                    self.count = 0\n                    \n                    # Rehash all entries\n                    for head in old_buckets:\n                        node = head\n                        while node:\n                            self.set(node.key, node.value)\n                            node = node.next\n            ",
      "id": "5dcc3275-2715-4121-acb8-b6baef4079da"
    },
    {
      "name": "Collision Resolution with Chaining",
      "tags": [
        "hash table",
        "collision resolution",
        "linked list"
      ],
      "description": "Collision Resolution with Chaining is a technique used in hash tables to handle multiple keys that hash to the same index. In chaining, each bucket (array index) contains a linked list of all key-value pairs whose keys hash to that index, allowing multiple entries to exist at the same location.",
      "complexity": {
        "time": "O(1 + \u03b1) average for operations, where \u03b1 is the load factor",
        "space": "O(n + m) where n is the number of entries and m is the number of buckets"
      },
      "problem_patterns": [
        "Implementing hash tables with predictable performance",
        "Handling hash collisions",
        "Problems requiring separate chaining"
      ],
      "leetcode_indicators": [
        "Design hash map",
        "Design hash set",
        "Problems involving custom hash table implementation"
      ],
      "implementation": "\n            class HashTableWithChaining:\n                def __init__(self, size=10):\n                    self.size = size\n                    self.table = [[] for _ in range(size)]  # List of lists for chaining\n                \n                def _hash(self, key):\n                    # Simple hash function\n                    if isinstance(key, int):\n                        return key % self.size\n                    # For strings, sum the ASCII values\n                    if isinstance(key, str):\n                        return sum(ord(char) for char in key) % self.size\n                    # For other types, use their hash\n                    return hash(key) % self.size\n                \n                def insert(self, key, value):\n                    # Find the bucket\n                    index = self._hash(key)\n                    bucket = self.table[index]\n                    \n                    # Check if key already exists\n                    for i, (k, v) in enumerate(bucket):\n                        if k == key:\n                            bucket[i] = (key, value)  # Update value\n                            return\n                    \n                    # Key not found, add new entry\n                    bucket.append((key, value))\n                \n                def get(self, key):\n                    # Find the bucket\n                    index = self._hash(key)\n                    bucket = self.table[index]\n                    \n                    # Look for the key\n                    for k, v in bucket:\n                        if k == key:\n                            return v\n                    \n                    # Key not found\n                    return None\n                \n                def remove(self, key):\n                    # Find the bucket\n                    index = self._hash(key)\n                    bucket = self.table[index]\n                    \n                    # Look for the key and remove it\n                    for i, (k, v) in enumerate(bucket):\n                        if k == key:\n                            del bucket[i]\n                            return True\n                    \n                    # Key not found\n                    return False\n                \n                def display(self):\n                    for i, bucket in enumerate(self.table):\n                        if bucket:  # Only show non-empty buckets\n                            print(f\"Bucket {i}: {bucket}\")\n            ",
      "id": "e61afa20-c5f9-4ddd-bd85-fb2b48c8cfa1"
    },
    {
      "name": "Open Addressing (Linear Probing)",
      "tags": [
        "hash table",
        "collision resolution",
        "open addressing"
      ],
      "description": "Open Addressing is a collision resolution technique where all elements are stored in the hash table itself (no external data structures). Linear Probing is one method of open addressing where, if a collision occurs, we sequentially search for the next available slot.",
      "complexity": {
        "time": "O(1) average for operations with low load factor, O(n) worst case",
        "space": "O(n)"
      },
      "problem_patterns": [
        "Implementing memory-efficient hash tables",
        "Problems requiring cache efficiency",
        "Situations where chaining is impractical"
      ],
      "leetcode_indicators": [
        "Design hash map with space constraints",
        "Problems involving linear probing",
        "Cache-friendly hash table design"
      ],
      "implementation": "\n            class HashTableWithLinearProbing:\n                def __init__(self, size=10):\n                    self.size = size\n                    self.keys = [None] * size\n                    self.values = [None] * size\n                    self.tombstone = object()  # Special marker for deleted entries\n                    self.count = 0\n                \n                def _hash(self, key):\n                    # Simple hash function\n                    if isinstance(key, int):\n                        return key % self.size\n                    # For strings, sum the ASCII values\n                    if isinstance(key, str):\n                        return sum(ord(char) for char in key) % self.size\n                    # For other types, use their hash\n                    return hash(key) % self.size\n                \n                def _get_index(self, key):\n                    # Find the position for a key using linear probing\n                    start_index = self._hash(key)\n                    \n                    # Linear probe until we find the key, an empty slot, or visit all positions\n                    for i in range(self.size):\n                        index = (start_index + i\n                        ) % self.size\n                        \n                        # Found the key\n                        if self.keys[index] == key:\n                            return index\n                        \n                        # Found an empty slot\n                        if self.keys[index] is None:\n                            return -1\n                    \n                    # Hash table is full and key not found\n                    return -1\n                \n                def _find_slot(self, key):\n                    # Find the position to insert a key using linear probing\n                    start_index = self._hash(key)\n                    \n                    # Linear probe until we find the key, an empty slot, or a tombstone\n                    for i in range(self.size):\n                        index = (start_index + i) % self.size\n                        \n                        # Found the key\n                        if self.keys[index] == key:\n                            return index\n                        \n                        # Found an empty slot or tombstone\n                        if self.keys[index] is None or self.keys[index] is self.tombstone:\n                            return index\n                    \n                    # Hash table is full\n                    return -1\n                \n                def put(self, key, value):\n                    # Don't allow None as a key\n                    if key is None:\n                        raise ValueError(\"None is not allowed as a key\")\n                    \n                    # If load factor is too high, resize\n                    if self.count >= self.size * 0.7:\n                        self._resize(self.size * 2)\n                    \n                    # Find slot for insertion\n                    index = self._find_slot(key)\n                    \n                    # If hash table is full\n                    if index == -1:\n                        self._resize(self.size * 2)\n                        index = self._find_slot(key)\n                    \n                    # Check if this is a new entry\n                    is_new = self.keys[index] is None or self.keys[index] is self.tombstone\n                    \n                    # Insert key-value pair\n                    self.keys[index] = key\n                    self.values[index] = value\n                    \n                    # Increment count for new entries\n                    if is_new:\n                        self.count += 1\n                \n                def get(self, key):\n                    index = self._get_index(key)\n                    \n                    # Key not found\n                    if index == -1:\n                        return None\n                    \n                    # Return value\n                    return self.values[index]\n                \n                def remove(self, key):\n                    index = self._get_index(key)\n                    \n                    # Key not found\n                    if index == -1:\n                        return False\n                    \n                    # Mark as deleted with tombstone\n                    self.keys[index] = self.tombstone\n                    self.values[index] = None\n                    self.count -= 1\n                    return True\n                \n                def _resize(self, new_size):\n                    old_keys = self.keys\n                    old_values = self.values\n                    \n                    # Create new arrays\n                    self.size = new_size\n                    self.keys = [None] * new_size\n                    self.values = [None] * new_size\n                    self.count = 0\n                    \n                    # Rehash all entries\n                    for i in range(len(old_keys)):\n                        if old_keys[i] is not None and old_keys[i] is not self.tombstone:\n                            self.put(old_keys[i], old_values[i])\n            ",
      "id": "658d2474-8278-4935-be58-d63806708637"
    },
    {
      "name": "Trie (Prefix Tree)",
      "tags": [
        "data structure",
        "tree",
        "string",
        "prefix",
        "search"
      ],
      "description": "A Trie is a tree-like data structure used to store a dynamic set of strings. Tries are efficient for prefix-based operations and are commonly used for fast retrieval of keys in a dataset of strings. Unlike a binary search tree, no node in the trie stores the key associated with that node; instead, its position in the tree defines the key with which it is associated.",
      "complexity": {
        "time": "O(m) for insert/search/delete where m is the length of the key",
        "space": "O(n * m) where n is the number of keys and m is the key length"
      },
      "problem_patterns": [
        "Dictionary implementations",
        "Prefix searching",
        "Autocomplete systems",
        "Spell checkers",
        "IP routing (longest prefix matching)"
      ],
      "leetcode_indicators": [
        "Word dictionary implementation",
        "Problems involving prefix matching",
        "Add and Search Word",
        "Implement Trie (Prefix Tree)",
        "Word Search II"
      ],
      "implementation": "\n        class TrieNode:\n            def __init__(self):\n                self.children = {}\n                self.is_end_of_word = False\n\n        class Trie:\n            def __init__(self):\n                self.root = TrieNode()\n            \n            def insert(self, word):\n                node = self.root\n                for char in word:\n                    if char not in node.children:\n                        node.children[char] = TrieNode()\n                    node = node.children[char]\n                node.is_end_of_word = True\n            \n            def search(self, word):\n                node = self.root\n                for char in word:\n                    if char not in node.children:\n                        return False\n                    node = node.children[char]\n                return node.is_end_of_word\n            \n            def starts_with(self, prefix):\n                node = self.root\n                for char in prefix:\n                    if char not in node.children:\n                        return False\n                    node = node.children[char]\n                return True\n            \n            def delete(self, word):\n                def _delete_helper(node, word, index):\n                    # If we've reached the end of the word\n                    if index == len(word):\n                        # This node is no longer the end of a word\n                        if node.is_end_of_word:\n                            node.is_end_of_word = False\n                            \n                        # Return True if this node can be deleted (has no children and is not end of another word)\n                        return len(node.children) == 0 and not node.is_end_of_word\n                    \n                    char = word[index]\n                    if char not in node.children:\n                        return False  # Word not in trie\n                    \n                    should_delete_child = _delete_helper(node.children[char], word, index + 1)\n                    \n                    # If child can be deleted, remove it\n                    if should_delete_child:\n                        del node.children[char]\n                        \n                    # Current node can be deleted if it has no children and is not end of another word\n                    return len(node.children) == 0 and not node.is_end_of_word\n                \n                _delete_helper(self.root, word, 0)\n        ",
      "id": "307b0a77-f0ad-43ab-91cf-00eed32f8480"
    },
    {
      "name": "Segment Tree",
      "tags": [
        "data structure",
        "tree",
        "range queries",
        "interval tree"
      ],
      "description": "A Segment Tree is a tree data structure for storing intervals or segments. It allows querying which of the stored segments contain a given point. It is, in principle, a static structure; that is, it's a structure that cannot be modified once it's built. A segment tree for a set of n intervals uses O(n log n) storage and can be built in O(n log n) time. Segment trees support range queries and updates in O(log n) time.",
      "complexity": {
        "time": "O(n log n) to build, O(log n) for range query and update",
        "space": "O(n)"
      },
      "problem_patterns": [
        "Range sum/min/max queries",
        "Range update operations",
        "Problems requiring efficient interval operations",
        "Finding the minimum/maximum in a range",
        "Counting number of elements in a range"
      ],
      "leetcode_indicators": [
        "Range sum query",
        "Finding minimum/maximum in a range",
        "Problems involving interval modifications and queries",
        "Problems requiring efficient range operations"
      ],
      "implementation": "\n        class SegmentTree:\n            def __init__(self, arr):\n                self.n = len(arr)\n                # The size of the segment tree array\n                self.tree = [0] * (4 * self.n)\n                if self.n > 0:\n                    self._build_tree(arr, 0, 0, self.n - 1)\n            \n            def _build_tree(self, arr, node_idx, start, end):\n                # Leaf node\n                if start == end:\n                    self.tree[node_idx] = arr[start]\n                    return\n                \n                mid = (start + end) // 2\n                # Build left subtree\n                self._build_tree(arr, 2 * node_idx + 1, start, mid)\n                # Build right subtree\n                self._build_tree(arr, 2 * node_idx + 2, mid + 1, end)\n                # Internal node will have the sum of both its children\n                self.tree[node_idx] = self.tree[2 * node_idx + 1] + self.tree[2 * node_idx + 2]\n            \n            def query(self, start, end):\n                if start < 0 or end >= self.n or start > end:\n                    raise ValueError(\"Invalid range\")\n                return self._query(0, 0, self.n - 1, start, end)\n            \n            def _query(self, node_idx, node_start, node_end, query_start, query_end):\n                # If segment of this node is completely outside the query range\n                if query_end < node_start or query_start > node_end:\n                    return 0\n                \n                # If segment of this node is completely inside the query range\n                if node_start >= query_start and node_end <= query_end:\n                    return self.tree[node_idx]\n                \n                # If segment of this node is partially inside and partially outside the query range\n                mid = (node_start + node_end) // 2\n                left_sum = self._query(2 * node_idx + 1, node_start, mid, query_start, query_end)\n                right_sum = self._query(2 * node_idx + 2, mid + 1, node_end, query_start, query_end)\n                return left_sum + right_sum\n            \n            def update(self, index, value):\n                if index < 0 or index >= self.n:\n                    raise ValueError(\"Invalid index\")\n                self._update(0, 0, self.n - 1, index, value)\n            \n            def _update(self, node_idx, node_start, node_end, index, value):\n                # Leaf node: update the value\n                if node_start == node_end:\n                    self.tree[node_idx] = value\n                    return\n                \n                mid = (node_start + node_end) // 2\n                if index <= mid:\n                    # Update left subtree\n                    self._update(2 * node_idx + 1, node_start, mid, index, value)\n                else:\n                    # Update right subtree\n                    self._update(2 * node_idx + 2, mid + 1, node_end, index, value)\n                \n                # Update the current node based on its children\n                self.tree[node_idx] = self.tree[2 * node_idx + 1] + self.tree[2 * node_idx + 2]\n        ",
      "id": "105dd833-9ba5-4cf2-8710-f5d6dd8c27f5"
    },
    {
      "name": "Union Find (Disjoint Set)",
      "tags": [
        "data structure",
        "graph",
        "disjoint set",
        "connectivity"
      ],
      "description": "Union Find is a data structure that tracks a set of elements partitioned into a number of disjoint (non-overlapping) subsets. It provides near-constant-time operations to add new sets, merge existing sets, and determine whether elements are in the same set. Union Find is particularly useful for Kruskal's algorithm and for tracking connected components in graphs.",
      "complexity": {
        "time": "O(\u03b1(n)) for find and union operations, where \u03b1(n) is the inverse Ackermann function",
        "space": "O(n)"
      },
      "problem_patterns": [
        "Finding connected components in a graph",
        "Detecting cycles in an undirected graph",
        "Minimum spanning tree algorithms (Kruskal's)",
        "Network connectivity",
        "Least common ancestor in trees"
      ],
      "leetcode_indicators": [
        "Problems involving graph connectivity",
        "Friend circles",
        "Number of connected components",
        "Redundant connection",
        "Account merging"
      ],
      "implementation": "\n        class UnionFind:\n            def __init__(self, n):\n                # Initially, each element is its own parent/representative\n                self.parent = list(range(n))\n                # Rank is used for union by rank optimization\n                self.rank = [0] * n\n                # Number of disjoint sets\n                self.count = n\n            \n            def find(self, x):\n                # Path compression: make every examined node point directly to the root\n                if self.parent[x] != x:\n                    self.parent[x] = self.find(self.parent[x])\n                return self.parent[x]\n            \n            def union(self, x, y):\n                # Find the roots of x and y\n                root_x = self.find(x)\n                root_y = self.find(y)\n                \n                # If x and y are already in the same set\n                if root_x == root_y:\n                    return False\n                \n                # Union by rank: attach smaller rank tree under root of higher rank tree\n                if self.rank[root_x] < self.rank[root_y]:\n                    self.parent[root_x] = root_y\n                elif self.rank[root_x] > self.rank[root_y]:\n                    self.parent[root_y] = root_x\n                else:\n                    # If ranks are same, make one as root and increment its rank\n                    self.parent[root_y] = root_x\n                    self.rank[root_x] += 1\n                \n                # Decrease the count of disjoint sets\n                self.count -= 1\n                return True\n            \n            def is_connected(self, x, y):\n                return self.find(x) == self.find(y)\n            \n            def get_count(self):\n                return self.count\n        ",
      "id": "1aa33ca1-ec5f-4f8c-8dda-c570bf9ba578"
    },
    {
      "name": "A* Search Algorithm",
      "tags": [
        "graph algorithm",
        "pathfinding",
        "heuristic",
        "search"
      ],
      "description": "A* (pronounced 'A star') is a pathfinding algorithm that finds the shortest path between two nodes. It uses a heuristic function to guide the search, making it more efficient than Dijkstra's algorithm in many cases. A* evaluates nodes by combining the cost to reach the node and the estimated cost to reach the goal. It's widely used in games, robotics, and navigation systems.",
      "complexity": {
        "time": "O(E) in the worst case, where E is the number of edges, but typically much better with a good heuristic",
        "space": "O(V), where V is the number of vertices"
      },
      "problem_patterns": [
        "Shortest path finding with heuristics",
        "Maze solving",
        "Navigation in games and robotics",
        "Path planning with obstacles",
        "Routing algorithms with additional constraints"
      ],
      "leetcode_indicators": [
        "Shortest path problems with specific constraints",
        "Problems requiring path optimization with heuristics",
        "Grid-based pathfinding"
      ],
      "implementation": "\n        import heapq\n\n        def a_star(graph, start, goal, heuristic):\n            # Open set is a priority queue of nodes to explore\n            # Each element is (f_score, node) where f_score = g_score + heuristic\n            # g_score is the cost from start to node\n            # f_score is the estimated cost from start to goal through node\n            open_set = [(0 + heuristic(start, goal), start)]\n            \n            # g_score[n] is the cost of the cheapest path from start to n\n            g_score = {start: 0}\n            \n            # came_from[n] is the node immediately preceding n on the cheapest path\n            came_from = {}\n            \n            while open_set:\n                # Get the node with lowest f_score\n                current_f, current = heapq.heappop(open_set)\n                \n                # If we've reached the goal, reconstruct the path\n                if current == goal:\n                    path = []\n                    while current in came_from:\n                        path.append(current)\n                        current = came_from[current]\n                    path.append(start)\n                    path.reverse()\n                    return path\n                \n                # Explore neighbors\n                for neighbor, weight in graph[current].items():\n                    # Tentative g_score is the cost from start to neighbor through current\n                    tentative_g_score = g_score[current] + weight\n                    \n                    # If this path to neighbor is better than any previous one, record it\n                    if neighbor not in g_score or tentative_g_score < g_score[neighbor]:\n                        came_from[neighbor] = current\n                        g_score[neighbor] = tentative_g_score\n                        f_score = tentative_g_score + heuristic(neighbor, goal)\n                        heapq.heappush(open_set, (f_score, neighbor))\n            \n            # If we get here, there's no path from start to goal\n            return None\n\n        # Example heuristic for a grid-based graph (Manhattan distance)\n        def manhattan_distance(a, b):\n            return abs(a[0] - b[0]) + abs(a[1] - b[1])\n        ",
      "id": "56b598c0-b372-4147-8bdc-cbf09521b646"
    },
    {
      "name": "Bellman-Ford Algorithm",
      "tags": [
        "graph algorithm",
        "shortest path",
        "negative weight",
        "dynamic programming"
      ],
      "description": "The Bellman-Ford algorithm finds the shortest paths from a single source vertex to all other vertices in a weighted graph. Unlike Dijkstra's algorithm, Bellman-Ford can handle graphs with negative weight edges. It also detects negative weight cycles, which are cycles whose edges sum to a negative value. The algorithm relaxes all edges V-1 times, where V is the number of vertices.",
      "complexity": {
        "time": "O(V * E) where V is the number of vertices and E is the number of edges",
        "space": "O(V)"
      },
      "problem_patterns": [
        "Finding shortest paths with negative weights",
        "Detecting negative cycles in graphs",
        "Network routing",
        "Currency exchange and arbitrage detection",
        "Dynamic programming on graphs"
      ],
      "leetcode_indicators": [
        "Shortest path problems with negative weights",
        "Problems requiring detection of negative cycles",
        "Network delay with possible negative costs"
      ],
      "implementation": "\n        def bellman_ford(graph, source):\n            # Initialize distances\n            distances = {vertex: float('infinity') for vertex in graph}\n            distances[source] = 0\n            \n            # Store predecessors for path reconstruction\n            predecessors = {vertex: None for vertex in graph}\n            \n            # Get all vertices\n            vertices = list(graph.keys())\n            \n            # Relax all edges |V| - 1 times\n            for _ in range(len(vertices) - 1):\n                for u in graph:\n                    for v, weight in graph[u].items():\n                        if distances[u] != float('infinity') and distances[u] + weight < distances[v]:\n                            distances[v] = distances[u] + weight\n                            predecessors[v] = u\n            \n            # Check for negative weight cycles\n            # If we can still relax edges, then we have a negative cycle\n            negative_cycle = False\n            for u in graph:\n                for v, weight in graph[u].items():\n                    if distances[u] != float('infinity') and distances[u] + weight < distances[v]:\n                        negative_cycle = True\n                        break\n            \n            return distances, predecessors, negative_cycle\n\n        def reconstruct_path(predecessors, source, destination):\n            path = []\n            current = destination\n            \n            while current != source:\n                if current is None:\n                    return None  # No path exists\n                path.append(current)\n                current = predecessors[current]\n            \n            path.append(source)\n            path.reverse()\n            return path\n        ",
      "id": "ae0775d5-71c3-41f4-9fb6-d7316762d1d6"
    },
    {
      "name": "Floyd-Warshall Algorithm",
      "tags": [
        "graph algorithm",
        "all-pairs shortest path",
        "dynamic programming"
      ],
      "description": "The Floyd-Warshall algorithm finds the shortest paths between all pairs of vertices in a weighted graph. It works with positive or negative edge weights and can detect negative cycles. The algorithm uses dynamic programming to gradually improve an estimate on the shortest path between two vertices by including intermediate vertices.",
      "complexity": {
        "time": "O(V\u00b3) where V is the number of vertices",
        "space": "O(V\u00b2)"
      },
      "problem_patterns": [
        "Finding shortest paths between all pairs of vertices",
        "Transitive closure of directed graphs",
        "Detecting negative cycles",
        "Problems requiring the shortest distance between any two points"
      ],
      "leetcode_indicators": [
        "All-pairs shortest path problems",
        "Problems requiring shortest paths between multiple sources and destinations",
        "Network connectivity with shortest path requirement",
        "Graph diameter calculation"
      ],
      "implementation": "\n        def floyd_warshall(graph):\n            # Number of vertices\n            n = len(graph)\n            \n            # Initialize distance matrix\n            # dist[i][j] will be the shortest distance from vertex i to j\n            dist = [row[:] for row in graph]  # Create a copy of the graph\n            \n            # Initialize path reconstruction matrix\n            # next_vertex[i][j] will be the next vertex on the path from i to j\n            next_vertex = [[j if graph[i][j] != float('inf') and i != j else None for j in range(n)] for i in range(n)]\n            \n            # Main algorithm: consider each vertex as an intermediate\n            for k in range(n):\n                for i in range(n):\n                    for j in range(n):\n                        if dist[i][k] != float('inf') and dist[k][j] != float('inf') and dist[i][k] + dist[k][j] < dist[i][j]:\n                            dist[i][j] = dist[i][k] + dist[k][j]\n                            next_vertex[i][j] = next_vertex[i][k]\n            \n            # Check for negative cycles\n            has_negative_cycle = False\n            for i in range(n):\n                if dist[i][i] < 0:\n                    has_negative_cycle = True\n                    break\n            \n            return dist, next_vertex, has_negative_cycle\n\n        def reconstruct_path(next_vertex, u, v):\n            # If there's no path\n            if next_vertex[u][v] is None:\n                return []\n            \n            path = [u]\n            while u != v:\n                u = next_vertex[u][v]\n                path.append(u)\n            \n            return path\n        ",
      "id": "260820a3-e978-4bf4-ae0e-b89b6f8fd104"
    },
    {
      "name": "Two Pointers Technique",
      "tags": [
        "algorithm technique",
        "array",
        "string",
        "optimization"
      ],
      "description": "The Two Pointers technique is an algorithmic approach that uses two pointers to iterate through a data structure (usually an array or linked list). The pointers can move toward each other, in the same direction at different speeds, or start at different positions. This technique is often used to search for pairs, triplets, or subarrays with certain properties, and it typically reduces the time complexity from O(n\u00b2) to O(n).",
      "complexity": {
        "time": "O(n) in most cases",
        "space": "O(1)"
      },
      "problem_patterns": [
        "Finding pairs with a target sum in a sorted array",
        "Detecting palindromes",
        "Removing duplicates from sorted arrays",
        "Finding the longest substring without repeating characters",
        "Container with most water problem",
        "Three sum problem"
      ],
      "leetcode_indicators": [
        "Two pointers",
        "Problems involving sorted arrays",
        "Finding pairs/triplets with specific sum",
        "Problems with phrases like 'find a pair'",
        "Container with most water"
      ],
      "implementation": "\n        # Example 1: Two sum in sorted array\n        def two_sum_sorted(nums, target):\n            left, right = 0, len(nums) - 1\n            \n            while left < right:\n                current_sum = nums[left] + nums[right]\n                \n                if current_sum == target:\n                    return [left, right]\n                elif current_sum < target:\n                    left += 1\n                else:\n                    right -= 1\n            \n            return []  # No solution\n\n        # Example 2: Remove duplicates from sorted array\n        def remove_duplicates(nums):\n            if not nums:\n                return 0\n            \n            # Position to place the next non-duplicate\n            write_pointer = 1\n            \n            # Iterate through the array\n            for read_pointer in range(1, len(nums)):\n                # If current element is different from the previous one\n                if nums[read_pointer] != nums[read_pointer - 1]:\n                    # Place it at the write_pointer position\n                    nums[write_pointer] = nums[read_pointer]\n                    write_pointer += 1\n            \n            return write_pointer  # Length of the array without duplicates\n\n        # Example 3: Check if string is palindrome (ignoring non-alphanumeric)\n        def is_palindrome(s):\n            # Convert to lowercase and filter out non-alphanumeric characters\n            s = ''.join(c.lower() for c in s if c.isalnum())\n            \n            left, right = 0, len(s) - 1\n            while left < right:\n                if s[left] != s[right]:\n                    return False\n                left += 1\n                right -= 1\n            \n            return True\n        ",
      "id": "c9a11e86-cd4a-47b8-92eb-1ac4c7ca44a3"
    },
    {
      "name": "Monotonic Stack/Queue",
      "tags": [
        "data structure",
        "stack",
        "queue",
        "optimization"
      ],
      "description": "A Monotonic Stack is a stack that maintains its elements in either strictly increasing or strictly decreasing order. Similarly, a Monotonic Queue maintains the same property. These structures are particularly useful for problems involving finding the next greater/smaller element or maximum/minimum in a sliding window. By maintaining the monotonic property, these structures allow for efficient solving of these problems in linear time.",
      "complexity": {
        "time": "O(n) for most operations (each element is pushed and popped at most once)",
        "space": "O(n)"
      },
      "problem_patterns": [
        "Next greater/smaller element problems",
        "Largest rectangle in histogram",
        "Maximum value in sliding window",
        "Problems involving finding the closest boundary",
        "Stock span problem",
        "Problems involving 'finding the next' pattern"
      ],
      "leetcode_indicators": [
        "Next greater element",
        "Next smaller element",
        "Largest rectangle in histogram",
        "Sliding window maximum",
        "Problems involving finding closest larger/smaller elements"
      ],
      "implementation": "\n        # Example 1: Next Greater Element\n        def next_greater_element(nums):\n            n = len(nums)\n            result = [-1] * n  # Initialize with -1 (no greater element)\n            stack = []  # Monotonic decreasing stack\n            \n            for i in range(n):\n                # While stack is not empty and current element is greater than stack top\n                while stack and nums[i] > nums[stack[-1]]:\n                    # Pop and update result\n                    result[stack.pop()] = nums[i]\n                \n                # Push current index\n                stack.append(i)\n            \n            return result\n\n        # Example 2: Largest Rectangle in Histogram\n        def largest_rectangle_area(heights):\n            n = len(heights)\n            stack = []  # Monotonic increasing stack of indices\n            max_area = 0\n            \n            i = 0\n            while i < n:\n                # If stack is empty or current height is >= height at stack top\n                if not stack or heights[i] >= heights[stack[-1]]:\n                    stack.append(i)\n                    i += 1\n                else:\n                    # Pop and calculate area\n                    top_index = stack.pop()\n                    \n                    # Calculate width\n                    width = i if not stack else i - stack[-1] - 1\n                    \n                    # Update max area\n                    max_area = max(max_area, heights[top_index] * width)\n            \n            # Process remaining elements in stack\n            while stack:\n                top_index = stack.pop()\n                width = n if not stack else n - stack[-1] - 1\n                max_area = max(max_area, heights[top_index] * width)\n            \n            return max_area\n\n        # Example 3: Sliding Window Maximum using Monotonic Queue\n        from collections import deque\n\n        def max_sliding_window(nums, k):\n            n = len(nums)\n            if n == 0 or k == 0:\n                return []\n            \n            result = []\n            queue = deque()  # Monotonic decreasing queue of indices\n            \n            for i in range(n):\n                # Remove elements outside the window\n                while queue and queue[0] < i - k + 1:\n                    queue.popleft()\n                \n                # Remove smaller elements (they will never be the maximum)\n                while queue and nums[i] > nums[queue[-1]]:\n                    queue.pop()\n                \n                # Add current element\n                queue.append(i)\n                \n                # Add to result if we have a full window\n                if i >= k - 1:\n                    result.append(nums[queue[0]])\n            \n            return result\n        ",
      "id": "de6eedbe-8bad-457e-b473-d19e71d1f9f8"
    },
    {
      "name": "Backtracking",
      "tags": [
        "algorithm technique",
        "recursion",
        "combinatorial",
        "search"
      ],
      "description": "Backtracking is an algorithmic technique for solving problems recursively by trying to build a solution incrementally, one step at a time, removing solutions that fail to satisfy the constraints of the problem. It's like a systematic trial and error approach. The name comes from the fact that when you reach a state where you can't proceed further, you 'backtrack' to the previous state and try a different path.",
      "complexity": {
        "time": "O(b^d) where b is the branching factor and d is the maximum depth",
        "space": "O(d) for the recursion stack"
      },
      "problem_patterns": [
        "Permutations and combinations",
        "Subset problems",
        "Constraint satisfaction problems",
        "N-Queens problem",
        "Sudoku solving",
        "Path finding in a maze",
        "Parsing and grammar-related problems"
      ],
      "leetcode_indicators": [
        "Generate all possible",
        "All permutations/combinations/subsets",
        "N-Queens",
        "Problems involving trying all possibilities",
        "Sudoku solver"
      ],
      "implementation": "\n        # Example 1: Generate all permutations\n        def permute(nums):\n            result = []\n            \n            def backtrack(current, remaining):\n                # If no more elements to add, add current permutation to result\n                if not remaining:\n                    result.append(current[:])\n                    return\n                \n                # Try each remaining element\n                for i, num in enumerate(remaining):\n                    # Add the current element\n                    current.append(num)\n                    \n                    # Recursively generate permutations with the remaining elements\n                    backtrack(current, remaining[:i] + remaining[i+1:])\n                    \n                    # Backtrack by removing the current element\n                    current.pop()\n            \n            backtrack([], nums)\n            return result\n\n        # Example 2: Subset Generation\n        def subsets(nums):\n            result = []\n            \n            def backtrack(start, current):\n                # Add the current subset to the result\n                result.append(current[:])\n                \n                # Try each element as the next to add\n                for i in range(start, len(nums)):\n                    # Add the element\n                    current.append(nums[i])\n                    \n                    # Recursively generate subsets with next elements\n                    backtrack(i + 1, current)\n                    \n                    # Backtrack by removing the element\n                    current.pop()\n            \n            backtrack(0, [])\n            return result\n\n        # Example 3: N-Queens\n        def solve_n_queens(n):\n            result = []\n            \n            def is_safe(board, row, col):\n                # Check column\n                for i in range(row):\n                    if board[i][col] == 'Q':\n                        return False\n                \n                # Check upper-left diagonal\n                for i, j in zip(range(row-1, -1, -1), range(col-1, -1, -1)):\n                    if board[i][j] == 'Q':\n                        return False\n                \n                # Check upper-right diagonal\n                for i, j in zip(range(row-1, -1, -1), range(col+1, n)):\n                    if board[i][j] == 'Q':\n                        return False\n                \n                return True\n            \n            def backtrack(board, row):\n                # If all queens are placed, add the solution\n                if row == n:\n                    result.append([''.join(row) for row in board])\n                    return\n                \n                # Try placing a queen in each column of the current row\n                for col in range(n):\n                    if is_safe(board, row, col):\n                        # Place the queen\n                        board[row][col] = 'Q'\n                        \n                        # Recursively place queens in the next row\n                        backtrack(board, row + 1)\n                        \n                        # Backtrack by removing the queen\n                        board[row][col] = '.'\n            \n            # Initialize board with empty cells\n            board = [['.' for _ in range(n)] for _ in range(n)]\n            backtrack(board, 0)\n            \n            return result\n        ",
      "id": "551b24cf-30f8-45d3-9cac-118a4f4be592"
    },
    {
      "name": "0/1 Knapsack Pattern",
      "tags": [
        "dynamic programming",
        "optimization",
        "knapsack",
        "decision"
      ],
      "description": "The 0/1 Knapsack pattern is a dynamic programming approach for problems where you have a set of items with values and weights, and you need to determine which items to include to maximize the value while staying within a weight constraint. Each item can either be included (1) or excluded (0), hence the name 0/1 Knapsack. This pattern extends to many problems involving decision-making with constraints.",
      "complexity": {
        "time": "O(n*W) where n is the number of items and W is the weight constraint",
        "space": "O(n*W) for the standard approach, can be optimized to O(W)"
      },
      "problem_patterns": [
        "Subset sum problems",
        "Partition equal subset sum",
        "Minimum difference subset sum",
        "Count of subsets with given sum",
        "Target sum problems",
        "Problems involving picking items with constraints"
      ],
      "leetcode_indicators": [
        "Given array of numbers, find subset with target sum",
        "Partition array into two subsets with equal/minimum difference sum",
        "Problems involving either including or excluding items",
        "Problems with phrases like 'pick items to maximize value with weight constraint'"
      ],
      "implementation": "\n        # Example 1: Classic 0/1 Knapsack\n        def knapsack_01(values, weights, capacity):\n            n = len(values)\n            \n            # Initialize DP table\n            dp = [[0 for _ in range(capacity + 1)] for _ in range(n + 1)]\n            \n            # Fill DP table\n            for i in range(1, n + 1):\n                for w in range(capacity + 1):\n                    # If current item's weight is less than or equal to the capacity\n                    if weights[i-1] <= w:\n                        # Max of including or excluding the current item\n                        dp[i][w] = max(\n                            values[i-1] + dp[i-1][w-weights[i-1]],  # Include item\n                            dp[i-1][w]  # Exclude item\n                        )\n                    else:\n                        # Can't include this item\n                        dp[i][w] = dp[i-1][w]\n            \n            # Reconstruct the solution\n            selected_items = []\n            i, j = n, capacity\n            while i > 0 and j > 0:\n                if dp[i][j] != dp[i-1][j]:\n                    # Item was included\n                    selected_items.append(i-1)\n                    j -= weights[i-1]\n                i -= 1\n            \n            return dp[n][capacity], selected_items[::-1]\n\n        # Example 2: Subset Sum Problem\n        def subset_sum(nums, target_sum):\n            n = len(nums)\n            \n            # Initialize DP table\n            dp = [[False for _ in range(target_sum + 1)] for _ in range(n + 1)]\n            \n            # Empty subset has sum 0\n            for i in range(n + 1):\n                dp[i][0] = True\n            \n            # Fill DP table\n            for i in range(1, n + 1):\n                for j in range(1, target_sum + 1):\n                    # If current element is greater than sum j\n                    if nums[i-1] > j:\n                        dp[i][j] = dp[i-1][j]\n                    else:\n                        # Include or exclude current element\n                        dp[i][j] = dp[i-1][j] or dp[i-1][j-nums[i-1]]\n            \n            return dp[n][target_sum]\n\n        # Example 3: Partition Equal Subset Sum\n        def can_partition(nums):\n            total_sum = sum(nums)\n            \n            # If sum is odd, can't partition into equal subsets\n            if total_sum % 2 != 0:\n                return False\n            \n            target_sum = total_sum // 2\n            return subset_sum(nums, target_sum)\n        ",
      "id": "eed532fb-ab95-491e-9ac9-803d01ac0a68"
    },
    {
      "name": "Longest Common Subsequence Pattern",
      "tags": [
        "dynamic programming",
        "string",
        "sequence",
        "comparison"
      ],
      "description": "The Longest Common Subsequence (LCS) pattern is a dynamic programming approach for finding the longest subsequence common to two sequences. A subsequence is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements. The LCS pattern extends to many string and sequence comparison problems.",
      "complexity": {
        "time": "O(m*n) where m and n are the lengths of the sequences",
        "space": "O(m*n)"
      },
      "problem_patterns": [
        "Longest common subsequence/substring",
        "Edit distance (insert, delete, replace)",
        "Shortest common supersequence",
        "Longest palindromic subsequence",
        "Minimum deletions/insertions to transform one string to another",
        "Sequence alignment problems"
      ],
      "leetcode_indicators": [
        "Find longest common subsequence/substring",
        "Minimum edits to transform one string to another",
        "Problems involving comparison of two strings/sequences",
        "Problems involving finding similarities between sequences"
      ],
      "implementation": "\n        # Example 1: Longest Common Subsequence\n        def longest_common_subsequence(text1, text2):\n            m, n = len(text1), len(text2)\n            \n            # Initialize DP table\n            dp = [[0 for _ in range(n + 1)] for _ in range(m + 1)]\n            \n            # Fill DP table\n            for i in range(1, m + 1):\n                for j in range(1, n + 1):\n                    if text1[i-1] == text2[j-1]:\n                        dp[i][j] = dp[i-1][j-1] + 1\n                    else:\n                        dp[i][j] = max(dp[i-1][j], dp[i][j-1])\n            \n            # Reconstruct the LCS\n            i, j = m, n\n            lcs = []\n            \n            while i > 0 and j > 0:\n                if text1[i-1] == text2[j-1]:\n                    lcs.append(text1[i-1])\n                    i -= 1\n                    j -= 1\n                elif dp[i-1][j] > dp[i][j-1]:\n                    i -= 1\n                else:\n                    j -= 1\n            \n            return ''.join(reversed(lcs)), dp[m][n]\n\n        # Example 2: Edit Distance\n        def edit_distance(word1, word2):\n            m, n = len(word1), len(word2)\n            \n            # Initialize DP table\n            dp = [[0 for _ in range(n + 1)] for _ in range(m + 1)]\n            \n            # Fill the first row and column\n            for i in range(m + 1):\n                dp[i][0] = i\n            for j in range(n + 1):\n                dp[0][j] = j\n            \n            # Fill DP table\n            for i in range(1, m + 1):\n                for j in range(1, n + 1):\n                    if word1[i-1] == word2[j-1]:\n                        dp[i][j] = dp[i-1][j-1]\n                    else:\n                        dp[i][j] = 1 + min(\n                            dp[i-1][j],      # Delete\n                            dp[i][j-1],      # Insert\n                            dp[i-1][j-1]     # Replace\n                        )\n            \n            return dp[m][n]\n\n        # Example 3: Longest Palindromic Subsequence\n        def longest_palindromic_subsequence(s):\n            # The LPS of a string is the LCS of the string and its reverse\n            return longest_common_subsequence(s, s[::-1])[1]\n        ",
      "id": "efc63be1-ee9a-4df8-8e7e-e1c52fae345b"
    },
    {
      "name": "Sliding Window Algorithm",
      "tags": [
        "algorithm technique",
        "array",
        "string",
        "optimization"
      ],
      "description": "The Sliding Window algorithm is a technique used to process arrays or strings by maintaining a 'window' of elements. This window can grow or shrink as needed while sliding through the data structure. This approach is particularly useful for problems involving subarrays or substrings with specific properties, and it typically reduces time complexity from O(n\u00b2) to O(n).",
      "complexity": {
        "time": "O(n) where n is the size of the array/string",
        "space": "O(1) to O(k) where k is the window size or alphabet size"
      },
      "problem_patterns": [
        "Finding the longest substring with k distinct characters",
        "Finding the longest substring without repeating characters",
        "Finding the minimum window substring",
        "Maximum sum subarray of size k",
        "Finding the longest subarray with ones after replacement",
        "Maximum number of fruits in two baskets"
      ],
      "leetcode_indicators": [
        "Sliding window",
        "Substring with specific properties",
        "Problems involving consecutive elements",
        "Maximum/minimum subarray/substring",
        "Problems with phrases like 'all subarrays of length k'"
      ],
      "implementation": "\n        # Example 1: Fixed-size sliding window (Maximum sum subarray of size k)\n        def max_sum_subarray(arr, k):\n            n = len(arr)\n            if k > n:\n                return None\n            \n            # Initialize window sum and result\n            window_sum = sum(arr[:k])\n            max_sum = window_sum\n            \n            # Slide the window\n            for i in range(k, n):\n                # Remove the element going out of the window\n                window_sum -= arr[i - k]\n                # Add the element coming into the window\n                window_sum += arr[i]\n                # Update max_sum\n                max_sum = max(max_sum, window_sum)\n            \n            return max_sum\n\n        # Example 2: Variable-size sliding window (Longest substring without repeating characters)\n        def length_of_longest_substring(s):\n            n = len(s)\n            if n == 0:\n                return 0\n            \n            char_index = {}  # To store the index of each character\n            max_length = 0\n            window_start = 0\n            \n            for window_end in range(n):\n                # If character is in the current window, update window_start\n                if s[window_end] in char_index and char_index[s[window_end]] >= window_start:\n                    window_start = char_index[s[window_end]] + 1\n                else:\n                    # Update max_length\n                    max_length = max(max_length, window_end - window_start + 1)\n                \n                # Update the character's index\n                char_index[s[window_end]] = window_end\n            \n            return max_length\n\n        # Example 3: Minimum Window Substring\n        def min_window(s, t):\n            if not s or not t:\n                return \"\"\n            \n            # Dictionary to keep count of characters in t\n            target_counts = {}\n            for char in t:\n                target_counts[char] = target_counts.get(char, 0) + 1\n            \n            # Variables to track the window\n            window_counts = {}\n            required = len(target_counts)\n            formed = 0\n            window_start, window_end = 0, 0\n            \n            # Variables to track the minimum window\n            min_len = float('inf')\n            result_start = 0\n            \n            while window_end < len(s):\n                # Add current character to window\n                char = s[window_end]\n                window_counts[char] = window_counts.get(char, 0) + 1\n                \n                # Check if this character's count in window meets requirement\n                if char in target_counts and window_counts[char] == target_counts[char]:\n                    formed += 1\n                \n                # Try to minimize the window\n                while window_start <= window_end and formed == required:\n                    char = s[window_start]\n                    \n                    # Update minimum window\n                    if window_end - window_start + 1 < min_len:\n                        min_len = window_end - window_start + 1\n                        result_start = window_start\n                    \n                    # Remove character from window\n                    window_counts[char] -= 1\n                    if char in target_counts and window_counts[char] < target_counts[char]:\n                        formed -= 1\n                    \n                    window_start += 1\n                \n                window_end += 1\n            \n            return \"\" if min_len == float('inf') else s[result_start:result_start + min_len]\n        ",
      "id": "7d0f67ee-cb50-437b-a78f-a4dca328b55b"
    }
  ],
  "problems": [
    {
      "id": "1",
      "title": "Sort an Array",
      "difficulty": "Medium",
      "content": "Given an array of integers nums, sort the array in ascending order.",
      "tags": [
        "Array",
        "Sorting",
        "Divide and Conquer"
      ],
      "url": "https://leetcode.com/problems/sort-an-array/",
      "similar_questions": [],
      "hints": [
        "Try to think about the problem systematically.",
        "Can you break it down into smaller steps?"
      ],
      "suitable_algorithms": [
        "Quick Sort",
        "Merge Sort",
        "Heap Sort"
      ]
    },
    {
      "id": "2",
      "title": "Merge Sorted Array",
      "difficulty": "Easy",
      "content": "You are given two integer arrays nums1 and nums2, sorted in non-decreasing order, and two integers m and n, representing the number of elements in nums1 and nums2 respectively. Merge nums1 and nums2 into a single array sorted in non-decreasing order.",
      "tags": [
        "Array",
        "Two Pointers",
        "Sorting"
      ],
      "url": "https://leetcode.com/problems/merge-sorted-array/",
      "similar_questions": [],
      "hints": [
        "Try to think about the problem systematically.",
        "Can you break it down into smaller steps?"
      ],
      "suitable_algorithms": [
        "Quick Sort",
        "Merge Sort",
        "Heap Sort"
      ]
    },
    {
      "id": "3",
      "title": "Search in Rotated Sorted Array",
      "difficulty": "Medium",
      "content": "There is an integer array nums sorted in ascending order (with distinct values). Prior to being passed to your function, nums is possibly rotated at an unknown pivot index k (1 <= k < nums.length). Given the array nums after the possible rotation and an integer target, return the index of target if it is in nums, or -1 if it is not in nums.",
      "tags": [
        "Array",
        "Binary Search"
      ],
      "url": "https://leetcode.com/problems/search-in-rotated-sorted-array/",
      "similar_questions": [],
      "hints": [
        "Try to think about the problem systematically.",
        "Can you break it down into smaller steps?"
      ],
      "suitable_algorithms": [
        "Binary Search",
        "Depth-First Search (DFS)",
        "Breadth-First Search (BFS)"
      ]
    },
    {
      "id": "4",
      "title": "Find First and Last Position of Element in Sorted Array",
      "difficulty": "Medium",
      "content": "Given an array of integers nums sorted in non-decreasing order, find the starting and ending position of a given target value. If target is not found in the array, return [-1, -1].",
      "tags": [
        "Array",
        "Binary Search"
      ],
      "url": "https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/",
      "similar_questions": [],
      "hints": [
        "Try to think about the problem systematically.",
        "Can you break it down into smaller steps?"
      ],
      "suitable_algorithms": [
        "Binary Search",
        "Depth-First Search (DFS)",
        "Breadth-First Search (BFS)"
      ]
    },
    {
      "id": "5",
      "title": "Course Schedule",
      "difficulty": "Medium",
      "content": "There are a total of numCourses courses you have to take, labeled from 0 to numCourses - 1. You are given an array prerequisites where prerequisites[i] = [ai, bi] indicates that you must take course bi first if you want to take course ai. Return true if you can finish all courses. Otherwise, return false.",
      "tags": [
        "Depth-First Search",
        "Breadth-First Search",
        "Graph",
        "Topological Sort"
      ],
      "url": "https://leetcode.com/problems/course-schedule/",
      "similar_questions": [],
      "hints": [
        "Try to think about the problem systematically.",
        "Can you break it down into smaller steps?"
      ],
      "suitable_algorithms": [
        "Union Find (Disjoint Set)"
      ]
    },
    {
      "id": "6",
      "title": "Network Delay Time",
      "difficulty": "Medium",
      "content": "You are given a network of n nodes, labeled from 1 to n. You are also given times, a list of travel times as directed edges times[i] = (ui, vi, wi), where ui is the source node, vi is the target node, and wi is the time it takes for a signal to travel from source to target. We will send a signal from a given node k. Return the time it takes for all the n nodes to receive the signal. If it is impossible for all the n nodes to receive the signal, return -1.",
      "tags": [
        "Depth-First Search",
        "Breadth-First Search",
        "Graph",
        "Heap (Priority Queue)",
        "Shortest Path"
      ],
      "url": "https://leetcode.com/problems/network-delay-time/",
      "similar_questions": [],
      "hints": [
        "Try to think about the problem systematically.",
        "Can you break it down into smaller steps?"
      ],
      "suitable_algorithms": [
        "Union Find (Disjoint Set)"
      ]
    },
    {
      "id": "7",
      "title": "Coin Change",
      "difficulty": "Medium",
      "content": "You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money. Return the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1.",
      "tags": [
        "Array",
        "Dynamic Programming",
        "Breadth-First Search"
      ],
      "url": "https://leetcode.com/problems/coin-change/",
      "similar_questions": [],
      "hints": [
        "Try to think about the problem systematically.",
        "Can you break it down into smaller steps?"
      ],
      "suitable_algorithms": [
        "0/1 Knapsack",
        "Longest Common Subsequence",
        "Coin Change"
      ]
    },
    {
      "id": "8",
      "title": "Longest Increasing Subsequence",
      "difficulty": "Medium",
      "content": "Given an integer array nums, return the length of the longest strictly increasing subsequence.",
      "tags": [
        "Array",
        "Binary Search",
        "Dynamic Programming"
      ],
      "url": "https://leetcode.com/problems/longest-increasing-subsequence/",
      "similar_questions": [],
      "hints": [
        "Try to think about the problem systematically.",
        "Can you break it down into smaller steps?"
      ],
      "suitable_algorithms": [
        "0/1 Knapsack",
        "Longest Common Subsequence",
        "Coin Change"
      ]
    },
    {
      "id": "9",
      "title": "Longest Palindromic Substring",
      "difficulty": "Medium",
      "content": "Given a string s, return the longest palindromic substring in s.",
      "tags": [
        "String",
        "Dynamic Programming"
      ],
      "url": "https://leetcode.com/problems/longest-palindromic-substring/",
      "similar_questions": [],
      "hints": [
        "Try to think about the problem systematically.",
        "Can you break it down into smaller steps?"
      ],
      "suitable_algorithms": [
        "Balanced Parentheses Check",
        "Trie (Prefix Tree)",
        "Two Pointers Technique"
      ]
    },
    {
      "id": "10",
      "title": "Implement strStr()",
      "difficulty": "Easy",
      "content": "Given two strings needle and haystack, return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.",
      "tags": [
        "Two Pointers",
        "String",
        "String Matching"
      ],
      "url": "https://leetcode.com/problems/implement-strstr()/",
      "similar_questions": [],
      "hints": [
        "Try to think about the problem systematically.",
        "Can you break it down into smaller steps?"
      ],
      "suitable_algorithms": [
        "Balanced Parentheses Check",
        "Trie (Prefix Tree)",
        "Two Pointers Technique"
      ]
    },
    {
      "id": "11",
      "title": "Binary Tree Inorder Traversal",
      "difficulty": "Easy",
      "content": "Given the root of a binary tree, return the inorder traversal of its nodes' values.",
      "tags": [
        "Stack",
        "Tree",
        "Depth-First Search",
        "Binary Tree"
      ],
      "url": "https://leetcode.com/problems/binary-tree-inorder-traversal/",
      "similar_questions": [],
      "hints": [
        "Try to think about the problem systematically.",
        "Can you break it down into smaller steps?"
      ],
      "suitable_algorithms": [
        "Trie (Prefix Tree)",
        "Segment Tree"
      ]
    },
    {
      "id": "12",
      "title": "Lowest Common Ancestor of a Binary Tree",
      "difficulty": "Medium",
      "content": "Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree. According to the definition of LCA on Wikipedia: 'The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).'",
      "tags": [
        "Tree",
        "Depth-First Search",
        "Binary Tree"
      ],
      "url": "https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/",
      "similar_questions": [],
      "hints": [
        "Try to think about the problem systematically.",
        "Can you break it down into smaller steps?"
      ],
      "suitable_algorithms": [
        "Trie (Prefix Tree)",
        "Segment Tree"
      ]
    },
    {
      "id": "13",
      "title": "Reverse Linked List",
      "difficulty": "Easy",
      "content": "Given the head of a singly linked list, reverse the list, and return the reversed list.",
      "tags": [
        "Linked List",
        "Recursion"
      ],
      "url": "https://leetcode.com/problems/reverse-linked-list/",
      "similar_questions": [],
      "hints": [
        "Try to think about the problem systematically.",
        "Can you break it down into smaller steps?"
      ],
      "suitable_algorithms": [
        "Linked List Reversal"
      ]
    },
    {
      "id": "14",
      "title": "Linked List Cycle",
      "difficulty": "Easy",
      "content": "Given head, the head of a linked list, determine if the linked list has a cycle in it.",
      "tags": [
        "Linked List",
        "Two Pointers",
        "Hash Table"
      ],
      "url": "https://leetcode.com/problems/linked-list-cycle/",
      "similar_questions": [],
      "hints": [
        "Try to think about the problem systematically.",
        "Can you break it down into smaller steps?"
      ],
      "suitable_algorithms": [
        "Linked List Cycle Detection"
      ]
    },
    {
      "id": "15",
      "title": "Rotate List",
      "difficulty": "Medium",
      "content": "Given the head of a linked list, rotate the list to the right by k places.",
      "tags": [
        "Linked List",
        "Two Pointers"
      ],
      "url": "https://leetcode.com/problems/rotate-list/",
      "similar_questions": [],
      "hints": [
        "Try to think about the problem systematically.",
        "Can you break it down into smaller steps?"
      ],
      "suitable_algorithms": [
        "Linked List Rotation"
      ]
    },
    {
      "id": "16",
      "title": "Merge Two Sorted Lists",
      "difficulty": "Easy",
      "content": "You are given the heads of two sorted linked lists list1 and list2. Merge the two lists into one sorted list.",
      "tags": [
        "Linked List",
        "Recursion"
      ],
      "url": "https://leetcode.com/problems/merge-two-sorted-lists/",
      "similar_questions": [],
      "hints": [
        "Try to think about the problem systematically.",
        "Can you break it down into smaller steps?"
      ],
      "suitable_algorithms": [
        "Linked List Merge"
      ]
    },
    {
      "id": "17",
      "title": "Valid Parentheses",
      "difficulty": "Easy",
      "content": "Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.",
      "tags": [
        "String",
        "Stack"
      ],
      "url": "https://leetcode.com/problems/valid-parentheses/",
      "similar_questions": [],
      "hints": [
        "Try to think about the problem systematically.",
        "Can you break it down into smaller steps?"
      ],
      "suitable_algorithms": [
        "Balanced Parentheses Check",
        "Stack Implementation"
      ]
    },
    {
      "id": "18",
      "title": "Min Stack",
      "difficulty": "Medium",
      "content": "Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.",
      "tags": [
        "Stack",
        "Design"
      ],
      "url": "https://leetcode.com/problems/min-stack/",
      "similar_questions": [],
      "hints": [
        "Try to think about the problem systematically.",
        "Can you break it down into smaller steps?"
      ],
      "suitable_algorithms": [
        "Stack Implementation"
      ]
    },
    {
      "id": "19",
      "title": "Design Circular Queue",
      "difficulty": "Medium",
      "content": "Design your implementation of the circular queue. The circular queue is a linear data structure in which the operations are performed based on FIFO principle.",
      "tags": [
        "Array",
        "Linked List",
        "Design",
        "Queue"
      ],
      "url": "https://leetcode.com/problems/design-circular-queue/",
      "similar_questions": [],
      "hints": [
        "Try to think about the problem systematically.",
        "Can you break it down into smaller steps?"
      ],
      "suitable_algorithms": [
        "Circular Queue Implementation"
      ]
    },
    {
      "id": "20",
      "title": "Sliding Window Maximum",
      "difficulty": "Hard",
      "content": "You are given an array of integers nums, there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position. Return the max sliding window.",
      "tags": [
        "Array",
        "Queue",
        "Sliding Window",
        "Heap (Priority Queue)"
      ],
      "url": "https://leetcode.com/problems/sliding-window-maximum/",
      "similar_questions": [],
      "hints": [
        "Try to think about the problem systematically.",
        "Can you break it down into smaller steps?"
      ],
      "suitable_algorithms": [
        "Queue Implementation",
        "Priority Queue Implementation"
      ]
    },
    {
      "id": "21",
      "title": "Two Sum",
      "difficulty": "Easy",
      "content": "Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.",
      "tags": [
        "Array",
        "Hash Table"
      ],
      "url": "https://leetcode.com/problems/two-sum/",
      "similar_questions": [],
      "hints": [
        "Try to think about the problem systematically.",
        "Can you break it down into smaller steps?"
      ],
      "suitable_algorithms": [
        "Hash Table Implementation"
      ]
    },
    {
      "id": "22",
      "title": "Design HashMap",
      "difficulty": "Easy",
      "content": "Design a HashMap without using any built-in hash table libraries.",
      "tags": [
        "Array",
        "Hash Table",
        "Linked List",
        "Design"
      ],
      "url": "https://leetcode.com/problems/design-hashmap/",
      "similar_questions": [],
      "hints": [
        "Try to think about the problem systematically.",
        "Can you break it down into smaller steps?"
      ],
      "suitable_algorithms": [
        "Hash Table Implementation",
        "Collision Resolution with Chaining",
        "Open Addressing (Linear Probing)"
      ]
    },
    {
      "id": "23",
      "title": "Implement Trie (Prefix Tree)",
      "difficulty": "Medium",
      "content": "A trie (pronounced as \"try\") or prefix tree is a tree data structure used to efficiently store and retrieve keys in a dataset of strings. Implement the Trie class with insert, search, and startsWith methods.",
      "tags": [
        "Hash Table",
        "String",
        "Design",
        "Trie"
      ],
      "url": "https://leetcode.com/problems/implement-trie-(prefix-tree)/",
      "similar_questions": [],
      "hints": [
        "Try to think about the problem systematically.",
        "Can you break it down into smaller steps?"
      ],
      "suitable_algorithms": [
        "Trie (Prefix Tree)"
      ]
    },
    {
      "id": "24",
      "title": "Word Search II",
      "difficulty": "Hard",
      "content": "Given an m x n board of characters and a list of strings words, return all words on the board. Each word must be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring.",
      "tags": [
        "Array",
        "String",
        "Backtracking",
        "Trie"
      ],
      "url": "https://leetcode.com/problems/word-search-ii/",
      "similar_questions": [],
      "hints": [
        "Try to think about the problem systematically.",
        "Can you break it down into smaller steps?"
      ],
      "suitable_algorithms": [
        "Trie (Prefix Tree)",
        "Backtracking"
      ]
    },
    {
      "id": "25",
      "title": "Range Sum Query - Mutable",
      "difficulty": "Medium",
      "content": "Given an array nums and two types of queries: update an element to a new value, and calculate the sum of the elements of nums between indices left and right inclusive where left <= right.",
      "tags": [
        "Array",
        "Design",
        "Binary Indexed Tree",
        "Segment Tree"
      ],
      "url": "https://leetcode.com/problems/range-sum-query---mutable/",
      "similar_questions": [],
      "hints": [
        "Try to think about the problem systematically.",
        "Can you break it down into smaller steps?"
      ],
      "suitable_algorithms": [
        "Segment Tree"
      ]
    },
    {
      "id": "26",
      "title": "Number of Connected Components in an Undirected Graph",
      "difficulty": "Medium",
      "content": "You have a graph of n nodes. You are given an integer n and an array edges where edges[i] = [ai, bi] indicates that there is an edge between ai and bi in the graph. Return the number of connected components in the graph.",
      "tags": [
        "Depth-First Search",
        "Breadth-First Search",
        "Union Find",
        "Graph"
      ],
      "url": "https://leetcode.com/problems/number-of-connected-components-in-an-undirected-graph/",
      "similar_questions": [],
      "hints": [
        "Try to think about the problem systematically.",
        "Can you break it down into smaller steps?"
      ],
      "suitable_algorithms": [
        "Union Find (Disjoint Set)",
        "Depth-First Search (DFS)",
        "Breadth-First Search (BFS)"
      ]
    },
    {
      "id": "27",
      "title": "Path With Minimum Effort",
      "difficulty": "Medium",
      "content": "You are a hiker preparing for an upcoming hike. You are given heights, a 2D array of size rows x columns, where heights[row][col] represents the height of cell (row, col). You are situated in the top-left cell, (0, 0), and you hope to travel to the bottom-right cell, (rows-1, columns-1).",
      "tags": [
        "Array",
        "Binary Search",
        "Depth-First Search",
        "Breadth-First Search",
        "Union Find",
        "Heap (Priority Queue)",
        "Matrix"
      ],
      "url": "https://leetcode.com/problems/path-with-minimum-effort/",
      "similar_questions": [],
      "hints": [
        "Try to think about the problem systematically.",
        "Can you break it down into smaller steps?"
      ],
      "suitable_algorithms": [
        "A* Search Algorithm",
        "Dijkstra's Algorithm"
      ]
    },
    {
      "id": "28",
      "title": "Container With Most Water",
      "difficulty": "Medium",
      "content": "You are given an integer array height of length n. There are n vertical lines drawn such that the two endpoints of the ith line are (i, 0) and (i, height[i]). Find two lines that together with the x-axis form a container, such that the container contains the most water.",
      "tags": [
        "Array",
        "Two Pointers",
        "Greedy"
      ],
      "url": "https://leetcode.com/problems/container-with-most-water/",
      "similar_questions": [],
      "hints": [
        "Try to think about the problem systematically.",
        "Can you break it down into smaller steps?"
      ],
      "suitable_algorithms": [
        "Two Pointers Technique"
      ]
    },
    {
      "id": "29",
      "title": "Next Greater Element I",
      "difficulty": "Easy",
      "content": "The next greater element of some element x in an array is the first greater element that is to the right of x in the same array. You are given two distinct 0-indexed integer arrays nums1 and nums2, where nums1 is a subset of nums2. Find all the next greater elements of nums1 in nums2 and return them in an array.",
      "tags": [
        "Array",
        "Hash Table",
        "Stack",
        "Monotonic Stack"
      ],
      "url": "https://leetcode.com/problems/next-greater-element-i/",
      "similar_questions": [],
      "hints": [
        "Try to think about the problem systematically.",
        "Can you break it down into smaller steps?"
      ],
      "suitable_algorithms": [
        "Monotonic Stack/Queue"
      ]
    },
    {
      "id": "30",
      "title": "Permutations",
      "difficulty": "Medium",
      "content": "Given an array nums of distinct integers, return all the possible permutations. You can return the answer in any order.",
      "tags": [
        "Array",
        "Backtracking"
      ],
      "url": "https://leetcode.com/problems/permutations/",
      "similar_questions": [],
      "hints": [
        "Try to think about the problem systematically.",
        "Can you break it down into smaller steps?"
      ],
      "suitable_algorithms": [
        "Backtracking"
      ]
    },
    {
      "id": "31",
      "title": "Two Sum",
      "difficulty": "Easy",
      "content": "Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. You may assume that each input would have exactly one solution, and you may not use the same element twice.",
      "tags": [
        "Array",
        "Hash Table"
      ],
      "url": "https://leetcode.com/problems/two-sum/",
      "similar_questions": [
        "Three Sum",
        "Four Sum",
        "Two Sum II"
      ],
      "hints": [
        "Think about using a hash table to store numbers you've seen."
      ],
      "suitable_algorithms": [
        "Hash Table Implementation",
        "Two Pointers Technique"
      ]
    },
    {
      "id": "32",
      "title": "Add Two Numbers",
      "difficulty": "Medium",
      "content": "You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.",
      "tags": [
        "Linked List",
        "Math",
        "Recursion"
      ],
      "url": "https://leetcode.com/problems/add-two-numbers/",
      "similar_questions": [
        "Multiply Strings",
        "Add Binary"
      ],
      "hints": [
        "Keep track of the carry using a variable."
      ],
      "suitable_algorithms": [
        "Linked List Traversal",
        "Math"
      ]
    },
    {
      "id": "33",
      "title": "Median of Two Sorted Arrays",
      "difficulty": "Hard",
      "content": "Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays.",
      "tags": [
        "Array",
        "Binary Search",
        "Divide and Conquer"
      ],
      "url": "https://leetcode.com/problems/median-of-two-sorted-arrays/",
      "similar_questions": [
        "Find K-th Smallest Pair Distance"
      ],
      "hints": [
        "Think about a binary search approach."
      ],
      "suitable_algorithms": [
        "Binary Search",
        "Divide and Conquer"
      ]
    },
    {
      "id": "34",
      "title": "LRU Cache",
      "difficulty": "Medium",
      "content": "Design a data structure that follows the constraints of a Least Recently Used (LRU) cache.",
      "tags": [
        "Hash Table",
        "Linked List",
        "Design",
        "Doubly-Linked List"
      ],
      "url": "https://leetcode.com/problems/lru-cache/",
      "similar_questions": [
        "LFU Cache",
        "Design In-Memory File System"
      ],
      "hints": [
        "Use a combination of a hash table and a doubly linked list."
      ],
      "suitable_algorithms": [
        "Hash Table Implementation",
        "Linked List Implementation"
      ]
    }
  ],
  "mappings": {
    "algorithm_to_problems": {
      "Quick Sort": [
        {
          "id": "1",
          "title": "Sort an Array",
          "difficulty": "Medium",
          "url": "https://leetcode.com/problems/sort-an-array/"
        },
        {
          "id": "2",
          "title": "Merge Sorted Array",
          "difficulty": "Easy",
          "url": "https://leetcode.com/problems/merge-sorted-array/"
        }
      ],
      "Merge Sort": [
        {
          "id": "1",
          "title": "Sort an Array",
          "difficulty": "Medium",
          "url": "https://leetcode.com/problems/sort-an-array/"
        },
        {
          "id": "2",
          "title": "Merge Sorted Array",
          "difficulty": "Easy",
          "url": "https://leetcode.com/problems/merge-sorted-array/"
        }
      ],
      "Heap Sort": [
        {
          "id": "1",
          "title": "Sort an Array",
          "difficulty": "Medium",
          "url": "https://leetcode.com/problems/sort-an-array/"
        },
        {
          "id": "2",
          "title": "Merge Sorted Array",
          "difficulty": "Easy",
          "url": "https://leetcode.com/problems/merge-sorted-array/"
        }
      ],
      "Binary Search": [
        {
          "id": "3",
          "title": "Search in Rotated Sorted Array",
          "difficulty": "Medium",
          "url": "https://leetcode.com/problems/search-in-rotated-sorted-array/"
        },
        {
          "id": "4",
          "title": "Find First and Last Position of Element in Sorted Array",
          "difficulty": "Medium",
          "url": "https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/"
        },
        {
          "id": "33",
          "title": "Median of Two Sorted Arrays",
          "difficulty": "Hard",
          "url": "https://leetcode.com/problems/median-of-two-sorted-arrays/"
        }
      ],
      "Depth-First Search (DFS)": [
        {
          "id": "3",
          "title": "Search in Rotated Sorted Array",
          "difficulty": "Medium",
          "url": "https://leetcode.com/problems/search-in-rotated-sorted-array/"
        },
        {
          "id": "4",
          "title": "Find First and Last Position of Element in Sorted Array",
          "difficulty": "Medium",
          "url": "https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/"
        },
        {
          "id": "26",
          "title": "Number of Connected Components in an Undirected Graph",
          "difficulty": "Medium",
          "url": "https://leetcode.com/problems/number-of-connected-components-in-an-undirected-graph/"
        }
      ],
      "Breadth-First Search (BFS)": [
        {
          "id": "3",
          "title": "Search in Rotated Sorted Array",
          "difficulty": "Medium",
          "url": "https://leetcode.com/problems/search-in-rotated-sorted-array/"
        },
        {
          "id": "4",
          "title": "Find First and Last Position of Element in Sorted Array",
          "difficulty": "Medium",
          "url": "https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/"
        },
        {
          "id": "26",
          "title": "Number of Connected Components in an Undirected Graph",
          "difficulty": "Medium",
          "url": "https://leetcode.com/problems/number-of-connected-components-in-an-undirected-graph/"
        }
      ],
      "Dijkstra's Algorithm": [
        {
          "id": "27",
          "title": "Path With Minimum Effort",
          "difficulty": "Medium",
          "url": "https://leetcode.com/problems/path-with-minimum-effort/"
        }
      ],
      "Kruskal's Algorithm": [],
      "Topological Sort": [],
      "Linked List Reversal": [
        {
          "id": "13",
          "title": "Reverse Linked List",
          "difficulty": "Easy",
          "url": "https://leetcode.com/problems/reverse-linked-list/"
        }
      ],
      "Linked List Cycle Detection": [
        {
          "id": "14",
          "title": "Linked List Cycle",
          "difficulty": "Easy",
          "url": "https://leetcode.com/problems/linked-list-cycle/"
        }
      ],
      "Linked List Rotation": [
        {
          "id": "15",
          "title": "Rotate List",
          "difficulty": "Medium",
          "url": "https://leetcode.com/problems/rotate-list/"
        }
      ],
      "Linked List Merge": [
        {
          "id": "16",
          "title": "Merge Two Sorted Lists",
          "difficulty": "Easy",
          "url": "https://leetcode.com/problems/merge-two-sorted-lists/"
        }
      ],
      "Stack Implementation": [
        {
          "id": "17",
          "title": "Valid Parentheses",
          "difficulty": "Easy",
          "url": "https://leetcode.com/problems/valid-parentheses/"
        },
        {
          "id": "18",
          "title": "Min Stack",
          "difficulty": "Medium",
          "url": "https://leetcode.com/problems/min-stack/"
        }
      ],
      "Balanced Parentheses Check": [
        {
          "id": "9",
          "title": "Longest Palindromic Substring",
          "difficulty": "Medium",
          "url": "https://leetcode.com/problems/longest-palindromic-substring/"
        },
        {
          "id": "10",
          "title": "Implement strStr()",
          "difficulty": "Easy",
          "url": "https://leetcode.com/problems/implement-strstr()/"
        },
        {
          "id": "17",
          "title": "Valid Parentheses",
          "difficulty": "Easy",
          "url": "https://leetcode.com/problems/valid-parentheses/"
        }
      ],
      "Infix to Postfix Conversion": [],
      "0/1 Knapsack": [
        {
          "id": "7",
          "title": "Coin Change",
          "difficulty": "Medium",
          "url": "https://leetcode.com/problems/coin-change/"
        },
        {
          "id": "8",
          "title": "Longest Increasing Subsequence",
          "difficulty": "Medium",
          "url": "https://leetcode.com/problems/longest-increasing-subsequence/"
        }
      ],
      "Longest Common Subsequence": [
        {
          "id": "7",
          "title": "Coin Change",
          "difficulty": "Medium",
          "url": "https://leetcode.com/problems/coin-change/"
        },
        {
          "id": "8",
          "title": "Longest Increasing Subsequence",
          "difficulty": "Medium",
          "url": "https://leetcode.com/problems/longest-increasing-subsequence/"
        }
      ],
      "Coin Change": [
        {
          "id": "7",
          "title": "Coin Change",
          "difficulty": "Medium",
          "url": "https://leetcode.com/problems/coin-change/"
        },
        {
          "id": "8",
          "title": "Longest Increasing Subsequence",
          "difficulty": "Medium",
          "url": "https://leetcode.com/problems/longest-increasing-subsequence/"
        }
      ],
      "Knuth-Morris-Pratt (KMP)": [],
      "Rabin-Karp": [],
      "Longest Palindromic Substring": [],
      "Binary Tree Traversal": [],
      "Binary Search Tree Operations": [],
      "Lowest Common Ancestor": [],
      "Queue Implementation": [
        {
          "id": "20",
          "title": "Sliding Window Maximum",
          "difficulty": "Hard",
          "url": "https://leetcode.com/problems/sliding-window-maximum/"
        }
      ],
      "Circular Queue Implementation": [
        {
          "id": "19",
          "title": "Design Circular Queue",
          "difficulty": "Medium",
          "url": "https://leetcode.com/problems/design-circular-queue/"
        }
      ],
      "Priority Queue Implementation": [
        {
          "id": "20",
          "title": "Sliding Window Maximum",
          "difficulty": "Hard",
          "url": "https://leetcode.com/problems/sliding-window-maximum/"
        }
      ],
      "Hash Table Implementation": [
        {
          "id": "21",
          "title": "Two Sum",
          "difficulty": "Easy",
          "url": "https://leetcode.com/problems/two-sum/"
        },
        {
          "id": "22",
          "title": "Design HashMap",
          "difficulty": "Easy",
          "url": "https://leetcode.com/problems/design-hashmap/"
        },
        {
          "id": "31",
          "title": "Two Sum",
          "difficulty": "Easy",
          "url": "https://leetcode.com/problems/two-sum/"
        },
        {
          "id": "34",
          "title": "LRU Cache",
          "difficulty": "Medium",
          "url": "https://leetcode.com/problems/lru-cache/"
        }
      ],
      "Collision Resolution with Chaining": [
        {
          "id": "22",
          "title": "Design HashMap",
          "difficulty": "Easy",
          "url": "https://leetcode.com/problems/design-hashmap/"
        }
      ],
      "Open Addressing (Linear Probing)": [
        {
          "id": "22",
          "title": "Design HashMap",
          "difficulty": "Easy",
          "url": "https://leetcode.com/problems/design-hashmap/"
        }
      ],
      "Trie (Prefix Tree)": [
        {
          "id": "9",
          "title": "Longest Palindromic Substring",
          "difficulty": "Medium",
          "url": "https://leetcode.com/problems/longest-palindromic-substring/"
        },
        {
          "id": "10",
          "title": "Implement strStr()",
          "difficulty": "Easy",
          "url": "https://leetcode.com/problems/implement-strstr()/"
        },
        {
          "id": "11",
          "title": "Binary Tree Inorder Traversal",
          "difficulty": "Easy",
          "url": "https://leetcode.com/problems/binary-tree-inorder-traversal/"
        },
        {
          "id": "12",
          "title": "Lowest Common Ancestor of a Binary Tree",
          "difficulty": "Medium",
          "url": "https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/"
        },
        {
          "id": "23",
          "title": "Implement Trie (Prefix Tree)",
          "difficulty": "Medium",
          "url": "https://leetcode.com/problems/implement-trie-(prefix-tree)/"
        },
        {
          "id": "24",
          "title": "Word Search II",
          "difficulty": "Hard",
          "url": "https://leetcode.com/problems/word-search-ii/"
        }
      ],
      "Segment Tree": [
        {
          "id": "11",
          "title": "Binary Tree Inorder Traversal",
          "difficulty": "Easy",
          "url": "https://leetcode.com/problems/binary-tree-inorder-traversal/"
        },
        {
          "id": "12",
          "title": "Lowest Common Ancestor of a Binary Tree",
          "difficulty": "Medium",
          "url": "https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/"
        },
        {
          "id": "25",
          "title": "Range Sum Query - Mutable",
          "difficulty": "Medium",
          "url": "https://leetcode.com/problems/range-sum-query---mutable/"
        }
      ],
      "Union Find (Disjoint Set)": [
        {
          "id": "5",
          "title": "Course Schedule",
          "difficulty": "Medium",
          "url": "https://leetcode.com/problems/course-schedule/"
        },
        {
          "id": "6",
          "title": "Network Delay Time",
          "difficulty": "Medium",
          "url": "https://leetcode.com/problems/network-delay-time/"
        },
        {
          "id": "26",
          "title": "Number of Connected Components in an Undirected Graph",
          "difficulty": "Medium",
          "url": "https://leetcode.com/problems/number-of-connected-components-in-an-undirected-graph/"
        }
      ],
      "A* Search Algorithm": [
        {
          "id": "27",
          "title": "Path With Minimum Effort",
          "difficulty": "Medium",
          "url": "https://leetcode.com/problems/path-with-minimum-effort/"
        }
      ],
      "Bellman-Ford Algorithm": [],
      "Floyd-Warshall Algorithm": [],
      "Two Pointers Technique": [
        {
          "id": "9",
          "title": "Longest Palindromic Substring",
          "difficulty": "Medium",
          "url": "https://leetcode.com/problems/longest-palindromic-substring/"
        },
        {
          "id": "10",
          "title": "Implement strStr()",
          "difficulty": "Easy",
          "url": "https://leetcode.com/problems/implement-strstr()/"
        },
        {
          "id": "28",
          "title": "Container With Most Water",
          "difficulty": "Medium",
          "url": "https://leetcode.com/problems/container-with-most-water/"
        },
        {
          "id": "31",
          "title": "Two Sum",
          "difficulty": "Easy",
          "url": "https://leetcode.com/problems/two-sum/"
        }
      ],
      "Monotonic Stack/Queue": [
        {
          "id": "29",
          "title": "Next Greater Element I",
          "difficulty": "Easy",
          "url": "https://leetcode.com/problems/next-greater-element-i/"
        }
      ],
      "Backtracking": [
        {
          "id": "24",
          "title": "Word Search II",
          "difficulty": "Hard",
          "url": "https://leetcode.com/problems/word-search-ii/"
        },
        {
          "id": "30",
          "title": "Permutations",
          "difficulty": "Medium",
          "url": "https://leetcode.com/problems/permutations/"
        }
      ],
      "0/1 Knapsack Pattern": [],
      "Longest Common Subsequence Pattern": [],
      "Sliding Window Algorithm": []
    },
    "problem_to_algorithms": {
      "1": [
        "Quick Sort",
        "Merge Sort",
        "Heap Sort"
      ],
      "2": [
        "Quick Sort",
        "Merge Sort",
        "Heap Sort"
      ],
      "3": [
        "Binary Search",
        "Depth-First Search (DFS)",
        "Breadth-First Search (BFS)"
      ],
      "4": [
        "Binary Search",
        "Depth-First Search (DFS)",
        "Breadth-First Search (BFS)"
      ],
      "5": [
        "Union Find (Disjoint Set)"
      ],
      "6": [
        "Union Find (Disjoint Set)"
      ],
      "7": [
        "0/1 Knapsack",
        "Longest Common Subsequence",
        "Coin Change"
      ],
      "8": [
        "0/1 Knapsack",
        "Longest Common Subsequence",
        "Coin Change"
      ],
      "9": [
        "Balanced Parentheses Check",
        "Trie (Prefix Tree)",
        "Two Pointers Technique"
      ],
      "10": [
        "Balanced Parentheses Check",
        "Trie (Prefix Tree)",
        "Two Pointers Technique"
      ],
      "11": [
        "Trie (Prefix Tree)",
        "Segment Tree"
      ],
      "12": [
        "Trie (Prefix Tree)",
        "Segment Tree"
      ],
      "13": [
        "Linked List Reversal"
      ],
      "14": [
        "Linked List Cycle Detection"
      ],
      "15": [
        "Linked List Rotation"
      ],
      "16": [
        "Linked List Merge"
      ],
      "17": [
        "Balanced Parentheses Check",
        "Stack Implementation"
      ],
      "18": [
        "Stack Implementation"
      ],
      "19": [
        "Circular Queue Implementation"
      ],
      "20": [
        "Queue Implementation",
        "Priority Queue Implementation"
      ],
      "21": [
        "Hash Table Implementation"
      ],
      "22": [
        "Hash Table Implementation",
        "Collision Resolution with Chaining",
        "Open Addressing (Linear Probing)"
      ],
      "23": [
        "Trie (Prefix Tree)"
      ],
      "24": [
        "Trie (Prefix Tree)",
        "Backtracking"
      ],
      "25": [
        "Segment Tree"
      ],
      "26": [
        "Union Find (Disjoint Set)",
        "Depth-First Search (DFS)",
        "Breadth-First Search (BFS)"
      ],
      "27": [
        "A* Search Algorithm",
        "Dijkstra's Algorithm"
      ],
      "28": [
        "Two Pointers Technique"
      ],
      "29": [
        "Monotonic Stack/Queue"
      ],
      "30": [
        "Backtracking"
      ],
      "31": [
        "Hash Table Implementation",
        "Two Pointers Technique"
      ],
      "32": [
        "Linked List Traversal",
        "Math"
      ],
      "33": [
        "Binary Search",
        "Divide and Conquer"
      ],
      "34": [
        "Hash Table Implementation",
        "Linked List Implementation"
      ]
    }
  }
}